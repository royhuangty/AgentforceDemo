var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_bundle = __commonJS({
  "bundle.js"(exports, module) {
    /**
    * @vue/shared v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$2 = Object.assign;
    const remove = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
    const isArray$2 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString(val) === "[object Date]";
    const isFunction$2 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$2 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$2(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString$2(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$2(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$2(value) || isObject$2(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$2(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate$2(a);
      let bValidType = isDate$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol(a);
      bValidType = isSymbol(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$2(a);
      bValidType = isArray$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$2(a);
      bValidType = isObject$2(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    const toDisplayString = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject$2(val) && !isArray$2(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a;
      return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
    };
    /**
    * @vue/reactivity v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn, trigger2, scheduler, scope) {
        this.fn = fn;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i = 0; i < this._depsLength; i++) {
            const dep = this.deps[i];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        var _a;
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          (_a = this.onStop) == null ? void 0 : _a.call(this);
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
          cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$2(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$2(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$2(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$2;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$2(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._shallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$2(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap2(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap2(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add$2(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto2 = getProto(target);
      const hadKey = proto2.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$2(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap2(value), wrap2(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap2 = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap2(value[0]), wrap2(value[1])] : wrap2(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$3(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$3(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$2(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$2(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this, 4);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    /**
    * @vue/runtime-core v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$2(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$2(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type, args) {
      try {
        return args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction$2(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id) {
      let start2 = flushIndex + 1;
      let end2 = queue.length;
      while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start2 = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$2(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff2 = getId(a) - getId(b);
      if (diff2 === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff2;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
        if (trim2) {
          args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$2(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$2(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$2(normalized, raw);
      }
      if (isObject$2(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root.transition = vnode.transition;
      }
      {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root = parent.subTree;
        if (root.suspense && root.suspense.activeBranch === vnode) {
          root.el = vnode.el;
        }
        if (root === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$2(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    function watchPostEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "post" }
      );
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$2(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$2(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$2(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope) {
          remove(scope.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$2(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, depth, currentDepth = 0, seen) {
      if (!isObject$2(value) || value["__v_skip"]) {
        return value;
      }
      if (depth && depth > 0) {
        if (currentDepth >= depth) {
          return value;
        }
        currentDepth++;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, depth, currentDepth, seen);
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, currentDepth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, currentDepth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, currentDepth, seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$2(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children || !children.length) {
            return;
          }
          let child = children[0];
          if (children.length > 1) {
            for (const c of children) {
              if (c.type !== Comment) {
                child = c;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$2(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks2 = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks2.delayedLeave) {
              hooks2.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks2;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? (
        // #7121 ensure get the child component subtree in case
        // it's been replaced during HMR
        vnode.children ? vnode.children[0] : void 0
      ) : vnode;
    }
    function setTransitionHooks(vnode, hooks2) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks2);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks2;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children.length; i++) {
        let child = children[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks2 = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks2.unshift(wrappedHook);
        } else {
          hooks2.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (isArray$2(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject$2(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l = keys2.length; i < l; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          i.effect.dirty = true;
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$2(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$2(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$2(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$2(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$2(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$2(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$2(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$2(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$2(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$2(raw)) {
        if (isArray$2(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$2(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject$2(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from2, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from2;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from2) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from2) {
      if (!from2) {
        return to2;
      }
      if (!to2) {
        return from2;
      }
      return function mergedDataFn() {
        return extend$2(
          isFunction$2(to2) ? to2.call(this, this) : to2,
          isFunction$2(from2) ? from2.call(this, this) : from2
        );
      };
    }
    function mergeInject(to2, from2) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
    }
    function normalizeInject(raw) {
      if (isArray$2(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from2) {
      return to2 ? [...new Set([].concat(to2, from2))] : from2;
    }
    function mergeObjectOptions(to2, from2) {
      return to2 ? extend$2(/* @__PURE__ */ Object.create(null), to2, from2) : from2;
    }
    function mergeEmitsOrPropsOptions(to2, from2) {
      if (to2) {
        if (isArray$2(to2) && isArray$2(from2)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from2])];
        }
        return extend$2(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from2 != null ? from2 : {})
        );
      } else {
        return from2;
      }
    }
    function mergeWatchOptions(to2, from2) {
      if (!to2)
        return from2;
      if (!from2)
        return to2;
      const merged = extend$2(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from2) {
        merged[key] = mergeAsArray(to2[key], from2[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$2(rootComponent)) {
          rootComponent = extend$2({}, rootComponent);
        }
        if (rootProps != null && !isObject$2(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$2(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$2(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace === true) {
                namespace = "svg";
              } else if (namespace === false) {
                namespace = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$2(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$2(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$2({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$2(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      if (ctor === null) {
        return "null";
      }
      if (typeof ctor === "function") {
        return ctor.name || "";
      } else if (typeof ctor === "object") {
        const name = ctor.constructor && ctor.constructor.name;
        return name || "";
      }
      return "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$2(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$2(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$2(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend$2(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$2(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$2(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString2 = isString$2(ref3);
        const _isRef = isRef(ref3);
        if (_isString2 || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString2 ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$2(existing) && remove(existing, refValue);
              } else {
                if (!isArray$2(existing)) {
                  if (_isString2) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString2) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace = "svg";
        } else if (n2.type === "math") {
          namespace = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start2 = 0) => {
        for (let i = start2; i < children.length; i++) {
          const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    namespace,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children.length; i++) {
            move(children[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i = start2; i < children.length; i++) {
          unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render = (vnode, container, namespace) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$2(ch1) && isArray$2(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type) => type.__isTeleport;
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$2(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$2(style)) {
          if (isProxy(style) && !isArray$2(style)) {
            style = extend$2({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$2(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$2(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$2(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$2(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$2(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$2(
              extend$2(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name = getComponentName(Component);
      if (!name && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name = match[1];
        }
      }
      if (!name && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name ? classify(name) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$2(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$2(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const version = "3.4.19";
    /**
    * @vue/runtime-dom v3.4.19
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace, is, props) => {
        const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector2) => doc.querySelector(selector2),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace, start2, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
          while (true) {
            parent.insertBefore(start2.cloneNode(true), anchor);
            if (start2 === end2 || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace === "svg" || namespace === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$2(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$2(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$2(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$2(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue && (el.style.display === el[vShowOldKey] || !value))
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOldKey] : "none";
    }
    const CSS_VAR_TEXT = Symbol("");
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      const setVars = () => {
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
      };
      watchPostEffect(setVars);
      onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor)
            break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for (const key in vars) {
          style.setProperty(`--${key}`, vars[key]);
          cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
      }
    }
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$2(next);
      const currentDisplay = style.display;
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev && !isString$2(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOldKey in el) {
        el[vShowOldKey] = hasControlledDisplay ? style.display : "";
        style.display = currentDisplay;
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$2(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$2(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$2(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$2(value)) {
        return false;
      }
      return key in el;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    function getValue(el) {
      return "_value" in el ? el._value : el.value;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      const cache = fn._withKeys || (fn._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$2(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const IconSettings = {
      name: "IconSettings",
      render() {
        const _default = this.$slots.default ? this.$slots.default()[0] : null;
        return _default;
      },
      props: {
        iconPath: String,
        actionSpritePath: String,
        customSpritePath: String,
        doctypeSpritePath: String,
        standardSpritePath: String,
        utilitySpritePath: String
      },
      provide() {
        return {
          $__getIconSettings: () => this.$props
        };
      }
    };
    const getGUID = () => {
      function s4() {
        return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
      }
      return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
    };
    const hasOwnProperty$1 = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    const getMissingProps = (object, props) => {
      const missing = [];
      props.forEach((prop) => {
        if (!hasOwnProperty$1(object, prop)) {
          missing.push(prop);
        }
      });
      return missing;
    };
    function bind$1(fn, thisArg) {
      return function wrap2() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString: toString$1 } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString$1.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$1 } = Array;
    const isUndefined$1 = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$1 = typeOfTest("string");
    const isFunction$1 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$1 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$1 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray$1(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray$2 = (thing) => {
      if (!thing)
        return null;
      if (isArray$1(thing))
        return thing;
      let i = thing.length;
      if (!isNumber$1(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source, i) => {
        if (isObject$1(source)) {
          if (stack2.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack2[i] = source;
            const target = isArray$1(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined$1(reducedValue) && (target[key] = reducedValue);
            });
            stack2[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    const utils$1 = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isBoolean,
      isObject: isObject$1,
      isPlainObject,
      isUndefined: isUndefined$1,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend: extend$1,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray$2,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token2, i) {
        token2 = removeBrackets(token2);
        return !dots && i ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack2 = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack2.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack2.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack2.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$1 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$1.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults$1.headers[method] = {};
    });
    const defaults$2 = defaults$1;
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens2[match[1]] = match[2];
      }
      return tokens2;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$2;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION = "1.6.7";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack2;
            } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack2;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i = token2._listeners.length;
          while (i-- > 0) {
            token2._listeners[i](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token2.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap2(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind$1(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$2);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const Node$2 = function() {
      this.keys = /* @__PURE__ */ new Map();
      this.childCount = 0;
      this.end = false;
      this.setEnd = function() {
        this.end = true;
      };
      this.isEnd = function() {
        return this.end;
      };
    };
    const Trie = function() {
      this.root = new Node$2();
      this.add = function(input, node = this.root) {
        if (input.length === 0) {
          node.setEnd();
          return;
        }
        node.childCount++;
        if (!node.keys.has(input[0])) {
          node.keys.set(input[0], new Node$2());
          return this.add(input.substr(1), node.keys.get(input[0]));
        }
        return this.add(input.substr(1), node.keys.get(input[0]));
      };
      this.countChildren = function(word) {
        let node = this.findNode(word);
        if (node === false)
          return -1;
        return node.childCount;
      };
      this.isWord = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        return !!(node.keys.has(word) && node.keys.get(word).isEnd());
      };
      this.findNode = (word) => {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (node.keys.get(word))
          return node.keys.get(word);
        else
          return false;
      };
      this.prefixMatchingWords = (prefix) => {
        const words = new Array();
        let node = this.findNode(prefix);
        if (!node)
          return words;
        if (node.childCount === 0)
          return [prefix];
        const search = function(node2, string) {
          if (node2.keys.size != 0) {
            for (const letter of node2.keys.keys()) {
              search(node2.keys.get(letter), string.concat(letter));
            }
            if (node2.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(node, new String());
        if (words.length > 0) {
          return words.map((word) => `${prefix}${word}`);
        }
        return [];
      };
      this.countDirectChildren = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (!node.keys.has(word))
          return false;
        if (node.keys.get(word).isEnd()) {
          return 0;
        }
        return node.keys.get(word).keys.size;
      };
      this.print = function() {
        const words = new Array();
        const search = function(node, string) {
          if (node.keys.size != 0) {
            for (const letter of node.keys.keys()) {
              search(node.keys.get(letter), string.concat(letter));
            }
            if (node.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(this.root, new String());
        return words.length > 0 ? words : mo;
      };
    };
    const Trie$1 = { Trie };
    const Symbols = {
      Circle: {
        label: "Circle",
        marker: "●",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <circle r="24" cy="26" cx="26" style="fill:#706e6b;stroke:#706e6b;stroke-width:3.847;stroke-linejoin:round;fill-opacity:1;stroke-opacity:1"/>
            </svg>
        `
      },
      Square: {
        label: "Square",
        marker: "■",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path style="fill:#706e6b;fill-opacity:1;stroke:#706e6b;stroke-width:3.77953;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="M1.889765 1.889765h48v48h-48z"/>
            </svg>
        `
      },
      Pyramid: {
        label: "Pyramid",
        marker: "▲",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path  d="M52 52 25 0 0 52Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Triangle: {
        label: "Triangle",
        marker: "▼",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="m0 0 27 52L52 0Z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Diamond: {
        label: "Diamond",
        marker: "◆",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M26 0 0 26l26 26 26-26Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Star: {
        label: "Star",
        marker: "★",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path transform="matrix(1.04945 0 0 1.10341 -.23623862 1.1584795)" d="m25.000001 0 7.347315 14.887288 16.429097 2.387288-11.888207 11.588136 2.806425 16.362713L25 37.5l-14.694632 7.725424 2.806426-16.362712L1.2235873 17.274575l16.4290967-2.387287Z" style="fill:#706e6b;fill-rule:evenodd;stroke:#706e6b;stroke-width:.929286;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Parallelogram: {
        label: "Parallelogram",
        marker: "▰",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52-2.6e-7H10L0 51.999999h43z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Rectangle: {
        label: "Rectangle",
        marker: "▬",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52 10H0v32h52z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Box: {
        label: "Box",
        marker: "▮",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M43 0 10-2.6e-7V52l33-.000001z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      }
    };
    const MapUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Symbols
    }, Symbol.toStringTag, { value: "Module" }));
    function SegClient({ Buffer: Buffer2, Papa: Papa2 } = {}) {
      const Rule = {
        toSaql(rule, dataSource) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: dataSource._referenceFields.find((f) => f.id === item.sfsp__Field__c).dataType === "Numeric" ? "Numeric" : "Text"
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        }
      };
      const Filter = {
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i = 0; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        toSaql(filter) {
          const { field, operator, value = "", dataType } = filter;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] && ${field} is not null)` : `${field} not in ["${values.join('","')}"]` : value ? `${field} != "${value}"` : `(${field} != "" && ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              case "doesnotcontain":
                return values.length > 1 ? `(${values.map((v) => `!(${field} matches "${v}")`).join(" && ")})` : `!(${field} matches "${value}")`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: ""
        }),
        getDataSetCountSaql({ datasetId, versionId }) {
          return `
                -- load records
                q = load "${datasetId}/${versionId}";
    
                -- results
                results = group q by all;
                results = foreach results generate count() as count;
            `;
        },
        // saql generation
        generateHierarchySaql({ node, nodeMap, dataSource, fields = [] }) {
          if (!node._parentId) {
            return `
                    ------------------------------------
                    -- Records
                    ------------------------------------
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    ------------------------------------
                    -- Filters
                    ------------------------------------
    
                    -- all org
                    all_org = group q by all;
                    ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}
    
                    ------------------------------------
                    -- Projections
                    ------------------------------------
                    ${Object.keys(nodeMap).map((id) => `
                        ${id} = group ${id} by all;
                        ${id} = foreach ${id} generate ${[
              `"${id}" as __NodeId`,
              `count() as __Records`,
              ...fields.map((f) => `sum(${f}) as ${f}`)
            ].join(", ")};
                    `).join("")}
    
                    ------------------------------------
                    -- Results
                    ------------------------------------
                    ${Object.keys(nodeMap).length > 1 ? `results = union ${Object.keys(nodeMap).join(", ")};` : `results = limit ${Object.keys(nodeMap)[0]} 1;`}
                `.replace(/^ */gm, "");
          }
          return `
                -- ${node.Name}
                ${node.Id} = filter ${node._parentId} by ${this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id })};
                ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}`;
        },
        generateNodeFilterSaql({ node, nodeMap, dataSource, descendantFilters = [], isBurndown = false }) {
          descendantFilters.push(this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id, isBurndown }));
          if (!node._parentId) {
            return `
                    -- load records
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    -- filters
                    results = filter q by (${descendantFilters.join(") && (")});
                `;
          }
          return this.generateNodeFilterSaql({ node: nodeMap[node._parentId], nodeMap, dataSource, descendantFilters });
        },
        generateRules({ node, nodeMap, dataSource, uniqueIdField, isBurndown }) {
          const burndownNodes = isBurndown ? node.sfsp__SalesNodes__r : [];
          if (node.sfsp__SalesNodeRules__r.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} ${node.Id === "all_org" ? "is not null" : "is null"}`;
          const saqlParts = [];
          if (node.sfsp__SalesNodeRules__r.length) {
            const matchingRulesLogic = this.getRuleLogic({ node });
            const matchingRulesFilterExpression = Filter.mergeBooleanFilter(
              matchingRulesLogic,
              node.sfsp__SalesNodeRules__r.map((r) => Rule.toSaql(r, dataSource))
            );
            saqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${this.generateRules({ node: childNode, nodeMap, dataSource, uniqueIdField })})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        // rule logic
        getRuleLogic({ node }) {
          const existingRuleLogic = node.sfsp__RuleLogics__c;
          if (existingRuleLogic)
            return existingRuleLogic;
          return node.sfsp__SalesNodeRules__r.length === 0 ? "" : Array(node.sfsp__SalesNodeRules__r.length).fill().map((item, i) => i + 1).join(" or ");
        },
        setRuleLogic({ node, logic }) {
          node.sfsp__RuleLogics__c = logic;
        },
        // hierarchy
        async buildNodeMap({ nodeId: nodeId2 }) {
          const nodeMap = {
            all_org: {
              ...SPM.Utils.Segment.Node.defaults(),
              Id: "all_org",
              Name: "All Org"
            }
          };
          const loadAncestors = async (parentId) => {
            let [node] = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        sfsp__SalesPlan__c,
                        sfsp__Parent__c,
                        ${Array(5).fill().map((item, i) => {
              const prefix = Array(i + 1).fill().map(() => "sfsp__Parent__r").join(".");
              return `
                                ${prefix}.Name,
                                ${prefix}.sfsp__Parent__c,
                                ${prefix}.sfsp__RuleLogics__c,
                            `;
            }).join("")}
                        sfsp__RuleLogics__c
                    FROM sfsp__SalesNode__c
                    WHERE Id = '${parentId}'
                `]);
            while (node) {
              nodeMap[node.Id] = {
                ...SPM.Utils.Segment.Node.defaults(),
                ...node,
                _parentId: node.sfsp__Parent__c || "all_org"
              };
              if (node.sfsp__Parent__c && !node.sfsp__Parent__r) {
                await loadAncestors(node.sfsp__Parent__c);
              }
              node = node.sfsp__Parent__r;
            }
          };
          await loadAncestors(nodeId2);
          const rules = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c,
                    (
                        SELECT Id, sfsp__SalesNodeRule__r.sfsp__SalesNode__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                        FROM sfsp__SalesNodeRuleItems__r
                        ORDER BY sfsp__SortOrder__c
                    )
                FROM sfsp__SalesNodeRule__c
                WHERE sfsp__SalesNode__c IN ('${Object.keys(nodeMap).filter((id) => id !== "all_org").join(`','`)}')
                ORDER BY sfsp__SortOrder__c
            `]);
          rules.forEach((r) => nodeMap[r.sfsp__SalesNode__c].sfsp__SalesNodeRules__r.push(r));
          return nodeMap;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node._parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.sfsp__SalesNodes__r || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        compare({ node, compareNode, breadcrumbs = [] }) {
          const diff2 = [];
          const map2 = {};
          node.sfsp__SalesNodes__r.forEach((n) => {
            const matchingNodeIndex = compareNode.sfsp__SalesNodes__r.findIndex((n2) => n2.Name === n.Name);
            if (matchingNodeIndex !== -1) {
              const matchingNode = compareNode.sfsp__SalesNodes__r.splice(matchingNodeIndex, 1)[0];
              map2[n.Id] = matchingNode;
              const childCompareResults = Node2.compare({ node: n, compareNode: matchingNode, breadcrumbs: [...breadcrumbs, n] });
              diff2.push(...childCompareResults.diff);
              Object.assign(map2, childCompareResults.map);
            } else {
              diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Target Not Found" });
            }
          });
          compareNode.sfsp__SalesNodes__r.forEach((n) => {
            diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Source Not Found" });
          });
          return { diff: diff2, map: map2 };
        },
        // queries
        async getRecordCount({ segmentId, dataSource, nodeMap }) {
          var _a;
          nodeMap = nodeMap || await Node2.buildNodeMap({ segmentId });
          const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[nodeId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = group results by all;
                results = foreach results generate count() as count;
            `.replace(/^ */gm, "") });
          return ((_a = aggregateResults == null ? void 0 : aggregateResults.records[0]) == null ? void 0 : _a.count) || 0;
        },
        async resetStampedDataSource(segmentId) {
          await SPM.Utils.CRM.upsert({ records: [{
            Id: segmentId,
            sfsp__StampDataSourceId__c: ""
          }] });
        },
        async buildDataSource({ planId }) {
          const [dataSource] = await SPM.Utils.Apex.invoke("Query", [`
                SELECT Id, Name, sfsp__SourceId__c, sfsp__ReferenceFields__c
                FROM sfsp__SalesDataSource__c
                WHERE Id IN (SELECT sfsp__SalesDataSource__c FROM sfsp__SalesPlan__c WHERE Id = '${planId}')
            `]);
          dataSource._referenceFields = JSON.parse(dataSource.sfsp__ReferenceFields__c);
          dataSource._dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: dataSource.sfsp__SourceId__c });
          return dataSource;
        },
        async getRecords({ segmentId, dataSource, nodeMap, uniqueIds = [], limit = 1, offset: offset2 }) {
          nodeMap = nodeMap || await this.buildNodeMap({ segmentId });
          if (uniqueIds.length > 0)
            limit = uniqueIds.length;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", {
            query: `
                    ${Node2.generateNodeFilterSaql({
              node: nodeMap[segmentId],
              nodeMap,
              dataSource,
              uniqueIds
            })}

                    -- results
                    results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                    ${offset2 ? `results = offset results ${offset2};` : ""}
                    results = limit results ${limit};
                `.replace(/^ */gm, "")
          });
          return results.records;
        }
      };
      const ExternalData = {
        async getNumericScaleData({ dataSource }) {
          const scaleData = /* @__PURE__ */ new Map();
          const metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataSource._dataset.currentVersionUrl });
          metadata.measures.forEach((m) => {
            scaleData.set(m.fullyQualifiedName, m.format.decimalDigits);
          });
          return scaleData;
        },
        generateCsvMetadata({ segmentId, dataSource, scaleDataMap, datasetName, datasetLabel }) {
          const fields = [];
          dataSource._referenceFields.forEach((f) => {
            const field = {
              fullyQualifiedName: f.id,
              name: f.id,
              label: f.label,
              isUniqueId: false,
              type: f.dataType,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.dataType === "Numeric") {
              field.precision = 18;
              field.scale = scaleDataMap.get(f.id) || 0;
              field.defaultValue = 0;
            }
            fields.push(field);
          });
          const csvMetadata = {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: "SegmentData",
                label: "Segment Data",
                name: "SegmentData",
                description: "",
                fields
              }
            ]
          };
          return csvMetadata;
        },
        async waitDataflowJobComplete({ jobId, retries = 5 }) {
          let waitInMilliseconds = 1e4;
          while (retries > 0) {
            const response = await SPM.Utils.Rest.invoke("GetCurrentDataflowJob", { id: jobId });
            if (!["Failure", "Warning", "Success"].includes(response.status)) {
              await SPM.Utils.Async.wait(waitInMilliseconds);
              waitInMilliseconds *= 2;
              retries--;
            } else if (["Success", "Warning"].includes(response.status)) {
              return true;
            } else if (["Failure"].includes(response.status)) {
              return false;
            }
          }
          return false;
        },
        async stampDataSource({ segmentId, dataSource, planName, planId, segmentName }) {
          var _a;
          const nodeMap = await Node2.buildNodeMap({ nodeId: segmentId });
          const scaleDataMap = await ExternalData.getNumericScaleData({ dataSource });
          const datasetName = planId + "_" + segmentId;
          const datasetLabel = (planName + " - " + segmentName).slice(0, 80);
          const csvMetadata = ExternalData.generateCsvMetadata({
            segmentId,
            dataSource,
            scaleDataMap
          });
          const crmafolder = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id
                    FROM Folder
                    WHERE Type = 'Insights' AND Name = '${dataSource._dataset.folder.label}'
            `]);
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDatasetName: dataSource._dataset.name,
              stampDatasetName: datasetLabel,
              jobName: "Stamp Records"
            }
          });
          const stampJobStartTime = performance.now();
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: datasetName, label: datasetLabel, app: (_a = crmafolder[0]) == null ? void 0 : _a.Id, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const batchSize = 5e4;
          let batchNum = 0;
          let batchStats = [];
          let datasetRowMap = {};
          let csvParts = [];
          let recordBatches = [];
          let partNumber = 0;
          let offset2 = 0;
          let doMore = true;
          const uniqueIdField = dataSource._referenceFields.find((f) => f.isId).id;
          const saql = `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[segmentId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                results = order results by ${dataSource._referenceFields.find((f) => f.isId).id};
            `;
          while (doMore) {
            datasetRowMap = {};
            csvParts = [];
            const saqlBatch = saql + `
                results = offset results ${offset2};
                results = limit results ${batchSize};
                `;
            const downloadStartTime = performance.now();
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saqlBatch.replace(/^ */gm, "") });
            const downloadEndTime = performance.now();
            if (results.records.length === 0) {
              doMore = false;
              continue;
            }
            batchNum++;
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            const csv = Papa2.unparse(recordBatches[0]);
            const chunkSize = 9e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results2, parser) {
                csvParts.unshift(Papa2.unparse(results2.data));
              }
            });
            const uploadStartTime = performance.now();
            await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
              const base64String = Buffer2.from(`${data}\r
`).toString("base64");
              const csvPart = base64String;
              partNumber += 1;
              const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
              if (!partResponse.success)
                throw partResponse.errors[0] || "";
            }, 5);
            const uploadEndtime = performance.now();
            batchStats.push({
              numRows: results.records.length,
              downloadTime: downloadEndTime - downloadStartTime,
              uploadTime: uploadEndtime - uploadStartTime
            });
            offset2 += results.records.length;
          }
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDataset: {
                id: dataSource._dataset.id,
                name: dataSource._dataset.name,
                numRows: dataSource._dataset.currentVersionTotalRowCount,
                numColumns: csvMetadata.objects[0].fields.length
              },
              stampDataset: {
                name: datasetLabel,
                numRows: offset2,
                numColumns: csvMetadata.objects[0].fields.length
              },
              jobRunTime: Math.round(performance.now() - stampJobStartTime),
              numBatches: batchNum,
              batchStats,
              crmaJobId: jobResponse.id,
              status: "SUCCESS"
            }
          });
          return { jobId: jobResponse.id, datasetLabel, numRecords: offset2, numFields: csvMetadata.objects[0].fields.length };
        },
        async fetchStampJobResults(jobId, datasetId, datasetLabel, segmentId) {
          const jobStatus = await ExternalData.waitDataflowJobComplete({ jobId });
          if (!jobStatus) {
            SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
            return;
          }
          if (datasetId) {
            const datasetResponse = await SPM.Utils.Rest.invoke("GetDataset", { id: datasetId });
            try {
              if (datasetResponse.label !== datasetLabel) {
                await SPM.Utils.Rest.invoke("PatchDataset", { id: datasetId, metadata: { label: datasetLabel } });
              }
            } catch (err) {
            }
          } else {
            const datasetsResponse = await SPM.Utils.Rest.invoke("GetDatasets", { alias: datasetLabel.replaceAll("'", "%5C%27") });
            if (!(datasetsResponse == null ? void 0 : datasetsResponse.length)) {
              SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
              return;
            }
            const dataset = datasetsResponse[0];
            await SPM.Utils.CRM.upsert({ records: [{
              Id: segmentId,
              sfsp__StampDataSourceId__c: dataset.id
            }] });
          }
        }
      };
      const TPDataSet = {
        async fetchRelatedDataSets() {
          let dataSets = [];
          const externalAssets = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__AssetType__c, sfsp__AssetId__c FROM sfsp__SalesNodeExternalAsset__c WHERE sfsp__SalesNode__c = '${SPM.$store.segment.Id}'`]);
          try {
            dataSets = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        maps__Config__c,
                        (SELECT Id, Name, CreatedById, CreatedBy.Name, CreatedDate FROM maps__Alignments__r WHERE maps__Status__c != 'Deleted')
                    FROM maps__TPDataSet__c
                    WHERE Id IN ('${externalAssets.filter((a) => a.sfsp__AssetType__c === "Territory Plan").map((a) => a.sfsp__AssetId__c).join("','")}') AND maps__Status__c != 'Deleted'
                `]);
          } catch (err) {
          }
          const matchingDataSets = dataSets.filter((ds) => {
            return JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id);
          });
          SPM.$store.$patch((state) => state.TPDataSets = matchingDataSets);
          return matchingDataSets || [];
        },
        async fetchRelatedAlignments() {
          const alignments = [];
          const dataSets = await TPDataSet.fetchRelatedDataSets();
          dataSets.forEach((ds) => {
            if ((ds == null ? void 0 : ds.maps__Alignments__r) && JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id))
              alignments.push(...ds == null ? void 0 : ds.maps__Alignments__r);
          });
          SPM.$store.$patch((state) => state.TPAlignments = alignments);
          return alignments;
        }
      };
      const TerritoryStampUtils = {
        parsedStampDetails(stampDetails, referenceFields) {
          return stampDetails.map((detail) => {
            const hierarchyData = JSON.parse(detail.sfsp__HierarchyReferenceData__c);
            const parsedData = {};
            Object.keys(hierarchyData).forEach((key) => {
              const referenceMetadata = referenceFields.find((f) => f.type === "Territory" && f.id === key);
              parsedData[key] = "";
              if (referenceMetadata.dataType === "Number") {
                parsedData[key] = hierarchyData[key].SUM;
              } else if (referenceMetadata.dataType === "String") {
                parsedData[key] = hierarchyData[key].VALUE;
              }
            });
            const labeledData = referenceFields.reduce((acc, field) => {
              const keyValue = parsedData[field.id];
              if (keyValue === void 0) {
                if (field.dataType === "Number") {
                  acc[field.label] = 0;
                } else {
                  acc[field.label] = "";
                }
              } else {
                acc[field.label] = keyValue;
              }
              return acc;
            }, {});
            return {
              ...detail,
              data: labeledData
            };
          });
        },
        hierarchicalStampDetails(parsedStampDetails) {
          const detailsMap = /* @__PURE__ */ new Map();
          parsedStampDetails.forEach((detail) => {
            detail.children = [];
            detailsMap.set(detail.Id, detail);
          });
          const rootDetails = [];
          detailsMap.forEach((detail) => {
            if (detail.sfsp__Parent__c) {
              const parentDetail = detailsMap.get(detail.sfsp__Parent__c);
              if (parentDetail) {
                parentDetail.children.push(detail);
              }
            } else {
              rootDetails.push(detail);
            }
          });
          const result = [];
          const traverse2 = (details, indent) => {
            details.forEach((detail) => {
              detail.indent = indent;
              result.push(detail);
              traverse2(detail.children, indent + 1);
            });
          };
          traverse2(rootDetails, 0);
          return result;
        }
      };
      return {
        Rule,
        Filter,
        Node: Node2,
        ExternalData,
        TPDataSet,
        TerritoryStampUtils
      };
    }
    const deconstructFQAPIName = (field = []) => {
      const parts = field.split(".");
      return {
        field: parts[parts.length - 1],
        lookups: parts.splice(0, parts.length - 1)
      };
    };
    const getValueFromRecord = (fullyQualifiedApiName, record = {}) => {
      const { field, lookups = [] } = deconstructFQAPIName(fullyQualifiedApiName);
      const obj = lookups.reduce((r, l) => r == null ? void 0 : r[l], record);
      return obj == null ? void 0 : obj[field];
    };
    function UtilsClient({ Buffer: Buffer2, Papa: Papa2, randomLocation } = {}) {
      const Apex = {
        async invoke(action, params = [], { cls = "SPMRemoteActions" } = {}) {
          const startTime = window.performance.now();
          const promise = new Promise((resolve2) => {
            const args = [
              `sfsp.${cls}.${action}`,
              ...params,
              (data, event) => resolve2({ data, event })
            ];
            Visualforce.remoting.Manager.invokeAction(...args, { buffer: false, escape: false, timeout: 12e4 });
          });
          const result = await promise;
          if (!result.event.status) {
            throw {
              type: "RemoteActionException",
              error: result.event
            };
          } else {
            if (action === "Query") {
              SPM.Utils.Splunk.sendLog({
                logName: "spmAPEX",
                logPayload: {
                  query: params[0],
                  returnCount: result.data.length,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
            return result.data;
          }
        }
      };
      const Rest = {
        async invoke() {
          const [method, params = {}] = arguments;
          const headers = { Authorization: `Bearer ${SPM.SessionId}` };
          const promise = new SPM.Utils.DeferredPromise();
          const response = await this.Actions[method](headers, params);
          promise.resolve(response);
          if (SPM.Utils.Debug) {
            promise.then((r) => {
              console.groupCollapsed(method);
              [params, r].forEach((obj) => console.log(obj));
              console.groupEnd();
            }).catch((err) => {
              console.groupCollapsed(method);
              [params, err].forEach((obj) => console.log(obj));
              console.groupEnd();
            });
          }
          return promise;
        },
        Actions: {
          async Query(headers, { query }) {
            const startTime = window.performance.now();
            const records = [];
            let { data: results } = await axios({
              method: "GET",
              url: "/services/data/v53.0/query",
              params: {
                q: query
              },
              headers
            });
            records.push(...results.records);
            while (results.nextRecordsUrl) {
              results = (await axios({ method: "GET", url: results.nextRecordsUrl, headers })).data;
              records.push(...results.records);
            }
            records.forEach((r) => {
              Object.keys(r).forEach((key) => {
                var _a;
                if ((_a = r[key]) == null ? void 0 : _a.records) {
                  r[key] = r[key].records;
                }
              });
            });
            SPM.Utils.Splunk.sendLog({
              logName: "spmREST",
              logPayload: {
                query,
                returnCount: records.length,
                executionTime: window.performance.now() - startTime
              }
            });
            return records;
          },
          async Insert(headers, { records }) {
            if (records.length === 0)
              return [];
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v53.0/composite/sobjects",
              data: {
                allOrNone: true,
                records
              },
              headers
            });
            return results;
          },
          async Delete(headers, { ids }) {
            const batches = [];
            while (ids.length)
              batches.push(ids.splice(0, 1e3));
            await Async.forEachParallel(batches, async (batch) => {
              await axios({
                method: "DELETE",
                url: "/services/data/v53.0/composite/sobjects",
                params: {
                  ids: batch.join(",")
                },
                headers
              });
            }, 5);
          },
          async tpRest(headers, { action, data }) {
            const { data: results } = await axios({
              method: "POST",
              url: `/services/apexrest/maps/TPRest/${action}`,
              data,
              headers
            });
            return results.data;
          },
          async ToolingQuery(headers, query) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/tooling/query/?q=${query}`,
              headers
            });
            return results;
          },
          async ToolingSObject(headers, { sObject }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/tooling/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async ToolingSObjectPatch(headers, { url, metadata }) {
            const { data: results } = await axios({
              method: "PATCH",
              url,
              data: metadata,
              headers
            });
            return results;
          },
          async SObjects(headers) {
            const { data: results } = await axios({
              method: "GET",
              url: "/services/data/v53.0/sobjects",
              headers
            });
            return results;
          },
          async SObject(headers, { sObject }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async RunSaql(headers, { query }) {
            var _a, _b;
            const startTime = window.performance.now();
            let res;
            try {
              const { data: results } = await axios({
                method: "POST",
                url: "/services/data/v53.0/wave/query",
                data: {
                  query
                },
                headers
              });
              res = results;
              return results;
            } catch (e) {
              SPM.$store.toast({ message: e.response.data[0].message, duration: 5e3, state: "error" });
              return { records: [] };
            } finally {
              SPM.Utils.Splunk.sendLog({
                logName: "spmSAQL",
                logPayload: {
                  query,
                  returnCount: ((_b = (_a = res == null ? void 0 : res.results) == null ? void 0 : _a.records) == null ? void 0 : _b.length) || 0,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
          },
          async GetDataflows(headers, { alias }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflows?hasCurrentOnly&q=${alias}`,
              headers
            });
            return results.dataflows || [];
          },
          async UpdateDataflow(headers, { dataflowId, definition }) {
            const { data: results } = await axios({
              method: "PATCH",
              url: `/services/data/v50.0/wave/dataflows/${dataflowId}`,
              data: {
                definition
              },
              headers
            });
            return results;
          },
          async RunDataflow(headers, { dataflowId }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v53.0/wave/dataflowjobs",
              data: {
                dataflowId,
                command: "Start"
              },
              headers
            });
            return results;
          },
          async GetDatasets(headers, { alias, hasCurrentOnly = true }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets?hasCurrentOnly=${hasCurrentOnly}&q=${alias}&filterGroup=Supplemental`,
              headers
            });
            return results.datasets || [];
          },
          async GetDataset(headers, { id }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets/${id}?t=${Date.now()}`,
              headers
            });
            return results;
          },
          async PatchDataset(headers, { id, metadata }) {
            await axios({
              method: "PATCH",
              url: `/services/data/v53.0/wave/datasets/${id}`,
              data: metadata,
              headers
            });
          },
          async GetDatasetMetadata(headers, { url }) {
            const { data: results } = await axios({
              method: "GET",
              url: `${url}/xmds/main`,
              headers
            });
            return results;
          },
          async GetCurrentDataflowJob(headers, { id }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflowjobs/`,
              headers
            });
            results.dataflowJobs.filter((f) => f.label.includes(id));
            results.dataflowJobs.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
            return results.dataflowJobs[0];
          },
          async CreateExternalDataJob(headers, { metadata, alias, label, app, operation }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalData",
              data: {
                Format: "Csv",
                LicenseType: SPM.isScratch ? "EinsteinAnalytics" : "Sonic",
                EdgemartAlias: alias,
                EdgemartLabel: label || alias,
                EdgemartContainer: app || "",
                Operation: operation,
                Action: "None",
                NotificationSent: "Always",
                MetadataJson: metadata
              },
              headers
            });
            return results;
          },
          async UploadCsvPart(headers, { parentId, csvPart, partNumber }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalDataPart",
              data: {
                DataFile: csvPart,
                InsightsExternalDataId: parentId,
                PartNumber: partNumber
              },
              headers
            });
            return results;
          },
          async StartExternalDataJob(headers, { parentId }) {
            const { data: results } = await axios({
              method: "PATCH",
              url: `/services/data/v56.0/sobjects/InsightsExternalData/${parentId}`,
              data: {
                Action: "Process"
              },
              headers
            });
            return results;
          },
          async UploadAutoAssignmentData(headers, { scus, mapping }) {
            const uploadResponse = await Apex.invoke("GetAutoAssignmentUploadUrl", []);
            const data = {
              records: scus,
              mapping: mapping || {
                "Unique Id": "Id",
                "Assignment": "Assignment",
                "Boundaries": "Boundaries",
                "Locked": "Locked",
                "Latitude": "Latitude",
                "Longitude": "Longitude",
                "Weight": "Weight",
                "Volume": "Volume"
              }
            };
            await axios({
              method: "PUT",
              url: uploadResponse.externalDataUrl,
              headers: { "Content-Type": "application/json" },
              data
            });
            return uploadResponse.requestId;
          },
          async MoveDatasetToSharedFolder(headers, { datasetId }) {
            let response = await Apex.invoke("MoveDatasetToSharedFolder", [datasetId]);
            if (!response.success) {
              const folder = await Apex.invoke("Query", [`SELECT Id FROM Folder where Type = 'Insights' AND DeveloperName = 'Sales_Planning'`]);
              const data = {
                folder: { id: folder[0].Id }
              };
              ({ data: response } = await axios({
                method: "PATCH",
                url: `/services/data/v56.0/wave/datasets/${datasetId}`,
                headers,
                data
              }));
            }
            return response;
          }
        }
      };
      const HTTP = {
        async get({ url }) {
          const results = await axios({
            method: "GET",
            url
          });
          return results;
        }
      };
      const CRM = {
        MasterDetailRelationships: {
          sfsp__SalesNodeRuleItem__c: {
            sfsp__SalesNodeRule__c: true
          }
        },
        upsert: async ({ records, onProgress = () => {
        } }) => {
          const recordsToInsert = [];
          const recordsToUpdate = [];
          records.forEach((r) => (r.Id ? recordsToUpdate : recordsToInsert).push(r));
          const batches = [];
          while (recordsToInsert.length)
            batches.push({ type: "InsertSObjects", records: recordsToInsert.splice(0, 1e3) });
          while (recordsToUpdate.length)
            batches.push({ type: "UpdateSObjects", records: recordsToUpdate.splice(0, 1e3) });
          let recordsUpserted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            const primitiveRecords = batch.records.map((r) => {
              return Object.keys(r).reduce((obj, key) => {
                var _a, _b;
                const isPrivate = key.startsWith("_");
                const isTypeWithId = key === "sobjectType" && r.Id;
                const isChildRecords = key.endsWith("__r");
                const isUpdateMaster = batch.type === "UpdateSObjects" && ((_b = (_a = CRM.MasterDetailRelationships) == null ? void 0 : _a[r.sobjectType]) == null ? void 0 : _b[key]);
                const isReserved = ["CreatedBy", "CreatedById", "CreatedDate"].includes(key);
                if (!isPrivate && !isTypeWithId && !isChildRecords && !isUpdateMaster && !isReserved)
                  obj[key] = r[key];
                return obj;
              }, {});
            });
            const response = await Apex.invoke(batch.type, [primitiveRecords, true]);
            if (batch.type === "InsertSObjects") {
              response.forEach((r, i) => batch.records[i].Id = r.Id);
            }
            recordsUpserted += batch.records.length;
            onProgress(Math.floor(100 * recordsUpserted / records.length));
          }, 5);
        },
        delete: async ({ records, onProgress = () => {
        } }) => {
          const recordIdsToDelete = records.map((r) => r.Id).sort();
          const batches = [];
          while (recordIdsToDelete.length)
            batches.push(recordIdsToDelete.splice(0, 1e3));
          let recordsDeleted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            await Apex.invoke("DeleteIds", [batch, true]);
            recordsDeleted += batch.length;
            onProgress(Math.floor(100 * recordsDeleted / records.length));
          }, 5);
        }
      };
      const CRMA = {
        async checkDatasets(assignmentObject, options, callback = () => {
        }) {
          var _a, _b, _c;
          const toasts = [];
          const updateDatasets = async ({ recordsDataset, assignmentsDataset }) => {
            let canShare = true;
            await SPM.Utils.Async.forEachParallel([recordsDataset, assignmentsDataset], async (dataset) => {
              if (dataset.folder.name !== "Sales_Planning") {
                try {
                  const response = await SPM.Utils.Rest.invoke("MoveDatasetToSharedFolder", { datasetId: dataset.id });
                  if (response.folder)
                    dataset.folder = { name: "Sales_Planning" };
                } catch (err) {
                  canShare = false;
                }
              }
            });
            if (!canShare) {
              toasts.push({ showOnce: true, state: "warning", message: "This plan cannot be shared. Please see your admin about adding a Sales Planning app if you need to share with others." });
            }
            recordsDataset.dataflowStatus = "";
            assignmentsDataset.dataflowStatus = "";
            Object.assign(storeAssignment, { recordsDataset, assignmentsDataset, totalCount: recordsDataset.currentVersionTotalRowCount, assignmentCount: storeAssignment.assignmentCount || 0 });
            if (assignmentAsyncJob)
              Object.assign(assignmentAsyncJob, { status: "Success" });
            storeAssignment.asyncJob.status = "Success";
            callback();
          };
          const checkDataflowJobs = async (assignmentObject2, retries = 5) => {
            const { dataflowJobs } = await SPM.Utils.Apex.invoke("GetDataflowJobs", [SPM.$store.plan.Id, assignmentObject2.id]);
            const assignmentsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Assignments`);
            });
            const recordsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Records`);
            });
            if (!recordsJob || !assignmentsJob) {
              const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
              if (datasetResponse2) {
                await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                return 0;
              }
              await Async.wait(1e4);
              return retries;
            } else {
              assignmentObject2.recordsDataset.dataflowStatus = recordsJob.status;
              assignmentObject2.assignmentsDataset.dataflowStatus = assignmentsJob.status;
              if (!["Failure", "Warning", "Success"].includes(recordsJob.status) || !["Failure", "Warning", "Success"].includes(assignmentsJob.status)) {
                await Async.wait(1e4);
                return retries;
              } else if (["Success", "Warning"].includes(recordsJob.status) && ["Success", "Warning"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2) {
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                  if (["create", "update"].includes(options == null ? void 0 : options.type)) {
                    toasts.push(
                      recordsJob.status === "Warning" ? { message: `Assignment Object "${assignmentObject2.label}" was created with some warnings.`, duration: null, state: "warning", subMessage: `${SPM.orgDomainUrl}/analytics/dataManager` } : { message: `Assignment Object "${assignmentObject2.label}" was ${(options == null ? void 0 : options.type) === "create" ? "created" : "updated"}.`, duration: 3e3, state: "success" }
                    );
                    if (assignmentObject2.asyncJob.type === "Refresh Assignment Object")
                      await SPM.Utils.AssignmentObject.updateReferenceFields({ assignmentObject: assignmentObject2 });
                  }
                  return 0;
                }
                if (retries - 1 === 1) {
                  try {
                    await Promise.allSettled([
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
                    ]);
                  } catch (err) {
                  }
                }
                await Async.wait(1e4);
                return retries - 1;
              } else if (["Failure"].includes(recordsJob.status) || ["Failure"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2)
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                toasts.push({ message: `Assignment Object "${assignmentObject2.label}" dataflow had a failure ${(options == null ? void 0 : options.type) === "create" ? "creating" : options.type === "update" ? "updating" : "loading"}.`, duration: null, state: "error", subMessage: `Records: ${recordsJob.message}, Assignments: ${assignmentsJob.message}` });
                return 0;
              }
            }
          };
          const checkAsyncJobs = async (assignmentObject2) => {
            const latestJob = (await SPM.Utils.AssignmentObject.getSalesAsyncJobs({ objectId: assignmentObject2.id, statusFilter: ["Queued", "Running", "Waiting", "Failure"] }))[0] || false;
            if (!latestJob)
              return;
            SPM.$store.$patch((state) => {
              const storeSalesAsyncJob = SPM.$store.salesAsyncJobs.find((job) => job.Id === latestJob.Id);
              if (storeSalesAsyncJob)
                Object.assign(storeSalesAsyncJob, latestJob);
              const storeAssignmentObject = state.assignmentObjects.find((a) => a.id === assignmentObject2.id);
              if (storeAssignmentObject.recordsDataset && latestJob.sfsp__Status__c === "Waiting") {
                CRM.upsert({ records: [{ Id: latestJob.Id, sfsp__Status__c: "Success" }] });
                latestJob.sfsp__Status__c = "Success";
              }
              Object.assign(storeAssignmentObject.asyncJob, { id: latestJob.Id, type: latestJob.sfsp__Type__c, status: latestJob.sfsp__Status__c, details: latestJob.sfsp__Details__c });
              state.hasChanged = true;
            });
            if (!["Success", "Warning"].includes(latestJob.sfsp__Status__c)) {
              if (["Failure"].includes(latestJob.sfsp__Status__c)) {
                return latestJob;
              } else {
                await Async.wait(5e3);
                return await checkAsyncJobs(assignmentObject2);
              }
            }
          };
          const assignmentAsyncJob = SPM.$store.salesAsyncJobs.find((s) => s.sfsp__SalesAssignmentObject__c === assignmentObject.Id);
          const storeAssignment = SPM.$store.assignmentObjects.find((a) => a.id === assignmentObject.Id);
          if (!storeAssignment) {
            const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
            if (asyncJobIndex > -1)
              SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            if (options.type === "delete") {
              callback();
              toasts.push({ message: `Assignment Object "${options.assignmentObject.sfsp__Label__c}" was deleted.`, duration: 3e3, state: "success" });
            }
            return;
          }
          let datasetResponse = null;
          try {
            datasetResponse = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject.Id, planId: SPM.$store.plan.Id });
          } catch (err) {
            const errorCode = ((_a = err.response) == null ? void 0 : _a.data[0].errorCode) || null;
            if (errorCode === "FUNCTIONALITY_NOT_ENABLED")
              toasts.push({ showOnce: true, state: "warning", message: "Some features may not work properly. Please contact your admin to ensure you are properly licensed.", duration: null });
          }
          if (datasetResponse)
            await updateDatasets({ recordsDataset: datasetResponse.recordsDataset, assignmentsDataset: datasetResponse.assignmentsDataset });
          if (assignmentAsyncJob) {
            const failedJob = await checkAsyncJobs(storeAssignment);
            if (!failedJob) {
              let retries = await checkDataflowJobs(storeAssignment, 5);
              while (retries !== 0) {
                retries = await checkDataflowJobs(storeAssignment, retries);
                await Async.wait(2e3);
              }
            } else {
              SPM.$store.toast({ message: `Can’t ${options.type === "create" ? "create" : "update"} the ${options.assignmentObject.sfsp__Label__c} assignment object. Try again or contact Salesforce Customer Support.`, duration: null, state: "error" });
            }
            if (failedJob || ["Warning", "Success"].includes(storeAssignment.asyncJob.status)) {
              if (assignmentAsyncJob.sfsp__Splunk__c)
                SPM.Utils.Splunk.sendLog(JSON.parse(assignmentAsyncJob.sfsp__Splunk__c));
              try {
                await SPM.Utils.CRM.delete({ records: [{ Id: assignmentAsyncJob.Id }] });
              } catch (err) {
              }
              const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
              if (asyncJobIndex > -1)
                SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            }
          }
          if (!((_b = storeAssignment == null ? void 0 : storeAssignment.recordsDataset) == null ? void 0 : _b.dimensions) || !((_c = storeAssignment == null ? void 0 : storeAssignment.assignmentsDataset) == null ? void 0 : _c.dimensions)) {
            try {
              const settle2 = await Promise.allSettled([
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
              ]);
              await checkDataflowJobs(storeAssignment, 1);
              if (settle2.some((s) => s.status === "rejected")) {
                toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
              }
            } catch (err) {
              toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
            }
          }
          toasts.forEach((toast) => {
            if (SPM.$store.showOnLoadToasts || !toast.showOnce)
              SPM.$store.toast(toast);
          });
          SPM.$store.showOnLoadToasts = false;
          return;
        }
      };
      const Async = {
        forEach: async (array, callback) => {
          for (let i = 0; i < array.length; i++) {
            await callback(array[i], i, array);
          }
        },
        forEachParallel: (array, callback, threads) => {
          array = array.map((item) => item);
          return Promise.all(
            threads ? Array(threads).fill().map(() => (async () => {
              for (let item; item = array.shift(); )
                await callback(item);
            })()) : array.map((item, index) => (async () => callback(item, index, array))())
          );
        },
        forEachBulk: async (array, callback, blockCount) => {
          let blockStart = 0;
          while (blockStart < array.length) {
            const blockEnd = Math.min(blockStart + blockCount, array.length);
            for (let i = blockStart; i < blockEnd; i++) {
              callback(array[i]);
            }
            blockStart += blockCount;
            await Async.wait(1);
          }
        },
        wrapper: (callback) => (resolveAsync, rejectAsync) => {
          callback().then(resolveAsync).catch((err) => rejectAsync(err));
        },
        wait(milliseconds2, callback = async () => {
        }) {
          return new Promise((resolve2, reject) => setTimeout(() => {
            callback().then((val) => resolve2(val)).catch(reject);
          }, milliseconds2));
        }
      };
      const Store = {
        on(store, event, callback) {
          store.$onAction(async ({ name, args, after }) => {
            if (name === "emit" && args[0] === event)
              after(callback);
          });
        }
      };
      const Obj = {
        get(obj = {}, path, def2 = "") {
          const fullPath = path.replace(/\[/g, ".").replace(/]/g, "").split(".").filter(Boolean);
          return fullPath.every((part) => {
            obj = obj[part];
            return obj !== null && obj !== void 0;
          }) ? obj : def2;
        },
        compare(a, b, criteria) {
          const aVal = a[criteria];
          const bVal = b[criteria];
          if (aVal > bVal)
            return 1;
          if (aVal < bVal)
            return -1;
          return 0;
        },
        shallowCompare(a, b) {
          return Object.keys(a).length === Object.keys(b).length && Object.keys(a).every((key) => b.hasOwnProperty(key) && a[key] === b[key]);
        }
      };
      const Arr = {
        move(arr, from2, to2) {
          arr.splice(to2, 0, arr.splice(from2, 1)[0]);
        },
        splice(arr, fn) {
          if (arr.length === 0)
            return [];
          const spliced = [];
          arr.length - 1;
          for (let i2 = arr.length - 1; i2 >= 0; i2--) {
            if (fn(arr[i2]))
              spliced.push(arr.splice(i2, 1)[0]);
          }
          return spliced;
        }
      };
      const Tree2 = {
        inspect({ node, nodeCount = 1, depth = 1 }) {
          var _a;
          let maxDepth = depth;
          (_a = node == null ? void 0 : node.children) == null ? void 0 : _a.forEach((child) => {
            const childDetails = this.inspect({ node: child, depth: depth + 1 });
            nodeCount += childDetails.nodeCount;
            maxDepth = Math.max(maxDepth, childDetails.maxDepth);
          });
          return { nodeCount, maxDepth };
        }
      };
      const Rule = {
        RuleItem: {
          ETMOperators: {
            equals: "==",
            notEqual: "!=",
            lessThan: "<",
            lessOrEqual: "<=",
            greaterThan: ">",
            greaterOrEqual: ">=",
            contains: "like",
            notContain: "doesnotcontain",
            startsWith: "startsWith"
          },
          fromFilter(filter) {
            const isMeasure = typeof filter.value === "object";
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter.key,
              sfsp__Operator__c: isMeasure ? "between" : "==",
              sfsp__Value__c: isMeasure ? `${filter.value.from},${filter.value.to}` : filter.value
            };
          },
          fromRecordFilter(filter) {
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter.field,
              sfsp__Operator__c: filter.operator,
              sfsp__Value__c: filter.value
            };
          }
        },
        fromFilterSet(filterSet, assignmentObjectId, startItemIndex = 1) {
          const booleanFilterParts = [];
          const ruleItems = [];
          const ancestorFilters = filterSet[0].slice(0, filterSet[0].length - 1);
          const filters = filterSet.map((fs) => fs.slice(-1)[0]);
          if (ancestorFilters.length) {
            booleanFilterParts.push(ancestorFilters.map((f, index) => startItemIndex + index + ruleItems.length).join(" and "));
            ruleItems.push(...ancestorFilters.map((f) => Rule.RuleItem.fromFilter(f)));
          }
          const isMeasure = typeof filters[0].value === "object";
          if (isMeasure) {
            const indices = filters.map((f, index) => startItemIndex + index + ruleItems.length);
            booleanFilterParts.push(`(${indices.join(" or ")})`);
            ruleItems.push(...filters.map((f) => SPM.Utils.Rule.RuleItem.fromFilter(f)));
          } else {
            booleanFilterParts.push(String(startItemIndex + ruleItems.length));
            ruleItems.push({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filters[0].key,
              sfsp__Operator__c: "==",
              sfsp__Value__c: filters.map((f) => f.value).join(",")
            });
          }
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            sfsp__BooleanFilter__c: booleanFilterParts.join(" and "),
            sfsp__SalesNodeRuleItems__r: ruleItems.map((ruleItem, i) => ({
              ...ruleItem,
              sfsp__SortOrder__c: i + 1
            }))
          };
        },
        fromBoundaries({ boundaries, boundaryObject }) {
          const containerSet = SPM.$store.containerSets[boundaryObject.containerSetId];
          let availableContainers = containerSet.containers;
          if (!boundaryObject.includesPoints) {
            availableContainers = Object.keys(availableContainers).filter((key) => !availableContainers[key].parent).reduce((res, key) => (res[key] = availableContainers[key], res), {});
          }
          const ruleItemOperator = "startsWith";
          boundaries = SPM.Utils.Rule.simplifyValues(Object.values(availableContainers).map((c) => c.name), boundaries);
          const ruleItemValues = [];
          let currentValue = "";
          boundaries.forEach((boundary) => {
            if (currentValue.length + boundary.length + 1 >= 1e3) {
              ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
              currentValue = "";
            }
            currentValue += `${boundary},`;
          });
          if (currentValue)
            ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            Name: containerSet.label,
            sfsp__SalesNodeBoundary__c: boundaryObject.id,
            sfsp__SortOrder__c: 1,
            sfsp__FilterLogic__c: "any",
            sfsp__BooleanFilter__c: Array(ruleItemValues.length).fill().map((v, i) => i + 1).join(" or "),
            sfsp__SalesNodeRuleItems__r: ruleItemValues.map((value, i) => ({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: boundaryObject.name,
              sfsp__Operator__c: ruleItemOperator,
              sfsp__Value__c: value,
              sfsp__SortOrder__c: i + 1
            }))
          };
        },
        toString(rule) {
          const expressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => `${item.sfsp__Field__c} ${item.sfsp__Operator__c} ${JSON.stringify(item.sfsp__Value__c)}`);
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, expressions);
        },
        toSaql(rule, assignmentObject) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: rule.sfsp__SalesNodeBoundary__c ? "Text" : assignmentObject.referenceFields.find((f) => f.id === item.sfsp__Field__c).type
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        },
        simplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const selectedTrie = new Trie$1.Trie();
          selectedValues.forEach((v) => selectedTrie.add(v));
          const simplifiedValues = /* @__PURE__ */ new Set();
          selectedValues.forEach((value) => {
            for (let i = 1; i <= value.length; i++) {
              const matchString = value.slice(0, i);
              if (selectedTrie.countChildren(matchString) === allTrie.countChildren(matchString)) {
                simplifiedValues.add(matchString);
                break;
              }
            }
          });
          return [...simplifiedValues];
        },
        unsimplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const unsimplifiedValues = selectedValues.map((v) => allTrie.prefixMatchingWords(v)).flat();
          return unsimplifiedValues;
        },
        validateCustomLogic(expression, numCriteria) {
          if (!expression || numCriteria == 0) {
            return false;
          }
          var numCritArr = [];
          for (let i = 1; i <= numCriteria; i++) {
            numCritArr.push(i.toString());
          }
          const pattern = /\d+/g;
          const values = expression.match(pattern);
          if (values) {
            for (let i = 0; i < values.length; i++) {
              if (values[i] < 1 || values[i] > numCriteria) {
                return false;
              }
              let position = numCritArr.indexOf(values[i]);
              if (position >= 0)
                numCritArr.splice(position, 1);
            }
          }
          if (numCritArr.length !== 0) {
            return false;
          }
          return this.validateBooleanExpr(expression);
        },
        validateBooleanExpr(expression) {
          let expressionLC = expression.toLowerCase();
          const pattern = /\(\d+\)|\d+ (?:and|or|\|\||\&\&) \d+|\d+/g;
          while (true) {
            const replaced = expressionLC.replace(pattern, "1");
            if (replaced == "1")
              return true;
            if (replaced == expressionLC)
              return false;
            expressionLC = replaced;
          }
        }
      };
      const Filter = {
        toSaql(filter) {
          const { field, operator, value = "", dataType } = filter;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] || ${field} is null)` : `${field} not in ["${values.join('","')}"]` : value ? `(${field} != "${value}" || ${field} is null)` : `(${field} != "" || ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        },
        evaluate({ filters, filterLogic, record }) {
          if (filters.length === 0)
            return true;
          const expressions = filters.map((filter) => {
            const { field, operator, value = "", dataType } = filter;
            const values = operator === "between" ? [value] : value.split(",");
            const recordValue = record[field];
            const recordValueLower = (recordValue || "").toString().toLowerCase();
            return values.some((v) => {
              switch (operator) {
                case "==":
                  return recordValue == v;
                case "!=":
                  return recordValue != v;
                case "like":
                  return recordValueLower.includes(v.toLowerCase());
                case "startsWith":
                  return recordValueLower.startsWith(v.toLowerCase());
                case "between":
                  const [from2, to2] = v.split(",");
                  return recordValue >= from2 && recordValue <= to2;
                case "<":
                  return recordValue < v;
                case "<=":
                  return recordValue <= v;
                case ">":
                  return recordValue > v;
                case ">=":
                  return recordValue >= v;
                default:
                  return false;
              }
            });
          });
          const mergedExpressions = Filter.mergeBooleanFilter(filterLogic, expressions);
          return Function(`"use strict";return (${mergedExpressions})`)();
        },
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i = 0; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        removeBooleanFilterExpression(booleanFilter, expressionIndex, startIndex = 0) {
          booleanFilter = booleanFilter.toLowerCase();
          expressionIndex = String(expressionIndex);
          let currentToken = "";
          let matchingIndex;
          for (let i = startIndex; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken === expressionIndex) {
              matchingIndex = i - String(expressionIndex).length;
              break;
            }
            if (Number(currentToken) > Number(expressionIndex)) {
              const newToken = String(Number(currentToken) - 1);
              booleanFilter = `${booleanFilter.slice(0, i - 1)}${newToken}${booleanFilter.slice(i - 1 + currentToken.length)}`;
              if (newToken.length < expressionIndex.length)
                i--;
            }
            currentToken = "";
          }
          if (!matchingIndex && currentToken === expressionIndex) {
            matchingIndex = booleanFilter.length - String(expressionIndex).length;
          } else if (!matchingIndex && currentToken && Number(currentToken) > Number(expressionIndex)) {
            const newToken = String(Number(currentToken) - 1);
            booleanFilter = booleanFilter.replace(new RegExp(`${currentToken}$`), newToken);
          }
          if (matchingIndex) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, matchingIndex, expressionIndex.length);
            return Filter.removeBooleanFilterExpression(
              `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`,
              expressionIndex,
              start2
            );
          }
          let paramIndex;
          while ((paramIndex = booleanFilter.indexOf("()")) !== -1) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, paramIndex, 2);
            booleanFilter = `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`;
          }
          return booleanFilter;
        },
        getOperatorBounds(booleanFilter, matchingIndex, matchLength) {
          const matchingIndexEnd = matchingIndex + matchLength;
          let start2;
          let end2;
          if (matchingIndex > 4 && booleanFilter.slice(matchingIndex - 4, matchingIndex) === " or ") {
            start2 = matchingIndex - 4;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 4 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 4) === " or ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 4;
          } else if (matchingIndex > 5 && booleanFilter.slice(matchingIndex - 5, matchingIndex) === " and ") {
            start2 = matchingIndex - 5;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 5 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 5) === " and ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 5;
          } else {
            start2 = matchingIndex;
            end2 = matchingIndexEnd;
          }
          return { start: start2, end: end2 };
        }
      };
      const DeferredPromise = function() {
        this._promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
        this.then = this._promise.then.bind(this._promise);
        this.catch = this._promise.catch.bind(this._promise);
        this.finally = this._promise.finally.bind(this._promise);
        this[Symbol.toStringTag] = "Promise";
      };
      const Plan2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesPlan__c",
          Name: "",
          sfsp__SalesMetrics__r: [],
          sfsp__SalesAssignmentObjects__r: [],
          sfsp__SalesNodeMetrics__r: [],
          sfsp__ListViews__r: [],
          sfsp__SalesNodeBoundaries__r: [],
          sfsp__SalesPlanUsers__r: [],
          sfsp__SalesUserAccess__r: []
        })
      };
      const AssignmentObject = {
        getIcon(objName) {
          const icons = {
            Account: { category: "standard", name: "account", color: "#5867E8" },
            Lead: { category: "standard", name: "lead", color: "#FF5D2D" },
            Contact: { category: "standard", name: "contact", color: "#a094ed" },
            Opportunity: { category: "standard", name: "opportunity", color: "#fcb95b" },
            User: { category: "standard", name: "customers", color: "#06A59A" }
          };
          return icons[objName] || { category: "standard", name: "entity", color: "#f88962" };
        },
        getReferenceMetadata({ assignmentObject }) {
          return [
            ...assignmentObject.recordsDataset.dimensions.map((d) => ({ id: d.id, title: `Unique ${d.title}`, type: "unique" })),
            ...assignmentObject.recordsDataset.measures.reduce((arr, m) => [
              { id: m.id, title: `Sum of ${m.title}`, type: "sum" },
              { id: m.id, title: `Min ${m.title}`, type: "min" },
              { id: m.id, title: `Max ${m.title}`, type: "max" }
            ].concat(arr), [])
          ];
        },
        getFieldOptions({ assignmentObject, mode = "Record" }) {
          const aggregateIdPrefix = mode === "Record" ? "" : "sum__";
          const aggregateLabelPrefix = mode === "Record" ? "" : "Sum of ";
          const fields = assignmentObject.referenceFields.filter((f) => f.type === "Numeric" || mode === "Record").map(({ id, label, type, isNameField }) => ({
            id: `${aggregateIdPrefix}${assignmentObject.id}__${id}`,
            label: `${aggregateLabelPrefix}${label}`,
            type,
            isNameField
          }));
          if (mode === "Record") {
            SPM.$store.boundaryObjects.forEach((boundaryObject) => {
              var _a, _b;
              if ((_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name)) {
                fields.push({ id: `${assignmentObject.id}__${boundaryObject.name}`, label: boundaryObject.label, type: "Text" });
              }
            });
          }
          fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
          if (fields.find((f) => f.isNameField)) {
            fields.unshift(fields.splice(fields.findIndex((f) => f.isNameField), 1)[0]);
            if (mode === "Record") {
              fields.splice(
                1,
                0,
                { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
                { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
              );
            }
          } else if (mode === "Record") {
            fields.push(
              { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
              { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
            );
          }
          return fields;
        },
        getDefaultColumns({ assignmentObject, mode = "Record" }) {
          const fields = AssignmentObject.getFieldOptions({ assignmentObject, mode });
          if (fields.find((f) => f.isNameField)) {
            return fields.filter((f) => f.id !== `${assignmentObject.id}__Id`).map(({ id, type, isNameField }) => ({
              id,
              summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique",
              isNameField
            }));
          }
          return fields.map(({ id, type }) => ({
            id,
            summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique"
          }));
        },
        async getDatasetInfo({ alias }) {
          let response = {};
          let dataset = [];
          let metadata = {};
          if (!SPM.hasDataPipelinesAccess) {
            ({ datasets: response, metadata } = await SPM.Utils.Apex.invoke("GetDatasets", [alias]));
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
          } else {
            response = await SPM.Utils.Rest.invoke("GetDatasets", { alias });
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
            metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataset.currentVersionUrl });
          }
          return { dataset, metadata };
        },
        async loadDatasets({ assignmentObjectId, planId }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Records` });
          if (!recordsDataset || !recordsMetadata)
            return false;
          const { dataset: assignmentsDataset, metadata: assignmentsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Assignments` });
          if (!assignmentsDataset || !assignmentsDataset)
            return false;
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          Object.assign(assignmentsDataset, {
            measures: assignmentsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: assignmentsMetadata.measures,
            dimensions: assignmentsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          return { recordsDataset, assignmentsDataset };
        },
        async reassign({ objectId, reassignments }) {
          const recordAssignmentsMap = SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }).reduce((map2, node) => {
            if (node !== SPM.$store.rootNode) {
              node.assignments.forEach((a) => {
                if (a.sfsp__SalesAssignmentObject__c === objectId) {
                  map2[a.sfsp__RecordId__c] = map2[a.sfsp__RecordId__c] || [];
                  map2[a.sfsp__RecordId__c].push(a);
                }
              });
            }
            return map2;
          }, {});
          const assignmentsToDelete = [];
          const assignmentsToInsert = [];
          const impactedNodeIds = /* @__PURE__ */ new Set();
          reassignments.forEach(({ recordId, targetId }) => {
            const existingAssignments = recordAssignmentsMap[recordId];
            existingAssignments == null ? void 0 : existingAssignments.forEach((a) => {
              assignmentsToDelete.push(a);
              impactedNodeIds.add(a.sfsp__SalesNode__c);
            });
            let currentNode = SPM.$store.nodeMap[targetId];
            while (currentNode !== SPM.$store.rootNode) {
              impactedNodeIds.add(currentNode.id);
              assignmentsToInsert.push({
                sobjectType: "sfsp__SalesNodeAssignment__c",
                sfsp__SalesAssignmentObject__c: objectId,
                sfsp__RecordId__c: recordId,
                sfsp__AssignmentType__c: "Manual",
                sfsp__SalesNode__c: currentNode.id,
                sfsp__Status__c: "Active"
              });
              currentNode = SPM.$store.nodeMap[currentNode.parentId];
            }
          });
          await Promise.all([
            SPM.Utils.CRM.delete({ records: assignmentsToDelete }),
            SPM.Utils.CRM.upsert({ records: assignmentsToInsert })
          ]);
          impactedNodeIds.forEach((nodeId2) => {
            SPM.$store.nodeMap[nodeId2].assignments = SPM.$store.nodeMap[nodeId2].assignments.filter((a) => !assignmentsToDelete.includes(a));
            SPM.$store.nodeMap[nodeId2].assignments.push(...assignmentsToInsert.filter((a) => a.sfsp__SalesNode__c === nodeId2));
          });
        },
        async reassignBoundaries({ objectId, reassignments, isPreview, onProgress = () => {
        } }) {
          const boundaryObject = SPM.$store.boundaryObjects.find((o) => o.id === objectId);
          const rulesToDelete = [];
          const rulesToUpsert = [];
          SPM.$store.allNodes.forEach((node) => {
            if (node.id === "All Org")
              return;
            const nodeBoundaryMap = SPM.Utils.Node.getBoundaries({ node, boundaryObject, format: "map" });
            const considerSiblings = SPM.$store.rootNode.assignmentBehavior === "Exclusive";
            let isAffected = false;
            reassignments.forEach(({ boundary, targetId }) => {
              const targetNode = SPM.$store.nodeMap[targetId];
              const shouldHaveBoundary = node.id === targetNode.id || SPM.Utils.Node.isAncestor({ node: targetNode, ancestor: node, nodeMap: SPM.$store.nodeMap });
              if (shouldHaveBoundary && !nodeBoundaryMap[boundary]) {
                nodeBoundaryMap[boundary] = true;
                isAffected = true;
              } else if (considerSiblings && !shouldHaveBoundary && nodeBoundaryMap[boundary]) {
                delete nodeBoundaryMap[boundary];
                isAffected = true;
              }
            });
            if (isAffected) {
              if (isPreview) {
                const previewRules = [...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId)];
                rulesToDelete.push(...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = SPM.Utils.Rule.fromBoundaries({
                    boundaries: Object.keys(nodeBoundaryMap),
                    boundaryObject
                  });
                  previewRules.push(newBoundaryRule);
                }
                node.previewRules = previewRules;
              } else {
                rulesToDelete.push(...node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                node.rules = node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId);
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = {
                    ...SPM.Utils.Rule.fromBoundaries({
                      boundaries: Object.keys(nodeBoundaryMap),
                      boundaryObject
                    }),
                    sfsp__SalesNode__c: node.id
                  };
                  node.rules.push(newBoundaryRule);
                  rulesToUpsert.push(newBoundaryRule);
                }
              }
            }
          });
          if (isPreview)
            return;
          await SPM.Utils.CRM.upsert({
            records: rulesToUpsert,
            onProgress: (percent) => onProgress(`Saving Rules...${percent}%`)
          });
          const ruleItemsToUpsert = [];
          rulesToUpsert.forEach((rule) => {
            rule.sfsp__SalesNodeRuleItems__r.forEach((item) => {
              item.sfsp__SalesNodeRule__c = rule.Id;
              ruleItemsToUpsert.push(item);
            });
          });
          await SPM.Utils.CRM.upsert({
            records: ruleItemsToUpsert,
            onProgress: (percent) => onProgress(`Saving Rule Items...${percent}%`)
          });
          await SPM.Utils.CRM.delete({
            records: rulesToDelete,
            onProgress: (percent) => onProgress(`Cleaning Up...${percent}%`)
          });
        },
        async getSalesAsyncJobs({ objectId, statuses = [] }) {
          const objectFilter = objectId ? ` AND sfsp__SalesAssignmentObject__c = '${objectId}'` : "";
          const statusFilter = statuses.length > 0 ? ` AND sfsp__Status__c IN ('${statuses.join("','")}')` : "";
          return await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Name,
                    CreatedDate,
                    sfsp__Details__c,
                    sfsp__Status__c,
                    sfsp__Type__c,
                    sfsp__Splunk__c,
                    sfsp__SalesAssignmentObject__c,
                    sfsp__SalesAssignmentObject__r.Name,
                    sfsp__SalesAssignmentObject__r.sfsp__Label__c,
                    sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c
                FROM sfsp__SalesAsyncJob__c
                WHERE sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c = '${SPM.$store.plan.Id}'${objectFilter}${statusFilter}
                ORDER BY CreatedDate DESC
            `]) || [];
        },
        async updateReferenceFields({ assignmentObject }) {
          const referenceFields = JSON.parse((SPM.$store.plan.sfsp__SalesAssignmentObjects__r.find((obj) => obj.Id === assignmentObject.id) || {}).sfsp__ReferenceFields__c);
          referenceFields.forEach((field) => field.lastModifiedDate = Date.now());
          const [updatedAssignmentObject] = await SPM.Utils.Apex.invoke("UpdateSObjects", [
            [{
              Id: assignmentObject.id,
              Name: assignmentObject.name,
              sfsp__Label__c: assignmentObject.label,
              sfsp__ReferenceFields__c: JSON.stringify(referenceFields)
            }],
            true
          ]);
          SPM.$store.$patch((state) => {
            const assignmentObjectIndex = state.plan.sfsp__SalesAssignmentObjects__r.findIndex((a) => a.Id === assignmentObject.id);
            state.plan.sfsp__SalesAssignmentObjects__r.splice(assignmentObjectIndex, 1, updatedAssignmentObject);
            state.hasChanged = true;
          });
        }
      };
      const BoundaryObject = {
        Defaults: {
          type: "boundary",
          icon: "location",
          styles: {
            visible: true,
            opacity: 0.3
          }
        },
        getFieldOptions({ boundaryObject }) {
          const fields = [
            { id: "Name", label: boundaryObject.label, type: "Text" },
            { id: "AssignedTo", label: "Assigned To", type: "Text" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            fields.push(
              { id: `unique__${assignmentObject.id}__Id`, label: assignmentObject.label, type: "Numeric" },
              ...assignmentObject.referenceFields.filter((f) => f.type === "Numeric").map(({ id, label, type }) => ({
                id: `sum__${assignmentObject.id}__${id}`,
                label,
                type
              }))
            );
          });
          Object.entries(boundaryObject.metadata).forEach(([key, { label, type, visible }]) => {
            if (visible)
              fields.push({ id: `BoundaryMetadata:${key}`, label, type: type === "float" ? "Numeric" : "Text" });
          });
          return fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
        },
        getDefaultColumns({ boundaryObject }) {
          const defaultColumns = [
            { id: "Name", summaryFormat: "Unique" },
            { id: "AssignedTo", summaryFormat: "Unique" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            defaultColumns.push({ id: `unique__${assignmentObject.id}__Id`, summaryFormat: "Sum" });
          });
          return defaultColumns;
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: "{}"
        }),
        buildRows({ parentRow, childNodes, lazy, includeBoundaries = true }) {
          const childRows = [];
          childNodes.forEach((node) => {
            const row = {
              id: node.id,
              name: node.name,
              data: [
                { id: "Name", format: "Name", type: "custom", node },
                ...SPM.$store.assignmentObjects.filter((obj) => obj.recordsDataset.dimensions).map((assignment) => ({
                  id: assignment.id,
                  format: "Assignment",
                  type: "custom",
                  state: "loading",
                  value: 0,
                  columnName: assignment.name
                })),
                ...((includeBoundaries ? SPM.$store.boundaryObjects : []) || []).map((boundary) => ({
                  id: boundary.id,
                  format: "Boundary",
                  type: "custom",
                  state: "loading",
                  value: 0
                })),
                ...node.metrics.map((metric) => {
                  const salesMetric = SPM.$store.plan.sfsp__SalesMetrics__r.find((m) => m.Id === metric.sfsp__SalesMetric__c);
                  const monthKeys = [...Object.keys(metric)].filter((name) => name.startsWith("sfsp__Target_Month"));
                  const metricDetails = {
                    id: metric.Id,
                    format: "Allocation",
                    type: "custom",
                    dataType: salesMetric.sfsp__Type__c,
                    value: monthKeys.reduce((agg, field) => agg + metric[field], 0),
                    columnName: salesMetric.Name
                  };
                  metricDetails.overrideAmount = salesMetric.sfsp__TargetOverrideEnabled__c ? metric.sfsp__TargetOverrideType__c === "Percentage" ? metric.sfsp__TargetOverrideAmount__c / 100 * metricDetails.value : metric.sfsp__TargetOverrideAmount__c : 0;
                  return metricDetails;
                })
              ],
              parent: parentRow,
              children: [],
              childCount: 0,
              expanded: !lazy,
              loaded: !lazy
            };
            if (SPM.$store.hasSalesPlanningTemplateApp && SPM.$store.isEditor)
              row.data.splice(1, 0, { id: "SharedWith", format: "Shared with", type: "custom", node });
            childRows.push(row);
            parentRow.children.push(row);
          });
          parentRow.loaded = true;
          parentRow.expanded = true;
          return childRows;
        },
        async importHierarchy({ hierarchy, includeBoundaries = true }) {
          const rowMap = {};
          const traverse2 = (rows) => {
            rows.forEach((r) => {
              rowMap[r.id] = r;
              traverse2(r.children);
            });
          };
          traverse2(SPM.Components.Hierarchy.rows);
          let hierarchyNodes = [hierarchy];
          while (hierarchyNodes.length) {
            const parentIds = hierarchyNodes.map((n) => n.id);
            hierarchyNodes = hierarchyNodes.reduce((arr, hierarchyNode) => arr.concat(
              hierarchyNode.children.map((hierarchyChild) => Object.assign(hierarchyChild, {
                parentNode: SPM.$store.nodeMap[hierarchyNode.id] || { id: hierarchyNode.id, childCount: 0 }
              }))
            ), []);
            const nodesToInsert = hierarchyNodes.map((hierarchyNode, i) => ({
              sobjectType: "sfsp__SalesNode__c",
              Name: hierarchyNode.name,
              sfsp__SalesPlan__c: SPM.$store.plan.Id,
              sfsp__Parent__c: hierarchyNode.parentNode.id.replace("All Org", ""),
              sfsp__Priority__c: hierarchyNode.parentNode.childCount + i + 1,
              sfsp__Color__c: SPM.Utils.Node.randomColor(),
              sfsp__AssignmentBehavior__c: "Exclusive"
            }));
            await SPM.Utils.CRM.upsert({ records: nodesToInsert });
            nodesToInsert.forEach((node, i) => {
              hierarchyNodes[i].id = node.Id;
              const parentId = node.sfsp__Parent__c || "All Org";
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              const newNode = {
                id: node.Id,
                name: node.Name,
                color: node.sfsp__Color__c,
                assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
                ownerId: "",
                ownerName: "",
                level: parentNode.level + 1,
                parentId,
                childCount: 0,
                children: [],
                metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => ({
                  ...SPM.Utils.NodeMetric.Defaults,
                  sfsp__SalesPlan__c: SPM.$store.plan.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  sfsp__SalesNode__c: node.Id
                })),
                users: [],
                accessRecords: [],
                rules: [],
                ruleLogics: {},
                previewRuleLogics: {},
                assignments: [],
                boundaries: [],
                referenceData: []
              };
              SPM.$store.nodeMap[newNode.id] = newNode;
              parentNode.children.push(newNode);
              rowMap[newNode.id] = this.buildRows({ parentRow: rowMap[parentNode.id], childNodes: [newNode], includeBoundaries })[0];
            });
            parentIds.forEach((parentId) => {
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              parentNode.childCount = parentNode.children.length;
              parentNode.children.forEach((childNode) => {
                childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
                childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
              });
            });
            SPM.$store.branch.descendantIds.push(...nodesToInsert.map((node) => node.Id));
          }
          this.calculateValues(SPM.Components.Hierarchy.rows);
        },
        getBoundaryValue({ cell, nodeId: nodeId2, boundaryObjectId }) {
          const count2 = SPM.Utils.Node.getBoundaries({ node: SPM.$store.nodeMap[nodeId2], boundaryObject: SPM.$store.boundaryObjects.find((o) => o.id === boundaryObjectId) }).length;
          cell.state = "loaded";
          cell.value = count2;
        },
        async getAssignmentValues({ nodeId: nodeId2, assignmentObjectId, referenceFields = [] }) {
          var _a;
          const assignmentObject = SPM.$store.assignmentObjects.find((o) => o.id === assignmentObjectId);
          if (!((_a = assignmentObject == null ? void 0 : assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions))
            return;
          const saql = SPM.Utils.Node.generateSaql({
            node: SPM.$store.nodeMap[nodeId2],
            assignmentObject,
            referenceFields,
            boundaryObjects: SPM.$store.boundaryObjects,
            nodeMap: SPM.$store.nodeMap,
            recordsDataset: assignmentObject.recordsDataset,
            assignmentsDataset: assignmentObject.assignmentsDataset,
            type: "cogroup"
          });
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          return ((results == null ? void 0 : results.records) || []).reduce((map2, rec) => {
            map2[rec.nodeId] = {};
            Object.entries(rec).forEach(([key, value]) => {
              if (key !== "nodeId")
                map2[rec.nodeId][key] = value;
            }, {});
            return map2;
          }, {});
        },
        calculateValues(rows) {
          const boundaryCalculations = [];
          const parentToObjectMap = {};
          const findValues = (parents) => {
            parents.forEach((row) => {
              var _a;
              const parentId = ((_a = row.parent) == null ? void 0 : _a.id) || "All Org";
              parentToObjectMap[parentId] = parentToObjectMap[parentId] || {};
              row.data.forEach((col) => {
                if (col.format === "Assignment" && col.state === "loading") {
                  parentToObjectMap[parentId][col.id] = parentToObjectMap[parentId][col.id] || {};
                  parentToObjectMap[parentId][col.id][row.id] = col;
                } else if (col.format === "Boundary" && col.state === "loading") {
                  boundaryCalculations.push({ cell: col, nodeId: row.id, boundaryObjectId: col.id });
                }
              });
              findValues(row.children);
            });
          };
          findValues(rows);
          SPM.Utils.Async.forEachParallel(boundaryCalculations, (boundaryToCalculate) => this.getBoundaryValue(boundaryToCalculate), 5);
          SPM.Utils.Async.forEach(Object.values(parentToObjectMap), async (assignmentObjectToCellMap) => {
            await SPM.Utils.Async.forEachParallel(Object.entries(assignmentObjectToCellMap), async ([assignmentObjectId, cellMap]) => {
              const nodeIds = Object.keys(cellMap);
              const lastSiblingId = nodeIds[nodeIds.length - 1];
              const assignmentValues = await this.getAssignmentValues({ nodeId: lastSiblingId, assignmentObjectId });
              nodeIds.forEach((nodeId2) => {
                var _a;
                const value = ((_a = assignmentValues[nodeId2]) == null ? void 0 : _a.count) || 0;
                cellMap[nodeId2].value = value;
                cellMap[nodeId2].state = "loaded";
              });
            }, 5);
          });
        },
        async getMaxLevel({ planId, nodeIds, currentLevel }) {
          if (nodeIds.includes(""))
            throw new Error("Blank node id is not supported");
          const fifthLevelChildNodes = await SPM.Utils.Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id IN ('${nodeIds.join("','")}')`]);
          if (fifthLevelChildNodes.length) {
            return Node2.getMaxLevel({ planId, nodeIds: fifthLevelChildNodes.map((n) => n.Id), currentLevel: currentLevel + 5 });
          }
          for (let i = 4; i > 0; i--) {
            const ancestorPath = Array(i).fill().map((item) => "sfsp__Parent__r").join(".");
            const nodes = await Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND ${ancestorPath}.Id IN ('${nodeIds.join("','")}') LIMIT 1`]);
            if (nodes.length) {
              return currentLevel + i;
            }
          }
          return currentLevel;
        },
        async getNodeLevel({ nodeId: nodeId2 }) {
          var _a, _b, _c, _d, _e;
          let level = 1;
          while (nodeId2) {
            const node = (await Apex.invoke("Query", [`
                    SELECT Id,
                        sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                    FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
                `]))[0];
            let parentNode = node;
            while (parentNode = (_a = parentNode == null ? void 0 : parentNode.sfsp__Parent__r) == null ? void 0 : _a.Id)
              level++;
            nodeId2 = (_e = (_d = (_c = (_b = node == null ? void 0 : node.sfsp__Parent__r) == null ? void 0 : _b.sfsp__Parent__r) == null ? void 0 : _c.sfsp__Parent__r) == null ? void 0 : _d.sfsp__Parent__r) == null ? void 0 : _e.sfsp__Parent__r.Id;
          }
          return level;
        },
        async getDescendantIds({ planId, nodeIds }) {
          if (!nodeIds || nodeIds.length === 0)
            return [];
          const descendantIds = (await Apex.invoke("Query", [`
                SELECT Id, sfsp__SalesPlan__c, sfsp__Parent__r.Id FROM sfsp__SalesNode__c WHERE sfsp__Parent__r.Id IN ('${nodeIds.join("','")}') AND sfsp__SalesPlan__c = '${planId}'
            `])).map((node) => node.Id);
          return [
            ...descendantIds,
            ...await Node2.getDescendantIds({ planId, nodeIds: descendantIds })
          ];
        },
        async getAncestorIds({ nodeId: nodeId2 }) {
          if (!nodeId2 || nodeId2 === "All Org")
            return [];
          let node = (await Apex.invoke("Query", [`
                SELECT Id,
                    sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
            `]))[0];
          const ancestorIds = [];
          while (node = node.sfsp__Parent__r)
            ancestorIds.push(node.Id);
          return [
            ...ancestorIds,
            ...await Node2.getAncestorIds({ nodeId: ancestorIds[4] }),
            "All Org"
          ];
        },
        async loadScope({ planId, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false, rootNodeId, parentNodeIds = [] }) {
          if (rootNodeId && nodeMap[rootNodeId]) {
            parentNodeIds.push(rootNodeId);
            rootNodeId = null;
          }
          parentNodeIds = [...new Set(parentNodeIds)].filter((id) => {
            var _a;
            return !((_a = nodeMap[id || "All Org"]) == null ? void 0 : _a.children);
          });
          const parentNodeBatches = rootNodeId ? [[]] : [];
          let parentNodeIndex = 0;
          while (parentNodeIndex < parentNodeIds.length) {
            parentNodeBatches.push(parentNodeIds.slice(parentNodeIndex, parentNodeIndex + 1e3));
            parentNodeIndex += 1e3;
          }
          const nodes = [];
          await Async.forEachParallel(parentNodeBatches, async (batchIds) => {
            const parentClause = rootNodeId ? `(Id = '${rootNodeId}' OR sfsp__Parent__c = '${rootNodeId}')` : `sfsp__Parent__c IN ('${batchIds.join("','")}')`;
            const batchNodes = await Apex.invoke(
              "Query",
              [`
                        SELECT
                            Id,
                            Name,
                            sfsp__Parent__c,
                            sfsp__Color__c,
                            sfsp__Owner__c,
                            sfsp__Owner__r.Name,
                            sfsp__AssignmentBehavior__c,
                            sfsp__RuleLogics__c,
                            sfsp__HierarchyReferenceData__c,
                            (
                                SELECT
                                    Id,
                                    sfsp__TargetOverrideAmount__c,
                                    sfsp__TargetOverrideType__c,
                                    ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")},
                                    sfsp__SalesMetric__c
                                FROM sfsp__SalesNodeMetrics__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c, sfsp__SalesAssignmentObject__c, sfsp__SalesNodeBoundary__c
                                FROM sfsp__SalesNodeRules__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c
                                FROM sfsp__SalesNodeBoundaries__r
                            ),
                            (
                                SELECT Id, sfsp__SalesNode__c, sfsp__User__c, sfsp__User__r.Name, sfsp__Role__c
                                FROM sfsp__SalesNodeUsers__r
                            ),
                            (
                                SELECT Id
                                FROM sfsp__SalesNodes__r
                            ),
                            (
                                SELECT Id, sfsp__User__r.Name, sfsp__AccessLevel__c, sfsp__SalesNode__r.Name FROM sfsp__SalesUserAccess__r 
                            )
                        FROM sfsp__SalesNode__c
                        WHERE sfsp__SalesPlan__c = '${planId}' AND ${parentClause}
                        ORDER BY sfsp__Priority__c ASC
                    `]
            );
            nodes.push(...batchNodes);
            if (loadRuleItems) {
              const batchRuleMap = batchNodes.reduce((map2, node) => {
                (node.sfsp__SalesNodeRules__r || []).forEach((rule) => {
                  rule.sfsp__SalesNodeRuleItems__r = [];
                  map2[rule.Id] = rule;
                });
                return map2;
              }, {});
              const batchRuleItems = Object.keys(batchRuleMap).length === 0 ? [] : await Apex.invoke(
                "Query",
                [`
                            SELECT Id, sfsp__SalesNodeRule__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                            FROM sfsp__SalesNodeRuleItem__c
                            WHERE sfsp__SalesNodeRule__c IN ('${Object.keys(batchRuleMap).join("','")}')
                        `]
              );
              batchRuleItems.forEach((item) => batchRuleMap[item.sfsp__SalesNodeRule__c].sfsp__SalesNodeRuleItems__r.push(item));
            }
            if (loadAssignments) {
              const batchNodeMap = batchNodes.reduce((map2, node) => {
                node.assignments = [];
                map2[node.Id] = node;
                return map2;
              }, {});
              const batchAssignments = Object.keys(batchNodeMap).length === 0 ? [] : await SPM.Utils.Rest.invoke(
                "Query",
                { query: `
                            SELECT sfsp__SalesNode__c, sfsp__SalesAssignmentObject__c, sfsp__AssignmentType__c, sfsp__RecordId__c, sfsp__Status__c
                            FROM sfsp__SalesNodeAssignment__c
                            WHERE sfsp__SalesNode__c IN ('${Object.keys(batchNodeMap).join("','")}') AND sfsp__Status__c != 'Deleted'
                        ` }
              );
              batchAssignments.forEach((assignment) => batchNodeMap[assignment.sfsp__SalesNode__c].assignments.push(assignment));
            }
          }, 5);
          let rootNodeLevel;
          if (rootNodeId) {
            rootNodeLevel = await Node2.getNodeLevel({ nodeId: rootNodeId });
            nodeMap[rootNodeId] = {
              level: rootNodeLevel,
              siblingIds: [],
              olderSiblingIds: [],
              users: [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: [],
              referenceData: []
            };
          }
          nodes.forEach((node) => {
            var _a, _b, _c;
            const nodeMetrics = node.sfsp__SalesNodeMetrics__r || [];
            const childNode = {
              ...nodeMap[node.Id],
              id: node.Id,
              name: node.Name,
              color: node.sfsp__Color__c,
              assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: node.sfsp__Owner__c || "",
              ownerName: ((_a = node == null ? void 0 : node.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: node.Id === rootNodeId ? rootNodeLevel : nodeMap[node.sfsp__Parent__c || "All Org"].level + 1,
              parentId: node.sfsp__Parent__c || "All Org",
              childCount: ((_b = node == null ? void 0 : node.sfsp__SalesNodes__r) == null ? void 0 : _b.length) || 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = nodeMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: node.sfsp__SalesNodeUsers__r || [],
              accessRecords: ((_c = node.sfsp__SalesUserAccess__r) == null ? void 0 : _c.map(({ sfsp__User__r, sfsp__User__c, sfsp__SalesNode__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: sfsp__SalesNode__c }))) || [],
              rules: node.sfsp__SalesNodeRules__r || [],
              ruleLogics: JSON.parse(node.sfsp__RuleLogics__c || "{}"),
              previewRuleLogics: {},
              assignments: node.assignments || [],
              boundaries: node.sfsp__SalesNodeBoundaries__r || [],
              referenceData: JSON.parse((node == null ? void 0 : node.sfsp__HierarchyReferenceData__c) || "[]")
            };
            nodeMap[node.Id] = childNode;
            const parentNode = nodeMap[node.sfsp__Parent__c || "All Org"];
            if (parentNode) {
              parentNode.children = parentNode.children || [];
              const childIndex = parentNode.children.findIndex((c) => c.id === childNode.id);
              if (childIndex === -1) {
                parentNode.children.push(childNode);
              } else {
                parentNode.children.splice(childIndex, 1, childNode);
              }
            }
          });
          const parentIdsToInit = rootNodeId ? [rootNodeId, ...parentNodeIds] : parentNodeIds;
          parentIdsToInit.forEach((parentId) => {
            const parentNode = nodeMap[parentId || "All Org"];
            parentNode.children = parentNode.children || [];
            parentNode.childCount = parentNode.children.length;
            parentNode.rules = parentNode.rules || [];
            parentNode.boundaries = parentNode.boundaries || [];
            parentNode.children.forEach((childNode) => {
              childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
              childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
            });
          });
        },
        async loadAncestors({ planId, nodeId: nodeId2, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false }) {
          var _a;
          const ancestorIds = await Node2.getAncestorIds({ nodeId: nodeId2 });
          if (!ancestorIds.length)
            return;
          if (!nodeMap["All Org"]) {
            const allOrgMetrics = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__TargetOverrideAmount__c, sfsp__TargetOverrideType__c, ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")}, sfsp__SalesMetric__c FROM sfsp__SalesNodeMetric__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''`]);
            const planNodeBoundaries = await SPM.Utils.Rest.invoke("Query", { query: `SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c FROM sfsp__SalesNodeBoundary__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''` });
            nodeMap["All Org"] = {
              id: "All Org",
              name: "All Org",
              color: "#2C7ED0",
              assignmentBehavior: SPM.$store.plan.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: SPM.$store.plan.sfsp__Owner__c || "",
              ownerName: ((_a = SPM.$store.plan.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = allOrgMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: SPM.$store.plan.sfsp__SalesPlanUsers__r || [],
              accessRecords: SPM.$store.plan.sfsp__SalesUserAccess__r.filter((ua) => !ua.sfsp__SalesNode__c && !SPM.$store.availableAdminIds.has(ua.sfsp__User__c) && !SPM.$store.availableManagerIds.has(ua.sfsp__User__c)).map(({ sfsp__User__r, sfsp__User__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: "All Org" })) || [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: planNodeBoundaries,
              siblingIds: [],
              olderSiblingIds: []
            };
            await Node2.loadScope({ planId, metrics, nodeMap, loadRuleItems, loadAssignments, parentNodeIds: [""] });
          }
          let currentAncestor = nodeMap["All Org"].children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          while (currentAncestor.id !== nodeId2) {
            await Node2.loadScope({
              planId,
              metrics,
              nodeMap,
              loadRuleItems,
              loadAssignments,
              parentNodeIds: [currentAncestor.id]
            });
            currentAncestor = currentAncestor.children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          }
        },
        getProjectionFields({ node, referenceFields }) {
          const fields = /* @__PURE__ */ new Set(["Id"]);
          referenceFields.forEach((f) => fields.add(f.name));
          const checkParent = (node2) => {
            if (node2.parentId) {
              const parentNode = SPM.$store.nodeMap[node2.parentId];
              const allRules = [...parentNode.rules, ...parentNode.previewRules || []];
              allRules.forEach((rule) => {
                (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                  fields.add(ruleItem.sfsp__Field__c);
                });
              });
              [...parentNode.olderSiblingIds].forEach((nodeId2) => {
                const levelNode = SPM.$store.nodeMap[nodeId2];
                const allRules2 = [...levelNode.rules, ...levelNode.previewRules || []];
                allRules2.forEach((rule) => {
                  (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                    fields.add(ruleItem.sfsp__Field__c);
                  });
                });
              });
              checkParent(parentNode);
            }
          };
          checkParent(node);
          [...node.olderSiblingIds, node.id].forEach((nodeId2) => {
            const levelNode = SPM.$store.nodeMap[nodeId2];
            const allRules = [...levelNode.rules, ...levelNode.previewRules || []];
            allRules.forEach((rule) => {
              (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                fields.add(ruleItem.sfsp__Field__c);
              });
            });
          });
          return fields;
        },
        generateSaql({ node, assignmentObject, boundaryObjects, projectionFields, referenceFields = [], nodeMap, recordIds, type, returnType = "count", descendantNodes = [], descendantSaql = "", prefix = "", skipLoad = false, isBurndown = false }) {
          const dimensions = [...assignmentObject.recordsDataset.dimensions].map((d) => d.id);
          const measures = [...assignmentObject.recordsDataset.measures].map((d) => d.id);
          const uniqueIdField = "Id";
          prefix = prefix ? `${prefix}_` : "";
          if (!projectionFields) {
            if (returnType === "count") {
              projectionFields = this.getProjectionFields({ node, referenceFields });
            } else {
              projectionFields = /* @__PURE__ */ new Set([...dimensions, ...measures]);
            }
          }
          const referenceProjections = referenceFields.reduce((str, field) => {
            const aggregatePrefix = field.type === "Text" ? "unique" : "sum";
            str += ` ${aggregatePrefix}('${field.name}') as ${field.name},`;
            return str;
          }, "");
          function projection(dataStream = "") {
            const streamPrefix = dataStream ? `${dataStream}.` : "";
            return [
              ...dimensions.filter((d) => projectionFields.has(d)).map((d) => `${streamPrefix}${d} as ${d}`),
              ...measures.filter((m) => projectionFields.has(m)).map((m) => `sum(${streamPrefix}${m}) as ${m}`)
            ].join(", ");
          }
          function grouping() {
            return `(${dimensions.filter((d) => projectionFields.has(d)).map((f) => f).join(", ")})`;
          }
          if (!node.parentId) {
            const filterNodes = isBurndown && node === SPM.$store.rootNode ? [node, ...descendantNodes] : descendantNodes;
            return `
                    ${skipLoad ? `` : `
                            -- load records
                            q = load "${assignmentObject.recordsDataset.id}/${assignmentObject.recordsDataset.currentVersionId}";
                        `}

                    ------------------------------------------------------------------
                    -- All Possible
                    ------------------------------------------------------------------
                    ${recordIds ? `
                            all_possible = filter q by ${uniqueIdField} in ${JSON.stringify(recordIds)};
                            all_possible = foreach all_possible generate ${projection()};
                        ` : `
                            all_possible = filter q by ${filterNodes.length ? `(${filterNodes.map((n) => this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)).join(") && (")})` : `${uniqueIdField} is not null`};
                            all_possible = foreach all_possible generate ${projection()};
                        `}
                    ${descendantSaql || (returnType === "count" ? `
                            -- All Org
                            ${prefix}all_possible = group all_possible by all;
                            ${prefix}all_possible = foreach all_possible generate "All Org" as nodeId,${referenceProjections} count() as count;
                        ` : `
                            -- all records
                            ${prefix}all_possible = filter all_possible by ${uniqueIdField} != "";
                        `)}
                `.replace(/^ */gm, "");
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          let saql = "";
          [...node.olderSiblingIds.map((id) => nodeMap[id]), node].forEach((n, i) => {
            const parentId = n.parentId.replace("All Org", "");
            saql += `
                    ------------------------------------------------------------------
                    -- ${n.name}${n.id !== node.id ? `(${node.name} sibling)` : ""}
                    ------------------------------------------------------------------
                `;
            saql += `
                    -- rules
                    ${n.id} = filter ${parentId || "all_possible"} by ${this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)};
                `;
            if (considerSiblings) {
              if (i === 0) {
                saql += `
                            -- exclusions
                            exclusions = union ${n.id}, ${n.id};
                        `;
              } else {
                saql += type === "join" ? `
                                -- remove exclusions from older siblings
                                ${n.id} = join ${n.id} by ${uniqueIdField} anti, exclusions by ${uniqueIdField};
                            ` : `
                                -- remove exclusions from older siblings
                                ${n.id} = cogroup ${n.id} by ${grouping()} left, exclusions by ${grouping()};
                                ${n.id} = foreach ${n.id} generate ${projection(n.id)}, exclusions.${uniqueIdField} as UnexceptionId;
                                ${n.id} = filter ${n.id} by UnexceptionId is null;
                            `;
                saql += `
                            -- exclusions
                            exclusions = union exclusions, ${n.id};
                        `;
              }
            }
          });
          if (!descendantSaql) {
            saql += `
                    ------------------------------------------------------------------
                    -- Results
                    ------------------------------------------------------------------
                `;
            if (returnType === "count") {
              const resultStreams = [];
              [nodeMap[node.parentId], ...node.olderSiblingIds.map((id) => nodeMap[id]), node].forEach((n) => {
                const streamId = n.id === "All Org" ? "all_possible" : n.id;
                saql += `
                            -- ${n.name}
                            ${prefix}${streamId} = group ${streamId} by all;
                            ${prefix}${streamId} = foreach ${prefix}${streamId} generate "${n.id}" as nodeId,${referenceProjections} count() as count;
                        `;
                resultStreams.push(`${prefix}${streamId}`);
              });
              saql += `
                        -- union results for target node, parent node, older siblings
                        results = union ${resultStreams.join(", ")};
                    `;
            } else {
              saql += `
                        -- all records
                        ${prefix}${node.id} = filter ${node.id} by ${uniqueIdField} != "";
                    `;
            }
          }
          return this.generateSaql({
            node: nodeMap[node.parentId || "All Org"],
            assignmentObject,
            boundaryObjects,
            projectionFields,
            nodeMap,
            recordIds,
            type,
            descendantNodes: descendantSaql ? [node, ...descendantNodes] : descendantNodes,
            descendantSaql: saql + descendantSaql
          });
        },
        generateRules(node, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown) {
          var _a, _b;
          const matchingRules = (node.previewRules || node.rules).filter((r) => {
            const matchesAssignmentObject = r.sfsp__SalesAssignmentObject__c === assignmentObject.id && r.state !== "deleted";
            return matchesAssignmentObject;
          });
          const matchingBoundaryRules = (node.previewRules || node.rules).filter((r) => {
            var _a2, _b2, _c;
            const boundaryField = (_a2 = boundaryObjects == null ? void 0 : boundaryObjects.find((o) => o.id === r.sfsp__SalesNodeBoundary__c)) == null ? void 0 : _a2.name;
            const matchesBoundary = (_c = (_b2 = assignmentObject.recordsDataset) == null ? void 0 : _b2.dimensions) == null ? void 0 : _c.some((f) => f.id === boundaryField);
            return matchesBoundary;
          });
          const matchingAssignments = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted");
          const burndownNodes = isBurndown ? node.children : [];
          if (matchingRules.length === 0 && matchingBoundaryRules.length === 0 && matchingAssignments.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} is null`;
          const ruleAndAssignmentSaqlParts = [];
          if (matchingRules.length) {
            const matchingRulesLogic = ((_a = node == null ? void 0 : node.previewRuleLogics) == null ? void 0 : _a[assignmentObject.id]) || ((_b = node == null ? void 0 : node.ruleLogics) == null ? void 0 : _b[assignmentObject.id]) || Array(matchingRules.length).fill().map((item, i) => i + 1).join(" or ");
            const matchingRulesFilterExpression = SPM.Utils.Filter.mergeBooleanFilter(
              matchingRulesLogic,
              matchingRules.map((r) => Rule.toSaql(r, assignmentObject))
            );
            ruleAndAssignmentSaqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (matchingBoundaryRules.length) {
            ruleAndAssignmentSaqlParts.push(`(${matchingBoundaryRules.map((r) => Rule.toSaql(r, assignmentObject)).join(" || ")})`);
          }
          if (matchingAssignments.length) {
            ruleAndAssignmentSaqlParts.push(`${uniqueIdField} in ${JSON.stringify(matchingAssignments.map((a) => a.sfsp__RecordId__c))}`);
          }
          const saqlParts = [];
          if (ruleAndAssignmentSaqlParts.length) {
            saqlParts.push(`(${ruleAndAssignmentSaqlParts.join(" || ")})`);
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          if (considerSiblings) {
            const unexceptionIds = Node2.getUnexceptionIds(node, nodeMap, assignmentObject);
            if (unexceptionIds.length) {
              saqlParts.push(`${uniqueIdField} not in ${JSON.stringify(unexceptionIds)}`);
            }
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${Node2.generateRules(childNode, nodeMap, assignmentObject, boundaryObjects, uniqueIdField)})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        getUnexceptionIds(node, nodeMap, assignmentObject) {
          const nodeExceptionMap = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted").reduce((map2, a) => {
            map2[a.sfsp__RecordId__c] = a;
            return map2;
          }, {});
          const unexceptionMap = [];
          node.siblingIds.forEach((siblingId) => {
            const siblingNode = nodeMap[siblingId];
            const siblingIsOlder = node.olderSiblingIds.includes(siblingId);
            (siblingNode.previewAssignments || siblingNode.assignments).forEach((siblingAssignment) => {
              if (siblingAssignment.sfsp__SalesAssignmentObject__c !== assignmentObject.id || siblingAssignment.sfsp__Status__c === "Deleted")
                return;
              if (siblingIsOlder || !nodeExceptionMap[siblingAssignment.sfsp__RecordId__c])
                unexceptionMap[siblingAssignment.sfsp__RecordId__c] = siblingAssignment;
            });
          });
          return Object.keys(unexceptionMap);
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.children || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        getAncestors({ node, nodeMap }) {
          const ancestors = [];
          while (node = nodeMap[node.parentId]) {
            ancestors.unshift(node);
          }
          return ancestors;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node.parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        async getChildren({ node }) {
          const children = [];
          const childrenResponse = await SPM.Utils.Apex.invoke(
            "Query",
            [`
                    SELECT
                        Id,
                        Name,
                        sfsp__Parent__c,
                        (
                            SELECT
                                Id,
                                sfsp__TargetOverrideAmount__c,
                                sfsp__TargetOverrideType__c,
                                ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")},
                                sfsp__SalesMetric__c
                            FROM sfsp__SalesNodeMetrics__r
                        ),
                        (
                            SELECT Id
                            FROM sfsp__SalesNodes__r
                        )
                    FROM sfsp__SalesNode__c
                    WHERE sfsp__SalesPlan__c = '${SPM.$store.plan.Id}' AND sfsp__Parent__c = '${node.id}'
                `]
          );
          childrenResponse.forEach((c) => {
            var _a;
            children.push({
              id: c.Id,
              name: c.Name,
              parentId: c.sfsp__Parent__c || "All Org",
              childCount: ((_a = c.sfsp__SalesNodes__r) == null ? void 0 : _a.length) || 0,
              metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => {
                const nodeMetric = (c.sfsp__SalesNodeMetrics__r || []).find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              })
            });
          });
          return children;
        },
        isExclusiveBranch({ node }) {
          return Node2.getDescendants({ nodes: [node] }).every((n) => n.assignmentBehavior === "Exclusive");
        },
        getBoundaryObjects({ node, nodeMap, includeDescendants = false }) {
          return [...Node2.getAncestors({ node, nodeMap }), ...includeDescendants ? Node2.getDescendants({ nodes: [node] }) : [node]].reduce((arr, n) => {
            arr.push(...(n.boundaries || []).map((b) => {
              const salesBoundary = SPM.$store.salesBoundaries.find((s) => s.Id === b.sfsp__SalesBoundary__c);
              const containerSet = SPM.$store.containerSets[b.sfsp__ContainerSet__c];
              const includesPoints = (salesBoundary == null ? void 0 : salesBoundary.sfsp__IncludePoints__c) || b.sfsp__IncludePoints__c;
              const fieldName = salesBoundary ? `${n.id === "All Org" || b.sfsp__SalesBoundary__c ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}${includesPoints ? "_points" : ""}` : `${n.id === "All Org" ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}`;
              return {
                id: b.Id,
                containerSetId: (salesBoundary == null ? void 0 : salesBoundary.sfsp__ContainerSet__c) || b.sfsp__ContainerSet__c,
                salesBoundary: b == null ? void 0 : b.sfsp__SalesBoundary__c,
                rootNodeId: n.id,
                name: fieldName,
                includesPoints,
                label: containerSet.label,
                metadata: containerSet.metadata,
                assignmentCount: 0,
                totalCount: containerSet.size + (b.sfsp__IncludePoints__c ? Object.keys(containerSet.childContainers || {}).length : 0),
                progress: null,
                icon: { category: "standard", name: "address", color: "#3BA755" }
              };
            }));
            return arr;
          }, []);
        },
        getBoundaries({ node, boundaryObject, format: format2 = "array" }) {
          let containers2 = SPM.$store.containerSets[boundaryObject.containerSetId].containers;
          if (!boundaryObject.includesPoints) {
            containers2 = Object.keys(containers2).filter((key) => !containers2[key].parent).reduce((res, key) => (res[key] = containers2[key], res), {});
          }
          if (boundaryObject.rootNodeId === node.id) {
            return format2 === "map" ? Object.values(containers2).reduce((map2, boundary) => {
              map2[boundary.name] = true;
              return map2;
            }, {}) : Object.values(containers2).map((boundary) => boundary.name);
          }
          const boundaryRule = (node.previewRules || node.rules).find((r) => r.sfsp__SalesNodeBoundary__c === boundaryObject.id);
          const boundaryValueMap = ((boundaryRule == null ? void 0 : boundaryRule.sfsp__SalesNodeRuleItems__r) || []).reduce((map2, ruleItem) => {
            ruleItem.sfsp__Value__c.split(",").forEach((v) => map2[v] = true);
            return map2;
          }, {});
          const boundaryPrefixValues = Object.keys(boundaryValueMap);
          const expandedBoundaries = SPM.Utils.Rule.unsimplifyValues(Object.values(containers2).map((c) => c.name), boundaryPrefixValues);
          const boundaries = expandedBoundaries.map((boundary) => containers2[boundary]);
          return format2 === "map" ? boundaries.reduce((map2, boundary) => {
            map2[boundary.name] = true;
            return map2;
          }, {}) : boundaries.map((boundary) => boundary.name);
        },
        async getBoundaryData({ nodes, boundaryObject }) {
          var _a, _b;
          const boundaryNodeMap = {};
          Node2.getDescendants({ nodes }).forEach((descendant) => {
            if (descendant.level > SPM.$store.scope)
              return;
            SPM.Utils.Node.getBoundaries({ node: descendant, boundaryObject }).forEach((boundary) => {
              boundaryNodeMap[boundary] = boundaryNodeMap[boundary] || [];
              const newBoundaryNodes = [];
              let isAncestor = false;
              boundaryNodeMap[boundary].forEach((n) => {
                if (SPM.Utils.Node.isAncestor({ node: n, ancestor: descendant, nodeMap: SPM.$store.nodeMap })) {
                  isAncestor = true;
                  return;
                } else if (!SPM.Utils.Node.isAncestor({ node: descendant, ancestor: n, nodeMap: SPM.$store.nodeMap })) {
                  newBoundaryNodes.push(n);
                }
              });
              if (!isAncestor)
                newBoundaryNodes.push(descendant);
              boundaryNodeMap[boundary] = newBoundaryNodes;
            });
          });
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === boundaryObject.name);
          });
          const containerMap = SPM.$store.containerMap[boundaryObject.containerSetId];
          const recordMap = {};
          Object.keys(boundaryNodeMap).forEach((boundary) => {
            recordMap[boundary] = {
              id: boundary,
              label: containerMap[boundary].label,
              nodeId: boundaryNodeMap[boundary][0].id,
              // nodeId is only used in exclusive assignment where there will be a single value
              AssignedTo: boundaryNodeMap[boundary].map((n) => n.name).join(", ")
            };
            objectsWithGeoField.forEach((o) => recordMap[boundary][o.id] = 0);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            nodes.forEach((node) => {
              saql += SPM.Utils.Node.generateSaql({
                node,
                assignmentObject,
                boundaryObjects: SPM.$store.boundaryObjects,
                nodeMap: SPM.$store.nodeMap,
                type: "cogroup",
                returnType: "records",
                prefix: "boundary",
                skipLoad: !!saql
              });
            });
            let rootStream = "all_possible";
            if (nodes.length > 1) {
              saql += `
                        ------------------------------------------------------------------
                        -- Combine Filter Nodes
                        ------------------------------------------------------------------
                        all_possible = union ${nodes.map((n) => `boundary_${n.id}`).join(", ")};
                    `;
            } else {
              rootStream = `boundary_${nodes[0].id.replace("All Org", "all_possible")}`;
            }
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, count() as '${assignmentObject.id}';
                    boundaries = order boundaries by '${assignmentObject.id}' desc;
                `;
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            ((results == null ? void 0 : results.records) || []).forEach((record) => {
              const existingRecord = recordMap[record[geoField.id]];
              if (existingRecord) {
                existingRecord[assignmentObject.id] = record[assignmentObject.id];
              }
            });
          }
          return Object.values(recordMap);
        },
        async getAssignments({ recordIds, assignmentObject, nodes = SPM.$store.scopeChildNodes }) {
          const assignments = recordIds.reduce((map2, id) => {
            map2[id] = [];
            return map2;
          }, {});
          await Async.forEachParallel(nodes, async (node) => {
            const saql = Node2.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              recordIds,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            results.records.forEach((record) => {
              var _a, _b, _c;
              const currentLevel = ((_c = (_b = SPM.$store.nodeMap) == null ? void 0 : _b[(_a = assignments[record.Id]) == null ? void 0 : _a[0]]) == null ? void 0 : _c.level) || 0;
              if (node.level > currentLevel) {
                assignments[record.Id] = [node.id];
              } else if (node.level === currentLevel) {
                assignments[record.Id].push(node.id);
              }
            });
          });
          return assignments;
        },
        async getAssignmentData({ nodes, includeDescendants = false, filters = [], filterLogic, assignmentObject, type, isBurndown }) {
          let saql = "";
          nodes.forEach((node) => {
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "filter",
              skipLoad: !!saql,
              isBurndown
            });
          });
          let rootStream = "all_possible";
          if (nodes.length > 1) {
            saql += `
                    ------------------------------------------------------------------
                    -- Combine Nodes
                    ------------------------------------------------------------------
                    all_possible = union ${nodes.map((n) => `filter_${n.id.replace("All Org", "all_possible")}`).join(", ")};
                `;
          } else {
            rootStream = `filter_${nodes[0].id.replace("All Org", "all_possible")}`;
          }
          if (filters.length) {
            const recordFiltersExpression = SPM.Utils.Filter.mergeBooleanFilter(
              filterLogic || Array(filters.length).fill("").map((item, i) => i + 1).join(" and "),
              filters.map((f) => SPM.Utils.Filter.toSaql(f))
            );
            saql += `
                    ------------------------------------------------------------------
                    -- Record Filters
                    ------------------------------------------------------------------
                    q = filter ${rootStream} by ${recordFiltersExpression};
                `;
            rootStream = "q";
          }
          if (type === "aggregates") {
            const referenceMetadata = AssignmentObject.getReferenceMetadata({ assignmentObject });
            saql += `
                    ------------------------------------------------------------------
                    -- Measure Aggregation
                    ------------------------------------------------------------------
                    q = group ${rootStream} by all;
                    q = foreach q generate ${referenceMetadata.map(
              (m) => ["min", "max"].includes(m.type) ? `floor(${m.type}(${m.id})) as ${m.type}__${assignmentObject.id}__${m.id}` : `${m.type}(${m.id}) as ${m.type}__${assignmentObject.id}__${m.id}`
            ).join(", ")};
                `;
            const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            return referenceMetadata.reduce((map2, m) => {
              var _a, _b, _c, _d;
              map2[`${m.type}__${assignmentObject.id}__${m.id}`] = ["min", "max"].includes(m.type) ? (_b = (_a = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _a[0]) == null ? void 0 : _b[`${m.type}__${assignmentObject.id}__${m.id}`] : ((_d = (_c = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _c[0]) == null ? void 0 : _d[`${m.type}__${assignmentObject.id}__${m.id}`]) || 0;
              return map2;
            }, {});
          }
          if (type === "records") {
            saql += `
                    ------------------------------------------------------------------
                    -- Record Projections
                    ------------------------------------------------------------------
                    q = foreach ${rootStream} generate ${[
              ...assignmentObject.recordsDataset.dimensions.map((d) => d.id),
              ...assignmentObject.recordsDataset.measures.map((m) => m.id)
            ].map((f) => `${f} as ${assignmentObject.id}__${f}`).join(", ")};
                `;
            const { results: recordResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const records = Object.values(((recordResults == null ? void 0 : recordResults.records) || []).reduce((map2, record) => {
              const recordId = record[`${assignmentObject.id}__Id`];
              if (!map2[recordId])
                map2[recordId] = record;
              return map2;
            }, {}));
            const assignments = await SPM.Utils.Node.getAssignments({
              recordIds: records.map((r) => r[`${assignmentObject.id}__Id`]),
              assignmentObject,
              nodes: includeDescendants ? SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }) : SPM.$store.scopeNodes
            });
            const cachedNodeAssignments = /* @__PURE__ */ new Map();
            records.forEach((record) => {
              var _a;
              const recordId = record[`${assignmentObject.id}__Id`];
              assignments[recordId].forEach((nodeId2) => {
                if (!cachedNodeAssignments.has(nodeId2)) {
                  cachedNodeAssignments.set(nodeId2, new Map(SPM.$store.nodeMap[nodeId2].assignments.map((a) => [`${a.sfsp__RecordId__c}:${a.sfsp__SalesAssignmentObject__c}`, a])));
                }
              });
              record.NodeId = ((_a = assignments[recordId]) == null ? void 0 : _a[0]) || "";
              record.AssignedTo = assignments[recordId].join(", ");
              record.AssignmentType = assignments[recordId].map((nodeId2) => cachedNodeAssignments.get(nodeId2).has(`${recordId}:${assignmentObject.id}`) ? "Manual" : "Rule").join(", ") || "Rule";
            });
            return records;
          }
          if (type === "saql") {
            return { saql, rootStream };
          }
        },
        Colors: [
          // standard; a11y
          "#FFFA00",
          "#FF6E00",
          "#FF7B96",
          "#D31A28",
          "#D053FF",
          "#6C2777",
          "#46E71B",
          "#6FB384",
          "#68FFD7",
          "#01BFBF",
          "#ADD4F3",
          "#2C7ED0",
          // expanded
          "#e3abec",
          "#c2dbf7",
          "#9fd6ff",
          "#9de7da",
          "#9df0c0",
          "#fff099",
          "#fed49a",
          "#d073e0",
          "#86baf3",
          "#5ebbff",
          "#44d8be",
          "#3be282",
          "#ffe654",
          "#ffb758",
          "#bd35bd",
          "#5779c1",
          "#05007a",
          "#00aea9",
          "#3cba4c",
          "#f5bc25",
          "#f99221",
          "#580d8c",
          "#001970",
          "#0a2399",
          "#0b7477",
          "#0b6b50",
          "#b67e11",
          "#b85d0d"
        ],
        randomColor() {
          return SPM.Utils.Node.Colors[Math.floor(Math.random() * SPM.Utils.Node.Colors.length)];
        }
      };
      const NodeMetric = {
        Defaults: {
          sobjectType: "sfsp__SalesNodeMetric__c",
          sfsp__TargetOverrideAmount__c: 0,
          sfsp__TargetOverrideType__c: null,
          ...[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].reduce((fieldMap, monthIndex) => {
            fieldMap[`sfsp__Target_Month${monthIndex}__c`] = 0;
            fieldMap[`previewValue${monthIndex}`] = void 0;
            return fieldMap;
          }, {})
        },
        changeTarget({ nodeMetric, period, index, target, isPreview, startingMonth, customPercentages }) {
          function targetFieldName(i) {
            return isPreview ? `previewValue${i}` : `sfsp__Target_Month${i}__c`;
          }
          if (customPercentages) {
            for (let i = 1; i < 13; i++) {
              const monthValue = customPercentages[i];
              nodeMetric[targetFieldName(i)] = monthValue;
            }
          } else if (period === "Year") {
            const monthValue = Math.floor(target / 12);
            for (let i = 1; i < 12; i++) {
              nodeMetric[targetFieldName(i)] = monthValue;
            }
            nodeMetric[targetFieldName(12)] = monthValue + (target - monthValue * 12);
          } else if (period === "Quarter") {
            const monthValue = Math.floor(target / 3);
            let month = startingMonth + (index - 1) * 3 <= 12 ? startingMonth + (index - 1) * 3 : (startingMonth + (index - 1) * 3) % 12;
            for (let i = 0; i < 2; i++) {
              nodeMetric[targetFieldName(month)] = monthValue;
              month = month + 1 <= 12 ? month + 1 : (month + 1) % 12;
            }
            nodeMetric[targetFieldName(month)] = monthValue + (target - monthValue * 3);
          } else {
            const month = index + startingMonth - 1 <= 12 ? index + startingMonth - 1 : (index + startingMonth - 1) % 12;
            nodeMetric[targetFieldName(month)] = target;
          }
        },
        getTarget({ nodeMetric, period = "Year", index = 0 }) {
          let startMonth;
          let endMonth;
          if (period === "Year") {
            startMonth = 1;
            endMonth = 12;
          } else if (period === "Quarter") {
            startMonth = (index - 1) * 3 + 1;
            endMonth = index * 3;
          } else {
            startMonth = index;
            endMonth = index;
          }
          let target = 0;
          for (let i = startMonth; i <= endMonth; i++) {
            target += typeof nodeMetric[`previewValue${i}`] === "undefined" ? nodeMetric[`sfsp__Target_Month${i}__c`] : nodeMetric[`previewValue${i}`];
          }
          return target;
        }
      };
      const Allocation = {
        generateAllocationDistributionTable() {
          const allocationTable = [];
          const quarterLength = SPM.FiscalPeriod.Quarter.length;
          const percentToAllocateEachQuarter = Math.round(100 / quarterLength * 10) / 10;
          for (let i = 0; i < quarterLength; i++) {
            const months2 = SPM.FiscalPeriod.Quarter[i];
            allocationTable[i] = allocationTable[i] || { months: [], percent: percentToAllocateEachQuarter, label: `Quarter ${i + 1}`, previewPercent: null };
            allocationTable[i].percent = percentToAllocateEachQuarter;
            const percentToAllocateEachMonth = Math.round(percentToAllocateEachQuarter / months2.length * 10) / 10;
            for (let m = 0; m < months2.length - 1; m++) {
              const id = months2[m];
              const monthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[id] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, id - 1), { month: "long" });
              allocationTable[i].months.push({
                label: monthLabel,
                percent: percentToAllocateEachMonth,
                id,
                previewPercent: null
              });
            }
            const lastMonthOfQuarter = months2[months2.length - 1];
            const lastMonthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[lastMonthOfQuarter] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, lastMonthOfQuarter - 1), { month: "long" });
            allocationTable[i].months.push({
              label: lastMonthLabel,
              percent: Math.round((percentToAllocateEachMonth + (percentToAllocateEachQuarter - percentToAllocateEachMonth * months2.length)) * 10) / 10,
              id: lastMonthOfQuarter,
              previewPercent: null
            });
          }
          allocationTable[quarterLength - 1].percent = Math.round((percentToAllocateEachQuarter + (100 - percentToAllocateEachQuarter * quarterLength)) * 10) / 10;
          return allocationTable;
        },
        getPercentageChange(oldNumber, newNumber) {
          const decreaseValue = newNumber - oldNumber;
          const change = Math.floor(decreaseValue / oldNumber * 100);
          if (change === 0 || decreaseValue === 0) {
            return "0%";
          }
          if (change === Infinity) {
            return `+ ${newNumber}%`;
          }
          return change > 0 ? `+ ${change}%` : `- ${change * -1}%`;
        }
      };
      const ExternalData = {
        // https://developer.salesforce.com/docs/atlas.en-us.238.0.bi_dev_guide_ext_data.meta/bi_dev_guide_ext_data/bi_ext_data_overview.htm
        generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries }) {
          const fields = [];
          JSON.parse(assignmentObject.sfsp__ReferenceFields__c).forEach((f) => {
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${f.name}`,
              name: f.name,
              label: f.label,
              isUniqueId: f.unique,
              type: f.type,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.type === "Numeric") {
              field.precision = f.precision;
              field.scale = f.scale;
              field.defaultValue = 0;
            }
            if (["Latitude", "Longitude"].includes(f.type))
              field.type = "Text";
            fields.push(field);
          });
          const boundaryFields = [];
          geoBoundaries == null ? void 0 : geoBoundaries.forEach((boundary) => {
            const fieldName = `${boundary.sfsp__SalesNode__c || boundary.sfsp__SalesPlan__c}_${boundary.sfsp__ContainerSet__c}`;
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${fieldName}`,
              name: fieldName,
              label: boundary.Name,
              isUniqueId: false,
              type: "Text",
              isMultiValue: false,
              description: ""
            };
            const existingField = boundaryFields.find((f) => f.name === field.name);
            if (existingField)
              Object.assign(existingField, field);
            else
              boundaryFields.push(field);
          });
          fields.push(...boundaryFields);
          if (datasetType === "Assignments") {
            fields.push(
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentNode`,
                label: "Assignment Node",
                name: "AssignmentNode",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              },
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentType`,
                label: "Assignment Type",
                name: "AssignmentType",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              }
            );
          }
          return {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: assignmentObject.Id,
                label: `${planName} ${assignmentObject.sfsp__Label__c} ${datasetType}`,
                name: assignmentObject.Name,
                description: "",
                fields
              }
            ]
          };
        },
        async getDatasetRecords({ alias, assignmentObject }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias });
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          const datasetRowMap = {};
          const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
          await async function getBatch(offset2, batchSize) {
            const saql = `
                    // total records
                    records_batch = load "${recordsDataset.id}/${recordsDataset.currentVersionId}";
                    records_batch = foreach records_batch generate ${recordsDataset.dimensions.concat(recordsDataset.measures).map((field) => `'${field.id}' as '${field.id}'`).join(", ")};
                    records_batch = order records_batch by '${uniqueIdField}';
                    records_batch = offset records_batch ${offset2};
                    records_batch = limit records_batch ${batchSize};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            if (results.records.length === batchSize)
              await getBatch(offset2 + batchSize, batchSize);
          }(0, 1e4);
          return datasetRowMap;
        },
        async updateDataset({ planId, planName, datasetType, assignmentObject, geoBoundaries, rowsToUpdate }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const datasetRowMap = await this.getDatasetRecords({ alias: `${planId}_${assignmentObject.Id}_Records`, assignmentObject });
            const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
            rowsToUpdate.forEach((row) => {
              const existingRow = datasetRowMap[row[uniqueIdField]];
              if (existingRow) {
                Object.keys(row).forEach((fieldName) => {
                  existingRow[fieldName] = row[fieldName];
                });
                datasetRowMap[row[uniqueIdField]] = existingRow;
              }
            });
            const recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa2.unparse(batch);
              const chunkSize = 3e6;
              Papa2.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa2.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa2.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa2.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        },
        async createManualDataset({ planId, planName, datasetType, assignmentObject, records }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const recordBatches = [];
            while (records.length) {
              recordBatches.push(records.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => {
                return getValueFromRecord(field.name, record) || (field.type === "Text" ? "" : 0);
              })));
            }
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa2.unparse(batch);
              const chunkSize = 3e6;
              Papa2.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa2.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa2.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa2.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        }
      };
      const AutoAssignment = {
        async buildAssignmentObjectScus({ balanceField, geoAssignment, selectedObject, selectedRecords, targetNodeIds }) {
          const rootNodeId = SPM.$store.rootNode.id === "All Org" ? SPM.$store.plan.Id : SPM.$store.rootNode.id;
          const containerSetIds = /* @__PURE__ */ new Set();
          SPM.$store.boundaryObjects.forEach((o) => containerSetIds.add(o.containerSetId));
          const scus = {};
          selectedRecords.forEach((unit) => {
            var _a, _b;
            const boundaryFields = Object.keys(unit).filter((fieldName) => fieldName.startsWith(`${selectedObject.id}__${rootNodeId}`));
            const boundaryKey = boundaryFields.find((f) => !!unit[f]);
            let boundary = unit[boundaryKey] || "";
            const record = {
              Id: unit[`${selectedObject.id}__Id`],
              Locked: false,
              Boundaries: boundary || "",
              Weight: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0,
              Volume: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0
            };
            const latitudeField = (_a = selectedObject.latitude) == null ? void 0 : _a.name;
            const longitudeField = (_b = selectedObject.longitude) == null ? void 0 : _b.name;
            if (latitudeField && longitudeField) {
              record.Latitude = parseFloat(unit[`${selectedObject.id}__${latitudeField}`]);
              record.Longitude = parseFloat(unit[`${selectedObject.id}__${longitudeField}`]);
            }
            if (geoAssignment === "nonContiguous" && (!record.Latitude || !record.Longitude)) {
              const middleUSA = { latitude: 39.8283, longitude: 98.5795 };
              const radius = 944685;
              const randomPoint = randomLocation.randomCirclePoint(middleUSA, radius);
              record.Latitude = randomPoint.latitude;
              record.Longitude = randomPoint.longitude;
            }
            if (record.Latitude && record.Longitude)
              scus[record.Id] = record;
          });
          const assignmentNodes = targetNodeIds.map((id) => SPM.$store.nodeMap[id]);
          for (const assignmentNode of assignmentNodes) {
            const saql = SPM.Utils.Node.generateSaql({
              node: assignmentNode,
              assignmentObject: selectedObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const boundaryRollup = results.records.reduce((agg, rec) => {
              const boundaryFields = Object.keys(rec).filter((fieldName) => fieldName.startsWith(rootNodeId));
              boundaryFields.forEach((fieldName) => {
                let boundary = rec[fieldName] || "";
                if (agg.includes(boundary))
                  ;
                else if (agg.length === 0)
                  agg = boundary;
                else
                  agg = `${agg},${boundary}`;
              });
              return agg;
            }, "");
            const weightRollup = results.records.reduce((agg, rec) => {
              if (scus[rec.Id])
                return agg;
              return agg + (balanceField === "Unit" ? 1 : rec[balanceField] || 0);
            }, 0);
            scus[`${assignmentNode.id}-Rollup`] = {
              Id: `${assignmentNode.id}-Rollup`,
              Assignment: assignmentNode.id,
              Boundaries: boundaryRollup,
              Locked: true,
              Latitude: 39.8283,
              Longitude: 98.5795,
              Weight: weightRollup,
              Volume: weightRollup
            };
          }
          return { scus: [...Object.values(scus)], containerSetIds };
        },
        async buildBoundaryObjectScus({ balanceField, selectedObject, selectedBoundaries, node }) {
          var _a, _b;
          const weightMap = {};
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === selectedObject.name);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "drilldown",
              skipLoad: !!saql
            });
            const rootStream = `drilldown_${node.id.replace("All Org", "all_possible")}`;
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === selectedObject.name);
            const aggregateProjection = balanceField === "Unit" ? `count() as ${balanceField}` : `sum('${balanceField}') as '${balanceField}'`;
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Filter
                    ------------------------------------------------------------------
                    ${rootStream} = filter ${rootStream} by ${geoField.id} ${node.id === SPM.$store.rootNode.id ? "in" : "not in"} ${JSON.stringify(selectedBoundaries)};

                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, ${aggregateProjection};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              const boundaryName = record[geoField.id];
              if (!weightMap[boundaryName])
                weightMap[boundaryName] = 0;
              weightMap[boundaryName] += record[balanceField];
            });
          }
          const scus = {};
          const boundaryMap = SPM.$store.containerMap[selectedObject.containerSetId];
          if (node.id !== SPM.$store.rootNode.id) {
            let boundaryRollup = "";
            let weightRollup = 0;
            let totalLat = 0;
            let totalLng = 0;
            Object.entries(weightMap).forEach(([boundary, weight]) => {
              if (boundaryRollup.length === 0)
                boundaryRollup = boundary;
              else
                boundaryRollup += `, ${boundary}`;
              totalLat += boundaryMap[boundary].metadata.lat;
              totalLng += boundaryMap[boundary].metadata.lng;
              weightRollup += weight;
            });
            const nodeId2 = node.id === "All Org" ? SPM.$store.plan.Id : node.id;
            scus[`${nodeId2}-Rollup`] = {
              Id: `${nodeId2}-Rollup`,
              Locked: true,
              Assignment: node.id,
              Boundaries: boundaryRollup,
              Weight: weightRollup,
              Volume: weightRollup,
              Latitude: totalLat / Object.keys(weightMap).length,
              Longitude: totalLng / Object.keys(weightMap).length
            };
          } else {
            selectedBoundaries.forEach((boundary) => {
              const weight = weightMap[boundary] || 0;
              scus[boundary] = {
                Id: boundary,
                Locked: false,
                Boundaries: boundary,
                Weight: weight,
                Volume: weight,
                Latitude: boundaryMap[boundary].metadata.lat,
                Longitude: boundaryMap[boundary].metadata.lng
              };
            });
          }
          return Object.values(scus);
        }
      };
      const Browser = {
        clearSelection() {
          var _a, _b, _c;
          (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.empty();
          (_b = window == null ? void 0 : window.getSelection()) == null ? void 0 : _b.removeAllRanges();
          (_c = document == null ? void 0 : document.selection) == null ? void 0 : _c.empty();
        },
        getCursorPosition(input, selectionPoint, { top: top2, left: left2 } = {}) {
          const { offsetLeft: inputX, offsetTop: inputY } = input;
          const div = document.createElement("div");
          const copyStyle = getComputedStyle(input);
          for (const prop of copyStyle)
            div.style[prop] = copyStyle[prop];
          const inputValue = input.tagName === "INPUT" ? input.value.replace(/ /g, ".") : input.value;
          div.textContent = inputValue.substr(0, selectionPoint);
          if (input.tagName === "TEXTAREA")
            div.style.height = "auto";
          if (input.tagName === "INPUT")
            div.style.width = "auto";
          const span = document.createElement("span");
          span.textContent = inputValue.substr(selectionPoint) || ".";
          div.appendChild(span);
          document.body.appendChild(div);
          div.style.position = "absolute";
          div.style.top = "0px";
          div.style.left = "-1000px";
          const { offsetLeft: spanX, offsetTop: spanY } = span;
          document.body.removeChild(div);
          return {
            x: inputX + spanX + (left2 || 0),
            y: inputY + spanY - input.scrollTop + (top2 || 0)
          };
        },
        // sets search params by replacing existing state (i.e. popstate event is not fired)
        setSearchParams(params = {}) {
          const url = new URL(window.location);
          for (const [key, value] of Object.entries(params)) {
            url.searchParams.set(key, value);
          }
          window.history.replaceState({}, "", url);
        }
      };
      const Str = {
        htmlEncode(str) {
          str = this.htmlDecode(str);
          return String(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        htmlDecode(stringValue) {
          let returnText = stringValue;
          if (typeof stringValue === "string") {
            if (typeof document === "object") {
              const txt = document.createElement("textarea");
              txt.innerHTML = stringValue;
              returnText = txt.value;
            } else {
              returnText = String(stringValue).replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }
          }
          return returnText;
        },
        sanitizeHTML(str) {
          const temp = document.createElement("div");
          temp.textContent = str;
          return temp.innerHTML;
        },
        splitLines(str) {
          return str.split(/\r?\n|\r|\n/g).filter((line) => !!line).map((line) => line.trim());
        },
        truncate(str, { length = 80, ellipsis = true } = {}) {
          return ellipsis && str.length > length && length >= 3 ? `${str.slice(0, length - 3)}...` : str.slice(0, length);
        }
      };
      const Pendo = {
        track(event, payload) {
          if (pendo.visitorId)
            pendo.track(event, payload);
          else
            console.log("Pendo is unable to track this event");
        }
      };
      const Splunk = {
        showLogs(logName = "spm*") {
          const baseSplunkUrl = `https://splunk-web.log-analytics.monitoring.aws-esvc1-useast2.aws.sfdc.is/en-US/app/search/search?q=search `;
          const searchParams = encodeURIComponent(` index=${SPM.instanceName} organizationId=${SPM.orgId} logRecordType=jsLog logName=${logName}`);
          window.open(`${`${baseSplunkUrl}${searchParams}&display.page.search.mode=verbose&dispatch.sample_ratio=1&earliest=-24h%40h&latest=now`}`);
        },
        sendLog({ txnId = SPM.$store.txnId || getGUID(), logName = "spmLog", logPayload = {} }) {
          if (logName === "spmEPT" && SPM.$store.eptCaptured)
            return;
          else if (logName === "spmEPT") {
            SPM.$store.eptCaptured = true;
            logPayload.ept = window.performance.now();
          }
          const logLines = [{
            logName,
            logLevel: "INFO",
            logAttrs: {
              txnId,
              ...logPayload
            }
          }];
          const iframe = document.createElement("iframe");
          iframe.style.display = "none";
          iframe.name = `jslogger_${Date.now()}`;
          document.body.appendChild(iframe);
          const logLinesInput = document.createElement("input");
          logLinesInput.style.display = "none";
          logLinesInput.name = "logLines";
          logLinesInput.value = JSON.stringify(logLines);
          const form = document.createElement("form");
          form.style.display = "none";
          form.method = "POST";
          form.action = `${SPM.orgDomainUrl}/_ui/common/request/servlet/JsLoggingServlet`;
          form.target = iframe.name;
          form.appendChild(logLinesInput);
          document.body.appendChild(form);
          form.submit();
          setTimeout(() => {
            form.remove();
            iframe.remove();
          }, 5e3);
        }
      };
      const Version244 = {
        /**
         * Waiting status metadata was introduced in version 244.4 to the SalesAsyncJob object on the Status field (picklist)
         * Picklist field values do not ship new or removed metadata values in managed package upgrades.
         * The new metadata values are only available on new installs. In this case 244.4 or higher
         * This check will run on every page load to see if the picklist value "Waiting" is available on the SalesAsyncJob object -> Status field
         */
        async checkAsyncJobWaitingStatus() {
          let toastMessage = "";
          try {
            const sObject = "sfsp__SalesAsyncJob__c";
            const statusField = "sfsp__Status__c";
            const sObjectDescribe = await SPM.Utils.Rest.invoke("SObject", { sObject });
            const field = sObjectDescribe.fields.find((f) => f.name === statusField);
            const waitingPicklistValue = field.picklistValues.find((f) => f.value === "Waiting");
            if (!waitingPicklistValue) {
              toastMessage = `Missing status "Waiting" on the ${statusField} field for the sobject ${sObject}`;
              const entityDefQuery = `SELECT DurableId, QualifiedApiName FROM EntityDefinition WHERE QualifiedApiName = '${sObject}'`;
              const entityRecords = await SPM.Utils.Rest.invoke("ToolingQuery", entityDefQuery);
              const entityRecord = entityRecords.records.length ? entityRecords.records[0] : null;
              if (entityRecord) {
                const sObjectToolingDescribe = await SPM.Utils.Rest.invoke("ToolingSObject", { sObject: "CustomField" });
                const toolingFieldsToQuery = sObjectToolingDescribe.fields.map((a) => a.name);
                const metadataCustomFieldQuery = `SELECT ${toolingFieldsToQuery.join(", ")} FROM CustomField WHERE DeveloperName = 'Status' AND EntityDefinitionId = '${entityRecord.DurableId}' AND NamespacePrefix = 'sfsp' LIMIT 1`;
                const customFieldRecords = await SPM.Utils.Rest.invoke("ToolingQuery", metadataCustomFieldQuery);
                if (!customFieldRecords.records.length) {
                  toastMessage = `Could not find ${statusField} field for the sobject ${sObject}`;
                  throw new Error(toastMessage);
                }
                const salesAsyncJobField = customFieldRecords.records.find((f) => f.FullName === `${sObject}.${statusField}`);
                if (!salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.find((f) => f.valueName === "Waiting")) {
                  salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.push({
                    color: null,
                    default: false,
                    description: null,
                    isActive: null,
                    label: "Waiting",
                    urls: null,
                    valueName: "Waiting"
                  });
                  salesAsyncJobField.Metadata.valueSet.valueSettings = [];
                  const metadata = { Metadata: salesAsyncJobField.Metadata, FullName: salesAsyncJobField.FullName };
                  const url = salesAsyncJobField.attributes.url;
                  try {
                    await SPM.Utils.Rest.invoke("ToolingSObjectPatch", { url, metadata });
                  } catch (ex) {
                    toastMessage = `Error updating ${statusField} field with picklist value "Waiting" for the sobject ${sObject}`;
                    throw new Error(ex);
                  }
                }
              } else {
                toastMessage = `Unable to find the sobject ${sObject}. Missing status "Waiting" on the ${statusField} field.`;
              }
              toastMessage = "";
            }
          } catch (e) {
            if (toastMessage !== "")
              SPM.$store.toast({ state: "error", message: `${toastMessage}.`, subMessage: "Please contact your admin to ensure Sales Planning is properly configured.", duration: null });
            console.log("checkAsyncJobWaitingStatus", e);
          }
        }
      };
      const Segment = SegClient({ Buffer: Buffer2, Papa: Papa2 });
      const Area = {
        getFieldValue(store, area, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = area.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getAreaValue(area);
          } else if (fieldType === "Metadata") {
            fieldValue = area.metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = area[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, area, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Area.getFieldValue(store, area, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Area.getFieldValue(store, area, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Area.getFieldValue(store, area, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Container = {
        getFieldValue(store, containerUnit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = containerUnit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(containerUnit);
          } else if (fieldType === "Metadata") {
            fieldValue = containerUnit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "ContainerMetadata") {
            fieldValue = store.state.containerSets.find((cs) => cs.id === containerUnit.ContainerSetId).containers[containerUnit.ContainerId].metadata[fieldId.replace(/^ContainerMetadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = containerUnit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, containerUnit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Unit = {
        getFieldValue(store, unit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = unit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(unit);
          } else if (fieldType === "Metadata") {
            fieldValue = unit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = unit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, unit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.altLabelFieldId);
          }
          return label;
        },
        get18CharacterId(store, unit) {
          let id = unit.UnitId || "";
          if (id.length !== 15)
            return null;
          for (let i = 0; i < 3; i++) {
            let flags = 0;
            for (let j = 0; j < 5; j++) {
              const c = id.charAt(i * 5 + j);
              if (c >= "A" && c <= "Z")
                flags += 1 << j;
            }
            id += "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345".charAt(flags);
          }
          return id;
        }
      };
      const PkChunking = {
        encode(int, charset) {
          let byCode = charset.byCode;
          if (int === 0) {
            return byCode[0];
          }
          var res = "", max2 = charset.length;
          while (int > 0) {
            res = byCode[int % max2] + res;
            int = Math.floor(int / max2);
          }
          return res;
        },
        decode(str, charset) {
          var byChar = charset.byChar, res = 0, length = str.length, max2 = charset.length, i, char;
          for (i = 0; i < length; i++) {
            char = str[i];
            res += byChar[char] * Math.pow(max2, length - i - 1);
          }
          return res;
        },
        // NB: does not validate input
        indexCharset(str) {
          var byCode = {}, byChar = {}, length = str.length, i, char;
          for (i = 0; i < length; i++) {
            char = str[i];
            byCode[i] = char;
            byChar[char] = i;
          }
          return { byCode, byChar, length };
        },
        /* strip the 6 digit id prefix, and last 3 digits (CRC check) if any
        * then base62 decode to convert to long
        */
        convertSalesforceIdToLong(salesforceId) {
          const salesforceIdStripped = salesforceId.substring(6, 15);
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          return this.decode(salesforceIdStripped, charset);
        },
        // base62 encode them, and add the id prefix back in
        convertLongToSalesforceId(idPrefix, longId) {
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          const sfNumId = Number(longId);
          const idStringB62 = this.encode(sfNumId, charset).padStart(9, 0);
          return idPrefix + idStringB62;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and break it into chunk ranges of specified size
        * Only works if all the IDs have the same pod identifier
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        chunkIdRange(startId, endId2, chunkSize) {
          const idPrefix = startId.substring(0, 6);
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const numberChunkList = this.chunkRange(startNum, endNum, 9, chunkSize);
          return numberChunkList.map((chunk) => {
            const first = this.convertLongToSalesforceId(idPrefix, chunk.first);
            const last = this.convertLongToSalesforceId(idPrefix, chunk.last);
            return { first, last };
          });
        },
        /*
        * This method is used to chunk up a large range of Long Integers into a list of smaller ranges.
        * start number, end number, and size of the chunks is passed in
        */
        chunkRange(firstNum, lastNum, totalLength, chunkSize) {
          const range = lastNum - firstNum;
          const numChunkList = [];
          if (range < chunkSize) {
            numChunkList.push({ first: firstNum, last: lastNum });
          } else {
            const numChunks = Math.trunc(range / chunkSize);
            let firstNumChunk = firstNum;
            let lastNumChunk = firstNum + chunkSize - 1;
            numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            for (let i = 1; i < numChunks; i++) {
              firstNumChunk = lastNumChunk + 1;
              lastNumChunk = firstNumChunk + chunkSize - 1;
              numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            }
            const lastlastNumChunk = numChunkList[numChunkList.length - 1].last;
            if (lastlastNumChunk < lastNum) {
              numChunkList.push({ first: lastlastNumChunk + 1, last: lastNum });
            }
          }
          const numChunkListZeroPadded = numChunkList.map((numChunk) => ({
            first: (numChunk.first || "").toString().padStart(totalLength, 0),
            last: (numChunk.last || "").toString().padStart(totalLength, 0)
          }));
          return numChunkListZeroPadded;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and calculate the number of ids between the two
        * Use the unit count to calculate fragementation between the range we require and the actual ids present
        * Only works if all the IDs have the same pod identider
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        calculateFragmentation(startId, endId2, unitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          return totalRange / unitCount;
        },
        // split the range into the number of chunks specified by splitCount
        splitIdChunk(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return this.chunkIdRange(startId, endId2, chunkSize);
        },
        // Calculate the size of a chunk to split the input range into the number of splits specified
        // For example a range of 30002 with a split of 3 would result in a chunk size of 10001
        calculateChunkSizeToSplitRange(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return chunkSize;
        }
      };
      return {
        Debug: false,
        Apex,
        Rest,
        Pendo,
        Splunk,
        HTTP,
        CRM,
        CRMA,
        ExternalData,
        Async,
        Store,
        Obj,
        Arr,
        Tree: Tree2,
        Rule,
        Filter,
        DeferredPromise,
        AutoAssignment,
        Plan: Plan2,
        AssignmentObject,
        BoundaryObject,
        Node: Node2,
        NodeMetric,
        Browser,
        Str,
        Map: MapUtil,
        Segment,
        Allocation,
        Area,
        Container,
        Unit,
        PkChunking,
        Version244
      };
    }
    class MathStream {
      constructor(expressionString) {
        this.expressionString = expressionString;
        this.position = 0;
        this.nextChar = null;
      }
      // Returns the next character in the expression without advancing the position.
      peek() {
        if (this.nextChar === null) {
          this.nextChar = this.expressionString.charAt(this.position);
        }
        return this.nextChar;
      }
      // Returns the next character in the expression and advances the position.
      next() {
        var returnChar;
        if (this.nextChar !== null) {
          returnChar = this.nextChar;
          this.nextChar = null;
        } else {
          returnChar = this.expressionString.charAt(this.position);
        }
        this.position++;
        return returnChar;
      }
      // Moves to the next position in the expression.
      skip() {
        this.nextChar = null;
        this.position++;
      }
      // True if there are no more characters in the expression.
      get end() {
        return this.position >= this.expressionString.length;
      }
    }
    class MathLexer {
      static isWhitespace(c) {
        const regex = /^[ \t\n]$/;
        return regex.test(c);
      }
      static isDigit(c) {
        const regex = /^[0-9]$/;
        return regex.test(c);
      }
      static isFunctionStart(c) {
        const regex = /^[a-zA-Z_]$/;
        return regex.test(c);
      }
      static isFunction(c) {
        const regex = /^[a-zA-Z_0-9]$/;
        return regex.test(c);
      }
      static isNumericStart(c) {
        const regex = /^[0-9.]$/;
        return regex.test(c);
      }
      static isVariableStart(c) {
        return c === "[";
      }
      static isVariableEnd(c) {
        return c === "]";
      }
      static isStringStart(c) {
        return c === '"';
      }
      static isStringEnd(c) {
        return c === '"';
      }
      static isE(c) {
        const regex = /^[eE]$/;
        return regex.test(c);
      }
      static isSign(c) {
        const regex = /^[+-]$/;
        return regex.test(c);
      }
      constructor(expressionString) {
        this.stream = new MathStream(expressionString);
        this.nextToken = null;
        this.position = 0;
      }
      // Skips characters in the expression while the predicate function holds.
      skipWhile(predicate) {
        while (!this.stream.end && predicate(this.stream.peek())) {
          this.stream.next();
        }
      }
      // Skips characters in the expression while the predicate function holds.
      readWhile(predicate) {
        let str = "";
        while (!this.stream.end && predicate(this.stream.peek())) {
          str += this.stream.next();
        }
        return str;
      }
      // Attempts to read a number from the expression.
      readNumber() {
        let startPosition = this.stream.position;
        let numStr = "";
        numStr += this.readWhile(MathLexer.isDigit);
        if (!this.stream.end && this.stream.peek() === ".") {
          numStr += this.stream.next();
          numStr += this.readWhile(MathLexer.isDigit);
        }
        if (!this.stream.end && MathLexer.isE(this.stream.peek())) {
          numStr += this.stream.next();
          if (!this.stream.end && MathLexer.isSign(this.stream.peek())) {
            numStr += this.stream.next();
          }
          numStr += this.readWhile(MathLexer.isDigit);
        }
        let num = Number(numStr);
        if (isNaN(num)) {
          throw { error: "Invalid token", position: startPosition };
        }
        return num;
      }
      // Attempts to read a string from the expression.
      readString() {
        let startPosition = this.stream.position;
        this.stream.skip();
        let str = this.readWhile((c) => {
          return !MathLexer.isStringEnd(c);
        });
        if (this.stream.end) {
          throw {
            error: "Missing closing quote for string",
            position: startPosition
          };
        }
        this.stream.skip();
        return str;
      }
      readFunction() {
        return this.readWhile(MathLexer.isFunction);
      }
      readVariable() {
        let startPosition = this.stream.position;
        this.stream.skip();
        let variable = this.readWhile((c) => {
          return !MathLexer.isVariableEnd(c);
        });
        if (this.stream.end) {
          throw {
            error: "Missing closing bracket for variable",
            position: startPosition
          };
        }
        this.stream.skip();
        return variable;
      }
      // Reads and returns the next token from the expression. Returns null if the end of the expression is reached.
      readNext() {
        this.skipWhile(MathLexer.isWhitespace);
        if (this.stream.end) {
          return null;
        }
        let startPosition = this.stream.position;
        let c = this.stream.peek();
        switch (c) {
          case "(":
            this.stream.skip();
            return { type: "ParenStart" };
          case ")":
            this.stream.skip();
            return { type: "ParenEnd" };
          case ",":
            this.stream.skip();
            return { type: "Comma" };
          case "+":
            this.stream.skip();
            return { type: "Plus" };
          case "-":
            this.stream.skip();
            return { type: "Minus" };
          case "*":
            this.stream.skip();
            return { type: "Multiply" };
          case "/":
            this.stream.skip();
            return { type: "Divide" };
          case "^":
            this.stream.skip();
            return { type: "Exponentiation" };
          case "<":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "LessThanOrEqual" };
            }
            return { type: "LessThan" };
          case ">":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "GreaterThanOrEqual" };
            }
            return { type: "GreaterThan" };
          case "=":
            this.stream.skip();
            return { type: "EqualTo" };
          case "!":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "NotEqualTo" };
            }
        }
        if (MathLexer.isNumericStart(c)) {
          return {
            type: "Number",
            value: this.readNumber(),
            startPosition
          };
        }
        if (MathLexer.isStringStart(c)) {
          return {
            type: "String",
            value: this.readString(),
            startPosition
          };
        }
        if (MathLexer.isFunctionStart(c)) {
          return {
            type: "Function",
            value: this.readFunction(),
            startPosition
          };
        }
        if (MathLexer.isVariableStart(c)) {
          return {
            type: "Variable",
            value: this.readVariable(),
            startPosition
          };
        }
        throw { error: "Invalid token", position: this.stream.position };
      }
      // Returns the next token in the expression, but does not advance the position.
      // Returns null if the end of the expression is reached.
      peek() {
        if (this.nextToken === null && !this.stream.end) {
          this.nextToken = this.readNext();
        }
        return this.nextToken;
      }
      // Returns the next token in the expression and advances the position.
      // Returns null if the end of the expression is reached.
      next() {
        let returnToken;
        if (this.nextToken === null) {
          returnToken = this.stream.end ? null : this.readNext();
        } else {
          returnToken = this.nextToken;
          this.nextToken = null;
        }
        this.position = this.stream.position;
        return returnToken;
      }
      // Determines if the end of the expression has been reached.
      get end() {
        this.peek();
        return this.nextToken == null;
      }
    }
    class ConditionalNode {
      constructor(conditions, operator) {
        this.conditions = conditions;
        this.operator = operator;
      }
      evaluate() {
        switch (this.operator) {
          case "AND":
            return this.conditions.find((condition) => !condition.evaluate()) ? false : true;
          case "OR":
            return this.conditions.find((condition) => condition.evaluate()) ? true : false;
        }
      }
    }
    class RelationalNode {
      constructor(leftNode, rightNode, operator) {
        this.leftNode = leftNode;
        this.rightNode = rightNode;
        this.operator = operator;
      }
      evaluate() {
        switch (this.operator) {
          case "LessThan":
            return this.leftNode.evaluate() < this.rightNode.evaluate();
          case "LessThanOrEqual":
            return this.leftNode.evaluate() <= this.rightNode.evaluate();
          case "GreaterThan":
            return this.leftNode.evaluate() > this.rightNode.evaluate();
          case "GreaterThanOrEqual":
            return this.leftNode.evaluate() >= this.rightNode.evaluate();
          case "EqualTo":
            return this.leftNode.evaluate() === this.rightNode.evaluate();
          case "NotEqualTo":
            return this.leftNode.evaluate() !== this.rightNode.evaluate();
          default:
            return false;
        }
      }
    }
    class BooleanNode {
      constructor(boolVal, trueVal, falseVal) {
        this.boolVal = boolVal;
        this.trueVal = trueVal;
        this.falseVal = falseVal;
      }
      evaluate() {
        return this.boolVal.evaluate() ? this.trueVal.evaluate() : this.falseVal.evaluate();
      }
    }
    class VariableNode {
      constructor() {
        this.varValue = 0;
      }
      set value(varValue) {
        this.varValue = varValue;
      }
      evaluate() {
        return this.varValue;
      }
    }
    class ConstantNode {
      constructor(value) {
        this.value = value;
      }
      evaluate() {
        return this.value;
      }
    }
    class AdditionNode {
      constructor(addend1, addend2) {
        this.addend1 = addend1;
        this.addend2 = addend2;
      }
      evaluate() {
        return this.addend1.evaluate() + this.addend2.evaluate();
      }
    }
    class SubtractionNode {
      constructor(minuend, subtrahend) {
        this.minuend = minuend;
        this.subtrahend = subtrahend;
      }
      evaluate() {
        return this.minuend.evaluate() - this.subtrahend.evaluate();
      }
    }
    class MultiplicationNode {
      constructor(factor1, factor2) {
        this.factor1 = factor1;
        this.factor2 = factor2;
      }
      evaluate() {
        return this.factor1.evaluate() * this.factor2.evaluate();
      }
    }
    class DivisionNode {
      constructor(dividend, divisor) {
        this.dividend = dividend;
        this.divisor = divisor;
      }
      evaluate() {
        return this.dividend.evaluate() / this.divisor.evaluate();
      }
    }
    class NegationNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return this.term.evaluate() * -1;
      }
    }
    class ExponentiationNode {
      constructor(base, exponent) {
        this.base = base;
        this.exponent = exponent;
      }
      evaluate() {
        return Math.pow(this.base.evaluate(), this.exponent.evaluate());
      }
    }
    class SqrtNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.sqrt(this.term.evaluate());
      }
    }
    class LogNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.log(this.term.evaluate());
      }
    }
    class ExpNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.exp(this.term.evaluate());
      }
    }
    class AbsNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.abs(this.term.evaluate());
      }
    }
    class FloorNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.floor(this.term.evaluate());
      }
    }
    class CeilNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.ceil(this.term.evaluate());
      }
    }
    class RoundNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.round(this.term.evaluate());
      }
    }
    class MathParser {
      constructor(expressionString) {
        this.lexer = new MathLexer(expressionString);
        this.variables = /* @__PURE__ */ new Map();
      }
      // parse the expression and returns the node for evaluating
      parse() {
        if (this.lexer.end) {
          return new ConstantNode(0);
        }
        let node = this.parseAddSub();
        if (!this.lexer.end) {
          throw {
            error: "Expression does not end where expected",
            position: this.lexer.position
          };
        }
        return node;
      }
      parseRelation() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node = this.parseAddSub();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "LessThan":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "LessThan");
              break;
            case "LessThanOrEqual":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "LessThanOrEqual");
              break;
            case "GreaterThan":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "GreaterThan");
              break;
            case "GreaterThanOrEqual":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "GreaterThanOrEqual");
              break;
            case "EqualTo":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "EqualTo");
              break;
            case "NotEqualTo":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "NotEqualTo");
              break;
          }
        } while (["LessThan", "GreaterThan", "GreaterThanOrEqual", "LessThanOrEqual", "EqualTo", "NotEqualTo"].includes(token2.type));
        return node;
      }
      // parse add and subtract operations
      parseAddSub() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node = this.parseMultDiv();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "Plus":
              this.lexer.next();
              node = new AdditionNode(node, this.parseMultDiv());
              break;
            case "Minus":
              this.lexer.next();
              node = new SubtractionNode(node, this.parseMultDiv());
              break;
          }
        } while (token2.type === "Plus" || token2.type === "Minus");
        return node;
      }
      // parse multiply and divide operations
      parseMultDiv() {
        let node = this.parseExp();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "Multiply":
              this.lexer.next();
              node = new MultiplicationNode(node, this.parseExp());
              break;
            case "Divide":
              this.lexer.next();
              node = new DivisionNode(node, this.parseExp());
              break;
          }
        } while (token2.type === "Multiply" || token2.type === "Divide");
        return node;
      }
      // parse exponentiation operations
      parseExp() {
        let node = this.parseNegation();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          if (token2.type === "Exponentiation") {
            this.lexer.next();
            node = new ExponentiationNode(node, this.parseExp());
          }
        } while (token2.type === "Exponentiation");
        return node;
      }
      // parse negation operations
      parseNegation() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let negate = false;
        let token2 = this.lexer.peek();
        switch (token2.type) {
          case "Plus":
            this.lexer.next();
            break;
          case "Minus":
            this.lexer.next();
            negate = true;
            break;
        }
        let node = this.parseParen();
        if (negate) {
          node = new NegationNode(node);
        }
        return node;
      }
      // parse expressions in parenthesis
      parseParen() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node;
        let token2 = this.lexer.peek();
        if (token2.type === "ParenStart") {
          this.lexer.next();
          node = this.parseAddSub();
          let closePosition = this.lexer.position;
          if (this.lexer.end || this.lexer.next().type !== "ParenEnd") {
            throw { error: "Missing closing parenthesis", position: closePosition };
          }
        } else {
          node = this.parseFuncVarNum();
        }
        return node;
      }
      // parse function calls, variables, and constants
      parseFuncVarNum() {
        let node;
        let token2 = this.lexer.next();
        if (token2.type === "Function") {
          if (!this.lexer.end && this.lexer.peek().type === "ParenStart") {
            this.lexer.next();
            let conditionArgs = [];
            let arg1Node, arg2Node, arg3Node;
            switch (token2.value.toLowerCase()) {
              case "pow":
                arg1Node = this.parseAddSub();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg2Node = this.parseAddSub();
                node = new ExponentiationNode(arg1Node, arg2Node);
                break;
              case "sqrt":
                arg1Node = this.parseAddSub();
                node = new SqrtNode(arg1Node);
                break;
              case "log":
                arg1Node = this.parseAddSub();
                node = new LogNode(arg1Node);
                break;
              case "exp":
                arg1Node = this.parseAddSub();
                node = new ExpNode(arg1Node);
                break;
              case "abs":
                arg1Node = this.parseAddSub();
                node = new AbsNode(arg1Node);
                break;
              case "floor":
                arg1Node = this.parseAddSub();
                node = new FloorNode(arg1Node);
                break;
              case "ceil":
                arg1Node = this.parseAddSub();
                node = new CeilNode(arg1Node);
                break;
              case "round":
                arg1Node = this.parseAddSub();
                node = new RoundNode(arg1Node);
                break;
              case "if":
                arg1Node = this.parseRelation();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg2Node = this.parseAddSub();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg3Node = this.parseAddSub();
                node = new BooleanNode(arg1Node, arg2Node, arg3Node);
                break;
              case "and":
                conditionArgs.push(this.parseRelation());
                while (this.lexer.peek().type === "Comma") {
                  this.lexer.next();
                  conditionArgs.push(this.parseRelation());
                }
                node = new ConditionalNode(conditionArgs, "AND");
                break;
              case "or":
                conditionArgs.push(this.parseRelation());
                while (this.lexer.peek().type === "Comma") {
                  this.lexer.next();
                  conditionArgs.push(this.parseRelation());
                }
                node = new ConditionalNode(conditionArgs, "OR");
                break;
              default:
                throw { error: "Unknown function", position: token2.startPosition };
            }
            if (this.lexer.end || this.lexer.next().type !== "ParenEnd") {
              throw {
                error: "Missing closing parenthesis",
                position: this.lexer.position - 1
              };
            }
          } else {
            throw {
              error: "Missing starting parenthesis",
              position: token2.startPosition
            };
          }
        } else if (token2.type === "Number" || token2.type === "String") {
          node = new ConstantNode(token2.value);
        } else if (token2.type === "Variable") {
          node = this.variables.get(token2.value);
          if (node === void 0) {
            node = new VariableNode();
            this.variables.set(token2.value, node);
          }
        } else {
          throw { error: "Invalid token", position: token2.startPosition };
        }
        return node;
      }
    }
    class MathExpression {
      constructor(expressionString) {
        let parser = new MathParser(expressionString);
        this.root = parser.parse();
        this.variableMap = parser.variables;
      }
      // Returns the variable names used in the expression
      get variableNames() {
        let names = [];
        this.variableMap.forEach(function(variable, variableName) {
          names.push(variableName);
        });
        return names;
      }
      // Evaluates the expression using the given variable values and returns the result.
      evaluate(variableValues) {
        for (let [variable, node] of this.variableMap) {
          let value = variableValues.get(variable);
          if (value === void 0) {
            throw "Undefined variable: " + variable;
          }
          node.value = value;
        }
        return this.root.evaluate();
      }
    }
    const Plan = {
      defaults: () => ({
        sobjectType: "sfsp__SalesPlan__c",
        Name: "",
        sfsp__Type__c: "Quota",
        sfsp__ReferenceFields__c: "[]",
        _target: 0
      }),
      async import(rows) {
        const nodesByName = Object.values(SPM.Components.Root.nodeMap).reduce((map2, node) => {
          map2[node.Name] = node;
          return map2;
        }, {});
        const newNodesByName = rows.reduce((map2, row) => {
          if (!nodesByName[row.Territory])
            map2[row.Territory] = { ...SPM.Utils.Quota.Node.defaults(), Name: row.Territory, _parentName: row.Parent || "All" };
          return map2;
        }, {});
        if (Object.values(newNodesByName).some((newNode) => !nodesByName[newNode._parentName] && !newNodesByName[newNode._parentName]))
          throw "Invalid Parents";
        await SPM.Utils.CRM.upsert({ records: Object.values(newNodesByName) });
        const nodesToCalculate = /* @__PURE__ */ new Set();
        Object.values(newNodesByName).forEach((newNode) => {
          newNode.sfsp__SalesPlan__c = SPM.Components.Root.plan.Id;
          newNode.sfsp__Parent__c = (nodesByName[newNode._parentName] || newNodesByName[newNode._parentName]).Id.replace("all_org", "");
          newNode._parentId = newNode.sfsp__Parent__c || "all_org";
          SPM.Components.Root.nodeMap[newNode._parentId].sfsp__SalesNodes__r.push(newNode);
          SPM.Components.Root.nodeMap[newNode.Id] = newNode;
          nodesByName[newNode.Name] = SPM.Components.Root.nodeMap[newNode.Id];
          nodesToCalculate.add(nodesByName[newNode.Name]);
        });
        await SPM.Components.Root.loadUsers([...new Set(rows.map((r) => r.Owner))].filter((owner) => !!owner && owner !== "TBH"));
        const rollupsToCalculate = /* @__PURE__ */ new Set();
        await SPM.Utils.Async.forEach(rows, async (row) => {
          const node = nodesByName[row.Territory];
          const updatedColumns = SPM.Utils.Quota.Node.update(node, row);
          if (updatedColumns.length) {
            nodesToCalculate.add(node);
            updatedColumns.filter((c) => c.type === "Quota").forEach((c) => rollupsToCalculate.add(c));
          }
        });
        rollupsToCalculate.forEach(SPM.Utils.Quota.Column.calculateRollups);
        SPM.Components.Root.calculateNodes(rollupsToCalculate.size ? null : nodesToCalculate);
        await SPM.Utils.CRM.upsert({ records: nodesToCalculate });
      }
    };
    const Node$1 = {
      defaults: () => ({
        sobjectType: "sfsp__SalesNode__c",
        Name: "",
        sfsp__SalesNodes__r: [],
        _data: {}
      }),
      // getters
      getDescendants({ nodes }) {
        if (nodes.length === 0)
          return [];
        const childNodes = nodes.reduce((arr, n) => arr.concat(n.sfsp__SalesNodes__r || []), []);
        return [
          ...nodes,
          ...Node$1.getDescendants({ nodes: childNodes })
        ];
      },
      getLeafNodes({ nodes }) {
        const leafNodes = [];
        nodes.forEach((node) => leafNodes.push(...node.sfsp__SalesNodes__r.length ? Node$1.getLeafNodes({ nodes: node.sfsp__SalesNodes__r }) : [node]));
        return leafNodes;
      },
      // modifiers
      update(node, data = {}) {
        const updatedColumns = /* @__PURE__ */ new Set();
        Object.entries(data).forEach(([key, value]) => {
          const columnId = key.split(":")[0];
          const column = SPM.Components.Root.plan._columns.find((c) => c.id === columnId || c.id === key);
          if ((column == null ? void 0 : column.type) === "Numeric") {
            const newValue = parseFloat(value) || 0;
            if (node._data[key] !== newValue) {
              node._data[key] = newValue;
              updatedColumns.add(column);
            }
          }
          if ((column == null ? void 0 : column.type) === "Text") {
            if (node._data[key] !== value) {
              node._data[key] = value;
              updatedColumns.add(column);
            }
          }
          if ((column == null ? void 0 : column.type) === "Quota") {
            const quotaField = key.split(":")[1];
            if (["Target", "Quota"].includes(quotaField)) {
              const newValue = parseFloat(value) || 0;
              if (node._data[key] !== newValue) {
                node._data[key] = newValue;
                updatedColumns.add(column);
              }
            }
          }
          if (columnId === "Parent") {
            const currentParent = SPM.Components.Root.nodeMap[node._parentId];
            const newParent = Object.values(SPM.Components.Root.nodeMap).find((n) => n.Name === value) || SPM.Components.Root.nodeHierarchy;
            if (currentParent !== newParent) {
              Object.assign(node, {
                sfsp__Parent__c: newParent.Id.replace("all_org", ""),
                _parentId: newParent.Id
              });
              SPM.Utils.Arr.splice(currentParent.sfsp__SalesNodes__r, (n) => n.Id === node.Id);
              newParent.sfsp__SalesNodes__r.push(node);
              SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota").forEach((c) => updatedColumns.add(c));
            }
          }
          if (columnId === "Owner") {
            const currentOwner = node.sfsp__Owner__r;
            const newOwner = SPM.Components.Root.usersByName[data.Owner];
            if ((currentOwner == null ? void 0 : currentOwner.Name) !== (newOwner == null ? void 0 : newOwner.Name)) {
              Object.assign(node, {
                sfsp__Owner__c: newOwner == null ? void 0 : newOwner.Id,
                sfsp__Owner__r: newOwner
              });
              updatedColumns.add("Owner");
            }
          }
        });
        node.sfsp__HierarchyReferenceData__c = JSON.stringify(
          Object.entries(node._data).reduce((map2, [key, value]) => {
            const columnId = key.split(":")[0];
            const column = SPM.Components.Root.plan._columns.find((c) => c.id === columnId || c.id === key);
            if ((column == null ? void 0 : column.type) === "Numeric") {
              map2[key] = value;
            }
            if ((column == null ? void 0 : column.type) === "Text") {
              map2[key] = value;
            }
            if ((column == null ? void 0 : column.type) === "Quota") {
              const quotaField = key.split(":")[1] || key;
              if (["Target", "Quota"].includes(quotaField)) {
                map2[key] = value;
              }
            }
            return map2;
          }, {})
        );
        return [...updatedColumns];
      },
      // calculators
      calculateColumns(node, { plan = SPM.Components.Root.plan } = {}) {
        const columnsToCalculate = plan._columns.filter((c) => c.type === "Formula" || c.type === "Quota" && c.expression);
        let column;
        let waitingColumnCount = 0;
        while (column = columnsToCalculate.shift()) {
          if (waitingColumnCount > columnsToCalculate.length)
            throw `Unable to calculate columns, please make sure there are no circular references.  First invalid column: {${SPM.Utils.Str.sanitizeHTML(column.label)}}`;
          if (new MathExpression(column.expression).variableNames.some((v) => [...columnsToCalculate, column].find((c) => c.id === v))) {
            columnsToCalculate.push(column);
            waitingColumnCount++;
            continue;
          }
          waitingColumnCount = 0;
          Node$1.calculateColumn({ node, column });
        }
      },
      calculateColumn({ node, column }) {
        const expression = new MathExpression(column.expression);
        const variableValues = /* @__PURE__ */ new Map();
        expression.variableNames.forEach((variableName) => {
          variableValues.set(variableName, node._data[variableName] || 0);
        });
        if (column.type === "Quota") {
          const target = +expression.evaluate(variableValues).toFixed();
          const quota = node._data[`${column.id}:Quota`] || 0;
          node._data[`${column.id}:Target`] = target;
          node._data[`${column.id}:Remaining`] = target - quota;
          node._data[`${column.id}:Progress`] = target ? 100 * quota / target : 100;
        } else {
          node._data[column.id] = +expression.evaluate(variableValues).toFixed();
        }
      }
    };
    const Column = {
      defaults: () => ({
        targetLabel: "Baseline",
        type: "Numeric",
        expression: ""
      }),
      types: () => ({
        Quota: { label: "Quota", description: "Hierarchical targets for allocation", icon: "hierarchy" },
        Numeric: { label: "Numeric", description: "Historic data, target, etc.", icon: "topic2" },
        Formula: { label: "Formula", description: "Column * Overassign = New Target", icon: "formula" },
        Text: { label: "Text", description: "Notes, comments, etc.", icon: "text" }
      }),
      calculateRollups(column, { nodeHierarchy = SPM.Components.Root.nodeHierarchy } = {}) {
        const rollup = (nodes) => {
          nodes.forEach((node) => {
            if (node.sfsp__SalesNodes__r.length > 0) {
              node._data[`${column.id}:Quota`] = rollup(node.sfsp__SalesNodes__r);
            }
            const quota = node._data[`${column.id}:Quota`] || 0;
            const target = node._data[`${column.id}:Target`] || 0;
            node._data[`${column.id}:Remaining`] = target - quota;
            node._data[`${column.id}:Progress`] = target ? 100 * quota / target : 100;
          });
          return nodes.reduce((total, node) => total + (node._data[`${column.id}:Quota`] || 0), 0);
        };
        rollup(nodeHierarchy.sfsp__SalesNodes__r);
      }
    };
    const helperUtils = {
      isColumnNameInvalid(name, columns) {
        const invalidSuffixRegex = /:(Quota|Target|Remaining|Progress)$/;
        const matchingCol = columns.find((c) => c.id === name.split(":")[0]);
        return !!matchingCol && invalidSuffixRegex.test(name);
      }
    };
    const QuotaUtils = {
      Plan,
      Node: Node$1,
      Column,
      helperUtils
    };
    const ClickOutside = {
      mounted(el, binding) {
        setTimeout(() => {
          el.clickOutsideEvent = function(event) {
            if (!(el === event.target || el.contains(event.target))) {
              binding.value(event);
            }
          };
          document.addEventListener("click", el.clickOutsideEvent);
        });
      },
      unmounted(el) {
        document.removeEventListener("click", el.clickOutsideEvent);
      }
    };
    const fetch = (url) => new Promise((resolve2, reject) => {
      console.log(url);
      const request = new XMLHttpRequest();
      request.onload = () => {
        if (request.status >= 200 && request.status < 400) {
          resolve2(request.responseText);
        } else {
          reject(request);
        }
      };
      request.onerror = () => console.error("Could not load the SVG.");
      request.open("GET", url, true);
      request.send();
    });
    const Icon = {
      name: "Icon",
      props: {
        assistiveText: String,
        button: Boolean,
        category: {
          type: String,
          default: "standard",
          validator(category) {
            if (!["action", "custom", "doctype", "standard", "utility"].includes(category)) {
              console.error("Invalid category. Please see documentation for valid categories.");
              return false;
            }
            return true;
          }
        },
        iconClass: {
          type: [Array, String]
        },
        inheritFillFromParent: Boolean,
        name: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          default: "",
          validator(size2) {
            if (size2 && !["xx-small", "x-small", "small", "large"].includes(size2)) {
              console.error("Invalid size. Please see documentation for valid sizes.");
              return false;
            }
            return true;
          }
        },
        src: String,
        svg: {
          type: [Object, String],
          validator(value) {
            const isString2 = typeof value === "string";
            const isESModule = typeof value === "object" && value.__esModule === true;
            return isString2 || isESModule;
          }
        },
        title: {
          type: String,
          default: ""
        },
        variant: {
          type: String,
          default: "default",
          validator(variant) {
            if (variant && !["inverse", "success", "warning", "error", "default", "none"].includes(variant)) {
              console.error("Invalid variant. Please see documentation for valid variants.");
              return false;
            }
            return true;
          }
        }
      },
      render() {
        const classes = [];
        if (!this.$props.button) {
          classes.push("slds-icon_container");
          if (this.hasFQIcon) {
            classes.push(`slds-icon-${this.$props.category}-${this.$props.name.replace(/_/g, "-")}`);
          }
        }
        const svgVNode = this.buildSVGVNode();
        const children = [svgVNode];
        if (this.$props.assistiveText) {
          children.push(
            h(
              "span",
              {
                class: "slds-assistive-text"
              },
              [this.$props.assistiveText]
            )
          );
        }
        if (this.$props.button) {
          return [children];
        }
        return h(
          "div",
          {
            class: classes,
            title: this.$props.title
          },
          [children]
        );
      },
      data() {
        return {
          processing: false,
          inlineData: null
        };
      },
      computed: {
        hasFQIcon() {
          return this.$props.category && this.$props.name;
        },
        computedFill() {
          return this.$props.button || this.hasFQIcon && this.$props.category === "utility" ? "inherit" : this.$props.fill;
        }
      },
      watch: {
        $props: {
          handler() {
            this.process();
          },
          deep: true,
          immediate: true
        }
      },
      inject: ["$__getIconSettings"],
      methods: {
        validateSources() {
          let numSources = 0;
          if (this.$props.src)
            numSources++;
          if (this.$props.svg)
            numSources++;
          if (this.hasFQIcon)
            numSources++;
          if (numSources === 0 || numSources > 1) {
            throw new Error("You must provide exactly one icon source.");
          }
        },
        async process() {
          if (this.processing)
            return;
          this.validateSources();
          try {
            this.processing = true;
            if (this.$props.src) {
              this.inlineData = await fetch(this.$props.src);
            } else if (this.$props.svg) {
              this.inlineData = this.$props.svg;
            }
          } finally {
            this.processing = false;
          }
        },
        buildSVGVNode() {
          const iconClasses = this.getIconClasses();
          const baseAttrs = {
            "aria-hidden": true,
            focusable: false,
            "data-key": this.$props.name
          };
          if (this.inlineData) {
            const fragment = document.createRange().createContextualFragment(this.inlineData);
            const svg = Array.from(fragment.childNodes).find((child) => child.nodeName === "svg");
            svg.classList.add(...iconClasses);
            if (this.$props.inheritFillFromParent) {
              svg.querySelectorAll("g, path").forEach((el) => {
                el.style.fill = "inherit";
              });
            }
            const attrs = Object.values(svg.attributes).reduce((result, attr) => {
              result[attr.name] = attr.value;
              return result;
            }, baseAttrs);
            return h(
              "svg",
              {
                ...attrs,
                class: iconClasses,
                innerHTML: svg.innerHTML
              }
            );
          }
          return h(
            "svg",
            {
              ...baseAttrs,
              class: iconClasses
            },
            [
              h(
                "use",
                {
                  href: this.getAssetURL()
                }
              )
            ]
          );
        },
        getAssetURL() {
          const {
            iconPath,
            actionSpritePath,
            customSpritePath,
            doctypeSpritePath,
            standardSpritePath,
            utilitySpritePath
          } = this.$__getIconSettings();
          if (iconPath) {
            return `${iconPath}/${this.$props.category}-sprite/svg/symbols.svg#${this.$props.name}`;
          }
          switch (this.$props.category) {
            case "action":
              return `${actionSpritePath}/symbols.svg#${this.$props.name}`;
            case "custom":
              return `${customSpritePath}/symbols.svg#${this.$props.name}`;
            case "doctype":
              return `${doctypeSpritePath}/symbols.svg#${this.$props.name}`;
            case "standard":
              return `${standardSpritePath}/symbols.svg#${this.$props.name}`;
            case "utility":
              return `${utilitySpritePath}/symbols.svg#${this.$props.name}`;
            default:
              throw new Error("Invalid path");
          }
        },
        getIconClasses() {
          const iconClasses = [];
          if (this.$props.category === "utility" && this.$props.variant !== "none") {
            iconClasses.push(`slds-icon-text-${this.$props.variant}`);
          }
          if (Array.isArray(this.iconClass)) {
            this.iconClass.forEach((cssClass) => iconClasses.push(cssClass));
          } else if (this.iconClass) {
            iconClasses.push(this.iconClass);
          }
          if (!this.$props.button && this.hasFQIcon) {
            iconClasses.push("slds-icon");
            if (this.$props.size) {
              iconClasses.push(`slds-icon_${this.$props.size}`);
            }
          }
          return iconClasses;
        }
      }
    };
    const ButtonIcon = {
      name: "Button",
      components: { Icon },
      props: {
        assistiveText: {
          type: String,
          required: true
        },
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        iconClass: {
          type: [Array, String],
          default: () => []
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Icon size.
         */
        iconSize: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid iconSize prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        more: Boolean,
        /**
         * Contained variants can be displayed in three smaller sizes—small, x-small, xx-small—by adding a sizing class on the <button>.
         */
        size: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid button icon prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, container,
         * brand, border, border-filled, base-inverse, border-inverse.
         */
        variant: {
          type: String,
          default: "bare",
          validator: (value) => {
            const variants = [
              "bare",
              "container",
              "brand",
              "border",
              "border-filled",
              "bare-inverse",
              "inverse",
              "border-inverse"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Displays browser-based tooltip text when the mouse moves over the element.
         */
        title: {
          type: String,
          required: true
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = Array.isArray(this.$props.iconClass) ? this.$props.iconClass : [this.$props.iconClass];
          iconClass.push("slds-button__icon");
          const props = {
            assistiveText: this.$props.assistiveText,
            category: this.$props.iconCategory,
            name: this.$props.iconName,
            iconClass,
            variant: "none",
            button: true
          };
          if (this.$props.iconSize) {
            iconClass.push(`slds-button__icon_${this.$props.iconSize}`);
            props.size = this.$props.iconSize;
          }
          iconVNode = h(Icon, props);
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children = [_default || iconVNode];
        if (this.$props.more) {
          const moreIconVNode = h(
            Icon,
            {
              assistiveText: iconVNode ? null : this.$props.assistiveText,
              category: "utility",
              name: "down",
              iconClass: ["slds-button__icon", "slds-button__icon_x-small"],
              variant: "none",
              button: true
            }
          );
          children.push(moreIconVNode);
        }
        const classes = ["slds-button", "slds-button_icon"];
        if (this.$props.more) {
          if (this.$props.variant === "border-filled") {
            classes.push("slds-button_icon-more");
          } else {
            classes.push("slds-button_icon-container-more");
          }
        }
        classes.push(`slds-button_icon-${this.$props.variant}`);
        if (this.$props.size)
          classes.push(`slds-button_icon-${this.$props.size}`);
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        return h(
          "button",
          {
            class: classes,
            title: this.$props.title,
            disabled: this.$props.disabled
          },
          children
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    const callbackMap = /* @__PURE__ */ new Map();
    function bind(el, handler, instance) {
      const callback = function(e) {
        if (instance.$.isUnmounted) {
          document.removeEventListener("click", callback);
          return;
        }
        if (!el.contains(e.target) && el !== e.target) {
          handler(e);
        }
      };
      callbackMap.set(el, callback);
      setTimeout(() => document.addEventListener("click", callback), 0);
    }
    function unbind(el) {
      const callback = callbackMap.get(el);
      document.removeEventListener("click", callback);
      callbackMap.delete(el);
    }
    const clickOutside = {
      created(el, { arg: { active, handler }, instance }) {
        if (typeof handler !== "function") {
          throw new Error("v-click-outside: missing required handler argument.");
        }
        if (active === true) {
          bind(el, handler, instance);
        }
      },
      updated(el, { arg: { active, handler } }, vNode) {
        if (active && !callbackMap.has(el)) {
          bind(el, handler, vNode);
        } else if (!active && callbackMap.has(el)) {
          unbind(el);
        }
      },
      unmounted(el) {
        unbind(el);
      }
    };
    const containers = /* @__PURE__ */ new Map();
    const createContainer = (el, context) => {
      const container = document.createElement("div");
      container.className = "slds-scope";
      container.appendChild(el);
      document.body.appendChild(container);
      context.$emit("detached", container);
      return container;
    };
    const alignToAnchor = (el, vnode, {
      anchorRef,
      resizeToAnchor,
      resizeToFitContent,
      alignment
    }) => {
      el.style.position = "fixed";
      const anchorRect = anchorRef.getBoundingClientRect();
      el.style.top = `${anchorRect.top + anchorRef.offsetHeight}px`;
      if (alignment === "left" || resizeToAnchor) {
        el.style.right = "auto";
        el.style.left = `${anchorRect.left}px`;
      } else if (alignment === "right") {
        el.style.left = "auto";
        el.style.right = `${document.documentElement.clientWidth - anchorRect.right}px`;
      }
      const anchorOffsetWidth = anchorRef.offsetWidth;
      if (resizeToAnchor) {
        el.style.width = `${anchorOffsetWidth}px`;
      } else if (resizeToFitContent) {
        el.style.minWidth = `${anchorOffsetWidth}px`;
        el.style.width = "auto";
      }
    };
    const getScrollbarWidth = () => {
      const scrollDiv = document.createElement("div");
      scrollDiv.style.width = "100px";
      scrollDiv.style.height = "100px";
      scrollDiv.style.overflow = "scroll";
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      scrollDiv.remove();
      return scrollbarWidth;
    };
    const adjustForViewPortOverflow = (el, options) => {
      const dropdownRect = el.getBoundingClientRect();
      const documentClientHeight = document.documentElement.clientHeight;
      const documentClientWidth = document.documentElement.clientWidth;
      const windowDocumentVerticalDiff = documentClientHeight - window.innerHeight;
      let viewportHeight;
      if (windowDocumentVerticalDiff <= 0) {
        viewportHeight = documentClientHeight;
      } else {
        viewportHeight = window.innerHeight - getScrollbarWidth();
      }
      if (dropdownRect.x < 0) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "left"
              }
            }
          );
        } else {
          el.style.left = `${el.offsetLeft + Math.abs(dropdownRect.x)}px`;
        }
      } else if (dropdownRect.left + dropdownRect.width > documentClientWidth) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "right"
              }
            }
          );
        } else {
          const overflowXDiff = dropdownRect.left + dropdownRect.width - documentClientWidth - window.pageXOffset;
          el.style.left = `${dropdownRect.left - overflowXDiff}px`;
        }
      }
      let dropdownHeight = el.offsetHeight;
      let adjustedVerticalPosition;
      if (options.anchorRef && options.anchorTopOnVerticalOverflow) {
        const anchor = options.anchorRef.getBoundingClientRect();
        let anchorY = anchor.bottom;
        const boxShadow = window.getComputedStyle(el)["box-shadow"];
        if (boxShadow && boxShadow !== "none") {
          dropdownHeight += parseInt(/(?:\dpx ){2}(\d)/.exec(boxShadow)[1], 10);
        }
        if (anchorY + dropdownHeight > viewportHeight) {
          anchorY = anchor.top - dropdownHeight;
        }
        adjustedVerticalPosition = anchorY;
      } else if (dropdownRect.top + dropdownHeight > viewportHeight) {
        adjustedVerticalPosition = dropdownRect.top - (dropdownRect.top + dropdownHeight - viewportHeight);
      }
      if (adjustedVerticalPosition) {
        el.style.top = `${adjustedVerticalPosition}px`;
      }
    };
    const removeContainer = (el) => {
      let container = containers.get(el);
      if (!container)
        return;
      container.remove();
      container = null;
      containers.delete(el);
    };
    let scrollHandlerFn;
    const scrollHandler = (el, _scrollHandler, e) => {
      if (e && e.type === "scroll" && el && el.contains(e.target))
        return;
      if (typeof _scrollHandler === "function") {
        _scrollHandler(el, e);
      } else {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const detach = {
      created(el, binding, vnode) {
        if (binding.value.disabled)
          return;
        binding.instance.$nextTick(() => {
          const options = binding.value;
          const container = createContainer(el, binding.instance);
          vnode.container = container;
          containers.set(el, container);
          if (typeof options.customDisplayMethod === "function") {
            options.customDisplayMethod();
          }
          if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
            alignToAnchor(el, vnode, options);
          }
          if (options.viewPortOverflow) {
            binding.instance.$nextTick(() => {
              if (typeof options.onRender === "function") {
                options.onRender();
                binding.instance.$nextTick(adjustForViewPortOverflow.bind(this, el, options));
              } else {
                adjustForViewPortOverflow(el, options);
              }
            });
          }
          scrollHandlerFn = scrollHandler.bind(null, el, options.scrollHandler);
          window.addEventListener("scroll", scrollHandlerFn, true);
        });
      },
      updated(el, { value: options, instance }, vnode) {
        if (options.disabled)
          return;
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(el, vnode, options);
        }
        if (options.viewPortOverflow) {
          instance.$nextTick(() => {
            if (typeof options.onUpdate === "function") {
              options.onUpdate();
            }
            adjustForViewPortOverflow(el, options);
          });
        }
      },
      unmounted(el) {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$N = {
      name: "ActionMenu",
      components: { ButtonIcon },
      directives: {
        "click-outside": clickOutside,
        "detach-element": detach
      },
      props: {
        /**
         * Determines which side of the anchor the dropdown should align to
         */
        alignment: {
          type: String,
          default: "left",
          validator(alignment) {
            if (!["left", "right"].includes(alignment)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return false;
            }
            return true;
          }
        },
        // TODO - Setup a watcher on bindTo. If changed, remove existing event listener and register a new one.
        /**
         * Bind to an HTML Element. Should be focusable.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to custom coordinates.
         * An object in the following format:
         * `{
                x: 50,
                y: 50
            }`
         */
        bindToCoords: {
          type: Object,
          default: null,
          validator: (value) => value.x && value.y
        },
        /**
         * Bind to current mouse position.
         */
        bindToMousePosition: {
          type: Boolean,
          default: false
        },
        buttonIconSize: {
          type: String,
          default: ""
        },
        /**
         * Disables entire action menu.
         */
        disabled: Boolean,
        /**
         * The sync-supported visibility state prop.
         */
        doShowSync: Boolean,
        /**
         * Hide on mouse leave.
         */
        hideOnMouseout: Boolean,
        /**
         * Name of the icon category.
         */
        iconCategory: {
          type: String,
          default: "utility"
        },
        /**
         * Name of the icon.
         */
        iconName: {
          type: String,
          default: "down"
        },
        /**
         * Determines the size of the icon.
         */
        iconSize: {
          type: String,
          default: ""
        },
        /**
         * Title property for the button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Action menu variant. Shows menu items with link styling.
         */
        isActionMenu: {
          type: Boolean,
          default: true
        },
        /**
         * If defined, this will get called before toggling the action menu and be passed the following:
         * 1. JS click event
         * 2. Current visibility state of the action menu
         *
         * If the function returns a boolean value of true then the action menu will be toggled, otherwise, nothing will occur
         */
        onToggleRequest: {
          type: Function,
          default: null
        },
        /**
         * Adjust menu width to be equal to the anchor's width
         */
        resizeToAnchor: Boolean,
        /**
         * Label for button title and icon assistive text.
         */
        showMoreLabel: {
          type: String,
          default: "Show More"
        }
      },
      data() {
        return {
          doShow: this.doShowSync,
          isDirty: false,
          adjustedAlignment: null,
          container: null,
          focusedMenuItemIndex: null,
          focusableMenuItems: []
        };
      },
      computed: {
        doShowAnchor() {
          return !(this.bindTo || this.bindToMousePosition || this.bindToCoords);
        },
        clickOutsideOptions() {
          return {
            active: this.doShow,
            handler: this.doHide
          };
        },
        computedShowMoreIconTitle() {
          return this.$props.iconTitle || this.$props.showMoreLabel;
        },
        dropdownClasses() {
          const classes = ["slds-dropdown"];
          if (this.$props.isActionMenu)
            classes.push("slds-dropdown_actions");
          return classes;
        }
      },
      watch: {
        "$props.alignment": {
          handler(value) {
            if (!["left", "right"].includes(value)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return;
            }
            this.adjustedAlignment = value;
          },
          immediate: true
        },
        doShow(value) {
          this.$emit("update:doShowSync", value);
        },
        doShowSync(value) {
          if (value === this.doShow)
            return;
          this.toggleMenu();
        }
      },
      created() {
        if (this.bindTo)
          this.bindTo.addEventListener("click", this.toggleMenu);
      },
      beforeUnmount() {
        if (this.bindTo)
          this.bindTo.removeEventListener("click", this.toggleMenu);
        this.destroy();
      },
      methods: {
        toggleMenu(e) {
          if (this.disabled || e && this.onToggleRequest && !this.onToggleRequest(e, this.doShow) || e && this.$refs.menu && (this.$refs.menu === e.target || this.$refs.menu.contains(e.target)))
            return;
          this.doShow = !this.doShow;
          if (this.doShow && !this.isKeyboardCallback) {
            window.addEventListener("scroll", this.doHide, true);
            window.addEventListener("resize", this.doHide);
            this.$nextTick(this.showMenu.bind(this, e));
            this.$emit("bindToClick", e);
          } else {
            this.destroy();
          }
        },
        showMenu() {
          this.$nextTick(() => {
            this.getFocusableMenuItems();
            if (this.focusableMenuItems.length) {
              this.focusedMenuItemIndex = 0;
              this.setMenuItemFocus();
            }
          });
        },
        onDetachRender() {
          this.$emit("detached", this.$refs.menu);
        },
        adjustAlignment(position) {
          this.adjustedAlignment = position;
        },
        destroy() {
          this.focusableMenuItems = [];
          this.doShow = false;
          window.removeEventListener("scroll", this.doHide, true);
          window.removeEventListener("resize", this.doHide);
          if (this.container) {
            this.container.remove();
            this.container = null;
          }
          if (this.doShowAnchor)
            this.$refs.anchor.firstElementChild.focus();
          this.$emit("hide");
        },
        doHide() {
          this.destroy();
        },
        mouseover(e) {
          this.$emit("mouseover", e);
        },
        mouseout(e) {
          if (this.hideOnMouseout && e.type === "mouseout" && !this.$refs.menu.contains(e.toElement || e.relatedTarget)) {
            this.destroy();
            return;
          }
          this.$emit("mouseout", e);
        },
        getFocusableMenuItems() {
          this.focusableMenuItems = [];
          this.$refs.menu.querySelectorAll(".slds-dropdown__item").forEach((item) => {
            this.focusableMenuItems.push(item.querySelector("a"));
          });
        },
        down() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex < this.focusableMenuItems.length - 1) {
              this.focusedMenuItemIndex++;
            } else {
              this.focusedMenuItemIndex = 0;
            }
            this.setMenuItemFocus();
          }
        },
        up() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex > 0) {
              this.focusedMenuItemIndex--;
            } else {
              this.focusedMenuItemIndex = this.focusableMenuItems.length - 1;
            }
            this.setMenuItemFocus();
          }
        },
        setMenuItemFocus() {
          this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = 0;
          this.focusableMenuItems[this.focusedMenuItemIndex].focus();
        }
      }
    };
    const _hoisted_1$G = {
      key: 0,
      ref: "anchor"
    };
    const _hoisted_2$F = ["aria-label"];
    function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: "slds-dropdown-trigger slds-dropdown-trigger_click slds-is-open slds-show",
        onClick: _cache[6] || (_cache[6] = (...args) => $options.toggleMenu && $options.toggleMenu(...args)),
        onKeydown: [
          _cache[7] || (_cache[7] = withKeys((...args) => $options.toggleMenu && $options.toggleMenu(...args), ["enter"])),
          _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
          _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"]))
        ]
      }, [
        $options.doShowAnchor ? (openBlock(), createElementBlock("div", _hoisted_1$G, [
          renderSlot(_ctx.$slots, "button", {}, () => [
            createVNode(_component_ButtonIcon, {
              "aria-haspopup": "",
              variant: "border-filled",
              disabled: _ctx.$props.disabled,
              iconSize: _ctx.$props.iconSize,
              iconCategory: _ctx.$props.iconCategory,
              iconName: _ctx.$props.iconName,
              title: $options.computedShowMoreIconTitle,
              assistiveText: $props.showMoreLabel,
              "aria-expanded": $data.doShow,
              size: _ctx.$props.buttonIconSize
            }, null, 8, ["disabled", "iconSize", "iconCategory", "iconName", "title", "assistiveText", "aria-expanded", "size"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        $data.doShow ? withDirectives((openBlock(), createElementBlock("div", {
          key: 1,
          ref: "menu",
          class: normalizeClass([$options.dropdownClasses, "translateX"]),
          onMouseover: _cache[0] || (_cache[0] = (...args) => $options.mouseover && $options.mouseover(...args)),
          onMouseout: _cache[1] || (_cache[1] = (...args) => $options.mouseout && $options.mouseout(...args)),
          onKeydown: [
            _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["stop"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["stop"]), ["up"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"])),
            _cache[5] || (_cache[5] = withKeys((...args) => $options.destroy && $options.destroy(...args), ["tab"]))
          ]
        }, [
          createBaseVNode("ul", {
            class: "slds-dropdown__list",
            role: "menu",
            "aria-label": $props.showMoreLabel
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode("--- menu items go here ---")
            ], true)
          ], 8, _hoisted_2$F)
        ], 34)), [
          [_directive_click_outside, void 0, $options.clickOutsideOptions],
          [_directive_detach_element, {
            anchorRef: _ctx.$refs.anchor,
            viewPortOverflow: true,
            anchorTopOnVerticalOverflow: true,
            onRender: $options.onDetachRender,
            onOverflowAdjustment: $options.adjustAlignment,
            resizeToAnchor: _ctx.$props.resizeToAnchor,
            scrollHandler: $options.doHide,
            alignment: _ctx.$props.alignment
          }]
        ]) : createCommentVNode("", true)
      ], 32);
    }
    const ActionMenu = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$L], ["__scopeId", "data-v-413e8c13"]]);
    const decodeHtml = {
      methods: {
        decodeHtml(html) {
          const txt = document.createElement("textarea");
          txt.innerHTML = html;
          return txt.value;
        }
      }
    };
    const _sfc_main$M = {
      name: "ActionMenuItem",
      components: {
        Icon
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Label for the menu item.
         */
        label: {
          type: String,
          required: true
        },
        /**
         * Disable action menu item.
         */
        disabled: Boolean,
        /**
         * Determines if this item is a read-only header.
         */
        header: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Role for menu item. Selectable items need the role "menuitemcheckbox" or "menuitemradio"
         * Options: `menuitem` | `menuitemcheckbox` | `menuitemradio`
         */
        role: {
          type: String,
          default: "menuitem",
          validator: (value) => {
            const validRoles = [
              "menuitem",
              "menuitemcheckbox",
              "menuitemradio"
            ];
            const isValid2 = !value || validRoles.includes(value);
            if (!isValid2)
              console.error(`Valid role values are ${validRoles.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * If true we add aria-checked="true" to the anchor tag
         */
        selected: Boolean
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      methods: {
        onEnter(e) {
          this.$attrs.onClick(e);
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        },
        onClick() {
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        }
      }
    };
    const _hoisted_1$F = {
      key: 0,
      role: "presentation",
      class: "slds-dropdown__header slds-text-heading--label"
    };
    const _hoisted_2$E = { role: "presentation" };
    const _hoisted_3$A = ["aria-disabled"];
    const _hoisted_4$y = ["role", "aria-checked"];
    const _hoisted_5$v = ["title"];
    function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return _ctx.$props.header ? (openBlock(), createElementBlock("li", _hoisted_1$F, [
        createBaseVNode("div", _hoisted_2$E, toDisplayString(_ctx.$props.label), 1)
      ])) : (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        class: ["slds-dropdown__item", { "slds-is-selected": _ctx.$props.selected }],
        "aria-disabled": $props.disabled,
        role: "presentation"
      }, toHandlers(_ctx.$attrs, true), {
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.onClick && $options.onClick(...args), ["stop", "prevent"])),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.onEnter && $options.onEnter(...args), ["stop", "prevent"]), ["enter"]))
      }), [
        createBaseVNode("a", {
          role: $props.role,
          tabindex: "-1",
          "aria-checked": _ctx.$props.selected,
          class: normalizeClass({ "disabled": $props.disabled })
        }, [
          createBaseVNode("span", {
            title: $props.label,
            class: normalizeClass([{ "slds-text-color_inverse-weak": $props.disabled, "disabled": $props.disabled }, "slds-truncate"])
          }, [
            $options.hasFQIcon ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              category: _ctx.$props.iconCategory,
              name: _ctx.$props.iconName,
              size: "x-small",
              class: "slds-m-right_x-small"
            }, null, 8, ["category", "name"])) : createCommentVNode("", true),
            !_ctx.$parent.$props.isActionMenu ? (openBlock(), createBlock(_component_Icon, {
              key: 1,
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-m-right_x-small",
              iconClass: "slds-icon_selected"
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($props.label)), 1)
            ], true)
          ], 10, _hoisted_5$v)
        ], 10, _hoisted_4$y)
      ], 16, _hoisted_3$A));
    }
    const ActionMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$K], ["__scopeId", "data-v-ffe335c1"]]);
    const _sfc_main$L = {
      name: "Badge",
      props: {
        /**
         * Content to be placed inside the badge component.
         */
        content: {
          type: [String, Number],
          default: ""
        },
        /**
         * Icon alignment for the badge component.
         */
        iconAlignment: {
          type: String,
          default: "left"
        },
        /**
         * Color variant for the badge component
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "inverse",
              "lightest",
              "success",
              "warning",
              "error"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        iconOnly() {
          return this.$slots.icon && !this.content;
        },
        themeClasses() {
          const contrastClasses = ["inverse", "lightest"];
          const themeClasses = ["success", "warning", "error"];
          let themeClass = "";
          if (contrastClasses.includes(this.theme))
            themeClass = `slds-badge_${this.theme}`;
          if (themeClasses.includes(this.theme))
            themeClass = `slds-theme_${this.theme}`;
          return themeClass;
        },
        badgeIconClasses() {
          const classes = ["slds-badge__icon"];
          if (this.theme === "inverse")
            classes.push("slds-badge__icon_inverse");
          if (this.iconAlignment && !this.iconOnly)
            classes.push(`slds-badge__icon_${this.iconAlignment}`);
          return classes;
        }
      }
    };
    function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(["slds-badge", $options.themeClasses])
      }, [
        _ctx.$slots["icon"] && $props.iconAlignment === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2),
          createTextVNode(" " + toDisplayString($props.content), 1)
        ], 64)) : _ctx.$slots["icon"] && $props.iconAlignment === "right" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString($props.content) + " ", 1),
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString($props.content), 1)
        ], 64))
      ], 2);
    }
    const Badge = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$J]]);
    const SLDSButton = {
      name: "Button",
      components: { Icon },
      props: {
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon class(es)
         */
        iconClass: {
          type: [Array, String]
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Describes the position of the icon with respect to body. Options include left and right.
         * This value defaults to left.
         */
        iconPosition: {
          type: String,
          default: "left"
        },
        iconVariant: {
          type: String,
          default: "none"
        },
        /**
         * The text to be displayed inside the button.
         */
        label: {
          type: String,
          default: "Button"
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, neutral,
         * brand, outline-brand, destructive, text-destructive, inverse, and success. This value defaults to neutral.
         */
        variant: {
          type: String,
          default: "neutral",
          validator: (value) => {
            const variants = [
              "base",
              "neutral",
              "brand",
              "inverse",
              "destructive",
              "success",
              "outline-brand",
              "text-destructive"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = ["slds-button__icon"];
          if (this.$props.iconPosition) {
            iconClass.push(`slds-button__icon_${this.$props.iconPosition}`);
          }
          if (this.$props.iconClass) {
            if (Array.isArray(this.$props.iconClass)) {
              iconClass.push(...this.$props.iconClass);
            } else {
              iconClass.push(this.$props.iconClass);
            }
          }
          iconVNode = h(
            Icon,
            {
              button: true,
              category: this.$props.iconCategory,
              iconClass,
              name: this.$props.iconName,
              variant: this.$props.iconVariant
            }
          );
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children = [_default || this.$props.label];
        if (iconVNode) {
          if (this.$props.iconPosition === "right") {
            children.push(iconVNode);
          } else {
            children.unshift(iconVNode);
          }
        }
        const classes = ["slds-button"];
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        if (this.$props.variant !== "base") {
          classes.push(`slds-button_${this.variant}`);
        }
        return h(
          "button",
          {
            // on: this.$listeners,
            class: classes,
            disabled: this.$props.disabled
          },
          children
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name) {
        var style = state.styles[name] || {};
        var attributes = state.attributes[name] || {};
        var element = state.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name) {
          var element = state.elements[name];
          var attributes = state.attributes[name] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$1 = Math.max;
    var min$1 = Math.min;
    var round$1 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x,
        y
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$2(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$2(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$2(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$2(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$1(min2, min$1(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v = within(min2, value, max2);
      return v > max2 ? max2 : v;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x, y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(x * dpr) / dpr || 0,
        y: round$1(y * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
      }) : {
        x,
        y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x,
        y
      }, getWindow(popper2)) : {
        x,
        y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x + getWindowScrollBarX(element),
        y
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$2(body || html).direction === "rtl") {
        x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      if (state.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x;
        state.modifiersData.popperOffsets.y += y;
      }
      state.modifiersData[name] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name = _ref.name;
      state.modifiersData[name] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$1(rect.width) / element.offsetWidth || 1;
      var scaleY = round$1(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce$1(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS$1 = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    const alignmentPositions$1 = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const isAlignmentValid$1 = (alignment) => Object.keys(alignmentPositions$1).find((value) => value === alignment);
    const _sfc_main$K = {
      name: "Tooltip",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Alignment of the Tooltip relative to the element that triggers it.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid$1(alignment);
          }
        },
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: String,
          default: "Help"
        },
        /**
         * Title prop for button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for popover body.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Trigger element or function. If provided, the source slot will not be rendered.
         */
        source: {
          type: [HTMLElement, Function],
          default: null
        },
        /**
         * Content inside Tooltip.
         */
        text: {
          type: String,
          default: ""
        }
      },
      data() {
        return {
          localSource: null,
          isOpen: false,
          tooltipId: getGUID(),
          popperInstance: null
        };
      },
      computed: {
        computedText() {
          return this.$props.text.replaceAll(/(<br>|<br \/>)/gm, "\n").replaceAll("<br />", "\n").replaceAll("&lt;br /&gt;", "\n").replaceAll(/(\\r\\n|\\n|\\r)/gm, "\n");
        },
        computedIconTitle() {
          return this.$props.iconTitle || this.$props.assistiveText;
        }
      },
      watch: {
        "$props.source": {
          handler() {
            if (!this.$props.source)
              return;
            if (this.$slots.source) {
              throw new Error("Cannot set source prop and provide a default source");
            }
            this.processSource(this.$props.source);
          },
          immediate: true
        },
        alignment() {
          if (isAlignmentValid$1(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions$1[this.$props.alignment]
            });
          }
        }
      },
      mounted() {
        if (this.$props.source)
          return;
        let source;
        if (this.$slots.source) {
          source = this.$refs.source;
        } else {
          source = this.$refs.defaultSource.$el;
        }
        this.processSource(source);
      },
      beforeUnmount() {
        this.removeListeners();
      },
      methods: {
        async processSource(source) {
          this.removeListeners();
          this.localSource = typeof source === "function" ? await source() : source;
          this.localSource.setAttribute("aria-describedby", this.tooltipId);
          this.addListeners();
          if (this.popperInstance) {
            this.popperInstance.state.elements.reference = this.localSource;
          } else {
            this.$nextTick(this.setPopperInstance);
          }
        },
        setPopperInstance() {
          this.popperInstance = createPopper(this.localSource, this.$refs.tooltip, {
            strategy: this.$props.position,
            placement: alignmentPositions$1[this.$props.alignment],
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: ({ placement }) => {
                    if (placement.includes("end")) {
                      return [16, 14];
                    }
                    if (placement.includes("start")) {
                      return [-16, 14];
                    }
                    return [0, 14];
                  }
                }
              },
              {
                name: "preventOverflow",
                options: {
                  padding: this.$props.overflowPadding
                }
              }
            ]
          });
          this.$nextTick(() => {
            if (document.activeElement === this.localSource)
              this.enter();
          });
        },
        addListeners() {
          const showEvents = ["mouseenter", "focus"];
          const hideEvents = ["mouseleave", "blur"];
          showEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.enter);
          });
          hideEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.leave);
          });
        },
        removeListeners() {
          if (!this.localSource)
            return;
          this.localSource.removeEventListener("focus", this.enter);
          this.localSource.removeEventListener("mouseenter", this.enter);
          this.localSource.removeEventListener("blur", this.leave);
          this.localSource.removeEventListener("mouseleave", this.leave);
        },
        enter() {
          this.isOpen = true;
          this.popperInstance.update();
        },
        leave() {
          if (document.activeElement === this.localSource)
            return;
          this.isOpen = false;
        }
      }
    };
    const _withScopeId$d = (n) => (pushScopeId("data-v-0233e977"), n = n(), popScopeId(), n);
    const _hoisted_1$E = {
      key: 0,
      ref: "source"
    };
    const _hoisted_2$D = ["id"];
    const _hoisted_3$z = { class: "slds-popover__body" };
    const _hoisted_4$x = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        !_ctx.$props.source ? (openBlock(), createElementBlock("span", _hoisted_1$E, [
          renderSlot(_ctx.$slots, "source", {}, () => [
            createVNode(_component_ButtonIcon, {
              ref: "defaultSource",
              "aria-describedby": $data.tooltipId,
              "aria-disabled": "true",
              iconCategory: "utility",
              iconName: "info",
              iconSize: "xx-small",
              assistiveText: _ctx.$props.assistiveText,
              title: $options.computedIconTitle
            }, null, 8, ["aria-describedby", "assistiveText", "title"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", {
          id: $data.tooltipId,
          ref: "tooltip",
          class: "slds-popover slds-popover_tooltip",
          role: "tooltip"
        }, [
          createBaseVNode("div", _hoisted_3$z, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedText)), 1)
            ], true)
          ]),
          _hoisted_4$x
        ], 8, _hoisted_2$D), [
          [vShow, $data.isOpen]
        ])
      ]);
    }
    const Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$I], ["__scopeId", "data-v-0233e977"]]);
    const defaultLabels$5 = () => ({
      name: "Default Label",
      stateOn: "Enabled",
      stateOff: "Disabled",
      required: "required"
    });
    const _sfc_main$J = {
      name: "Checkbox",
      components: {
        Icon,
        Tooltip
      },
      mixins: [decodeHtml],
      props: {
        /**
         * The aria-labelledby attribute establishes relationships between objects and their label(s), and its value should be one or more element IDs, which refer to elements that have the text needed for labeling. List multiple element IDs in a space delimited fashion.
         */
        ariaLabeledBy: {
          type: String,
          default: ""
        },
        /**
         * Disables the Checkbox and prevents clicking it.
         */
        disabled: Boolean,
        /**
         * An array of errors used for checkbox validation.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Content for Tooltip component that is displayed next to the label. Only for use with form element variant.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Adds assistive text class to visually hide checkbox label.
         */
        hideLabel: Boolean,
        /**
         * Adds a tertiary state to no-slide checkboxes.
         */
        indeterminate: Boolean,
        /**
         * Shows label as a block element.
         */
        isFormElement: Boolean,
        /**
         * Labels object for the checkbox
         */
        labels: {
          type: Object,
          default: () => {
          },
          validator: (value) => {
            if (!value || !value.name) {
              console.error('You must provide a "name" label, because it is the minimum requirement for accessibility. If you do not want to render the label than set hideLabel to true and the "name" label will be used as assistive text.');
              return false;
            }
            return true;
          }
        },
        /**
         * v-model binding.
         */
        modelValue: Boolean,
        /**
         * Displays the value of the input, but does not allow changes.
         */
        readonly: Boolean,
        /**
         * Highlights the Checkbox as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * Shows state labels for toggle variant.
         */
        showStateLabels: Boolean,
        /**
         * Checkbox Toggle variant.
         */
        slide: Boolean,
        // TODO - Change to 'toggle' in next major release to align with SLDS terminology
        toggleBuffer: {
          type: Number,
          default: 0
        }
      },
      data() {
        return {
          checkboxId: getGUID(),
          errorId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().checkbox || {} : {};
          return {
            ...defaultLabels$5(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length && !this.$props.slide;
        },
        checkboxClass() {
          return !this.slide ? "slds-form-element__control" : "slds-checkbox_toggle slds-grid";
        }
      },
      watch: {
        modelValue(checked) {
          if (this.$refs.checkbox) {
            this.$refs.checkbox.checked = checked;
          }
          if (checked) {
            this.$emit("update:indeterminate", false);
          }
        },
        indeterminate: {
          handler(state) {
            if (!this.$props.slide) {
              this.$nextTick(() => {
                this.$refs.checkbox.indeterminate = state;
                if (state) {
                  this.$emit("update:modelValue", false);
                }
              });
            }
          },
          immediate: true
        }
      },
      mounted() {
        if (this.$refs.checkbox) {
          this.$refs.checkbox.checked = this.$props.modelValue;
        }
      },
      methods: {
        onClick(e) {
          if (!e.clientX && !e.clientY)
            return;
          if (e.currentTarget.checked && this.toggleBuffer) {
            this.$refs.checkbox.disabled = true;
            setTimeout(() => {
              this.$refs.checkbox.disabled = false;
            }, this.toggleBuffer);
          }
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.checked);
        }
      }
    };
    const _withScopeId$c = (n) => (pushScopeId("data-v-6891711e"), n = n(), popScopeId(), n);
    const _hoisted_1$D = ["title"];
    const _hoisted_2$C = ["checked", "disabled", "aria-describedby"];
    const _hoisted_3$y = ["id"];
    const _hoisted_4$w = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_5$u = {
      key: 0,
      class: "slds-checkbox_on"
    };
    const _hoisted_6$l = {
      key: 1,
      class: "slds-checkbox_off"
    };
    const _hoisted_7$i = ["for"];
    const _hoisted_8$f = ["title"];
    const _hoisted_9$f = { class: "slds-form-element__control" };
    const _hoisted_10$b = {
      key: 0,
      class: "slds-checkbox slds-checkbox_standalone"
    };
    const _hoisted_11$8 = ["id", "aria-describedby", "checked", "disabled"];
    const _hoisted_12$8 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_13$6 = {
      key: 2,
      class: "slds-form-element__control"
    };
    const _hoisted_14$5 = {
      key: 0,
      class: "slds-checkbox"
    };
    const _hoisted_15$6 = ["title"];
    const _hoisted_16$6 = ["id", "checked", "disabled", "aria-describedby", "aria-labelledby"];
    const _hoisted_17$5 = ["id", "for"];
    const _hoisted_18$5 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_19$5 = { class: "slds-form-element__label slds-m-left_x-small" };
    const _hoisted_20$5 = ["id"];
    function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $props.slide ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass($options.checkboxClass)
        }, [
          !$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_1$D)) : createCommentVNode("", true),
            createBaseVNode("span", {
              class: normalizeClass(["slds-form-element__label slds-m-bottom_none", { "slds-assistive-text": _ctx.$props.hideLabel }])
            }, [
              createBaseVNode("span", null, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
            ], 2),
            createBaseVNode("input", mergeProps({
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": $data.labelId,
              type: "checkbox",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_2$C),
            createBaseVNode("span", {
              id: $data.labelId,
              class: "slds-checkbox_faux_container",
              "aria-live": "assertive"
            }, [
              _hoisted_4$w,
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_5$u, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOn)), 1)) : createCommentVNode("", true),
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_6$l, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOff)), 1)) : createCommentVNode("", true)
            ], 8, _hoisted_3$y)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ])
          ], 64))
        ], 2)) : $props.isFormElement ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("label", {
            class: "slds-form-element__label",
            for: $data.checkboxId
          }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_8$f)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 8, _hoisted_7$i),
          _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
            key: 0,
            class: "slds-form-element__icon",
            alignment: "top right",
            text: _ctx.$props.helpText
          }, null, 8, ["text"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_9$f, [
            !$props.readonly ? (openBlock(), createElementBlock("span", _hoisted_10$b, [
              createBaseVNode("input", mergeProps({
                id: $data.checkboxId,
                ref: "checkbox",
                "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                checked: _ctx.$props.modelValue || false,
                disabled: $props.disabled,
                type: "checkbox",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                onInput: _cache[3] || (_cache[3] = (...args) => $options.onInput && $options.onInput(...args))
              }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_11$8),
              _hoisted_12$8
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "check",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, _ctx.$props.modelValue]
              ]),
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "steps",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, !_ctx.$props.modelValue]
              ])
            ], 64))
          ])
        ], 64)) : (openBlock(), createElementBlock("div", _hoisted_13$6, [
          !$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_14$5, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_15$6)) : createCommentVNode("", true),
            createBaseVNode("input", mergeProps({
              id: $data.checkboxId,
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
              "aria-labelledby": `${$data.labelId} ${_ctx.$props.ariaLabeledBy}`,
              type: "checkbox",
              onClick: _cache[4] || (_cache[4] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[5] || (_cache[5] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_16$6),
            createBaseVNode("label", {
              id: $data.labelId,
              for: $data.checkboxId,
              class: "slds-checkbox__label"
            }, [
              _hoisted_18$5,
              createBaseVNode("span", {
                class: normalizeClass(["slds-form-element__label", { "slds-assistive-text": _ctx.$props.hideLabel }])
              }, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 3)
            ], 8, _hoisted_17$5)
          ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ]),
            createBaseVNode("span", _hoisted_19$5, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 64))
        ])),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 3,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_20$5)) : createCommentVNode("", true)
      ], 2);
    }
    const Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$H], ["__scopeId", "data-v-6891711e"]]);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$1;
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h2;
      let s;
      if (max2 === min2) {
        h2 = 0;
      } else if (r === max2) {
        h2 = (g - b) / delta;
      } else if (g === max2) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max2) {
        h2 = 4 + (r - g) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max2 + min2);
      } else {
        s = delta / (2 - max2 - min2);
      }
      return [h2, s * 100, l * 100];
    };
    convert$1.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff2 = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff2 / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h2 = bdif - gdif;
        } else if (g === v) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h2 = convert$1.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h2, w * 100, b * 100];
    };
    convert$1.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert$1.rgb.lab = function(rgb) {
      const xyz = convert$1.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h2 + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h2, sv * 100, v * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p2 = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p2];
        case 1:
          return [q, v, p2];
        case 2:
          return [p2, v, t];
        case 3:
          return [p2, q, v];
        case 4:
          return [t, p2, v];
        case 5:
          return [v, p2, q];
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h2, sl * 100, l * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h2);
      const v = 1 - bl;
      f = 6 * h2 - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert$1.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h2];
    };
    convert$1.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert$1.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert$1.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i = 0; i < len; i++) {
        graph[models2[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from2, to2) {
      return function(args) {
        return to2(from2(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i = 0; i < len; i++) {
        const toModel = models2[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    const ConditionalWrapper = {
      name: "ConditionalWrapper",
      functional: true,
      inheritAttrs: false,
      props: {
        element: {
          type: String,
          required: true
        },
        active: Boolean
      },
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        if (this.$props.active) {
          return h(
            this.$props.element,
            {
              ...this.$attrs
            },
            _default
          );
        }
        return _default;
      }
    };
    function debounce(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce.debounce = debounce;
    var debounce_1 = debounce;
    const _debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
    var vClickOutside_umd = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal, function() {
        var e = "__v-click-outside", n = "undefined" != typeof window, t = "undefined" != typeof navigator, r = n && ("ontouchstart" in window || t && navigator.msMaxTouchPoints > 0) ? ["touchstart"] : ["click"], i = function(e2) {
          var n2 = e2.event, t2 = e2.handler;
          (0, e2.middleware)(n2) && t2(n2);
        }, a = function(n2, t2) {
          var a2 = function(e2) {
            var n3 = "function" == typeof e2;
            if (!n3 && "object" != typeof e2)
              throw new Error("v-click-outside: Binding value must be a function or an object");
            return { handler: n3 ? e2 : e2.handler, middleware: e2.middleware || function(e3) {
              return e3;
            }, events: e2.events || r, isActive: !(false === e2.isActive), detectIframe: !(false === e2.detectIframe), capture: Boolean(e2.capture) };
          }(t2.value), o2 = a2.handler, d2 = a2.middleware, c = a2.detectIframe, u = a2.capture;
          if (a2.isActive) {
            if (n2[e] = a2.events.map(function(e2) {
              return { event: e2, srcTarget: document.documentElement, handler: function(e3) {
                return function(e4) {
                  var n3 = e4.el, t3 = e4.event, r2 = e4.handler, a3 = e4.middleware, o3 = t3.path || t3.composedPath && t3.composedPath();
                  (o3 ? o3.indexOf(n3) < 0 : !n3.contains(t3.target)) && i({ event: t3, handler: r2, middleware: a3 });
                }({ el: n2, event: e3, handler: o2, middleware: d2 });
              }, capture: u };
            }), c) {
              var l = { event: "blur", srcTarget: window, handler: function(e2) {
                return function(e3) {
                  var n3 = e3.el, t3 = e3.event, r2 = e3.handler, a3 = e3.middleware;
                  setTimeout(function() {
                    var e4 = document.activeElement;
                    e4 && "IFRAME" === e4.tagName && !n3.contains(e4) && i({ event: t3, handler: r2, middleware: a3 });
                  }, 0);
                }({ el: n2, event: e2, handler: o2, middleware: d2 });
              }, capture: u };
              n2[e] = [].concat(n2[e], [l]);
            }
            n2[e].forEach(function(t3) {
              var r2 = t3.event, i2 = t3.srcTarget, a3 = t3.handler;
              return setTimeout(function() {
                n2[e] && i2.addEventListener(r2, a3, u);
              }, 0);
            });
          }
        }, o = function(n2) {
          (n2[e] || []).forEach(function(e2) {
            return e2.srcTarget.removeEventListener(e2.event, e2.handler, e2.capture);
          }), delete n2[e];
        }, d = n ? { beforeMount: a, updated: function(e2, n2) {
          var t2 = n2.value, r2 = n2.oldValue;
          JSON.stringify(t2) !== JSON.stringify(r2) && (o(e2), a(e2, { value: t2 }));
        }, unmounted: o } : {};
        return { install: function(e2) {
          e2.directive("click-outside", d);
        }, directive: d };
      });
    })(vClickOutside_umd);
    var vClickOutside_umdExports = vClickOutside_umd.exports;
    const vClickOutside = /* @__PURE__ */ getDefaultExportFromCjs(vClickOutside_umdExports);
    function groupBuilder() {
      const groups = {
        0: {
          options: [],
          filtered: []
        }
      };
      let numAsyncGroups = 0;
      let hasStaticOptions = false;
      let groupIndex = 1;
      const optionsLength = this.options.length;
      for (let i = 0; i < optionsLength; i++) {
        const option = this.options[i];
        const isGroup = option.options;
        if (isGroup) {
          const isTitledGroup = option.title;
          if (Array.isArray(option.options)) {
            const { title, options } = option;
            if (isTitledGroup) {
              groups[groupIndex++] = {
                title,
                options,
                // static data
                filtered: [],
                static: true
              };
            } else {
              groups[0].options = groups[0].options.concat(options);
            }
            hasStaticOptions = true;
          } else if (typeof option.options === "function") {
            const groupId = isTitledGroup ? groupIndex++ : 0;
            const optionsFunction = (term) => this.invokeOptionsFunction(option.options, groupId, term);
            const debounce2 = _debounce(optionsFunction, this.asyncDelay, option.lazy);
            const asyncOptions = {
              searchIndex: 0,
              cached: false,
              options: [],
              doCancelAsync: false,
              loading: false,
              async: true,
              lazy: option.lazy,
              optionsFunction,
              debounce: debounce2
            };
            if (isTitledGroup) {
              groups[groupId] = {
                title: option.title,
                filtered: [],
                ...asyncOptions
              };
            } else {
              groups[0] = {
                ...groups[0],
                ...asyncOptions
              };
            }
            numAsyncGroups++;
          }
        } else {
          groups[0].static = true;
          hasStaticOptions = true;
          if (typeof option === "object") {
            groups[0].options.push({ $__guid: getGUID(), ...option });
          } else if (["string", "number", "symbol"].includes(typeof option)) {
            const title = typeof option === "symbol" ? option.description : option.toString();
            groups[0].options.push({
              $__guid: getGUID(),
              [this.idKey]: option,
              [this.titleKey]: title
            });
          }
        }
      }
      return { groups, numAsyncGroups, hasStaticOptions };
    }
    const _sfc_main$I = {
      name: "Spinner",
      props: {
        /**
         * This centers the spinner indicator within the viewport. This is used for when the spinner's container overflows the viewport and the indicator may be hidden.
         */
        adjustForOverflow: Boolean,
        /**
         * Adds delay of 300ms to the spinner.
         */
        delayed: Boolean,
        /**
         * Sets the spinner container position attribute to `fixed`.
         */
        fixed: Boolean,
        /**
         * Starts animation immediately.
         */
        immediate: Boolean,
        /**
         * Add styling to support an inline spinner inside of the document flow.
         */
        inline: Boolean,
        /**
         * Assistive text label for the spinner.
         */
        loadingLabel: {
          type: String,
          default: "Loading"
        },
        /**
         * Determines the size of the spinner.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = ["xx-small", "x-small", "small", "medium", "large"];
            const isValid2 = validSizes.includes(value);
            if (!isValid2)
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Determines the color of the spinner: `base` is gray, `brand` is blue, and `inverse` is white.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = ["base", "brand", "inverse"];
            const isValid2 = validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Render the spinner without a container.
         */
        withoutContainer: Boolean
      },
      data() {
        return {
          observer: null
        };
      },
      computed: {
        spinnerClasses() {
          const classes = [];
          if (this.$props.immediate)
            classes.push("spm-spinner_immediate");
          if (this.$props.theme)
            classes.push(`slds-spinner_${this.$props.theme}`);
          if (this.$props.delayed)
            classes.push("slds-spinner_delayed");
          if (this.$props.size)
            classes.push(`slds-spinner_${this.$props.size}`);
          if (this.$props.inline)
            classes.push("slds-spinner_inline");
          return classes;
        },
        containerClasses() {
          const classes = [];
          if (!this.$props.withoutContainer || this.$slots.description)
            classes.push("slds-spinner_container");
          if (this.$props.fixed)
            classes.push("slds-is-fixed");
          return classes;
        }
      },
      created() {
        if (this.$props.adjustForOverflow) {
          window.addEventListener("scroll", this.updateContainerSize);
        }
      },
      mounted() {
        if (this.$props.adjustForOverflow) {
          this.updateContainerSize();
          this.observer = new MutationObserver(this.updateContainerSize);
          this.observer.observe(this.$refs.container, { attributes: true });
        }
      },
      beforeUnmount() {
        if (this.$props.adjustForOverflow) {
          window.removeEventListener("scroll", this.updateContainerSize);
          this.observer.disconnect();
          this.observer = null;
        }
      },
      methods: {
        updateContainerSize() {
          const spinnerContainer = this.$refs.container;
          const { parentNode } = spinnerContainer.parentNode;
          const parentRect = parentNode.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          if (parentRect.height < windowHeight)
            return;
          if (parentRect.top < 0) {
            spinnerContainer.style.top = `${Math.abs(parentRect.top)}px`;
          } else {
            spinnerContainer.style.top = 0;
          }
          if (parentRect.bottom > windowHeight) {
            spinnerContainer.style.bottom = `${parentRect.bottom - windowHeight}px`;
          } else {
            spinnerContainer.style.bottom = 0;
          }
        }
      }
    };
    const _withScopeId$b = (n) => (pushScopeId("data-v-21b087de"), n = n(), popScopeId(), n);
    const _hoisted_1$C = { class: "slds-assistive-text" };
    const _hoisted_2$B = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-a" }, null, -1));
    const _hoisted_3$x = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-b" }, null, -1));
    const _hoisted_4$v = {
      key: 0,
      class: "description"
    };
    const _hoisted_5$t = {
      "aria-live": "assertive",
      class: "slds-grid slds-grid_vertical slds-p-top_xx-large slds-text-align_center"
    };
    function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass($options.containerClasses)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([$options.spinnerClasses, "slds-spinner"]),
          "aria-hidden": "false",
          role: "status"
        }, [
          createBaseVNode("span", _hoisted_1$C, toDisplayString(_ctx.$props.loadingLabel), 1),
          _hoisted_2$B,
          _hoisted_3$x
        ], 2),
        _ctx.$slots["description"] ? (openBlock(), createElementBlock("div", _hoisted_4$v, [
          createBaseVNode("div", _hoisted_5$t, [
            renderSlot(_ctx.$slots, "description", {}, void 0, true)
          ])
        ])) : createCommentVNode("", true)
      ], 2);
    }
    const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$G], ["__scopeId", "data-v-21b087de"]]);
    const {
      parseInt: parseInt$1,
      getComputedStyle: getComputedStyle$1
    } = window;
    const _sfc_main$H = {
      name: "PicklistDropdown",
      components: {
        Icon,
        Spinner
      },
      mixins: [decodeHtml],
      data() {
        return {
          focusedOption: null,
          paddingBuffer: 0,
          currentOptionsLength: this.getDefaultOptionsLength()
        };
      },
      computed: {
        focusedOptionId() {
          let result = null;
          if (this.focusedOption) {
            result = this.focusedOption.dataset.id;
            if (this.focusedOption.dataset.type === "number") {
              result = parseInt$1(result);
            }
            if (this.focusedOption.dataset.type === "symbol") {
              result = Symbol.for(result);
            }
          }
          return result;
        },
        computedOptionGroups() {
          const result = {};
          let remaining = this.currentOptionsLength;
          Object.entries(this.$parent.groupData.groups).forEach(([key, group]) => {
            if (group.async || group.filtered.length) {
              if (remaining === 0)
                return;
              let renderLength;
              if (group.filtered.length >= remaining) {
                renderLength = remaining;
                remaining = 0;
              } else {
                renderLength = group.filtered.length;
                remaining -= group.filtered.length;
              }
              result[key] = {
                renderLength,
                ...group
              };
            }
          });
          return result;
        },
        doRenderGlobalNoSearchResults() {
          return this.$parent.groupData.hasStaticOptions && !Object.values(this.$parent.groupData.groups).some((group) => group.async || group.filtered.length);
        }
      },
      watch: {
        focusedOption() {
          this.$parent.focusedOptionId = this.focusedOptionId;
        },
        "$parent.groupData.groups": {
          handler() {
            if (this.$parent.computedDoRenderDropdown) {
              this.currentOptionsLength = this.getDefaultOptionsLength();
              this.$nextTick(this.setDropdownHeight);
            }
          },
          deep: true,
          immediate: true
        },
        "$parent.comboboxInputOption": {
          handler(value) {
            this.$nextTick(() => {
              this.focusedOption = value ? this.$refs.comboboxInputOption : this.getFirstAvailableOptionEl();
              this.$el.scrollTop = 0;
            });
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.paddingBuffer = parseInt$1(getComputedStyle$1(this.$el).paddingTop || 0);
        });
      },
      methods: {
        getDefaultOptionsLength() {
          if (this.$parent.$props.pageSize <= 0) {
            return Infinity;
          }
          return Math.max(this.$parent.$props.pageSize, this.$parent.$props.heightInNumOptions + 1);
        },
        getListRole(groupId) {
          return !groupId ? "presentation" : "group";
        },
        setDropdownHeight() {
          var _a, _b, _c;
          const dropdown = this.$el;
          let dropdownHeight = 0;
          let numResultNodes = 0;
          let numTitleNodes = 0;
          const options = Array.from(this.$el.querySelectorAll("li.slds-listbox__item"));
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            dropdownHeight += option.clientHeight;
            if (Object.prototype.hasOwnProperty.call(option.dataset, "header")) {
              numTitleNodes++;
            } else {
              numResultNodes++;
            }
            if (numResultNodes === this.$parent.$props.heightInNumOptions)
              break;
          }
          if (options.length <= numResultNodes + numTitleNodes) {
            dropdown.style.height = "auto";
          } else {
            const { borderTopWidth, paddingTop } = getComputedStyle$1(dropdown);
            const dropdownHeightAdjustment = (parseInt$1(borderTopWidth, 10) + parseInt$1(paddingTop, 10)) * 2;
            let dropdownHeaderHeightAdjustment = (_a = this.$refs.dropdownHeader) == null ? void 0 : _a.clientHeight;
            if (dropdownHeaderHeightAdjustment) {
              const { marginTop, marginBottom } = getComputedStyle$1((_c = (_b = this.$refs.dropdownHeader) == null ? void 0 : _b.children) == null ? void 0 : _c[0]);
              dropdownHeaderHeightAdjustment += parseInt$1(marginTop, 10);
              dropdownHeaderHeightAdjustment += parseInt$1(marginBottom, 10);
            }
            dropdown.style.height = `${dropdownHeight + dropdownHeightAdjustment + dropdownHeaderHeightAdjustment}px`;
          }
          this.focusOption();
        },
        focusOption() {
          if (Array.isArray(this.$parent.modelValue)) {
            if (this.$parent.modelValue.length) {
              const [firstId] = this.$parent.modelValue;
              this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(firstId)}"][data-type="${typeof firstId}"]`) || this.getFirstAvailableOptionEl();
              this.scrollToFocusedOption();
            } else {
              this.focusedOption = this.getFirstAvailableOptionEl();
            }
          } else if (this.$parent.modelValue !== null && this.$parent.modelValue !== "" && this.$parent.comboboxInputOption === null) {
            this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(this.$parent.modelValue)}"][data-type="${typeof this.$parent.modelValue}"]`) || this.getFirstAvailableOptionEl();
            this.scrollToFocusedOption();
          } else {
            this.focusedOption = this.getFirstAvailableOptionEl();
          }
        },
        getFirstAvailableOptionEl() {
          return this.$el.querySelector("li[data-option]");
        },
        scrollToFocusedOption() {
          const focusedOptionAbsoluteOffsetTop = this.focusedOption.offsetTop + this.paddingBuffer;
          const dropdownHeight = this.$el.clientHeight;
          if (focusedOptionAbsoluteOffsetTop >= this.$el.scrollTop + dropdownHeight - this.paddingBuffer) {
            this.$el.scrollTop = focusedOptionAbsoluteOffsetTop + this.focusedOption.clientHeight - dropdownHeight;
          }
        },
        enter(e) {
          if (this.focusedOption === this.$refs.comboboxInputOption) {
            this.$parent.select(this.$parent.comboboxInputOption, e);
          } else {
            const option = this.$parent.getOptionById(this.focusedOptionId);
            this.$parent.select(option, e);
          }
        },
        down() {
          if (!this.focusedOption)
            return;
          const {
            nextElementSibling,
            parentElement: {
              nextElementSibling: parentsNextElementSibling
            }
          } = this.focusedOption;
          if (nextElementSibling) {
            this.focusedOption = nextElementSibling;
          } else if (parentsNextElementSibling) {
            const getNextDataOption = function getNextDataOption2(_parentsNextElementSibling) {
              if (_parentsNextElementSibling === null)
                return null;
              return _parentsNextElementSibling.querySelector("li[data-option]") || getNextDataOption2(parentsNextElementSibling.nextElementSibling);
            };
            const li = getNextDataOption(parentsNextElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption) {
            this.scrollToFocusedOption();
          }
          this.onScroll();
        },
        up() {
          if (!this.focusedOption)
            return;
          const {
            previousElementSibling,
            parentElement: {
              previousElementSibling: parentsPreviousElementSibling
            }
          } = this.focusedOption;
          const hasPreviousDataOptionSibling = previousElementSibling && Object.hasOwnProperty.call(previousElementSibling.dataset, "option");
          if (hasPreviousDataOptionSibling) {
            this.focusedOption = previousElementSibling;
          } else if (parentsPreviousElementSibling) {
            const getPreviousDataOption = function getPreviousDataOption2(_parentsPreviousElementSibling) {
              if (_parentsPreviousElementSibling === null)
                return null;
              return _parentsPreviousElementSibling.querySelector("li[data-option]:last-child") || getPreviousDataOption2(parentsPreviousElementSibling.previousElementSibling);
            };
            const li = getPreviousDataOption(parentsPreviousElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption.offsetTop <= this.$el.scrollTop) {
            this.$el.scrollTop = this.focusedOption.offsetTop - this.paddingBuffer;
          }
        },
        onScroll({ target = this.$el } = {}) {
          const { scrollTop, scrollHeight, clientHeight } = target || this.$el;
          if (this.lastScrollTop > scrollTop)
            return;
          if (scrollTop + clientHeight >= scrollHeight - 5) {
            this.currentOptionsLength += this.$parent.$props.pageSize;
            target.scrollTop = scrollTop;
            this.lastScrollTop = scrollTop;
          }
        }
      }
    };
    const _hoisted_1$B = ["id"];
    const _hoisted_2$A = { ref: "dropdownHeader" };
    const _hoisted_3$w = {
      key: 0,
      class: "slds-listbox slds-listbox_vertical",
      role: "presentation"
    };
    const _hoisted_4$u = ["data-id"];
    const _hoisted_5$s = ["aria-selected"];
    const _hoisted_6$k = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_7$h = { class: "slds-media__body" };
    const _hoisted_8$e = { class: "slds-listbox__option-text slds-listbox__option-text_entity" };
    const _hoisted_9$e = { key: 1 };
    const _hoisted_10$a = {
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_11$7 = ["title"];
    const _hoisted_12$7 = ["role"];
    const _hoisted_13$5 = {
      key: 0,
      role: "presentation",
      class: "slds-listbox__item",
      "data-header": ""
    };
    const _hoisted_14$4 = {
      class: "slds-media slds-listbox__option slds-listbox__option_plain slds-media_small",
      role: "presentation"
    };
    const _hoisted_15$5 = {
      class: "slds-listbox__option-header",
      role: "presentation"
    };
    const _hoisted_16$5 = {
      key: 1,
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_17$4 = ["title"];
    const _hoisted_18$4 = ["data-id", "data-type", "onMousedown"];
    const _hoisted_19$4 = ["aria-selected"];
    const _hoisted_20$4 = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_21$3 = { class: "slds-media__body" };
    const _hoisted_22$2 = ["title"];
    const _hoisted_23$2 = { key: 2 };
    const _hoisted_24$2 = { class: "slds-align_absolute-center slds-p-top_medium" };
    function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      return openBlock(), createElementBlock("div", mergeProps({
        id: _ctx.$parent.dropdownId,
        class: "slds-dropdown slds-dropdown_fluid",
        role: "listbox"
      }, toHandlers(_ctx.$parent.$props.pageSize > 0 ? { scroll: $options.onScroll } : {}, true)), [
        createBaseVNode("div", _hoisted_2$A, [
          renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
        ], 512),
        _ctx.$parent.comboboxInputOption ? (openBlock(), createElementBlock("ul", _hoisted_3$w, [
          createBaseVNode("li", {
            ref: "comboboxInputOption",
            role: "presentation",
            class: "slds-listbox__item",
            "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(_ctx.$parent.comboboxInputOption)),
            "data-option": "",
            onMousedown: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$parent.select(_ctx.$parent.comboboxInputOption, $event), ["prevent"]))
          }, [
            createBaseVNode("div", {
              "aria-selected": $data.focusedOption === _ctx.$refs.comboboxInputOption,
              class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_entity slds-listbox__option_term", { "slds-has-focus": $data.focusedOption === _ctx.$refs.comboboxInputOption }]),
              role: "option"
            }, [
              createBaseVNode("span", _hoisted_6$k, [
                createVNode(_component_Icon, {
                  assistiveText: _ctx.$parent.computedLabels.comboboxAdd,
                  title: _ctx.$parent.computedLabels.comboboxAdd,
                  category: "utility",
                  name: "add",
                  size: "x-small"
                }, null, 8, ["assistiveText", "title"])
              ]),
              createBaseVNode("span", _hoisted_7$h, [
                createBaseVNode("span", _hoisted_8$e, toDisplayString(_ctx.$parent.comboboxInputOption[_ctx.$parent.$props.titleKey]), 1)
              ])
            ], 10, _hoisted_5$s)
          ], 40, _hoisted_4$u)
        ])) : createCommentVNode("", true),
        $options.doRenderGlobalNoSearchResults ? (openBlock(), createElementBlock("ul", _hoisted_9$e, [
          createBaseVNode("li", _hoisted_10$a, [
            createBaseVNode("span", {
              class: "slds-m-left_x-large",
              title: _ctx.$parent.computedLabels.noSearchResults
            }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_11$7)
          ])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.computedOptionGroups, (group, name, index) => {
          return openBlock(), createElementBlock("ul", {
            key: index,
            class: "slds-listbox slds-listbox_vertical",
            role: $options.getListRole(group)
          }, [
            group.title != null && (group.filtered.length || group.async) ? (openBlock(), createElementBlock("li", _hoisted_13$5, [
              createBaseVNode("div", _hoisted_14$4, [
                createBaseVNode("h3", _hoisted_15$5, toDisplayString(_ctx.decodeHtml(group.title)), 1)
              ])
            ])) : createCommentVNode("", true),
            group.async && !group.filtered.length && !group.loading ? (openBlock(), createElementBlock("li", _hoisted_16$5, [
              createBaseVNode("span", {
                class: "slds-m-left_x-large",
                title: _ctx.$parent.computedLabels.noSearchResults
              }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_17$4)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(group.renderLength, (n) => {
              return openBlock(), createElementBlock("li", {
                key: group.filtered[n - 1].$__guid,
                "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(group.filtered[n - 1])),
                "data-type": _ctx.$parent.getIdType(group.filtered[n - 1]),
                "data-option": "",
                role: "presentation",
                class: "slds-listbox__item",
                onMousedown: withModifiers(($event) => _ctx.$parent.select(group.filtered[n - 1], $event), ["prevent"])
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_plain slds-media_small", { "slds-has-focus": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId, "slds-is-selected": _ctx.$parent.isOptionSelected(group.filtered[n - 1]) }]),
                  "aria-selected": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId,
                  role: "option"
                }, [
                  renderSlot(_ctx.$slots, "option", {
                    option: group.filtered[n - 1],
                    index: n
                  }, () => [
                    createBaseVNode("span", _hoisted_20$4, [
                      _ctx.$parent.isOptionSelected(group.filtered[n - 1]) ? (openBlock(), createBlock(_component_Icon, {
                        key: 0,
                        class: "slds-current-color",
                        category: "utility",
                        name: "check",
                        size: "x-small"
                      })) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("span", _hoisted_21$3, [
                      createBaseVNode("span", {
                        class: "slds-truncate",
                        title: _ctx.$parent.getTitle(group.filtered[n - 1])
                      }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.getTitle(group.filtered[n - 1]))), 9, _hoisted_22$2)
                    ])
                  ], true)
                ], 10, _hoisted_19$4)
              ], 40, _hoisted_18$4);
            }), 128)),
            group.loading ? (openBlock(), createElementBlock("li", _hoisted_23$2, [
              createBaseVNode("div", _hoisted_24$2, [
                createVNode(_component_Spinner, {
                  class: "slds-input__icon",
                  size: "x-small",
                  withoutContainer: "",
                  isInline: ""
                })
              ])
            ])) : createCommentVNode("", true)
          ], 8, _hoisted_12$7);
        }), 128))
      ], 16, _hoisted_1$B);
    }
    const Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$F], ["__scopeId", "data-v-4e43a862"]]);
    const _sfc_main$G = {
      components: { Checkbox },
      mixins: [decodeHtml],
      data() {
        return {
          dialogId: getGUID(),
          focusableElements: []
        };
      },
      watch: {
        "$parent.groupData": {
          handler(groupData) {
            Object.values(groupData.groups).forEach((group) => {
              group.filtered = group.filtered.map((option) => ({
                ...option,
                isSelected: this.$parent.isOptionSelected(option),
                original: option
              }));
            });
          },
          immediate: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.focusableElements = this.$el.querySelectorAll("input:not([disabled])");
          this.focusableElements[0].focus();
        });
      },
      methods: {
        save(e) {
          const valueArray = [];
          Object.values(this.$parent.groupData.groups).forEach((group) => {
            group.filtered.forEach((option) => {
              if (option.isSelected) {
                const id = this.$parent.getId(option);
                valueArray.push(id);
              }
            });
          });
          this.$parent.$emit("update:modelValue", valueArray);
          this.reset(e);
        },
        select(option, e) {
          this.$parent.$emit("selected-option", option.original, e);
        },
        reset(e) {
          this.$parent.reset(e);
          this.$parent.focus();
        },
        focusFirstElement(e) {
          e.stopPropagation();
          e.preventDefault();
          this.focusableElements[0].focus();
        },
        shiftTab(e) {
          if (document.activeElement === this.focusableElements[0]) {
            e.stopPropagation();
            e.preventDefault();
            this.$refs.savebutton.focus();
          }
        }
      }
    };
    const _hoisted_1$A = ["aria-describedby", "aria-label"];
    const _hoisted_2$z = ["id"];
    const _hoisted_3$v = {
      key: 0,
      class: "slds-form-element__legend slds-form-element__label"
    };
    const _hoisted_4$t = { class: "slds-form-element__control" };
    const _hoisted_5$r = { class: "slds-popover__footer slds-popover__footer_form" };
    function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Checkbox = resolveComponent("Checkbox");
      return openBlock(), createElementBlock("section", {
        "aria-describedby": $data.dialogId,
        "aria-label": _ctx.$parent.$props.labels.name,
        class: "slds-popover slds-popover_full-width custom-z-index",
        role: "dialog",
        onKeydown: [
          _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.reset && $options.reset(...args), ["stop"]), ["esc"])),
          _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["exact", "shift"]), ["tab"]))
        ]
      }, [
        createBaseVNode("div", {
          id: $data.dialogId,
          ref: "multiselectdialog",
          class: "slds-popover__body slds-popover__body_small"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$parent.groupData.groups, (group, name, index) => {
            return openBlock(), createElementBlock("fieldset", {
              key: index,
              class: "slds-form-element"
            }, [
              group.title != null ? (openBlock(), createElementBlock("legend", _hoisted_3$v, toDisplayString(_ctx.decodeHtml(group.title)), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$t, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(group.filtered, (option) => {
                  return openBlock(), createBlock(_component_Checkbox, {
                    key: option.$__guid,
                    modelValue: option.isSelected,
                    "onUpdate:modelValue": ($event) => option.isSelected = $event,
                    labels: { name: _ctx.$parent.getTitle(option) },
                    onClick: ($event) => $options.select(option, $event)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "labels", "onClick"]);
                }), 128))
              ])
            ]);
          }), 128))
        ], 8, _hoisted_2$z),
        createBaseVNode("footer", _hoisted_5$r, [
          createBaseVNode("button", {
            class: "slds-button slds-button_neutral",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.reset && $options.reset(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.cancel)), 1),
          createBaseVNode("button", {
            ref: "savebutton",
            class: "slds-button slds-button_brand",
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.focusFirstElement && $options.focusFirstElement(...args), ["stop", "exact"]), ["tab"])),
            onClick: _cache[2] || (_cache[2] = (...args) => $options.save && $options.save(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.save)), 545)
        ])
      ], 40, _hoisted_1$A);
    }
    const MultiselectDialog = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$E], ["__scopeId", "data-v-0a28cef2"]]);
    const _sfc_main$F = {
      name: "PillList",
      components: { Icon },
      mixins: [decodeHtml],
      props: {
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: Object,
          default: () => ({
            remove: "Press delete or backspace to remove.",
            listboxLabel: "Selected Options:",
            error: "Warning"
          })
        },
        /**
         * Adds border to pill list container.
         */
        containerBorder: Boolean,
        /**
         * Labels object for the pill list
         */
        labels: {
          type: Object,
          default: () => ({
            removeTitle: "Remove",
            error: "Error"
          })
        },
        /**
         * Options array for the pill list. `label` and `title` props are required.
         */
        options: {
          type: Array,
          default: () => [],
          validator(value) {
            return value.every((item) => {
              const requiredProps = ["label", "title"];
              const missing = getMissingProps(item, requiredProps);
              if (missing.length) {
                console.error(`Options object is missing required properties: ${missing.toString()}`);
                return false;
              }
              return true;
            });
          }
        },
        /**
         * Border for individual pill items.
         */
        pillBorder: {
          type: Boolean,
          default: true
        },
        /**
         * Sets pills to readonly and disables deletion.
         */
        readonly: Boolean
      },
      data() {
        return {
          mutableOptionsArray: [],
          lastFocusedOptionIndex: 0
        };
      },
      watch: {
        options: {
          handler(value) {
            this.mutableOptionsArray = value.map((item) => ({
              $__guid: getGUID(),
              ...item
            }));
          },
          deep: true,
          immediate: true
        }
      },
      methods: {
        focusLastFocusedOption() {
          const option = this.$refs[`option-${this.lastFocusedOptionIndex}`][0];
          if (option)
            option.focus();
        },
        remove(optionIndex, e) {
          if (this.readonly)
            return;
          const removedOption = this.mutableOptionsArray.splice(optionIndex, 1)[0];
          delete removedOption.$__guid;
          this.$emit("update:options", this.mutableOptionsArray);
          this.$emit("remove", removedOption, e);
          if (!this.mutableOptionsArray.length) {
            this.$nextTick(this.$refs.listbox.focus.bind(this.$refs.listbox));
            return;
          }
          if (this.lastFocusedOptionIndex > this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex--;
          }
          this.$nextTick(this.focusLastFocusedOption.bind(this));
        },
        left() {
          if (this.lastFocusedOptionIndex > 0) {
            this.lastFocusedOptionIndex--;
          } else {
            this.lastFocusedOptionIndex = this.mutableOptionsArray.length - 1;
          }
          this.focusLastFocusedOption();
        },
        right() {
          if (this.lastFocusedOptionIndex < this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex++;
          } else {
            this.lastFocusedOptionIndex = 0;
          }
          this.focusLastFocusedOption();
        }
      }
    };
    const _hoisted_1$z = ["aria-label"];
    const _hoisted_2$y = ["tabindex", "onFocus"];
    const _hoisted_3$u = ["title"];
    function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({ "slds-pill_container": _ctx.$props.containerBorder, "slds-listbox_selection-group": !_ctx.$props.containerBorder })
      }, [
        createBaseVNode("ul", {
          ref: "listbox",
          class: "slds-listbox slds-listbox_horizontal",
          role: "listbox",
          "aria-label": $props.assistiveText.listboxLabel,
          "aria-orientation": "horizontal",
          onKeydown: [
            _cache[0] || (_cache[0] = withKeys((...args) => $options.left && $options.left(...args), ["left"])),
            _cache[1] || (_cache[1] = withKeys((...args) => $options.right && $options.right(...args), ["right"])),
            _cache[2] || (_cache[2] = withKeys(($event) => $options.remove($data.lastFocusedOptionIndex, $event), ["delete"]))
          ]
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.mutableOptionsArray, (option, index) => {
            return openBlock(), createElementBlock("li", {
              key: option.$__guid,
              class: "slds-listbox-item",
              role: "presentation"
            }, [
              createBaseVNode("span", {
                ref_for: true,
                ref: `option-${index}`,
                class: normalizeClass(["slds-pill", { "slds-pill_bare": !$props.pillBorder, "slds-has-error": option.hasError }]),
                role: "option",
                tabindex: $data.lastFocusedOptionIndex === index ? 0 : -1,
                "aria-selected": "true",
                onFocus: ($event) => $data.lastFocusedOptionIndex = index
              }, [
                option.hasError ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  class: "slds-pill__icon_container",
                  category: "utility",
                  name: "error",
                  variant: "error",
                  assistiveText: $props.assistiveText.error,
                  title: $props.labels.error
                }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
                createBaseVNode("span", {
                  class: "slds-pill__label",
                  title: option.title
                }, toDisplayString(_ctx.decodeHtml(option.label)), 9, _hoisted_3$u),
                !$props.readonly ? (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  class: "slds-pill__remove cursor-pointer",
                  category: "utility",
                  name: "close",
                  size: "x-small",
                  assistiveText: $props.assistiveText.remove,
                  onMousedown: withModifiers(($event) => $options.remove(index, $event), ["prevent"])
                }, null, 8, ["assistiveText", "onMousedown"])) : createCommentVNode("", true)
              ], 42, _hoisted_2$y)
            ]);
          }), 128))
        ], 40, _hoisted_1$z)
      ], 2);
    }
    const PillList = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$D], ["__scopeId", "data-v-e31e462f"]]);
    const valuePropUpdater = function valuePropUpdater2(value) {
      if (value) {
        if (Array.isArray(this.$props.modelValue)) {
          this.mutableValueArray = [].concat(...this.$props.modelValue);
        } else {
          this.mutableValueArray = this.$props.modelValue ? [this.$props.modelValue] : [];
          this.$emit("update:modelValue", this.mutableValueArray);
        }
      } else {
        this.$emit("update:modelValue", this.mutableValueArray.length === 1 ? this.mutableValueArray[0] : "");
      }
    };
    const defaultLabels$4 = () => ({
      name: null,
      search: "Search...",
      noSearchResults: "No search results.",
      clearTitle: "Clear the text input",
      clearAssistiveText: "Clear the text input",
      removeTitle: "Remove",
      removeAssistiveText: "Remove",
      comboboxAdd: "Add",
      comboboxSearchAssistiveText: "Search for term",
      save: "Save",
      required: "Required",
      loading: "Loading",
      cancel: "Cancel",
      placeholder: "Select an Option"
    });
    const _sfc_main$E = {
      name: "Picklist",
      components: {
        ButtonIcon,
        Dropdown,
        Icon,
        MultiselectDialog,
        PillList,
        Spinner,
        Tooltip
      },
      directives: {
        "click-outside": vClickOutside.directive,
        "detach-element": detach
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Provides debounce function with delay value.
         */
        asyncDelay: {
          type: Number,
          default: 500
        },
        /**
         * When selected, allows combobox functionality.
         */
        combobox: Boolean,
        /**
         * Allows for Picklist dropdown to be removed from DOM flow
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * List of picklist errors.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Allows for filterable options.
         */
        filterable: Boolean,
        /**
         * Sets height of dropdown in number of options.
         */
        heightInNumOptions: {
          type: [Number, Infinity],
          default: 5
        },
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Value of the id key.
         */
        idKey: {
          type: String,
          default: "id"
        },
        /**
         * If using a label that is not part of this component, use this prop
         * since there is a label being used in the app that is located outside
         * of this component.
         */
        labelForId: {
          type: String,
          default: ""
        },
        /**
         * Picklist labels object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Minimum search length before search func is initiated.
         */
        minSearchLength: {
          type: Number,
          default: 2
        },
        /**
         * Currently selected picklist value(s).
         */
        modelValue: {
          type: [Number, String, Array, Symbol],
          default: ""
        },
        /**
         * Allows for multiselectable options.
         */
        multiselect: Boolean,
        /**
         * Multiselect Dialog options dropdown.
         */
        multiselectDialog: Boolean,
        /**
         * Callback function invoked by the component when a user selects an option.
         */
        onRequestSelectOption: {
          type: Function,
          default: null
        },
        /**
         * Array of item objects in the dropdown menu or asynchronous search function.
         */
        options: {
          type: Array,
          required: true,
          validator(options) {
            let hasUntitledGroup = false;
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (Object.hasOwnProperty.call(option, "options") && !Object.hasOwnProperty.call(option, "title")) {
                if (hasUntitledGroup) {
                  console.error("Cannot have more than one group without a title.");
                  return false;
                }
                hasUntitledGroup = true;
              }
            }
            return true;
          }
        },
        /**
         * When applicable, this value is used to lazily render options. To disable, set to a value of 0.
         */
        pageSize: {
          type: Number,
          default: 50
        },
        /**
         * Readonly version of the picklist.
         */
        readonly: Boolean,
        /**
         * Allows dropdown to remain open on selection of option
         */
        remainOpenOnSelect: Boolean,
        /**
         * Applies label styling for a required form element.
         */
        required: Boolean,
        /**
         * By default the dropdown list will resize itself to the width of the input element (anchor). If resizeToFitContent
         * is toggled on the dropdown width resizes to fit the content with the minimum width set to the width of the anchor.
         */
        resizeToFitContent: Boolean,
        /**
         * Value of the title key.
         */
        titleKey: {
          type: String,
          default: "title"
        }
      },
      emits: [
        "clear",
        "detached",
        "reset",
        "selected-option",
        "update:modelValue"
      ],
      data() {
        return {
          isActive: false,
          doRenderDropdown: false,
          dropdownId: getGUID(),
          errorId: getGUID(),
          focusedOptionId: null,
          input: "",
          cachedInput: "",
          labelId: getGUID(),
          inputId: getGUID(),
          mutableValueArray: [],
          comboboxInputOption: null,
          multiselectOptions: [],
          groupData: {
            groups: {},
            numAsyncGroups: 0,
            hasStaticOptions: false
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().picklist || {} : {};
          return {
            ...defaultLabels$4(),
            ...globals,
            ...this.$props.labels
          };
        },
        clickOutsideOptions() {
          return {
            isActive: this.doRenderDropdown,
            handler: this.clickedOutside
          };
        },
        showSearchIcon() {
          return this.$props.filterable && (this.$props.multiselect || !this.hasValue);
        },
        hasAutocompletedValue() {
          return this.hasValue && this.singleSelect && this.$props.filterable;
        },
        showDownIcon() {
          return !this.$props.filterable;
        },
        isReadOnly() {
          return this.hasAutocompletedValue || !this.$props.filterable && !this.$props.combobox;
        },
        readonlyValue() {
          if (this.singleSelect) {
            const option = this.getOptionById(this.$props.modelValue);
            return !option ? null : this.getTitle(option);
          }
          return null;
        },
        singleSelect() {
          return !this.$props.multiselect;
        },
        hasValue() {
          return this.$props.multiselect ? (this.$props.modelValue || []).length > 0 : !!this.$props.modelValue;
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        computedPlaceholder() {
          if (this.isLoading) {
            return this.computedLabels.loading;
          }
          return this.isReadOnly || this.$props.combobox && !this.$props.filterable ? this.computedLabels.placeholder : this.computedLabels.search;
        },
        doRenderPillList() {
          return this.$props.readonly && this.multiselectOptions.length || this.$props.multiselect && !this.$props.multiselectDialog && (this.multiselectOptions.length > 1 || (this.$props.filterable || this.$props.combobox) && this.multiselectOptions.length);
        },
        isLoading() {
          return Object.values(this.groupData.groups).some((group) => group.loading);
        },
        computedDoRenderDropdown() {
          return !this.$props.multiselectDialog && this.doRenderDropdown || this.groupData.numAsyncGroups > 1 && this.isLoading;
        }
      },
      watch: {
        modelValue: {
          handler(value) {
            if (value === null || Array.isArray(value)) {
              this.mutableValueArray = [].concat(...value || []);
            }
            this.setMultiselectOptions();
            this.setInput();
          },
          immediate: true
        },
        multiselect: valuePropUpdater,
        multiselectDialog: valuePropUpdater,
        $props: {
          handler() {
            if (this.$props.multiselectDialog) {
              if (this.$props.filterable || this.$props.combobox || this.$props.multiselect) {
                throw new Error("Cannot combine multiselectDialog with other features.");
              }
            }
            if (this.$props.labels && (!this.$props.labels.name || !this.$props.labels.name.length) && (!this.$props.labelForId || !this.$props.labelForId.length)) {
              console.error("Must provide label for name or pass value to labelForId prop");
            }
            if (this.$props.remainOpenOnSelect && !this.$props.multiselect) {
              console.error("Must enable multiselect to use remainOpenOnSelect prop");
            }
          },
          deep: true,
          immediate: true
        },
        focusedOptionId(value) {
          if (value && !this.$props.filterable && !this.$props.combobox && this.singleSelect) {
            this.input = this.getTitleById(value);
          }
        },
        options: {
          handler() {
            this.groupData = groupBuilder.call(this);
            this.reconcileOptions();
          },
          deep: true
        },
        asyncDelay(value) {
          Object.values(this.groupData.groups).forEach((group) => {
            if (group.async) {
              group.debounce = _debounce(group.optionsFunction, value);
            }
          });
        }
      },
      created() {
        this.validateValueBindingType();
        this.groupData = groupBuilder.call(this);
      },
      methods: {
        focus() {
          this.$refs.input.focus();
        },
        reconcileOptions() {
          if (this.$props.combobox || !this.hasValue)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            const originalLength = this.mutableValueArray.length;
            this.mutableValueArray = this.mutableValueArray.filter((value) => this.getOptionById(value));
            if (originalLength !== this.mutableValueArray.length) {
              this.$emit("update:modelValue", this.mutableValueArray);
            }
          } else if (this.getOptionById(this.$props.modelValue)) {
            this.setInput();
          } else {
            this.$emit("update:modelValue", "");
          }
        },
        clear() {
          this.input = "";
          this.$emit("update:modelValue", this.input);
          this.$emit("clear");
          this.$nextTick(this.activationHandler);
          this.$nextTick(() => {
            this.$refs.input.focus();
          });
        },
        setMultiselectOptions() {
          this.multiselectOptions = this.mutableValueArray.map((id) => {
            const option = this.getOptionById(id);
            const title = option ? this.getTitle(option) : id;
            return {
              [this.$props.idKey]: id,
              label: title,
              title
            };
          });
        },
        setInput() {
          if ((this.$props.multiselect || this.$props.multiselectDialog) && !this.$props.filterable) {
            if (this.$props.combobox) {
              this.input = null;
              return;
            }
            if (this.mutableValueArray.length > 1) {
              this.input = `${this.mutableValueArray.length} options selected`;
            } else {
              this.input = this.getTitleById(this.mutableValueArray[0]);
            }
          } else if (this.$props.modelValue) {
            this.input = this.getTitleById(this.$props.modelValue);
          } else {
            this.input = null;
          }
          this.cachedInput = this.input;
        },
        validateValueBindingType() {
          if (this.$props.modelValue === null)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            if (!Array.isArray(this.$props.modelValue)) {
              throw new Error("Value binding type must be in array in multi-select mode.");
            }
          } else if (!["string", "number", "symbol"].includes(typeof this.$props.modelValue)) {
            throw new Error("Value binding type must be a Number, String, or Symbol in single-select mode.");
          }
        },
        onBlur(e) {
          if (e.relatedTarget && this.doRenderDropdown && !this.$props.multiselectDialog) {
            this.reset(e);
            this.$emit("reset");
          }
        },
        onClick() {
          if (!this.doRenderDropdown) {
            this.activationHandler();
          }
        },
        onDetachRender() {
          if (!this.$props.multiselectDialog) {
            this.$refs.dropdown.setDropdownHeight();
          }
        },
        enter(e) {
          if (e.isComposing || e.keyCode === 229) {
            return;
          }
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.enter(e);
          } else {
            this.activationHandler();
          }
        },
        up() {
          if (!this.$props.multiselectDialog && this.doRenderDropdown) {
            this.$refs.dropdown.up();
          }
        },
        down() {
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.down();
          } else {
            this.activationHandler();
          }
        },
        activationHandler() {
          if (this.hasAutocompletedValue || this.isLoading)
            return;
          if (this.groupData.hasStaticOptions) {
            this.doRenderDropdown = true;
          } else if (this.$props.combobox && this.input) {
            this.doRenderDropdown = true;
            this.updateComboboxInputOption();
          } else {
            this.doRenderDropdown = false;
          }
          this.search();
        },
        clickedOutside(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.reset(e);
          this.$emit("reset");
        },
        escape(e) {
          this.reset(e);
          this.$emit("reset");
        },
        reset(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.input = this.cachedInput;
          Object.values(this.groupData.groups).forEach((group) => {
            group.filtered = [];
            group.searchIndex++;
            group.loading = false;
          });
          this.comboboxInputOption = null;
          this.focusedOptionId = null;
          this.doRenderDropdown = false;
        },
        getIdType(option) {
          return typeof this.getId(option);
        },
        getId(option) {
          if (!option || ["string", "number", "symbol"].includes(typeof option))
            return option;
          return option[this.$props.idKey];
        },
        getIdAsString(id) {
          return typeof id === "symbol" ? id.description : id;
        },
        getTitle(option) {
          if (["string", "number"].includes(typeof option))
            return option.toString();
          if (typeof option === "symbol")
            return option.description;
          return option[this.$props.titleKey];
        },
        getTitleById(id) {
          return this.getTitle(this.getOptionById(id) || id || "");
        },
        getOptionById(id) {
          if (!id)
            return null;
          for (let i = 0; i < this.$props.options.length; i++) {
            const item = this.$props.options[i];
            if (Array.isArray(item.options)) {
              const result = item.options.find((subOption) => this.getId(subOption) === id);
              if (result)
                return result;
            }
            if (typeof item === "object" && this.getId(item) === id)
              return item;
            if (["string", "number", "symbol"].includes(typeof item) && item === id)
              return item;
          }
          const groups = Object.values(this.groupData.groups);
          for (let i = 0; i < groups.length; i++) {
            const option = groups[i].filtered.find((_option) => this.getId(_option) === id);
            if (option)
              return option;
          }
          return null;
        },
        search() {
          if (this.hasAutocompletedValue)
            return;
          const sanitizedValue = (this.input || "").replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
          const regex = new RegExp(sanitizedValue, "i");
          const returnAllOptions = !sanitizedValue || (!this.$props.filterable || !this.$props.filterable && this.$props.combobox);
          Object.entries(this.groupData.groups).forEach(([, group]) => {
            group.filtered = [];
            if (group.static) {
              if (returnAllOptions || this.groupData.numAsyncGroups) {
                group.filtered = group.options;
              } else {
                group.options.forEach((option) => {
                  if (regex.test(this.getTitle(option))) {
                    group.filtered.push(option);
                  }
                });
              }
            } else if (group.async) {
              if (!this.$props.filterable) {
                group.optionsFunction(sanitizedValue);
              } else if (group.lazy || sanitizedValue.length >= this.$props.minSearchLength) {
                group.debounce(sanitizedValue);
              }
            }
          });
        },
        invokeOptionsFunction(fn, groupId, term) {
          const group = this.groupData.groups[groupId];
          group.loading = true;
          const searchIndex = ++group.searchIndex;
          fn.call(fn, term).then((options = []) => {
            if (searchIndex < group.searchIndex)
              return;
            const filtered = [];
            options.forEach((option) => {
              if (typeof option === "object") {
                filtered.push({ $__guid: getGUID(), ...option });
              } else if (["string", "number"].includes(typeof option)) {
                filtered.push({
                  $__guid: getGUID(),
                  [this.idKey]: option,
                  [this.titleKey]: option.toString()
                });
              }
            });
            group.filtered = group.filtered.concat(filtered);
            if (group.lazy || !this.$props.filterable) {
              group.options = group.filtered;
              group.static = true;
              group.async = false;
              this.groupData.hasStaticOptions = true;
              this.groupData.numAsyncGroups--;
            }
            this.doRenderDropdown = true;
            if (!this.multiselectDialog) {
              this.$nextTick(() => {
                group.loading = false;
              });
            }
          }).catch((error) => {
            throw new Error(error);
          });
        },
        isOptionSelected(option) {
          const id = this.getId(option);
          return this.$props.modelValue === id || (this.$props.multiselect || this.$props.multiselectDialog) && this.mutableValueArray.includes(id);
        },
        onInput() {
          this.activationHandler();
          this.updateComboboxInputOption();
        },
        updateComboboxInputOption() {
          if (!this.combobox)
            return;
          if (this.input) {
            this.comboboxInputOption = {
              [this.$props.idKey]: this.input,
              [this.$props.titleKey]: this.input
            };
          } else {
            this.comboboxInputOption = null;
          }
        },
        select(option, e) {
          if (this.onRequestSelectOption && typeof this.onRequestSelectOption === "function" && !this.onRequestSelectOption(option, e)) {
            return;
          }
          const id = this.getId(option);
          if (this.singleSelect) {
            this.$emit("update:modelValue", id);
          } else if (this.isOptionSelected(option)) {
            this.$emit("update:modelValue", this.mutableValueArray.filter((item) => this.getId(item) !== id));
          } else {
            this.mutableValueArray.push(id);
            this.$emit("update:modelValue", this.mutableValueArray);
          }
          const optionToEmit = { ...option };
          delete optionToEmit.$__guid;
          this.$emit("selected-option", optionToEmit, e);
          if (!this.$props.multiselectDialog && !this.$props.remainOpenOnSelect) {
            this.$nextTick(() => {
              this.reset();
              this.$nextTick(() => {
                this.$refs.input.focus();
              });
            });
          }
        },
        removePillListOptionHandler(option, e) {
          this.select(option, e);
        }
      }
    };
    const _hoisted_1$y = ["id", "for"];
    const _hoisted_2$x = ["title"];
    const _hoisted_3$t = { class: "slds-form-element__control" };
    const _hoisted_4$s = ["aria-expanded"];
    const _hoisted_5$q = {
      class: "slds-combobox__form-element slds-input-has-icon slds-input-has-icon_right",
      role: "none"
    };
    const _hoisted_6$j = ["id", "disabled", "aria-labelledby", "aria-controls"];
    const _hoisted_7$g = { class: "slds-truncate" };
    const _hoisted_8$d = ["id", "aria-controls", "aria-activedescendant", "aria-invalid", "aria-describedby", "placeholder", "readonly", "disabled"];
    const _hoisted_9$d = {
      key: 1,
      class: "readonly-select-label"
    };
    const _hoisted_10$9 = ["id"];
    function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Dropdown = resolveComponent("Dropdown");
      const _component_MultiselectDialog = resolveComponent("MultiselectDialog");
      const _component_PillList = resolveComponent("PillList");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slds-form-element", { "slds-has-error": $options.hasErrors }])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          class: "slds-form-element__label",
          for: $data.inputId
        }, [
          $props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "* ", 8, _hoisted_2$x)) : createCommentVNode("", true),
          createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$y)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$t, [
          createBaseVNode("div", {
            class: normalizeClass(["slds-combobox_container", { "slds-has-selection": $options.hasAutocompletedValue }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click", { "slds-is-open": $options.computedDoRenderDropdown }]),
              "aria-expanded": `${$options.computedDoRenderDropdown}`,
              "aria-haspopup": "listbox",
              role: "combobox"
            }, [
              createBaseVNode("div", _hoisted_5$q, [
                !_ctx.$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  $options.hasAutocompletedValue ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    id: $data.inputId,
                    ref: "input",
                    disabled: _ctx.$props.disabled,
                    type: "button",
                    class: "slds-input_faux slds-combobox__input slds-combobox__input-value",
                    "aria-labelledby": [$data.labelId, $data.inputId].join(" "),
                    "aria-controls": $data.dropdownId,
                    "aria-expanded": "false",
                    "aria-haspopup": "listbox"
                  }, [
                    createBaseVNode("span", _hoisted_7$g, toDisplayString($data.input), 1)
                  ], 8, _hoisted_6$j)) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
                    key: 1,
                    id: $options.computedLabels.name ? $data.inputId : $props.labelForId,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.input = $event),
                    type: "text",
                    class: ["slds-input slds-combobox__input", { "slds-combobox__input-value": $options.hasAutocompletedValue }],
                    "aria-autocomplete": "list",
                    autoComplete: "off",
                    role: "textbox",
                    "aria-controls": $options.computedDoRenderDropdown ? $data.dropdownId : null,
                    "aria-activedescendant": $options.getIdAsString($data.focusedOptionId),
                    "aria-invalid": !!_ctx.$props.errors.length,
                    "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                    placeholder: $options.computedPlaceholder,
                    readonly: $options.isReadOnly,
                    disabled: _ctx.$props.disabled
                  }, _ctx.$attrs, {
                    onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args)),
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                    onBlur: _cache[3] || (_cache[3] = (...args) => $options.onBlur && $options.onBlur(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
                      _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => $options.enter && $options.enter(...args), ["prevent"]), ["enter"])),
                      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => $options.escape && $options.escape(...args), ["stop"]), ["esc"]))
                    ]
                  }), null, 16, _hoisted_8$d)), [
                    [vModelText, $data.input]
                  ]),
                  !_ctx.$props.disabled && $options.hasAutocompletedValue ? (openBlock(), createBlock(_component_ButtonIcon, {
                    key: 2,
                    class: "slds-input__icon",
                    iconCategory: "utility",
                    iconName: "clear",
                    assistiveText: $options.computedLabels.clearAssistiveText,
                    title: $options.computedLabels.clearTitle,
                    onClick: $options.clear
                  }, null, 8, ["assistiveText", "title", "onClick"])) : $options.isLoading ? (openBlock(), createBlock(_component_Spinner, {
                    key: 3,
                    class: "slds-input__icon",
                    size: "x-small",
                    theme: "brand",
                    loadingLabel: $options.computedLabels.loading,
                    withoutContainer: ""
                  }, null, 8, ["loadingLabel"])) : renderSlot(_ctx.$slots, "icon", { key: 4 }, () => [
                    $options.showSearchIcon ? (openBlock(), createBlock(_component_Icon, {
                      key: 0,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "search",
                      size: "x-small"
                    })) : $options.showDownIcon && !$options.isLoading ? (openBlock(), createBlock(_component_Icon, {
                      key: 1,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "down",
                      size: "x-small"
                    })) : createCommentVNode("", true)
                  ], true)
                ], 64)) : (openBlock(), createElementBlock("div", _hoisted_9$d, toDisplayString($options.readonlyValue), 1))
              ]),
              $options.computedDoRenderDropdown ? withDirectives((openBlock(), createBlock(_component_Dropdown, {
                key: 0,
                ref: "dropdown"
              }, {
                option: withCtx(({ option, index }) => [
                  renderSlot(_ctx.$slots, "option", {
                    option,
                    index
                  }, void 0, true)
                ]),
                dropdownHeader: withCtx(() => [
                  renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
                ]),
                _: 3
              })), [
                [_directive_click_outside, $options.clickOutsideOptions],
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true),
              _ctx.$props.multiselectDialog && $data.doRenderDropdown ? withDirectives((openBlock(), createBlock(_component_MultiselectDialog, {
                key: 1,
                ref: "dropdown"
              }, null, 512)), [
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true)
            ], 10, _hoisted_4$s)
          ], 2),
          $options.doRenderPillList ? (openBlock(), createBlock(_component_PillList, {
            key: 0,
            readonly: _ctx.$props.readonly,
            options: $data.multiselectOptions,
            onRemove: $options.removePillListOptionHandler
          }, null, 8, ["readonly", "options", "onRemove"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "footer", {}, void 0, true),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_10$9)) : createCommentVNode("", true)
      ], 2);
    }
    const Picklist = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$C], ["__scopeId", "data-v-3db3f0d2"]]);
    const defaultLabels$3 = () => ({
      name: null,
      placeholder: null,
      required: "Required"
    });
    const _sfc_main$D = {
      name: "TextInput",
      components: { Tooltip },
      mixins: [decodeHtml],
      props: {
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * Disables manual resize for textarea type inputs.
         */
        disableResize: Boolean,
        /**
         * Error array for text input.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Displays text or node to the left of the input. This follows the fixed text input UX pattern.
         */
        fixedTextLeft: {
          type: String,
          default: ""
        },
        /**
         * Displays text or node to the right of the input. This follows the fixed text input UX pattern.
         */
        fixedTextRight: {
          type: String,
          default: ""
        },
        /**
         * Immediately sets focus to input.
         */
        hasFocus: Boolean,
        /**
         * Content for Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Labels prop for input.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The input is a controlled component, and will always display this value.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * Displays the value of the input as read-only. This is used in the inline edit UX pattern.
         */
        readonly: Boolean,
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * The element includes support for all HTML5 types.
         */
        type: {
          type: String,
          default: "text"
        },
        /**
         * A multi-line plain-text editing control.
         */
        useTextArea: Boolean
      },
      data() {
        return {
          errorId: getGUID(),
          inputId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().textInput || {} : {};
          return {
            ...defaultLabels$3(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        hasFixedAddon() {
          return this.$props.fixedTextLeft || this.$props.fixedTextRight;
        },
        fixedAddonIds() {
          if (!this.hasFixedAddon)
            return null;
          let addonIds = this.labelId;
          if (this.$props.fixedTextLeft)
            addonIds += " fixed-text-addon-pre";
          if (this.$props.fixedTextRight)
            addonIds += " fixed-text-addon-post";
          return addonIds;
        }
      },
      watch: {
        "$props.hasFocus": {
          handler(value) {
            if (value)
              this.focus();
          }
        }
      },
      mounted() {
        if (this.$props.hasFocus)
          this.focus();
      },
      methods: {
        focus() {
          this.$refs.input.focus();
          this.$refs.input.select();
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.value);
        }
      }
    };
    const _hoisted_1$x = ["id", "for"];
    const _hoisted_2$w = ["title"];
    const _hoisted_3$s = {
      key: 0,
      id: "fixed-text-addon-pre",
      class: "slds-form-element__addon"
    };
    const _hoisted_4$r = ["id", "disabled", "value", "placeholder", "readonly", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_5$p = ["id", "type", "disabled", "readonly", "placeholder", "value", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_6$i = {
      key: 3,
      id: "fixed-text-addon-post",
      class: "slds-form-element__addon"
    };
    const _hoisted_7$f = ["id"];
    function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          for: $data.inputId,
          class: "slds-form-element__label"
        }, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "*", 8, _hoisted_2$w)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$x)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          class: "slds-form-element__icon",
          alignment: "top right",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["slds-form-element__control", { "slds-input-has-fixed-addon": $options.hasFixedAddon }])
        }, [
          _ctx.$props.fixedTextLeft ? (openBlock(), createElementBlock("span", _hoisted_3$s, toDisplayString(_ctx.$props.fixedTextLeft), 1)) : createCommentVNode("", true),
          _ctx.$props.useTextArea ? (openBlock(), createElementBlock("textarea", mergeProps({
            key: 1,
            id: $data.inputId,
            ref: "input",
            disabled: _ctx.$props.disabled,
            value: _ctx.$props.modelValue,
            placeholder: $options.computedLabels.placeholder,
            readonly: _ctx.$props.readonly,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: [{ "disable-resize": _ctx.$props.disableResize }, "slds-textarea"]
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_4$r)) : (openBlock(), createElementBlock("input", mergeProps({
            key: 2,
            id: $data.inputId,
            ref: "input",
            type: _ctx.$props.type,
            disabled: _ctx.$props.disabled,
            readonly: _ctx.$props.readonly,
            placeholder: $options.computedLabels.placeholder,
            value: _ctx.$props.modelValue,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: "slds-input"
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[2] || (_cache[2] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_5$p)),
          _ctx.$props.fixedTextRight ? (openBlock(), createElementBlock("span", _hoisted_6$i, toDisplayString(_ctx.$props.fixedTextRight), 1)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "extend", {}, void 0, true)
        ], 2),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_7$f)) : createCommentVNode("", true)
      ], 2);
    }
    const TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$B], ["__scopeId", "data-v-7b6f943d"]]);
    var columnResizer = { exports: {} };
    (function(module2, exports2) {
      !function webpackUniversalModuleDefinition(e, t) {
        module2.exports = t();
      }(commonjsGlobal, () => (() => {
        var e = { 887: (e2) => {
          e2.exports = function hash2(e3) {
            for (var t2 = 5381, r2 = e3.length; r2; )
              t2 = 33 * t2 ^ e3.charCodeAt(--r2);
            return t2 >>> 0;
          };
        } }, t = {};
        function __webpack_require__(r2) {
          var i = t[r2];
          if (void 0 !== i)
            return i.exports;
          var o = t[r2] = { exports: {} };
          return e[r2](o, o.exports, __webpack_require__), o.exports;
        }
        __webpack_require__.n = (e2) => {
          var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
          return __webpack_require__.d(t2, { a: t2 }), t2;
        }, __webpack_require__.d = (e2, t2) => {
          for (var r2 in t2)
            __webpack_require__.o(t2, r2) && !__webpack_require__.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
        }, __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), __webpack_require__.r = (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var r = {};
        return (() => {
          __webpack_require__.r(r), __webpack_require__.d(r, { default: () => n });
          var e2 = __webpack_require__(887), t2 = __webpack_require__.n(e2);
          function _typeof(e3) {
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, _typeof(e3);
          }
          function _defineProperties(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++) {
              var i2 = t3[r2];
              i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, _toPropertyKey(i2.key), i2);
            }
          }
          function _createClass(e3, t3, r2) {
            return t3 && _defineProperties(e3.prototype, t3), r2 && _defineProperties(e3, r2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }
          function _classCallCheck(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperty(e3, t3, r2) {
            return (t3 = _toPropertyKey(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t3] = r2, e3;
          }
          function _toPropertyKey(e3) {
            var t3 = function _toPrimitive(e4, t4) {
              if ("object" !== _typeof(e4) || null === e4)
                return e4;
              var r2 = e4[Symbol.toPrimitive];
              if (void 0 !== r2) {
                var i2 = r2.call(e4, t4 || "default");
                if ("object" !== _typeof(i2))
                  return i2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t4 ? String : Number)(e4);
            }(e3, "string");
            return "symbol" === _typeof(t3) ? t3 : String(t3);
          }
          var i, o = (i = 0, function() {
            return i++;
          }), n = _createClass(function ColumnResizer2(e3) {
            var r2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            _classCallCheck(this, ColumnResizer2), _defineProperty(this, "ID", "id"), _defineProperty(this, "PX", "px"), _defineProperty(this, "RESIZABLE", "grip-resizable"), _defineProperty(this, "FLEX", "grip-flex"), _defineProperty(this, "legacyIE", navigator.userAgent.indexOf("Trident/4.0") > 0), _defineProperty(this, "reset", function(e4) {
              return r2.init(e4);
            }), _defineProperty(this, "onResize", function() {
              var e4 = r2.tb;
              if (e4.classList.remove(r2.RESIZABLE), e4.opt.fixed) {
                e4.tableWidth = Number(window.getComputedStyle(e4).width.replace(/px/, "")).valueOf();
                for (var t3 = 0, i3 = 0; i3 < e4.columnCnt; i3++)
                  t3 += e4.columns[i3].w;
                for (var o2 = 0; o2 < e4.columnCnt; o2++)
                  e4.columns[o2].style.width = Math.round(1e3 * e4.columns[o2].w / t3) / 10 + "%", e4.columns[o2].locked = true, e4.opt.currentWidths[o2] = Number(window.getComputedStyle(e4.columns[o2]).width.replace(/px/, "")).valueOf();
              } else
                r2.applyBounds(), "flex" === e4.opt.resizeMode && e4.opt.serialize && r2.serializeStore();
              e4.classList.add(r2.RESIZABLE), r2.syncGrips();
            }), _defineProperty(this, "onGripMouseDown", function(e4) {
              var t3 = e4.target.parentNode.data, i3 = r2.tb, o2 = i3.grips[t3.i], n2 = e4.touches;
              if (o2.ox = n2 ? n2[0].pageX : e4.pageX, o2.l = o2.offsetLeft, o2.x = o2.l, r2.createStyle(document.querySelector("head"), "*{cursor:" + i3.opt.dragCursor + "!important}"), document.addEventListener("touchmove", r2.onGripDrag), document.addEventListener("mousemove", r2.onGripDrag), document.addEventListener("touchend", r2.onGripDragOver), document.addEventListener("mouseup", r2.onGripDragOver), o2.classList.add(i3.opt.draggingClass), r2.grip = o2, i3.columns[t3.i].locked)
                for (var l, a = 0; a < i3.columnCnt; a++)
                  (l = i3.columns[a]).locked = false, l.w = Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf();
              e4.preventDefault();
            }), _defineProperty(this, "onGripDrag", function(e4) {
              var t3 = r2.grip;
              if (t3) {
                var i3 = t3.t, o2 = e4.touches, n2 = (o2 ? o2[0].pageX : e4.pageX) - t3.ox + t3.l, l = i3.opt.minWidth, a = t3.i, s = 1.5 * i3.cellSpace + l + i3.borderSpace, d = a === i3.columnCnt - 1, p2 = a ? i3.grips[a - 1].offsetLeft + i3.cellSpace + l : s, u = i3.opt.fixed ? a === i3.columnCnt - 1 ? i3.tableWidth - s : i3.grips[a + 1].offsetLeft - i3.cellSpace - l : 1 / 0;
                if (n2 = Math.max(p2, Math.min(u, n2)), t3.x = n2, t3.style.left = n2 + r2.PX, d && (t3.w = i3.columns[a].w + n2 - t3.l), i3.opt.liveDrag) {
                  d ? (i3.columns[a].style.width = t3.w + r2.PX, !i3.opt.fixed && i3.opt.overflow ? i3.style.minWidth = i3.tableWidth + n2 - t3.l + r2.PX : i3.tableWidth = Number(window.getComputedStyle(i3).width.replace(/px/, "")).valueOf()) : r2.syncCols(i3, a, false, i3.opt), r2.syncGrips();
                  var c = i3.opt.onDrag;
                  c && c(e4);
                }
                e4.preventDefault();
              }
            }), _defineProperty(this, "onGripDragOver", function(e4) {
              var t3 = r2.grip;
              document.removeEventListener("touchend", r2.onGripDragOver), document.removeEventListener("mouseup", r2.onGripDragOver), document.removeEventListener("touchmove", r2.onGripDrag), document.removeEventListener("mousemove", r2.onGripDrag);
              var i3 = document.querySelector("head").lastChild;
              if (i3.parentNode.removeChild(i3), t3) {
                if (t3.classList.remove(t3.t.opt.draggingClass), t3.x - t3.l != 0) {
                  var o2 = t3.t, n2 = o2.opt.onResize, l = t3.i;
                  if (l === o2.columnCnt - 1) {
                    var a = o2.columns[l];
                    a.style.width = t3.w + r2.PX, a.w = t3.w;
                  } else
                    r2.syncCols(o2, l, true, o2.opt);
                  o2.opt.fixed || r2.applyBounds(), r2.syncGrips(), n2 && n2(e4), o2.opt.serialize && r2.serializeStore();
                }
                r2.grip = null;
              }
            }), _defineProperty(this, "init", function(e4) {
              if (e4.disable)
                return r2.destroy();
              var t3 = r2.tb, i3 = t3.getAttribute(r2.ID) || r2.RESIZABLE + o();
              if (!t3.matches("table") || t3.extended && !e4.partialRefresh)
                return null;
              var n2 = document.querySelector("head");
              if (r2.createStyle(n2, " .grip-resizable{table-layout:fixed;} .grip-resizable > tbody > tr > td, .grip-resizable > tbody > tr > th{overflow:hidden} .grip-padding > tbody > tr > td, .grip-padding > tbody > tr > th{padding-left:0!important; padding-right:0!important;} .grip-container{ height:0px; position:relative;} .grip-handle{margin-left:-5px; position:absolute; z-index:5; } .grip-handle .grip-resizable{position:absolute;background-color:red;filter:alpha(opacity=1);opacity:0;width:10px;height:100%;cursor: col-resize;top:0px} .grip-lastgrip{position:absolute; width:1px; } .grip-drag{ border-left:1px dotted black;	} .grip-flex{width:auto!important;} .grip-handle.grip-disabledgrip .grip-resizable{cursor:default; display:none;}"), e4.hoverCursor && "col-resize" !== e4.hoverCursor) {
                var l = ".grip-handle .grip-resizable:hover{cursor:" + e4.hoverCursor + "!important}";
                r2.createStyle(n2, l);
              }
              t3.setAttribute(r2.ID, i3);
              var a = t3.opt;
              t3.opt = r2.extendOptions(e4);
              var s = r2.getTableHeaders(t3);
              if (r2.extendTable(s), e4.remoteTable && e4.remoteTable.matches("table")) {
                var d = r2.getTableHeaders(t3.opt.remoteTable);
                s.length === d.length ? r2.extendRemoteTable(t3.opt.remoteTable, d, t3) : console.warn("column count for remote table did not match");
              }
              return a;
            }), _defineProperty(this, "applyBounds", function() {
              var e4 = r2.tb, t3 = e4.columns.map(function(e5) {
                return window.getComputedStyle(e5).width;
              });
              e4.style.width = window.getComputedStyle(e4).width, e4.tableWidth = Number(e4.style.width.replace(/px/, "")).valueOf(), e4.classList.remove(r2.FLEX), e4.columns.forEach(function(r3, i3) {
                r3.style.width = t3[i3];
                var o2 = Number(t3[i3].replace(/px/, "")).valueOf();
                r3.w = o2, e4.opt.currentWidths[i3] = o2;
              }), e4.classList.add(r2.FLEX);
            }), _defineProperty(this, "serializeStore", function() {
              var e4 = r2.store, t3 = r2.tb;
              e4[t3.getAttribute(r2.ID)] = "";
              for (var i3 = 0, o2 = 0; o2 < t3.columns.length; o2++) {
                var n2 = window.getComputedStyle(t3.columns[o2]).width.replace(/px/, "");
                e4[t3.getAttribute(r2.ID)] += n2 + ";", i3 += Number(n2).valueOf();
              }
              e4[t3.getAttribute(r2.ID)] += i3.toString(), t3.opt.fixed || (e4[t3.getAttribute(r2.ID)] += ";" + window.getComputedStyle(t3).width.replace(/px/, ""));
            }), _defineProperty(this, "syncGrips", function() {
              var e4 = r2.tb;
              e4.gripContainer.style.width = e4.tableWidth + r2.PX;
              for (var t3 = 0; t3 < e4.columnCnt; t3++) {
                var i3 = e4.columns[t3], o2 = i3.getBoundingClientRect(), n2 = e4.getBoundingClientRect();
                e4.grips[t3].style.left = o2.left - n2.left + i3.offsetWidth + e4.cellSpace / 2 + r2.PX, e4.grips[t3].style.height = (e4.opt.headerOnly ? e4.columns[0].offsetHeight : e4.offsetHeight) + r2.PX;
              }
            }), _defineProperty(this, "destroy", function() {
              var e4 = r2.tb, t3 = e4.getAttribute(r2.ID);
              return t3 ? (r2.store[t3] = "", e4.classList.remove(r2.RESIZABLE), e4.classList.remove(r2.FLEX), e4.remote && (e4.remote.classList.remove(r2.RESIZABLE), e4.remote.classList.remove(r2.FLEX)), e4.gripContainer && e4.gripContainer.parentNode && e4.gripContainer.parentNode.removeChild(e4.gripContainer), delete e4.extended, e4.opt) : null;
            }), _defineProperty(this, "createStyle", function(e4, r3) {
              var i3 = t2()(r3).toString(), o2 = e4.querySelectorAll("style"), n2 = Array.from(o2).filter(function(e5) {
                return e5.gripid === i3;
              });
              if (!n2.length) {
                var l = document.createElement("style");
                l.type = "text/css", l.gripid = i3, l.styleSheet ? l.styleSheet.cssText = r3 : l.appendChild(document.createTextNode(r3)), e4.appendChild(l);
              }
            }), _defineProperty(this, "extendOptions", function(e4) {
              var t3 = Object.assign({}, ColumnResizer2.DEFAULTS, e4);
              switch (t3.fixed = true, t3.overflow = false, t3.resizeMode) {
                case "flex":
                  t3.fixed = false;
                  break;
                case "overflow":
                  t3.fixed = false, t3.overflow = true;
              }
              return t3;
            }), _defineProperty(this, "getTableHeaders", function(e4) {
              var t3 = "#" + e4.id, i3 = Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>th"));
              return (i3 = i3.concat(Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>td")))).length || (i3 = (i3 = (i3 = (i3 = Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>th"))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>th")))).concat(Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>td")))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>td")))), r2.filterInvisible(i3, false);
            }), _defineProperty(this, "filterInvisible", function(e4, t3) {
              return e4.filter(function(e5) {
                var r3 = t3 ? -1 : e5.offsetWidth, i3 = t3 ? -1 : e5.offsetHeight;
                return !(0 === r3 && 0 === i3 || e5.style && e5.style.display && "none" === window.getComputedStyle(e5).display || false);
              });
            }), _defineProperty(this, "extendTable", function(e4) {
              var t3 = r2.tb;
              t3.opt.removePadding && t3.classList.add("grip-padding"), t3.classList.add(r2.RESIZABLE), t3.insertAdjacentHTML("beforebegin", '<div class="grip-container"/>'), t3.grips = [], t3.columns = [], t3.tableWidth = Number(window.getComputedStyle(t3).width.replace(/px/, "")).valueOf(), t3.gripContainer = t3.previousElementSibling, t3.opt.marginLeft && (t3.gripContainer.style.marginLeft = t3.opt.marginLeft), t3.opt.marginRight && (t3.gripContainer.style.marginRight = t3.opt.marginRight), t3.cellSpace = parseInt(r2.legacyIE ? t3.cellSpacing || t3.currentStyle.borderSpacing : window.getComputedStyle(t3).borderSpacing.split(" ")[0].replace(/px/, "")) || 2, t3.borderSpace = parseInt(r2.legacyIE ? t3.border || t3.currentStyle.borderLeftWidth : window.getComputedStyle(t3).borderLeftWidth.replace(/px/, "")) || 1, t3.extended = true, r2.createGrips(e4);
            }), _defineProperty(this, "extendRemoteTable", function(e4, t3, i3) {
              i3.opt.removePadding && e4.classList.add("grip-padding"), e4.classList.add(r2.RESIZABLE), e4.getAttribute(r2.ID) || e4.setAttribute(r2.ID, i3.getAttribute(r2.ID) + "remote"), e4.columns = [], t3.forEach(function(o3, n2) {
                var l = t3[n2];
                l.w = i3.columns[n2].w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), e4.columns.push(l);
              }), e4.tableWidth = i3.tableWidth, e4.cellSpace = i3.cellSpace, e4.borderSpace = i3.borderSpace;
              var o2 = Array.from(e4.querySelectorAll("col"));
              e4.columnGrp = r2.filterInvisible(o2, true), e4.columnGrp.forEach(function(e5, t4) {
                e5.removeAttribute("width"), e5.style.width = i3.columnGrp[t4].style.width;
              }), i3.remote = e4;
            }), _defineProperty(this, "createGrips", function(e4) {
              var t3 = r2.tb;
              t3.columnGrp = r2.filterInvisible(Array.from(t3.querySelectorAll("col")), true), t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.columnCnt = e4.length;
              var i3 = false;
              r2.store[t3.getAttribute(r2.ID)] && (r2.deserializeStore(e4), i3 = true), e4.forEach(function(o3, n2) {
                var l = e4[n2], a = -1 !== t3.opt.disabledColumns.indexOf(n2);
                r2.createDiv(t3.gripContainer, "grip-handle");
                var s = t3.gripContainer.lastChild;
                !a && t3.opt.gripInnerHtml && (s.innerHTML = t3.opt.gripInnerHtml), r2.createDiv(s, r2.RESIZABLE), n2 === t3.columnCnt - 1 && (s.classList.add("grip-lastgrip"), t3.opt.fixed && (s.innerHTML = "")), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true), a ? s.classList.add("grip-disabledgrip") : (s.classList.remove("grip-disabledgrip"), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true)), s.t = t3, s.i = n2, t3.opt.widths[n2] ? l.w = t3.opt.widths[n2] : l.w = i3 ? Number(l.style.width.replace(/px/, "")).valueOf() : Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf(), t3.opt.currentWidths[n2] = l.w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), s.data = { i: n2, t: t3.getAttribute(r2.ID), last: n2 === t3.columnCnt - 1 }, t3.grips.push(s), t3.columns.push(l);
              });
              var o2 = Array.from(t3.querySelectorAll("td"));
              o2.concat(Array.from(t3.querySelectorAll("th"))), (o2 = (o2 = o2.filter(function(t4) {
                for (var r3 = 0; r3 < e4.length; r3++)
                  if (e4[r3] === t4)
                    return false;
                return true;
              })).filter(function(e5) {
                return !(e5.querySelectorAll("table th").length || e5.querySelectorAll("table td").length);
              })).forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.fixed || (t3.removeAttribute("width"), t3.classList.add(r2.FLEX)), r2.syncGrips();
            }), _defineProperty(this, "deserializeStore", function(e4) {
              var t3 = r2.tb;
              if (t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.flush)
                r2.store[t3.getAttribute(r2.ID)] = "";
              else {
                var i3 = r2.store[t3.getAttribute(r2.ID)].split(";"), o2 = i3[t3.columnCnt + 1];
                !t3.opt.fixed && o2 && (t3.style.width = o2 + r2.PX, t3.opt.overflow && (t3.style.minWidth = o2 + r2.PX, t3.tableWidth = Number(o2).valueOf()));
                for (var n2 = 0; n2 < t3.columnCnt; n2++)
                  e4[n2].style.width = i3[n2] + r2.PX, t3.columnGrp[n2] && (t3.columnGrp[n2].style.width = 100 * Number(i3[n2]).valueOf() / Number(i3[t3.columnCnt]).valueOf() + "%");
              }
            }), _defineProperty(this, "createDiv", function(e4, t3, r3) {
              var i3 = document.createElement("div");
              i3.classList.add(t3), r3 && (i3.innerHTML = r3), e4.appendChild(i3);
            }), _defineProperty(this, "syncCols", function(e4, t3, i3, o2) {
              var n2 = e4.remote, l = r2.grip.x - r2.grip.l, a = e4.columns[t3], s = e4.columns[t3 + 1];
              if (a && s) {
                var d = a.w + l, p2 = s.w - l, u = d + r2.PX;
                if (a.style.width = u, e4.columnGrp[t3] && e4.columnGrp[t3].style.width && (e4.columnGrp[t3].style.width = u), n2 && (n2.columns[t3].style.width = u, n2.columnGrp[t3] && n2.columnGrp[t3].style.width && (n2.columnGrp[t3].style.width = u)), o2.fixed) {
                  var c = p2 + r2.PX;
                  s.style.width = c, e4.columnGrp[t3 + 1] && e4.columnGrp[t3 + 1].style.width && (e4.columnGrp[t3 + 1].style.width = c), n2 && (n2.columns[t3 + 1].style.width = c, n2.columnGrp[t3 + 1] && n2.columnGrp[t3 + 1].style.width && (n2.columnGrp[t3 + 1].style.width = c));
                } else
                  o2.overflow && (e4.style.minWidth = e4.tableWidth + l + r2.PX);
                i3 && (a.w = d, s.w = o2.fixed ? p2 : s.w, n2 && (n2.columns[t3].w = d, n2.columns[t3 + 1].w = o2.fixed ? p2 : s.w));
              }
            });
            try {
              this.store = sessionStorage;
            } catch (e4) {
              this.store = {};
            }
            this.grip = null, this.tb = e3, window.addEventListener("resize", this.onResize), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector), this.init(i2);
          });
          n.DEFAULTS = { resizeMode: "fit", draggingClass: "grip-drag", gripInnerHtml: "", liveDrag: false, minWidth: 15, headerOnly: false, hoverCursor: "col-resize", dragCursor: "col-resize", flush: false, marginLeft: null, marginRight: null, remoteTable: null, disable: false, partialRefresh: false, disabledColumns: [], removePadding: true, widths: [], currentWidths: [], serialize: true, onDrag: null, onResize: null };
        })(), r;
      })());
    })(columnResizer);
    var columnResizerExports = columnResizer.exports;
    const ColumnResizer = /* @__PURE__ */ getDefaultExportFromCjs(columnResizerExports);
    const HALIN_CLASS = {
      center: "slds-grid_align-center",
      space: "slds-grid_align-space",
      spread: "slds-grid_align-spread",
      end: "slds-grid_align-end"
    };
    const VALIN_CLASS = {
      start: "slds-grid_vertical-align-start",
      center: "slds-grid_vertical-align-center",
      end: "slds-grid_vertical-align-end",
      stretch: "slds-grid_vertical-stretch"
    };
    const BOUNDARY_CLASS = {
      small: "slds-grid_pull-padded",
      medium: "slds-grid_pull-padded-medium",
      large: "slds-grid_pull-padded-large"
    };
    const VERTICAL_ALIGN = Object.keys(VALIN_CLASS);
    const BOUNDARY = Object.keys(BOUNDARY_CLASS);
    const HORIZONTAL_ALIGN = Object.keys(HALIN_CLASS);
    const ROWS_CLASS = "slds-wrap";
    const GRID_CLASS = "slds-grid";
    const VERTICAL_CLASS = "slds-grid_vertical";
    const GUTTERS_CLASS = "slds-gutters";
    const _sfc_main$C = {
      name: "Layout",
      props: {
        gutters: Boolean,
        horizontalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || HORIZONTAL_ALIGN.includes(value);
          }
        },
        multipleRows: Boolean,
        pullToBoundary: {
          type: String,
          default: null,
          validator(value) {
            return !value || BOUNDARY.includes(value);
          }
        },
        vertical: Boolean,
        verticalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || VERTICAL_ALIGN.includes(value);
          }
        }
      },
      computed: {
        computedClasses() {
          const result = [
            GRID_CLASS,
            HALIN_CLASS[this.$props.horizontalAlign],
            VALIN_CLASS[this.$props.verticalAlign],
            BOUNDARY_CLASS[this.$props.boundary]
          ];
          if (this.$props.multipleRows) {
            result.push(ROWS_CLASS);
          }
          if (this.$props.vertical) {
            result.push(VERTICAL_CLASS);
          }
          if (this.$props.gutters) {
            result.push(GUTTERS_CLASS);
          }
          return result;
        }
      }
    };
    function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    }
    const Layout = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$A], ["__scopeId", "data-v-8aa1ef04"]]);
    const PADDING = [
      "horizontal-small",
      "horizontal-medium",
      "horizontal-large",
      "around-small",
      "around-medium",
      "around-large"
    ];
    const PADDING_CLASS = {
      "slds-p-right_small": "horizontal-small",
      "slds-p-left_small": "horizontal-small",
      "slds-p-right_medium": "horizontal-medium",
      "slds-p-left_medium": "horizontal-medium",
      "slds-p-right_large": "horizontal-large",
      "slds-p-left_large": "horizontal-large",
      "slds-p-around_small": "around-small",
      "slds-p-around_medium": "around-medium",
      "slds-p-around_large": "around-large"
    };
    const FLEXIBILITY = [
      "auto",
      "shrink",
      "no-shrink",
      "grow",
      "no-grow",
      "no-flex"
    ];
    const FLEX_CLASS = {
      "slds-col": "auto",
      "slds-grow": "grow",
      "slds-shrink": "shrink",
      "slds-grow-none": "no-grow",
      "slds-shrink-none": "no-shrink",
      "slds-no-flex": "no-flex"
    };
    const SIZE_MIN = 1;
    const SIZE_MAX = 12;
    const SIZE_CLASS = {
      default: "slds-size_",
      small: "slds-small-size_",
      medium: "slds-medium-size_",
      large: "slds-large-size_"
    };
    const DIRECTION = ["left", "top", "right", "bottom"];
    const ERRORS = {
      FLEX_CONFLICT: "You cannot have `flexibility` value to be set to `auto` and `no-flex` together for LayoutItem component",
      SIZE_RANGE: "Invalid `size` attribute for LayoutItem component. The `size` attribute should be an integer between 1 and 12",
      SMALL_SIZE_RANGE: "Invalid `smallDeviceSize` attribute for LayoutItem component. The `smallDeviceSize` attribute should be an integer between 1 and 12",
      MEDIUM_SIZE_RANGE: "Invalid `mediumDeviceSize` attribute for LayoutItem component. The `mediumDeviceSize` attribute should be an integer between 1 and 12",
      LARGE_SIZE_RANGE: "Invalid `largeDeviceSize` attribute for LayoutItem component. The `largeDeviceSize` attribute should be an integer between 1 and 12",
      SIZE_REQUIRED: "You cannot have device specific size attributes for LayoutItem component without specifying the `size` attribute"
    };
    const _sfc_main$B = {
      name: "LayoutItem",
      props: {
        /**
         * Make the item fluid so that it absorbs any extra space in its
         * container or shrinks when there is less space. Allowed values are:
         *   auto (columns grow or shrink equally as space allows),
         *   shrink (columns shrink equally as space decreases),
         *   no-shrink (columns don't shrink as space reduces),
         *   grow (columns grow equally as space increases),
         *   no-grow (columns don't grow as space increases),
         *   no-flex (columns don't grow or shrink as space changes).
         * Use a comma-separated or space-separated value for multiple options, such as 'auto, no-shrink'.
         */
        flexibility: {
          type: String,
          default: "auto",
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/).map((item) => item.trim());
            if (classes.some((item) => item === "auto") && classes.some((item) => item === "no-flex")) {
              throw new Error(ERRORS.FLEX_CONFLICT);
            }
            return classes.every((item) => FLEXIBILITY.some((allowed) => item === allowed));
          }
        },
        /**
         * Specifies a direction to bump the alignment of adjacent layout items. Allowed values are left, top, right, bottom.
         */
        alignmentBump: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one alignment class set.");
            }
            return classes.every((item) => DIRECTION.some((allowed) => item === allowed));
          }
        },
        padding: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one padding class set.");
            }
            return classes.every((item) => PADDING.some((allowed) => item === allowed));
          }
        },
        size: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SIZE_RANGE);
            }
            return true;
          }
        },
        smallDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SMALL_SIZE_RANGE);
            }
            return true;
          }
        },
        mediumDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.MEDIUM_SIZE_RANGE);
            }
            return true;
          }
        },
        largeDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.LARGE_SIZE_RANGE);
            }
            return true;
          }
        }
      },
      data() {
        return {
          pFlexibility: null,
          pPadding: null,
          pAlignmentBump: null
        };
      },
      computed: {
        computedClasses() {
          const classes = /* @__PURE__ */ new Set();
          this.computeSizeClasses(
            {
              default: this.$props.size,
              small: this.$props.smallDeviceSize,
              medium: this.$props.mediumDeviceSize,
              large: this.$props.largeDeviceSize
            },
            classes
          );
          this.computePaddingClass(this.$props.padding, classes);
          this.computeFlexibilityClass(this.$props.flexibility, classes);
          this.computeBumpClass(this.$props.alignmentBump, classes);
          return Array.from(classes);
        }
      },
      watch: {
        size() {
          this.validateSizes();
        },
        smallDeviceSize() {
          this.validateSizes();
        },
        mediumDeviceSize() {
          this.validateSizes();
        },
        largeDeviceSize() {
          this.validateSizes();
        }
      },
      created() {
        this.validateSizes();
      },
      methods: {
        validateSizes() {
          if (this.$props.size === null && (this.$props.smallDeviceSize != null || this.$props.mediumDeviceSize != null || this.$props.largeDeviceSize != null)) {
            throw new Error(ERRORS.SIZE_REQUIRED);
          }
        },
        computeSizeClasses(sizes, classes) {
          Object.keys(SIZE_CLASS).forEach((key) => {
            const size2 = sizes[key];
            if (size2 != null && size2 !== 0) {
              classes.add(`${SIZE_CLASS[key]}${size2}-of-12`);
            }
          });
        },
        computeFlexibilityClass(flexibility, classes) {
          if (flexibility === null)
            return;
          flexibility = flexibility.trim().split(/[,|\s]+/).map((item) => item.trim());
          Object.keys(FLEX_CLASS).forEach((key) => {
            if (flexibility.some((flex) => flex === FLEX_CLASS[key])) {
              classes.add(key);
            }
          });
        },
        computePaddingClass(padding, classes) {
          if (padding === null)
            return;
          Object.keys(PADDING_CLASS).forEach((key) => {
            if (PADDING_CLASS[key].toLowerCase() === padding.trim()) {
              classes.add(key);
            }
          });
        },
        computeBumpClass(direction, classes) {
          if (direction) {
            classes.add(`slds-col_bump-${direction}`);
          }
        }
      }
    };
    function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    }
    const LayoutItem = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$z]]);
    const _sfc_main$A = {
      name: "DataTableRow",
      components: {
        ActionMenu,
        ActionMenuItem,
        Badge,
        ButtonIcon,
        Checkbox,
        ConditionalWrapper,
        Icon
      },
      inject: [
        "rootProps",
        "selectAllId",
        "rootEmit"
      ],
      props: [
        "childIndex",
        "depth",
        "parentRef",
        "row"
      ],
      data() {
        return {
          indexOfColumnBeingEdited: null
        };
      },
      methods: {
        handleAnchorClick(data, e) {
          if (typeof data.onClick === "function") {
            e.preventDefault();
            data.onClick(data, e);
          }
        },
        handleRowToggleClick() {
          this.$props.row.expanded = !this.$props.row.expanded;
        },
        handleCellEdit(event, index) {
          this.indexOfColumnBeingEdited = index;
          const cell = event.path.find((el) => ["td", "th"].includes(el.localName) && el.className.includes("slds-cell-edit"));
          this.$nextTick(() => cell.querySelector("input").focus());
        },
        handleRowAction(action) {
          this.rootEmit(
            "row-action",
            {
              action,
              ...this.$props
            }
          );
        },
        updateCellValue(e) {
          const cellValue = e.path[0].value;
          this.$props.row.data[this.indexOfColumnBeingEdited].value = cellValue;
          this.rootEmit("update-cell", { value: cellValue, row: this.$props.row, columnIndex: this.indexOfColumnBeingEdited });
          this.$nextTick(() => {
            if (!this.$props.row.data[this.indexOfColumnBeingEdited].error)
              this.indexOfColumnBeingEdited = null;
          });
        },
        resetEditMode() {
          this.indexOfColumnBeingEdited = null;
        }
      }
    };
    const _hoisted_1$w = ["aria-selected", "aria-level"];
    const _hoisted_2$v = {
      key: 0,
      class: "slds-text-align_right slds-cell_action-mode",
      role: "gridcell"
    };
    const _hoisted_3$r = ["title"];
    const _hoisted_4$q = {
      key: 0,
      "aria-describedby": "dialog-body-id-1",
      class: "slds-popover slds-popover slds-popover_edit",
      role: "dialog",
      style: { "position": "absolute", "top": "0px", "left": "0.0625rem" }
    };
    const _hoisted_5$o = {
      id: "dialog-body-id-1",
      class: "slds-popover__body"
    };
    const _hoisted_6$h = { class: "slds-media" };
    const _hoisted_7$e = { class: "slds-media__body" };
    const _hoisted_8$c = ["for"];
    const _hoisted_9$c = { class: "slds-assistive-text" };
    const _hoisted_10$8 = { class: "slds-form-element__control slds-grow" };
    const _hoisted_11$6 = ["id", "value"];
    const _hoisted_12$6 = {
      key: 0,
      class: "slds-form-element__help"
    };
    const _hoisted_13$4 = {
      key: 1,
      class: "slds-cell_action-mode",
      role: "gridcell"
    };
    function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Badge = resolveComponent("Badge");
      const _component_Icon = resolveComponent("Icon");
      const _component_ConditionalWrapper = resolveComponent("ConditionalWrapper");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      return openBlock(), createElementBlock("tr", {
        ref: "row",
        key: _ctx.$props.row.id,
        "aria-selected": $options.rootProps.multiselectable ? _ctx.$props.row.selected || "false" : null,
        "aria-level": _ctx.$props.depth ? _ctx.$props.depth : null,
        class: normalizeClass([{ "slds-is-selected": _ctx.$props.row.selected }, "slds-hint-parent"])
      }, [
        $options.rootProps.multiselectable ? (openBlock(), createElementBlock("td", _hoisted_2$v, [
          createVNode(_component_Checkbox, {
            modelValue: _ctx.$props.row.selected,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$props.row.selected = $event),
            ariaLabeledBy: $options.selectAllId,
            labels: { name: `Select item ${_ctx.$props.childIndex + 1}` },
            hideLabel: "",
            onInput: _cache[1] || (_cache[1] = ($event) => $options.rootEmit("select-row", { id: _ctx.$props.row.id, row: _ctx.$props.row, selected: _ctx.$props.row.selected }))
          }, null, 8, ["modelValue", "ariaLabeledBy", "labels"])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.data, (data, i) => {
          var _a2, _b;
          return openBlock(), createBlock(resolveDynamicComponent(i === 0 ? "th" : "td"), {
            key: `'Root' + ${i}`,
            "data-label": $options.rootProps.columns[i].name,
            class: normalizeClass([
              `slds-text-align_${((_a2 = $options.rootProps.columns[i]) == null ? void 0 : _a2.alignment) || "left"}`,
              {
                "slds-tree__item": i === 0 && $options.rootProps.tree,
                "slds-cell-edit": (_b = $options.rootProps) == null ? void 0 : _b.editableColumnIndices.includes(i),
                "slds-is-edited": data == null ? void 0 : data.dirty,
                "slds-has-error": data == null ? void 0 : data.error
              }
            ]),
            role: i > 0 && $options.rootProps.tree ? "gridcell" : null,
            scope: i === 0 ? "row" : null
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createVNode(_component_ConditionalWrapper, {
                  class: normalizeClass(["slds-grid slds-grid_align-spread", { "slds-grow": i === 0 }]),
                  element: "span",
                  style: { "width": "100%" },
                  active: (_a3 = $options.rootProps) == null ? void 0 : _a3.editableColumnIndices.includes(i)
                }, {
                  default: withCtx(() => {
                    var _a4, _b2;
                    return [
                      createVNode(_component_ConditionalWrapper, {
                        element: "span",
                        class: "slds-grid slds-truncate",
                        active: i === 0 && ((_a4 = $options.rootProps) == null ? void 0 : _a4.editableColumnIndices.includes(i))
                      }, {
                        default: withCtx(() => {
                          var _a5;
                          return [
                            $options.rootProps.tree && i === 0 ? (openBlock(), createBlock(_component_ButtonIcon, {
                              key: 0,
                              variant: "bare",
                              iconCategory: "utility",
                              iconName: _ctx.$props.row.expanded ? "chevrondown" : "chevronright",
                              size: "x-small",
                              class: normalizeClass(["slds-m-right_x-small", { "slds-is-disabled": !((_a5 = _ctx.$props.row.children) == null ? void 0 : _a5.length) }]),
                              tabindex: "-1",
                              title: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              assistiveText: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              onClick: $options.handleRowToggleClick
                            }, null, 8, ["iconName", "class", "title", "assistiveText", "onClick"])) : createCommentVNode("", true),
                            (data == null ? void 0 : data.type) === "custom" ? renderSlot(_ctx.$slots, "cell", mergeProps({
                              key: 1,
                              column: $options.rootProps.columns[i],
                              columnIndex: i,
                              data
                            }, _ctx.$props)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                              (data == null ? void 0 : data.type) === "badge" ? (openBlock(), createBlock(_component_Badge, {
                                key: 0,
                                theme: data.theme,
                                content: data.value
                              }, null, 8, ["theme", "content"])) : typeof data === "boolean" ? (openBlock(), createBlock(_component_Icon, {
                                key: 1,
                                category: "utility",
                                name: "check",
                                size: "xx-small"
                              })) : (openBlock(), createElementBlock("div", {
                                key: 2,
                                title: (data == null ? void 0 : data.type) === "anchor" ? data.value : data,
                                class: "slds-truncate"
                              }, [
                                createVNode(_component_ConditionalWrapper, mergeProps({
                                  tabindex: "-1",
                                  element: "a"
                                }, (data == null ? void 0 : data.attrs) || {}, {
                                  active: (data == null ? void 0 : data.type) === "anchor",
                                  onClick: ($event) => $options.handleAnchorClick(data, $event)
                                }), {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString((data == null ? void 0 : data.type) === "anchor" ? data.value : data), 1)
                                  ]),
                                  _: 2
                                }, 1040, ["active", "onClick"])
                              ], 8, _hoisted_3$r))
                            ], 64))
                          ];
                        }),
                        _: 2
                      }, 1032, ["active"]),
                      ((_b2 = $options.rootProps) == null ? void 0 : _b2.editableColumnIndices.includes(i)) ? (openBlock(), createBlock(_component_ButtonIcon, {
                        key: 0,
                        variant: "bare",
                        iconCategory: "utility",
                        iconClass: "slds-button__icon_hint slds-button__icon_edit",
                        iconName: data.locked ? "lock" : "edit",
                        size: "x-small",
                        class: "slds-cell-edit__button slds-m-left_x-small",
                        title: `Edit ${$options.rootProps.columns[i].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        assistiveText: `Edit ${$options.rootProps.columns[i].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        disabled: data.locked,
                        onClick: ($event) => $options.handleCellEdit($event, i)
                      }, null, 8, ["iconName", "title", "assistiveText", "disabled", "onClick"])) : createCommentVNode("", true)
                    ];
                  }),
                  _: 2
                }, 1032, ["class", "active"]),
                i === $data.indexOfColumnBeingEdited ? (openBlock(), createElementBlock("section", _hoisted_4$q, [
                  createBaseVNode("div", _hoisted_5$o, [
                    createBaseVNode("div", _hoisted_6$h, [
                      createBaseVNode("div", _hoisted_7$e, [
                        createBaseVNode("div", {
                          class: normalizeClass(["slds-form-element slds-grid slds-wrap", { "slds-has-error": data.error }])
                        }, [
                          createBaseVNode("label", {
                            class: "slds-form-element__label slds-form-element__label_edit slds-no-flex",
                            for: `${$options.rootProps.columns[i].name}-${i}`
                          }, [
                            createBaseVNode("span", _hoisted_9$c, toDisplayString($options.rootProps.columns[i].name), 1)
                          ], 8, _hoisted_8$c),
                          createBaseVNode("div", _hoisted_10$8, [
                            createBaseVNode("input", {
                              id: `${$options.rootProps.columns[i].name}-${i}`,
                              class: "slds-input",
                              type: "text",
                              value: data.value,
                              onBlur: _cache[2] || (_cache[2] = (...args) => $options.resetEditMode && $options.resetEditMode(...args)),
                              onKeydown: [
                                _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.resetEditMode && $options.resetEditMode(...args), ["stop"]), ["esc"])),
                                _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => $options.updateCellValue($event), ["stop"]), ["enter"]))
                              ]
                            }, null, 40, _hoisted_11$6)
                          ]),
                          data.error ? (openBlock(), createElementBlock("div", _hoisted_12$6, toDisplayString(data.error), 1)) : createCommentVNode("", true)
                        ], 2)
                      ])
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ];
            }),
            _: 2
          }, 1032, ["data-label", "class", "role", "scope"]);
        }), 128)),
        ((_a = _ctx.$props.row.actions) == null ? void 0 : _a.length) ? (openBlock(), createElementBlock("td", _hoisted_13$4, [
          createVNode(_component_ActionMenu, null, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.actions, (action, i) => {
                return openBlock(), createBlock(_component_ActionMenuItem, {
                  key: i,
                  label: action.label,
                  onClick: ($event) => $options.handleRowAction(action)
                }, null, 8, ["label", "onClick"]);
              }), 128))
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$w);
    }
    const Row = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$y]]);
    const Node = {
      name: "DataTableTreeNode",
      components: {
        Row
      },
      props: [
        "depth",
        "parentRef",
        "row",
        "childIndex"
      ],
      render() {
        const children = [
          h(
            Row,
            {
              ...this.$props
            },
            {
              cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
            }
          )
        ];
        if (this.$props.row.children && this.$props.row.expanded) {
          this.$props.row.children.forEach((row, childIndex) => children.push(
            h(
              Node,
              {
                childIndex,
                depth: this.$props.depth + 1,
                parentRef: this.$props.row,
                row
              },
              {
                cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
              }
            )
          ));
        }
        return [children];
      }
    };
    const Tree = {
      name: "DataTableTree",
      components: {
        Node
      },
      props: ["rows"],
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        return this.$props.rows.map((row, childIndex) => h(
          Node,
          {
            childIndex,
            depth: 0,
            parentRef: null,
            row
          },
          {
            cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
          }
        )).concat(_default);
      }
    };
    const _sfc_main$z = {
      name: "DataTable",
      components: {
        ActionMenu,
        ActionMenuItem,
        Checkbox,
        // ConditionalWrapper,
        Icon,
        Layout,
        LayoutItem,
        Row,
        Tree
      },
      provide() {
        return {
          rootProps: this.$props,
          selectAllId: this.selectAllId,
          rootEmit: (...args) => {
            this.$emit(args[0], ...args.slice(1));
          }
        };
      },
      props: {
        actions: Boolean,
        ariaLabel: {
          type: String,
          default: ""
        },
        bordered: Boolean,
        bufferCells: Boolean,
        columns: {
          type: Array,
          required: true
        },
        columnsBordered: Boolean,
        editableColumnIndices: {
          type: Array,
          default: () => []
        },
        hideHeader: Boolean,
        multiselectable: Boolean,
        resizable: Boolean,
        // TODO: Explore making a copy of this array to avoid directly manipulating rows
        rows: {
          type: Array,
          required: true
        },
        selectAll: Boolean,
        summaryFooter: Boolean,
        summaryHeader: Boolean,
        tree: Boolean,
        virtual: Boolean
      },
      emits: [
        "column-action",
        "row-action",
        "select-all",
        "select-column",
        "select-row",
        "update-cell"
      ],
      data() {
        return {
          selectedAll: false,
          selectAllId: getGUID(),
          columnResizer: {},
          rowHeight: 0,
          containerHeight: 0,
          visibleRowsStartIndex: 0,
          // CSS vars
          selectedColumnBackgroundColor: "blue"
        };
      },
      computed: {
        computedRole() {
          if (this.$props.tree)
            return "treegrid";
          if (this.$props.multiselectable)
            return "grid";
          return null;
        },
        visibleRows() {
          return this.$props.virtual ? this.rows.slice(this.visibleRowsStartIndex, this.visibleRowsStartIndex + 200) : this.rows;
        },
        tableContainerPaddingTop() {
          return this.visibleRowsStartIndex * this.rowHeight;
        },
        tableContainerPaddingBottom() {
          return (this.rows.length - this.visibleRows.length) * this.rowHeight - this.tableContainerPaddingTop;
        },
        hasSelectableColumns() {
          return this.$props.columns.some((column) => column.selectable);
        },
        verticalHeaderCellPadding() {
          return this.$props.summaryHeader && this.hasSelectableColumns ? "0.75rem" : "0.5rem";
        },
        selectedPseudoElementTop() {
          return !this.hasSelectableColumns || !this.$props.summaryHeader ? "-4px" : 0;
        },
        selectedBorderRadius() {
          return this.$props.summaryHeader ? 0 : "2px";
        }
      },
      watch: {
        "$props.rows": {
          handler(rows) {
            if (rows.length) {
              this.initColumnResizer();
              if (this.$props.virtual) {
                this.$nextTick(() => {
                  this.rowHeight = this.$refs["row-0"][0].$refs.row.offsetHeight;
                  this.containerHeight = this.$refs.tableContainer.offsetHeight;
                });
              }
            }
          },
          immediate: true
        }
      },
      methods: {
        async initColumnResizer() {
          if (!this.$props.resizable)
            return;
          await this.$nextTick();
          this.columnResizer = new ColumnResizer(this.$refs.table, {
            disable: !this.$props.resizable,
            innerGripHtml: "<div class='rangeGrip'></div>",
            removePadding: false,
            minWidth: 48
          });
        },
        onSelectAllChange() {
          this.rows.forEach((row) => {
            row.selected = this.selectedAll;
          });
          this.$emit("select-all", this.selectedAll);
        },
        onScroll() {
          if (!this.$props.virtual || this.scrollTimeout)
            return;
          this.scrollTimeout = setTimeout(() => {
            this.visibleRowsStartIndex = Math.max(0, Math.floor(this.$refs.tableContainer.scrollTop / this.rowHeight) - 100);
            this.scrollTimeout = null;
          }, 500);
        },
        getListeners(column, columnIndex) {
          const base = { ...column.listeners || {} };
          if (column.selectable) {
            base.click = [base.click, this.onHeaderClick.bind(this, column, columnIndex)];
          }
          return base;
        },
        onHeaderClick(column, columnIndex, e) {
          function getParentTH(el) {
            if (el.nodeName === "TH")
              return el;
            while (el.parentNode) {
              el = el.parentNode;
              if (el.nodeName === "TH") {
                return el;
              }
            }
            return null;
          }
          if (e.target.nodeName !== "BUTTON") {
            this.$emit("select-column", { column, columnIndex });
            column.selected = true;
            this.$refs.tableContainer.style.paddingTop = "5px";
            if (column.icon) {
              const iconContainer = getParentTH(e.target).querySelector("div.slds-icon_container");
              if (iconContainer) {
                this.selectedColumnBackgroundColor = window.getComputedStyle(iconContainer).backgroundColor;
              }
            }
          }
        }
      }
    };
    const __injectCSSVars__$1 = () => {
      useCssVars((_ctx) => ({
        "4d4e3100": _ctx.selectedPseudoElementTop,
        "85016f72": _ctx.selectedBorderRadius,
        "484c9e56": _ctx.selectedColumnBackgroundColor,
        "f99d0584": _ctx.verticalHeaderCellPadding
      }));
    };
    const __setup__$1 = _sfc_main$z.setup;
    _sfc_main$z.setup = __setup__$1 ? (props, ctx) => {
      __injectCSSVars__$1();
      return __setup__$1(props, ctx);
    } : __injectCSSVars__$1;
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i, length;
      for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
          array[i] = formatTokenFunctions[array[i]];
        } else {
          array[i] = removeFormattingTokens(array[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({ unit: u, priority: priorities[u] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d = mom._d, isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
        case "Seconds":
          return isUTC ? d.getUTCSeconds() : d.getSeconds();
        case "Minutes":
          return isUTC ? d.getUTCMinutes() : d.getMinutes();
        case "Hours":
          return isUTC ? d.getUTCHours() : d.getHours();
        case "Date":
          return isUTC ? d.getUTCDate() : d.getDate();
        case "Day":
          return isUTC ? d.getUTCDay() : d.getDay();
        case "Month":
          return isUTC ? d.getUTCMonth() : d.getMonth();
        case "FullYear":
          return isUTC ? d.getUTCFullYear() : d.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1(mom, unit, value) {
      var d, isUTC, year, month, date;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
        case "Hours":
          return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
        case "Date":
          return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value;
      month = mom.month();
      date = mom.date();
      date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
      void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function mod(n, x) {
      return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      var month = value, date = mom.date();
      date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y, m, d, h2, M, s, ms) {
      var date;
      if (y < 100 && y >= 0) {
        date = new Date(y + 400, m, d, h2, M, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h2, M, s, ms);
      }
      return date;
    }
    function createUTCDate(y) {
      var date, args;
      if (y < 100 && y >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return !!(name && name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDatesLen; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimesLen; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
        return h2 * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
        week = defaults(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = (string || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(
          m,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(
        m,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale$1(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }
    function utcStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray$1() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length; i < l; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale$1;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray$1;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index, field) {
      if (isNumber(format2)) {
        index = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index != null) {
        return get$1(format2, index, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index != null) {
        return get$1(format2, (index + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index) {
      return listMonthsImpl(format2, index, "months");
    }
    function listMonthsShort(format2, index) {
      return listMonthsImpl(format2, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale$1;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    const Modes = Object.freeze({
      ALL: Symbol.for("slds-vue-expression-all"),
      ANY: Symbol.for("slds-vue-expression-any"),
      CUSTOM: Symbol.for("slds-vue-expression-custom")
    });
    const getDefaultLabels = () => ({
      addCondition: "Add Condition",
      customLogic: "Custom Logic",
      takeAction: "Take Action When",
      title: "Conditions",
      modeAll: "All Conditions Are Met",
      modeAny: "Any Condition Is Met",
      modeCustom: "Custom Logic Is Met",
      and: "AND",
      or: "OR",
      customLogicPlaceholder: "e.g. (1 AND 2) OR 3"
    });
    ({
      name: "Expression",
      components: {
        Button: SLDSButton,
        TextInput,
        Picklist
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Proxied listeners to the custom logic TextInput component.
         */
        customLogicListeners: {
          type: Object,
          default: () => {
          }
        },
        /**
         * If true, disables built-in accessibility logic when component state changes.
         */
        disableA11y: Boolean,
        /**
         * If true, the logic selection picklist is diabled.
         */
        disableLogic: Boolean,
        /**
         * @param {Object} labels Text labels for internationalization.
         * @param {String} labels.addCondition Label for the Add Condition button. Defaults to "Add Condition".
         * @param {String} labels.customLogic Label for the custom logic input. Default to "Custom Logic".
         * @param {String} labels.takeAction Label for the expression mode dropdown. Defaults to "Take Action When".
         * @param {String} labels.title Label for the expression title. Defaults to "Conditions".
         * @param {String} labels.modeAll Label for the ALL mode. Defaults to "All Conditions Are Met".
         * @param {String} labels.modeAny Label for the ANY mode. Defaults to "Any Condition Is Met".
         * @param {String} labels.modeCustom Label for the CUSTOM mode. Defaults to "Custom Logic Is Met".
         * @param {String} labels.and Label for the gutter label when mode is ALL. Defaults to "AND".
         * @param {String} labels.or Label for the gutter label when mode is ANY. Defaults to "OR".
         */
        labels: {
          type: Object,
          default: () => getDefaultLabels()
        },
        /**
         * @param {Symbol} mode The selected mode. Defaults to Modes.ALL.
         */
        mode: {
          type: Symbol,
          default: Modes.ALL,
          validator(value) {
            const valid = Object.values(Modes).includes(value);
            if (!valid) {
              console.warn("Mode prop must be equal to one of the enumerated values from the exported Expression.Modes module.");
            }
            return valid;
          }
        },
        /**
        * @param {Array} modes The list of available modes. Defaults to ALL, ANY, and CUSTOM. Array members must be
        *                      one or more of the available properties from the exported Modes module.
        */
        modes: {
          type: Array,
          default: () => [
            Modes.ALL,
            Modes.ANY,
            Modes.CUSTOM
          ],
          validator() {
            return true;
          }
        },
        /**
         * If true, gutters are not rendered.
         */
        noGutter: Boolean,
        /**
         * If true, all logic-related artifacts will not be rendered.
         */
        noLogic: Boolean,
        /**
         * If true, no title is rendered.
         */
        noTitle: Boolean,
        /**
        * @param {String} customLogic The custom logic value. If set, it will appear in the custom logic input box
        *                             if the current mode is Modes.CUSTOM.
        */
        customLogic: {
          type: String,
          default: ""
        },
        customLogicErrors: {
          type: Array,
          default: () => []
        }
      },
      data() {
        return {
          registeredConditions: {},
          localMode: this.$props.mode,
          addConditionFlag: false,
          mergedLabels: {
            ...getDefaultLabels(),
            ...this.$props.labels
          }
        };
      },
      computed: {
        modeOptions() {
          return this.$props.modes.map((mode) => ({
            id: mode,
            title: this.modeLabels[mode]
          }));
        },
        modeLabels() {
          return {
            [Modes.ALL]: this.mergedLabels.modeAll,
            [Modes.ANY]: this.mergedLabels.modeAny,
            [Modes.CUSTOM]: this.mergedLabels.modeCustom
          };
        },
        showCustomLogicInput() {
          return this.$props.mode === Modes.CUSTOM;
        },
        numConditions() {
          return Object.keys(this.registeredConditions).length;
        }
      },
      watch: {
        numConditions(newValue, oldValue) {
          this.updateConditions();
          if (this.addConditionFlag && newValue > oldValue) {
            const conditionId = Object.keys(this.registeredConditions)[newValue - 1];
            this.$nextTick(this.registeredConditions[conditionId].focusResource);
          }
        },
        "$props.mode": {
          handler(value) {
            this.localMode = value;
          }
        },
        "$props.noGutter": {
          handler() {
            this.updateConditions();
          }
        },
        localMode() {
          this.updateConditions();
        }
      },
      mounted() {
        this.$el.addEventListener("register-condition", this.onRegisterCondition);
      },
      methods: {
        registerCondition(id, callbacks) {
          this.registeredConditions[id] = callbacks;
        },
        unregisterCondition(id) {
          this.updateFocus(id);
          delete this.registeredConditions[id];
        },
        updateFocus(id) {
          const conditionIds = Object.keys(this.registeredConditions);
          const indexToBeUnregistered = conditionIds.indexOf(id);
          let registeredCondition;
          if (indexToBeUnregistered === conditionIds.length - 1) {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered - 1]];
          } else {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered + 1]];
          }
          if (registeredCondition && registeredCondition.focusResource) {
            registeredCondition.focusResource();
          }
        },
        addCondition() {
          this.addConditionFlag = true;
          this.$emit("add-condition");
        },
        updateConditions() {
          Object.entries(this.registeredConditions).forEach(([, callbacks], index) => {
            callbacks.setGutterLabel(null);
            switch (this.localMode) {
              case Modes.ALL:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.and);
                }
                break;
              case Modes.ANY:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.or);
                }
                break;
              case Modes.CUSTOM:
                callbacks.setGutterLabel(index + 1);
                break;
            }
            callbacks.setGutterVisibility(!this.$props.noGutter);
            callbacks.setIndex(index);
            callbacks.setNumSiblings(this.numConditions - 1);
          });
        }
      }
    });
    const defaultLabels$2 = () => ({
      prompt: "Okay",
      closeTitle: "Close",
      closeAssistiveText: "Close"
    });
    const _sfc_main$y = {
      name: "Modal",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Hides modal body.
         */
        bodyless: Boolean,
        /**
         * Detaches modal from flow of DOM.
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Hides modal header.
         */
        headless: Boolean,
        /**
         * Hides close button.
         */
        hideCloseButton: Boolean,
        /**
         * Hides modal footer.
         */
        footless: Boolean,
        /**
         * Modal label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Styles the modal as a prompt.
         */
        prompt: Boolean,
        /**
         * Specifies the modal's width.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = [
              "small",
              "base",
              "medium",
              "large",
              "x-large"
            ];
            if (!value || !validSizes.includes(value)) {
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
              return false;
            }
            return true;
          }
        },
        /**
         * Text heading at the top of a modal.
         */
        title: {
          type: String,
          required: true
        }
      },
      data() {
        return {
          container: null,
          focusableElements: [],
          modalId: getGUID(),
          triggerElement: null
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().modal || {} : {};
          return {
            ...defaultLabels$2(),
            ...globals,
            ...this.$props.labels
          };
        },
        headerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_alert-texture slds-theme_error");
          if (this.headless)
            classes.push("slds-modal__header_empty");
          return classes;
        },
        footerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_default");
          if (this.bodyless)
            classes.push("footer-bodyless");
          return classes;
        },
        modalClass() {
          const classes = [];
          if (this.size !== "base") {
            classes.push(`slds-modal_${this.size}`);
          }
          if (this.prompt) {
            classes.push("slds-modal_prompt");
          }
          return classes;
        }
      },
      mounted() {
        this.triggerElement = document.activeElement || document.body;
        if (this.detach) {
          this._detach();
          Array.from(this.container.parentNode.children).filter((node) => node !== this.container && !(node instanceof HTMLScriptElement)).forEach((node) => {
            node.setAttribute("aria-hidden", true);
          });
        }
        this.getFocusableElements();
        this.setFocusOnFirstFocusableItem();
        this.$emit("mounted");
      },
      beforeUnmount() {
        if (this.container) {
          this.container.remove();
          this.container = null;
        }
        this.triggerElement.focus();
      },
      updated() {
        this.getFocusableElements();
      },
      methods: {
        _detach() {
          this.container = document.createElement("div");
          this.container.className = `slds-scope ${this.$el.className}`;
          this.container.appendChild(this.$el);
          document.body.appendChild(this.container);
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.section.querySelectorAll("a, button, input, textarea, select, details")].filter((el) => !el.hasAttribute("disabled") && el.tabIndex !== -1);
        },
        setFocusOnFirstFocusableItem() {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton.$el) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _hoisted_1$v = {
      appear: "",
      name: "fade"
    };
    const _hoisted_2$u = ["role", "tabindex", "aria-labelledby", "aria-describedby"];
    const _hoisted_3$q = { class: "slds-modal__container" };
    const _hoisted_4$p = ["id"];
    const _hoisted_5$n = ["id"];
    const _hoisted_6$g = { key: 1 };
    const _hoisted_7$d = {
      ref: "backdrop",
      key: "backdrop",
      class: "slds-backdrop-custom"
    };
    function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", _hoisted_1$v, [
        createBaseVNode("section", {
          ref: "section",
          key: "section",
          role: $props.prompt ? "alertdialog" : "dialog",
          tabindex: $props.prompt ? "0" : null,
          class: normalizeClass(["slds-modal-custom", $options.modalClass]),
          "aria-labelledby": $props.headless ? null : `modal-heading-${$data.modalId}`,
          "aria-describedby": `modal-content-${$data.modalId}`,
          onKeydown: [
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact"]), ["tab"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift"]), ["tab"])),
            _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.$emit("close"), ["stop"]), ["esc"]))
          ]
        }, [
          createBaseVNode("div", _hoisted_3$q, [
            createBaseVNode("header", {
              class: normalizeClass([$options.headerClasses, "slds-modal__header"])
            }, [
              !$props.hideCloseButton ? (openBlock(), createBlock(_component_ButtonIcon, {
                key: 0,
                ref: "closeButton",
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                class: "slds-modal__close slds-button_icon-inverse",
                assistiveText: $options.computedLabels.closeAssistiveText,
                title: $options.computedLabels.closeTitle,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
              !$props.headless ? (openBlock(), createElementBlock("h2", {
                key: 1,
                id: `modal-heading-${$data.modalId}`,
                class: "slds-text-heading_medium slds-hyphenate"
              }, toDisplayString(_ctx.decodeHtml($props.title)), 9, _hoisted_4$p)) : createCommentVNode("", true),
              !$props.headless ? renderSlot(_ctx.$slots, "tagline", { key: 2 }, void 0, true) : createCommentVNode("", true)
            ], 2),
            !$props.bodyless ? (openBlock(), createElementBlock("div", {
              key: 0,
              id: `modal-content-${$data.modalId}`,
              ref: "content",
              class: "slds-modal__content slds-p-around_medium slds-is-relative",
              onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("submit"), ["enter"]))
            }, [
              renderSlot(_ctx.$slots, "content", {}, () => [
                createTextVNode("default content")
              ], true)
            ], 40, _hoisted_5$n)) : createCommentVNode("", true),
            !$props.footless ? (openBlock(), createElementBlock("footer", {
              key: 1,
              class: normalizeClass(["slds-modal__footer", $options.footerClasses])
            }, [
              renderSlot(_ctx.$slots, "footer", {}, () => [
                $props.prompt ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
                }, toDisplayString($options.computedLabels.prompt), 1)) : (openBlock(), createElementBlock("span", _hoisted_6$g, " default footer "))
              ], true)
            ], 2)) : createCommentVNode("", true)
          ])
        ], 42, _hoisted_2$u),
        createBaseVNode("div", _hoisted_7$d, null, 512)
      ]);
    }
    const Modal = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$x], ["__scopeId", "data-v-7777abc4"]]);
    const alignmentPositions = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const defaultLabels$1 = () => ({
      closeTitle: "Close Dialog",
      closeAssistiveText: "Close Dialog"
    });
    const isAlignmentValid = (alignment) => Object.keys(alignmentPositions).find((value) => value === alignment);
    const _sfc_main$x = {
      name: "Popover",
      description: "Renders a SLDS-themed popover dialog",
      components: {
        ButtonIcon,
        Icon
      },
      directives: {
        "click-outside": clickOutside
      },
      props: {
        /**
         * Alignment of popover in relation to trigger element.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid(alignment);
          }
        },
        /**
         * `aria-label` for popover section element. If no Heading element is present, use this prop and set the value to be a meaningful title of the dialog
         */
        ariaLabel: {
          type: String,
          default: null
        },
        /**
         * Bind the dialog to a specific element.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to coordinates. Overrides bindTo.
         */
        bindToRect: {
          type: Object,
          default: () => {
          },
          validator: (value) => value.x && value.y
        },
        /**
         * Allow mouse click on elements outside popover to close popover.
         */
        closeOnClickOutside: Boolean,
        /**
         * Popover label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The rem set for the nubbin.
         */
        nubbinREM: {
          type: Number,
          default: 1.8
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for the popover.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Array of elements to allow scrolling without closing popover.
         */
        scrollElementsToIgnore: {
          type: Array,
          default: () => []
        },
        /**
         * Determines the type of the popover.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "error",
              "warning"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Sets width of popover.
         */
        width: {
          type: String,
          default: "small",
          validator: (value) => {
            const validThemes = [
              "small",
              "medium",
              "large",
              "x-large",
              "full-width"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid width prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      data() {
        return {
          container: null,
          el: null,
          focusableElements: [],
          triggerElement: null,
          popoverId: getGUID(),
          observer: null,
          popperInstance: () => {
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().popover || {} : {};
          return {
            ...defaultLabels$1(),
            ...globals,
            ...this.$props.labels
          };
        },
        widthClass() {
          return `slds-popover_${this.width}`;
        },
        popoverClass() {
          return this.theme !== "base" ? `slds-popover_${this.theme}` : "";
        },
        showHeader() {
          return this.$slots.header || this.$slots.custom;
        },
        showFooter() {
          return this.$slots.footer;
        },
        clickOutsideOptions() {
          return {
            active: this.closeOnClickOutside,
            handler: this.doHide
          };
        }
      },
      watch: {
        alignment() {
          if (isAlignmentValid(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions[this.$props.alignment]
            });
          }
        },
        width() {
          this.popperInstance.setOptions({
            placement: alignmentPositions[this.$props.alignment]
          });
        },
        "$props.bindTo": {
          handler() {
            if (!this.$props.bindTo)
              return;
            this.popperInstance.state.elements.reference = this.$props.bindTo;
            this.popperInstance.update();
          }
        }
      },
      mounted() {
        this.triggerElement = this.bindTo || document.activeElement || document.body;
        this.getFocusableElements();
        this.popperInstance = createPopper(this.triggerElement, this.$refs.popover, {
          strategy: this.position,
          placement: alignmentPositions[this.alignment],
          modifiers: [
            {
              name: "offset",
              options: {
                offset: ({ placement }) => {
                  if (placement.includes("end")) {
                    return [16, 16];
                  }
                  if (placement.includes("start")) {
                    return [-16, 16];
                  }
                  return [0, 16];
                }
              }
            },
            {
              name: "preventOverflow",
              options: {
                padding: this.$props.overflowPadding
              }
            }
          ]
        });
        this.observer = new MutationObserver(() => this.popperInstance.update());
        this.observer.observe(this.triggerElement, { attributes: true, childList: true, subtree: true });
        if (this.focusableElements.length) {
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        }
      },
      updated() {
        this.getFocusableElements();
      },
      beforeUnmount() {
        this.destroy();
      },
      methods: {
        doHide(e) {
          if (e) {
            if (e.type !== "scroll") {
              if (this.bindTo && this.bindTo.contains(e.target))
                return;
            } else {
              const isTargetInPopover = this.$refs.popover.contains(e.target);
              const targetIsInIgnoreList = this.scrollElementsToIgnore.includes(e.target) || this.scrollElementsToIgnore.some((el) => el && el.contains(e.target));
              if (isTargetInPopover || targetIsInIgnoreList)
                return;
            }
          }
          this.$emit("close", e);
        },
        destroy() {
          if (this.el)
            this.el.remove();
          if (this.container)
            this.container.remove();
          this.el = null;
          this.container = null;
          window.removeEventListener("scroll", this.doHide, true);
          this.triggerElement.focus();
          this.observer.disconnect();
          this.observer = null;
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.popover.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _withScopeId$a = (n) => (pushScopeId("data-v-ee69ade2"), n = n(), popScopeId(), n);
    const _hoisted_1$u = ["aria-describedby", "aria-labelledby", "aria-label"];
    const _hoisted_2$t = ["id"];
    const _hoisted_3$p = { class: "slds-media" };
    const _hoisted_4$o = { class: "slds-media__body" };
    const _hoisted_5$m = ["id"];
    const _hoisted_6$f = { class: "slds-text-heading_small" };
    const _hoisted_7$c = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_8$b = ["id"];
    const _hoisted_9$b = { class: "slds-media slds-media_center slds-has-flexi-truncate" };
    const _hoisted_10$7 = { class: "slds-media__figure" };
    const _hoisted_11$5 = { class: "slds-media__body" };
    const _hoisted_12$5 = { class: "slds-truncate slds-text-heading_medium" };
    const _hoisted_13$3 = ["id"];
    const _hoisted_14$3 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_15$4 = {
      key: 2,
      class: "slds-popover__footer"
    };
    const _hoisted_16$4 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Icon = resolveComponent("Icon");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("section", {
        ref: "popover",
        role: "dialog",
        "aria-describedby": `dialog-body-${$data.popoverId}`,
        "aria-labelledby": $options.showHeader ? `dialog-heading-${$data.popoverId}` : null,
        "aria-label": $props.ariaLabel,
        tabindex: "-1",
        class: normalizeClass([[$options.popoverClass, $options.widthClass], "slds-popover"]),
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact", "stop"]), ["tab"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift", "stop"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.doHide && $options.doHide(...args), ["stop"]), ["esc"]))
        ]
      }, [
        createVNode(_component_ButtonIcon, {
          ref: "closeButton",
          variant: $props.theme === "error" ? "inverse" : "bare",
          title: $options.computedLabels.closeTitle,
          class: "slds-float_right slds-popover__close",
          iconCategory: "utility",
          size: "small",
          iconName: "close",
          assistiveText: $options.computedLabels.closeAssistiveText,
          onClick: withModifiers($options.doHide, ["stop"])
        }, null, 8, ["variant", "title", "assistiveText", "onClick"]),
        $props.theme === "base" ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: `dialog-body-${$data.popoverId}`,
          class: "slds-popover__body"
        }, [
          createBaseVNode("div", _hoisted_3$p, [
            createBaseVNode("div", _hoisted_4$o, [
              $options.showHeader ? (openBlock(), createElementBlock("header", {
                key: 0,
                id: `dialog-heading-${$data.popoverId}`,
                class: "slds-popover__header"
              }, [
                renderSlot(_ctx.$slots, "custom", {}, () => [
                  createBaseVNode("h2", _hoisted_6$f, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ], true)
              ], 8, _hoisted_5$m)) : createCommentVNode("", true)
            ])
          ]),
          renderSlot(_ctx.$slots, "content", {}, () => [
            _hoisted_7$c
          ], true)
        ], 8, _hoisted_2$t)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $options.showHeader ? (openBlock(), createElementBlock("header", {
            key: 0,
            id: `dialog-heading-${$data.popoverId}`,
            class: "slds-popover__header"
          }, [
            createBaseVNode("div", _hoisted_9$b, [
              renderSlot(_ctx.$slots, "custom", {}, () => [
                createBaseVNode("div", _hoisted_10$7, [
                  $props.theme !== "base" ? (openBlock(), createBlock(_component_Icon, {
                    key: 0,
                    category: "utility",
                    name: _ctx.$props.theme,
                    variant: "inverse",
                    iconClass: ["slds-icon", "slds-icon_x-small"]
                  }, null, 8, ["name"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_11$5, [
                  createBaseVNode("h2", _hoisted_12$5, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ])
              ], true)
            ])
          ], 8, _hoisted_8$b)) : createCommentVNode("", true),
          createBaseVNode("div", {
            id: `dialog-body-${$data.popoverId}`,
            class: "slds-popover__body"
          }, [
            renderSlot(_ctx.$slots, "content", {}, () => [
              _hoisted_14$3
            ], true)
          ], 8, _hoisted_13$3)
        ], 64)),
        $options.showFooter ? (openBlock(), createElementBlock("footer", _hoisted_15$4, [
          renderSlot(_ctx.$slots, "footer", {}, void 0, true)
        ])) : createCommentVNode("", true),
        _hoisted_16$4
      ], 42, _hoisted_1$u)), [
        [_directive_click_outside, void 0, $options.clickOutsideOptions]
      ]);
    }
    const Popover = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$w], ["__scopeId", "data-v-ee69ade2"]]);
    const defaultLabels = () => ({
      name: null,
      required: "Required"
    });
    const _sfc_main$w = {
      components: { Tooltip },
      props: {
        /**
         * Disable all radio inputs.
         */
        disabled: Boolean,
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Indicates that the radio group is in an invalid state.
         */
        invalid: Boolean,
        /**
         * Label object for the radio group.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Selected value for the radio group.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * options needs to be an array of objects with label and value (optionally disabled).
         */
        options: {
          type: Array,
          required: true
        },
        /**
         * Read only state for the radio group.
         */
        readonly: Boolean,
        /**
         * Adds an indicator that this field is required.
         */
        required: Boolean
      },
      data() {
        return {
          guid: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().radio || {} : {};
          return {
            ...defaultLabels(),
            ...globals,
            ...this.$props.labels
          };
        },
        input: {
          get() {
            return this.$props.modelValue;
          },
          set(val) {
            this.$emit("update:modelValue", val);
          }
        }
      }
    };
    const BaseRadio = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["__scopeId", "data-v-20f14d8f"]]);
    const _sfc_main$v = {
      name: "RadioButtonGroup",
      extends: BaseRadio,
      mixins: [decodeHtml]
    };
    const _hoisted_1$t = {
      key: 0,
      class: "slds-form-element__legend slds-form-element__label"
    };
    const _hoisted_2$s = ["title"];
    const _hoisted_3$o = { class: "slds-form-element__control" };
    const _hoisted_4$n = {
      key: 0,
      class: "slds-radio_button-group"
    };
    const _hoisted_5$l = ["id", "name", "value", "disabled", "aria-describedby"];
    const _hoisted_6$e = ["for"];
    const _hoisted_7$b = { class: "slds-radio_faux" };
    const _hoisted_8$a = {
      key: 1,
      class: "readonly-radio-label"
    };
    const _hoisted_9$a = ["id"];
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("fieldset", {
        class: normalizeClass([{ "slds-has-error": _ctx.$props.invalid }, "slds-form-element"])
      }, [
        _ctx.computedLabels.name ? (openBlock(), createElementBlock("legend", _hoisted_1$t, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: _ctx.computedLabels.required
          }, "*", 8, _hoisted_2$s)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml(_ctx.computedLabels.name)), 1)
        ])) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$o, [
          !_ctx.$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_4$n, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
              return openBlock(), createElementBlock("span", {
                key: index,
                class: "slds-button slds-radio_button"
              }, [
                withDirectives(createBaseVNode("input", {
                  id: _ctx.guid + index,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.input = $event),
                  class: normalizeClass({ "ma-is-selected": _ctx.input === option.value }),
                  name: _ctx.guid,
                  value: option.value,
                  disabled: _ctx.$props.disabled || option.disabled,
                  "aria-describedby": _ctx.$props.invalid ? `error-${_ctx.guid}` : null,
                  type: "radio"
                }, null, 10, _hoisted_5$l), [
                  [vModelRadio, _ctx.input]
                ]),
                createBaseVNode("label", {
                  class: "slds-radio_button__label",
                  for: _ctx.guid + index
                }, [
                  createBaseVNode("span", _hoisted_7$b, toDisplayString(_ctx.decodeHtml(option.label)), 1)
                ], 8, _hoisted_6$e)
              ]);
            }), 128))
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$a, toDisplayString(_ctx.decodeHtml(_ctx.$props.modelValue) || " "), 1))
        ]),
        _ctx.$props.invalid ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: `error-${_ctx.guid}`,
          class: "slds-form-element__help"
        }, [
          renderSlot(_ctx.$slots, "errors")
        ], 8, _hoisted_9$a)) : createCommentVNode("", true)
      ], 2);
    }
    const RadioButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$v]]);
    const _sfc_main$u = {
      name: "RadioGroup",
      extends: BaseRadio,
      mixins: [decodeHtml]
    };
    const _hoisted_1$s = {
      key: 0,
      class: "slds-form-element__label"
    };
    const _hoisted_2$r = ["title"];
    const _hoisted_3$n = {
      key: 2,
      class: "slds-form-element__control",
      style: { "position": "relative" }
    };
    const _hoisted_4$m = ["id", "name", "value", "disabled", "aria-describedby"];
    const _hoisted_5$k = ["for"];
    const _hoisted_6$d = /* @__PURE__ */ createBaseVNode("span", { class: "slds-radio_faux" }, null, -1);
    const _hoisted_7$a = { class: "slds-form-element__label" };
    const _hoisted_8$9 = {
      key: 3,
      class: "slds-form-element__control readonly-radio-label"
    };
    const _hoisted_9$9 = ["id"];
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("fieldset", {
        class: normalizeClass([{ "slds-has-error": _ctx.$props.invalid }, "slds-form-element"])
      }, [
        _ctx.computedLabels.name ? (openBlock(), createElementBlock("label", _hoisted_1$s, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: _ctx.computedLabels.required
          }, "*", 8, _hoisted_2$r)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml(_ctx.computedLabels.name)), 1)
        ])) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        !_ctx.$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_3$n, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
            return openBlock(), createElementBlock("span", {
              key: index,
              class: "slds-radio"
            }, [
              withDirectives(createBaseVNode("input", {
                id: _ctx.guid + index,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.input = $event),
                name: _ctx.guid,
                value: option.value,
                disabled: _ctx.$props.disabled || option.disabled,
                "aria-describedby": _ctx.$props.invalid ? `error-${_ctx.guid}` : null,
                type: "radio"
              }, null, 8, _hoisted_4$m), [
                [vModelRadio, _ctx.input]
              ]),
              createBaseVNode("label", {
                for: _ctx.guid + index,
                class: "slds-radio__label"
              }, [
                _hoisted_6$d,
                createBaseVNode("span", _hoisted_7$a, toDisplayString(_ctx.decodeHtml(option.label)), 1)
              ], 8, _hoisted_5$k)
            ]);
          }), 128))
        ])) : (openBlock(), createElementBlock("div", _hoisted_8$9, toDisplayString(_ctx.decodeHtml(_ctx.$props.modelValue) || " "), 1)),
        _ctx.$props.invalid ? (openBlock(), createElementBlock("div", {
          key: 4,
          id: `error-${_ctx.guid}`,
          class: "slds-form-element__help"
        }, [
          renderSlot(_ctx.$slots, "errors")
        ], 8, _hoisted_9$9)) : createCommentVNode("", true)
      ], 2);
    }
    const RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$u]]);
    const stateMap = /* @__PURE__ */ new Map();
    stateMap.set("info", {
      divClass: "slds-theme_info"
    });
    stateMap.set("success", {
      divClass: "slds-theme_success"
    });
    stateMap.set("warning", {
      divClass: "slds-theme_warning"
    });
    stateMap.set("error", {
      divClass: "slds-theme_error"
    });
    const _sfc_main$t = {
      name: "ToastContainer",
      components: {
        ButtonIcon,
        Icon
      },
      mixins: [decodeHtml],
      props: {
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          stateMap
        };
      }
    };
    const _hoisted_1$r = { class: "slds-assistive-text" };
    const _hoisted_2$q = { class: "slds-notify__content" };
    const _hoisted_3$m = { class: "slds-text-heading_small" };
    const _hoisted_4$l = { key: 0 };
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createBlock(TransitionGroup, {
        name: "slide",
        tag: "div"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.toasts, (toast) => {
            return openBlock(), createElementBlock("div", {
              key: toast.$__id,
              class: normalizeClass([$data.stateMap.get(toast.state).divClass, "slds-notify slds-notify_toast"]),
              role: "status"
            }, [
              createBaseVNode("span", _hoisted_1$r, toDisplayString(toast.state), 1),
              createVNode(_component_Icon, {
                category: "utility",
                name: toast.state,
                size: "small",
                variant: "none",
                class: "slds-icon_container slds-m-right_small slds-no-flex slds-align-top"
              }, null, 8, ["name"]),
              createBaseVNode("div", _hoisted_2$q, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createBaseVNode("h2", _hoisted_3$m, toDisplayString(_ctx.decodeHtml(toast.message)), 1),
                  toast.subMessage ? (openBlock(), createElementBlock("p", _hoisted_4$l, toDisplayString(_ctx.decodeHtml(toast.subMessage)), 1)) : createCommentVNode("", true)
                ], true)
              ]),
              createVNode(_component_ButtonIcon, {
                title: toast.closeLabel,
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                variant: "inverse",
                class: "slds-notify__close",
                assistiveText: toast.closeLabel,
                onClick: ($event) => _ctx.$parent.close(toast.$__id)
              }, null, 8, ["title", "assistiveText", "onClick"])
            ], 2);
          }), 128))
        ]),
        _: 3
      });
    }
    const ToastContainer = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$t], ["__scopeId", "data-v-f8233d6c"]]);
    const _sfc_main$s = {
      name: "Toast",
      components: { ToastContainer },
      props: {
        /**
         * Array of toasts. Each toast object should have `position`, `state`, `message` and optionally `submessage` properties.
         */
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          timeoutMap: /* @__PURE__ */ new Map(),
          callbackMap: /* @__PURE__ */ new Map()
        };
      },
      computed: {
        topCenterToasts() {
          return this.toasts.filter((toast) => toast.position === "top-center");
        },
        topRightToasts() {
          return this.toasts.filter((toast) => toast.position === "top-right");
        },
        bottomRightToasts() {
          return this.toasts.filter((toast) => toast.position === "bottom-right");
        }
      },
      watch: {
        toasts: {
          handler(value) {
            value.forEach((toast) => {
              if (!Object.prototype.hasOwnProperty.call(toast, "$__id")) {
                if (!toast.state) {
                  toast.state = "info";
                }
                if (!toast.closeLabel) {
                  toast.closeLabel = "Close";
                }
                if (!toast.position) {
                  toast.position = "top-center";
                }
                const guid = getGUID();
                toast.$__id = guid;
                if (typeof toast.onClose === "function") {
                  this.callbackMap.set(guid, toast.onClose);
                }
                if (toast.duration > 0) {
                  this.timeoutMap.set(guid, setTimeout(this.close.bind(this, guid), toast.duration));
                }
              }
            });
          },
          immediate: true,
          deep: true
        }
      },
      beforeUnmount() {
        this.timeoutMap.forEach((timeoutId) => clearTimeout(timeoutId));
      },
      methods: {
        close(id) {
          this.$emit("close", id);
          const indexToRemove = this.toasts.findIndex((toast) => toast.$__id === id);
          const newToasts = this.toasts.splice(indexToRemove, 1);
          this.$emit("input", newToasts);
          this.$emit("update:toasts", newToasts);
          if (this.timeoutMap.has(id)) {
            clearTimeout(this.timeoutMap.get(id));
            this.timeoutMap.delete(id);
          }
          if (this.callbackMap.has(id)) {
            this.callbackMap.get(id)();
          }
        }
      }
    };
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ToastContainer = resolveComponent("ToastContainer");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_ToastContainer, {
          toasts: $options.topCenterToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_vertical-reverse"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.bottomRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_bottom-right slds-grid_vertical-align-end"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.topRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_top-right slds-grid_vertical-reversee"
        }, null, 8, ["toasts"])
      ]);
    }
    const Toasts = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$s], ["__scopeId", "data-v-339e5872"]]);
    const _sfc_main$r = {
      name: "DuelingPicklist",
      components: {
        ButtonIcon,
        Icon
      },
      props: ["labels", "fields"],
      computed: {
        availableFields() {
          return this.fields.filter((f) => !f.selected);
        },
        selectedFields() {
          return this.fields.filter((f) => f.selected).sort((a, b) => {
            if (a.order < b.order)
              return -1;
            if (a.order > b.order)
              return 1;
            return 0;
          }).map((f, i) => Object.assign(f, { order: i + 1 }));
        }
      },
      methods: {
        moveToSelected() {
          this.availableFields.filter((f) => f.active).forEach((f) => {
            if (f.locked)
              return;
            f.selected = true;
            f.active = false;
            f.order = this.selectedFields.length + 1;
          });
        },
        moveToAvailable() {
          this.selectedFields.filter((f) => f.active).forEach((f) => {
            f.selected = false;
            f.active = false;
          });
          this.selectedFields.forEach((f, i) => f.order = i + 1);
        },
        moveUp() {
          this.selectedFields.forEach((f, i) => {
            if (f.active && f.order > 1) {
              this.selectedFields[i - 1].order += 1;
              f.order -= 1;
            }
          });
        },
        moveDown() {
          this.selectedFields.forEach((f, i) => {
            if (f.active && f.order < this.selectedFields.length) {
              this.selectedFields[i + 1].order -= 1;
              f.order += 1;
            }
          });
        }
      }
    };
    const _hoisted_1$q = { key: 0 };
    const _hoisted_2$p = { class: "slds-form-element__label" };
    const _hoisted_3$l = { class: "slds-dueling-list" };
    const _hoisted_4$k = { class: "slds-dueling-list__column slds-size_5-of-12" };
    const _hoisted_5$j = {
      class: "slds-form-element__label",
      style: { "position": "relative" }
    };
    const _hoisted_6$c = { style: { "position": "absolute", "top": "0", "right": "0" } };
    const _hoisted_7$9 = {
      class: "slds-dueling-list__options",
      style: { "width": "auto" }
    };
    const _hoisted_8$8 = {
      "aria-multiselectable": "true",
      class: "slds-listbox slds-listbox_vertical",
      role: "listbox"
    };
    const _hoisted_9$8 = ["onClick"];
    const _hoisted_10$6 = ["aria-selected", "aria-disabled"];
    const _hoisted_11$4 = { class: "slds-media__body slds-grid" };
    const _hoisted_12$4 = ["title"];
    const _hoisted_13$2 = ["title"];
    const _hoisted_14$2 = {
      key: 2,
      class: "slds-icon_container slds-current-color"
    };
    const _hoisted_15$3 = { class: "slds-dueling-list__column" };
    const _hoisted_16$3 = { class: "slds-dueling-list__column slds-size_5-of-12" };
    const _hoisted_17$3 = { class: "slds-form-element__label" };
    const _hoisted_18$3 = {
      class: "slds-dueling-list__options",
      style: { "width": "auto" }
    };
    const _hoisted_19$3 = {
      "aria-multiselectable": "true",
      class: "slds-listbox slds-listbox_vertical",
      role: "listbox"
    };
    const _hoisted_20$3 = ["onClick"];
    const _hoisted_21$2 = ["aria-selected", "aria-disabled"];
    const _hoisted_22$1 = { class: "slds-media__body" };
    const _hoisted_23$1 = ["title"];
    const _hoisted_24$1 = {
      key: 0,
      class: "slds-icon_container slds-current-color"
    };
    const _hoisted_25$1 = { class: "slds-dueling-list__column" };
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      var _a, _b, _c;
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        ((_a = $props.labels) == null ? void 0 : _a.name) ? (openBlock(), createElementBlock("div", _hoisted_1$q, [
          createBaseVNode("label", _hoisted_2$p, [
            createBaseVNode("strong", null, toDisplayString($props.labels.name), 1)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$l, [
          createBaseVNode("div", _hoisted_4$k, [
            createBaseVNode("span", _hoisted_5$j, [
              createTextVNode(toDisplayString(((_b = $props.labels) == null ? void 0 : _b.available) || "Available") + " ", 1),
              createBaseVNode("div", _hoisted_6$c, [
                createBaseVNode("button", {
                  class: "slds-button slds-m-around_none",
                  onClick: _cache[0] || (_cache[0] = ($event) => {
                    $props.fields.forEach((f, i) => {
                      if (!f.locked)
                        f.selected = true;
                      f.active = false;
                      f.order = i + 1;
                    });
                  })
                }, "Select All"),
                createTextVNode(" | "),
                createBaseVNode("button", {
                  class: "slds-button slds-m-around_none",
                  onClick: _cache[1] || (_cache[1] = ($event) => {
                    $props.fields.filter((f) => !f.locked).forEach((f) => {
                      f.selected = false;
                      f.active = false;
                      f.locked = f.message ? true : false;
                    });
                  })
                }, "None")
              ])
            ]),
            createBaseVNode("div", _hoisted_7$9, [
              createBaseVNode("ul", _hoisted_8$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.availableFields, (field, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    role: "presentation",
                    class: "slds-listbox__item",
                    onClick: ($event) => field.active = !field.active && !field.locked
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline", { active: field.active }]),
                      "aria-selected": field.active,
                      role: "option",
                      "aria-disabled": field.locked
                    }, [
                      createBaseVNode("span", _hoisted_11$4, [
                        field.locked ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: "slds-truncate",
                          title: `${field.message}`
                        }, toDisplayString(field.label), 9, _hoisted_12$4)) : (openBlock(), createElementBlock("span", {
                          key: 1,
                          class: "slds-truncate",
                          title: field.label
                        }, toDisplayString(field.label), 9, _hoisted_13$2)),
                        field.locked ? (openBlock(), createElementBlock("span", _hoisted_14$2, [
                          createVNode(_component_Icon, {
                            category: "utility",
                            name: "warning",
                            size: "x-small",
                            class: "slds-media__figure slds-media__figure_reverse"
                          })
                        ])) : createCommentVNode("", true)
                      ]),
                      renderSlot(_ctx.$slots, "fieldEnd", normalizeProps(guardReactiveProps({ field })))
                    ], 10, _hoisted_10$6)
                  ], 8, _hoisted_9$8);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$3, [
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection to Second Category",
              iconCategory: "utility",
              iconName: "right",
              title: "Move Selection to Second Category",
              variant: "container",
              onClick: $options.moveToSelected
            }, null, 8, ["onClick"]),
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection to First Category",
              iconCategory: "utility",
              iconName: "left",
              title: "Move Selection to First Category",
              variant: "container",
              onClick: $options.moveToAvailable
            }, null, 8, ["onClick"])
          ]),
          createBaseVNode("div", _hoisted_16$3, [
            createBaseVNode("span", _hoisted_17$3, toDisplayString(((_c = $props.labels) == null ? void 0 : _c.selected) || "Selected"), 1),
            createBaseVNode("div", _hoisted_18$3, [
              createBaseVNode("ul", _hoisted_19$3, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.selectedFields, (field, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    role: "presentation",
                    class: "slds-listbox__item",
                    onClick: ($event) => field.active = !field.active && !field.locked
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline", { active: field.active }]),
                      "aria-selected": field.active,
                      "aria-disabled": field.locked,
                      role: "option"
                    }, [
                      createBaseVNode("span", _hoisted_22$1, [
                        createBaseVNode("span", {
                          class: "slds-truncate",
                          title: field.label
                        }, toDisplayString(field.label), 9, _hoisted_23$1)
                      ]),
                      field.locked ? (openBlock(), createElementBlock("span", _hoisted_24$1, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: "lock",
                          size: "x-small",
                          class: "slds-media__figure slds-media__figure_reverse"
                        })
                      ])) : createCommentVNode("", true),
                      renderSlot(_ctx.$slots, "fieldEnd", normalizeProps(guardReactiveProps({ field })))
                    ], 10, _hoisted_21$2)
                  ], 8, _hoisted_20$3);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_25$1, [
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection Up",
              iconCategory: "utility",
              iconName: "up",
              title: "Move Selection Up",
              variant: "container",
              onClick: $options.moveUp
            }, null, 8, ["onClick"]),
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection Down",
              iconCategory: "utility",
              iconName: "down",
              title: "Move Selection Down",
              variant: "container",
              onClick: $options.moveDown
            }, null, 8, ["onClick"])
          ])
        ])
      ]);
    }
    const DuelingPicklist = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
    const _sfc_main$q = {
      name: "ConfirmationModal",
      components: {
        Button: SLDSButton,
        Modal,
        Spinner
      },
      props: ["column"],
      emits: ["close"],
      data() {
        return {
          loadingMsg: "Deleting Column...",
          loading: false
        };
      },
      computed: {
        headerTitle() {
          const headerTitle = `Delete "${this.column.id}" Column`;
          return headerTitle;
        }
      },
      methods: {
        async deleteColumn(column) {
          var _a, _b, _c;
          this.loading = true;
          if (((_c = (_b = (_a = SPM.Components) == null ? void 0 : _a.ConfigureColumn) == null ? void 0 : _b.column) == null ? void 0 : _c.id) === column.id)
            SPM.Components.Root.rightPanelConfig = null;
          SPM.Utils.Arr.splice(SPM.Components.Root.plan._columns, (c) => c.id === column.id);
          SPM.Utils.Arr.splice(SPM.Components.Root.preferences.columns, (c) => c.id === column.id);
          Object.values(SPM.Components.Root.nodeMap).forEach((node) => {
            if (column.type === "Quota") {
              delete node._data[`${column.id}:Quota`];
              delete node._data[`${column.id}:Target`];
              delete node._data[`${column.id}:Remaining`];
            } else {
              delete node._data[column.id];
            }
            SPM.Utils.Quota.Node.update(node);
          });
          SPM.Components.Root.calculateNodes();
          SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
          await Promise.all([
            SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] }),
            SPM.Utils.CRM.upsert({ records: Object.values(SPM.Components.Root.nodeMap).filter((node) => node.Id !== "all_org") })
          ]);
          this.loading = false;
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$p = /* @__PURE__ */ createBaseVNode("div", null, "Are you sure you want to delete this column?", -1);
    const _hoisted_2$o = { class: "slds-grid" };
    const _hoisted_3$k = { class: "slds-col_bump-left" };
    function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        size: "base",
        title: $options.headerTitle,
        onClose: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          _hoisted_1$p
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_2$o, [
            createBaseVNode("div", _hoisted_3$k, [
              createVNode(_component_Button, {
                class: "slds-button slds-button_neutral",
                label: "Cancel",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }),
              createVNode(_component_Button, {
                class: "slds-button slds-button_brand",
                label: "Delete",
                onClick: _cache[1] || (_cache[1] = ($event) => $options.deleteColumn($props.column))
              })
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const ConfirmationModal = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
    const _sfc_main$p = {
      name: "ConfigureColumns",
      components: {
        DuelingPicklist,
        ConfirmationModal,
        // slds vue
        ButtonIcon
      },
      data() {
        return {
          columns: [],
          showConfirmationModal: false,
          editingColumn: null
        };
      },
      computed: {
        planColumns() {
          return SPM.Components.Root.plan._columns;
        },
        preferenceColumns() {
          return SPM.Components.Root.preferences.columns;
        }
      },
      watch: {
        columns: {
          handler() {
            const newPreferences = this.columns.filter((c) => c.selected).sort((a, b) => SPM.Utils.Obj.compare(a, b, "order")).map((c) => ({ id: c.id }));
            if (JSON.stringify(newPreferences) !== JSON.stringify(SPM.Components.Root.preferences.columns)) {
              SPM.Components.Root.preferences.columns = this.columns.filter((c) => c.selected).sort((a, b) => SPM.Utils.Obj.compare(a, b, "order")).map((c) => ({ id: c.id }));
            }
          },
          deep: true
        },
        planColumns: {
          handler() {
            this.loadColumns();
          },
          deep: true
        },
        preferenceColumns: {
          handler() {
            this.loadColumns();
          },
          deep: true
        }
      },
      async mounted() {
        SPM.Components.ConfigureColumns = this;
        this.loadColumns();
      },
      methods: {
        showDeleteModal(column) {
          this.editingColumn = column;
          this.showConfirmationModal = true;
        },
        loadColumns() {
          const activeColumnIds = this.columns.filter((c) => c.active).map((c) => c.id);
          this.columns = SPM.Components.Root.plan._columns.filter((c) => c.hasOwnProperty("id")).map((c) => {
            const preferenceIndex = SPM.Components.Root.preferences.columns.findIndex(({ id }) => id === c.id);
            return {
              ...c,
              label: c.id,
              selected: preferenceIndex !== -1,
              order: preferenceIndex,
              active: activeColumnIds.includes(c.id)
            };
          });
        },
        editColumn({ id }) {
          SPM.Components.TerritoryTable.editColumn(SPM.Components.Root.plan._columns.find((c) => c.id === id));
        }
      }
    };
    const _hoisted_1$o = { class: "column-buttons slds-col_bump-left" };
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_DuelingPicklist = resolveComponent("DuelingPicklist");
      const _component_ConfirmationModal = resolveComponent("ConfirmationModal");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_DuelingPicklist, {
          labels: { available: "Hidden", selected: "Visible" },
          fields: $data.columns
        }, {
          fieldEnd: withCtx(({ field }) => [
            createBaseVNode("div", _hoisted_1$o, [
              createVNode(_component_ButtonIcon, {
                iconCategory: "utility",
                iconName: "edit",
                title: `Edit ${field.id}`,
                assistiveText: `Edit ${field.id}`,
                onClick: withModifiers(($event) => $options.editColumn(field), ["stop"])
              }, null, 8, ["title", "assistiveText", "onClick"]),
              createVNode(_component_ButtonIcon, {
                iconCategory: "utility",
                iconName: "delete",
                title: `Delete ${field.id}`,
                assistiveText: `Delete ${field.id}`,
                onClick: withModifiers(($event) => $options.showDeleteModal(field), ["stop"])
              }, null, 8, ["title", "assistiveText", "onClick"])
            ])
          ]),
          _: 1
        }, 8, ["fields"]),
        $data.showConfirmationModal ? (openBlock(), createBlock(_component_ConfirmationModal, {
          key: 0,
          column: $data.editingColumn,
          onClose: _cache[0] || (_cache[0] = ($event) => {
            $data.editingColumn = null;
            $data.showConfirmationModal = false;
          })
        }, null, 8, ["column"])) : createCommentVNode("", true)
      ]);
    }
    const ConfigureColumns = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__scopeId", "data-v-e166e411"]]);
    const _sfc_main$o = {
      name: "LeftPanel",
      components: {
        ConfigureColumns,
        // slds vue
        ButtonIcon,
        Spinner
      },
      data() {
        return {
          loadingMsg: ""
        };
      },
      async mounted() {
        SPM.Components.LeftPanel = this;
      },
      methods: {
        addColumn() {
          SPM.Components.TerritoryTable.addColumn(SPM.Components.Root.preferences.columns.length);
        },
        // panel
        close() {
          SPM.Components.Root.leftPanelConfig = null;
        }
      }
    };
    const _withScopeId$9 = (n) => (pushScopeId("data-v-c66b18a8"), n = n(), popScopeId(), n);
    const _hoisted_1$n = { class: "slds-panel slds-panel_docked slds-panel_docked-left slds-size_x-large slds-grid slds-grid_vertical" };
    const _hoisted_2$n = { class: "slds-panel__header" };
    const _hoisted_3$j = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("h2", { class: "slds-panel__header-title slds-text-heading_small slds-truncate" }, "Columns", -1));
    const _hoisted_4$j = { class: "slds-panel__header-actions" };
    const _hoisted_5$i = { class: "slds-panel__body slds-grid slds-grid_vertical slds-grow" };
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ConfigureColumns = resolveComponent("ConfigureColumns");
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$n, [
          _hoisted_3$j,
          createBaseVNode("div", _hoisted_4$j, [
            createBaseVNode("button", {
              class: "slds-button slds-button_neutral slds-m-right_small",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.addColumn && $options.addColumn(...args))
            }, "New"),
            createVNode(_component_ButtonIcon, {
              iconCategory: "utility",
              iconName: "close",
              title: "Collapse Panel",
              assistiveText: "Collapse Panel",
              onClick: $options.close
            }, null, 8, ["onClick"])
          ])
        ]),
        createBaseVNode("div", _hoisted_5$i, [
          createVNode(_component_ConfigureColumns)
        ])
      ]);
    }
    const LeftPanel = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o], ["__scopeId", "data-v-c66b18a8"]]);
    const _sfc_main$n = {
      name: "Selectlist",
      components: {
        Icon
      },
      props: ["labels", "options", "modelValue", "size", "disabled"],
      data() {
        return {
          id: getGUID(),
          selectedOption: this.modelValue
        };
      },
      watch: {
        modelValue() {
          this.selectedOption = this.modelValue;
        },
        selectedOption() {
          this.$emit("update:modelValue", this.selectedOption);
        }
      },
      methods: {
        selectOption(id) {
          if (!this.disabled)
            this.selectedOption = id;
        }
      }
    };
    const _hoisted_1$m = { key: 0 };
    const _hoisted_2$m = { class: "slds-form-element__label" };
    const _hoisted_3$i = { class: "spm-selectlist" };
    const _hoisted_4$i = ["onClick"];
    const _hoisted_5$h = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_6$b = { class: "slds-radio" };
    const _hoisted_7$8 = ["name", "id", "value", "disabled"];
    const _hoisted_8$7 = ["for"];
    const _hoisted_9$7 = /* @__PURE__ */ createBaseVNode("span", { class: "slds-radio_faux" }, null, -1);
    const _hoisted_10$5 = [
      _hoisted_9$7
    ];
    const _hoisted_11$3 = { class: "slds-m-left_small" };
    const _hoisted_12$3 = {
      key: 0,
      style: { "color": "#747474" }
    };
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", null, [
        ((_a = $props.labels) == null ? void 0 : _a.name) ? (openBlock(), createElementBlock("div", _hoisted_1$m, [
          createBaseVNode("label", _hoisted_2$m, toDisplayString($props.labels.name), 1)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$i, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option) => {
            return openBlock(), createElementBlock("div", {
              key: option.id,
              class: normalizeClass(["slds-p-horizontal_medium", `slds-p-vertical_${$props.size || "medium"}`]),
              onClick: ($event) => $options.selectOption(option.id)
            }, [
              createBaseVNode("div", _hoisted_5$h, [
                createBaseVNode("span", _hoisted_6$b, [
                  withDirectives(createBaseVNode("input", {
                    name: `assignment-distribution-method-${option.id}`,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.selectedOption = $event),
                    type: "radio",
                    id: `${$data.id}${option.id}`,
                    value: option.id,
                    disabled: !!$props.disabled
                  }, null, 8, _hoisted_7$8), [
                    [vModelRadio, $data.selectedOption]
                  ]),
                  createBaseVNode("label", {
                    class: "slds-radio__label",
                    for: `${$data.id}${option.id}`
                  }, _hoisted_10$5, 8, _hoisted_8$7)
                ]),
                option.icon ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  category: "utility",
                  name: option.icon,
                  size: "x-small",
                  class: "slds-m-left_small"
                }, null, 8, ["name"])) : createCommentVNode("", true),
                createBaseVNode("div", _hoisted_11$3, [
                  createBaseVNode("div", {
                    class: "slds-form-element__label",
                    style: normalizeStyle(!!option.description ? "font-weight: 600" : "")
                  }, toDisplayString(option.label), 5),
                  option.description ? (openBlock(), createElementBlock("div", _hoisted_12$3, toDisplayString(option.description), 1)) : createCommentVNode("", true)
                ])
              ]),
              $data.selectedOption === option.id ? renderSlot(_ctx.$slots, "selected", normalizeProps(mergeProps({ key: 0 }, { option }))) : createCommentVNode("", true)
            ], 10, _hoisted_4$i);
          }), 128))
        ])
      ]);
    }
    const Selectlist = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
    const _sfc_main$m = {
      name: "ExpressionInput",
      components: {
        TextInput
      },
      props: ["modelValue", "labels", "options", "errors"],
      emits: ["update:modelValue"],
      data() {
        return {
          expression: this.modelValue || "",
          showSuggest: false,
          suggestTerm: "",
          suggestResults: [],
          suggestActiveIndex: 0,
          suggestPosition: null
        };
      },
      watch: {
        modelValue() {
          this.expression = this.modelValue;
        },
        expression() {
          this.$emit("update:modelValue", this.expression);
        }
      },
      methods: {
        updateSuggestResults() {
          const textarea = this.$refs.expression.$el.querySelector("textarea");
          for (let i = textarea.selectionEnd; i >= 0; i--) {
            if (textarea.value[i] === "]") {
              this.showSuggest = false;
              return;
            }
            if (textarea.value[i] === "[") {
              let suggestTermEnd = textarea.selectionEnd;
              for (let j = textarea.selectionEnd; j < textarea.value.length; j++) {
                if (textarea.value[j] === "]") {
                  suggestTermEnd = j;
                  break;
                }
              }
              const searchTerm = textarea.value.substring(i + 1, suggestTermEnd).toLowerCase();
              this.suggestResults = this.options.filter((columnId) => !searchTerm || columnId.toLowerCase().includes(searchTerm));
              this.suggestPosition = SPM.Utils.Browser.getCursorPosition(textarea, i, { top: 45 });
              if (!this.showSuggest) {
                this.showSuggest = true;
                this.suggestActiveIndex = 0;
              }
              return;
            }
          }
          this.showSuggest = false;
        },
        insertVariable(result) {
          this.showSuggest = false;
          const textarea = this.$refs.expression.$el.querySelector("textarea");
          let suggestTermStart = 1;
          let suggestTermEnd = textarea.selectionEnd;
          for (let i = textarea.selectionEnd; i >= 0; i--) {
            if (textarea.value[i] === "[") {
              suggestTermStart = i + 1;
              for (let j = textarea.selectionEnd; j < textarea.value.length; j++) {
                if (textarea.value[j] === "[") {
                  break;
                }
                if (textarea.value[j] === "]") {
                  suggestTermEnd = j;
                  break;
                }
              }
              break;
            }
          }
          this.expression = `${textarea.value.substring(0, suggestTermStart)}${result}]${textarea.value.substring(suggestTermEnd + 1)}`;
          const newCursorPosition = suggestTermStart + result.length + 1;
          setTimeout(() => {
            textarea.setSelectionRange(newCursorPosition, newCursorPosition);
            textarea.focus();
          }, 100);
        },
        onExpressionKeydown(e) {
          if (!this.showSuggest)
            return;
          if (e.key === "Enter" || e.key === "Tab") {
            e.preventDefault();
            this.insertVariable(this.suggestResults[this.suggestActiveIndex]);
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            this.suggestActiveIndex = Math.max(this.suggestActiveIndex - 1, 0);
          }
          if (e.key === "ArrowDown") {
            e.preventDefault();
            this.suggestActiveIndex = Math.min(this.suggestActiveIndex + 1, this.suggestResults.length - 1);
          }
        },
        hideSuggest() {
          this.showSuggest = false;
        }
      }
    };
    const _withScopeId$8 = (n) => (pushScopeId("data-v-f0381051"), n = n(), popScopeId(), n);
    const _hoisted_1$l = { style: { "position": "relative" } };
    const _hoisted_2$l = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("div", { class: "hint" }, "For column options, enter [.", -1));
    const _hoisted_3$h = { class: "slds-dropdown__list" };
    const _hoisted_4$h = ["onClick"];
    const _hoisted_5$g = { role: "menuitem" };
    const _hoisted_6$a = { class: "slds-truncate" };
    function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_TextInput = resolveComponent("TextInput");
      const _directive_click_outside = resolveDirective("click-outside");
      return openBlock(), createElementBlock("div", _hoisted_1$l, [
        createVNode(_component_TextInput, {
          ref: "expression",
          modelValue: $data.expression,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.expression = $event),
          labels: { name: $props.labels.name },
          useTextArea: "",
          errors: $props.errors,
          onKeydown: $options.onExpressionKeydown,
          onKeyup: $options.updateSuggestResults,
          onClick: $options.updateSuggestResults,
          onFocus: $options.updateSuggestResults
        }, null, 8, ["modelValue", "labels", "errors", "onKeydown", "onKeyup", "onClick", "onFocus"]),
        _hoisted_2$l,
        $data.showSuggest ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          ref: "suggest",
          class: "suggest slds-dropdown",
          style: normalizeStyle({ top: `${$data.suggestPosition.y}px`, left: `${$data.suggestPosition.x}px` })
        }, [
          createBaseVNode("ul", _hoisted_3$h, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.suggestResults, (result, i) => {
              return openBlock(), createElementBlock("li", {
                key: result,
                class: normalizeClass(["slds-dropdown__item", { "suggest-active": $data.suggestActiveIndex === i }]),
                onClick: ($event) => $options.insertVariable(result)
              }, [
                createBaseVNode("a", _hoisted_5$g, [
                  createBaseVNode("span", _hoisted_6$a, toDisplayString(result), 1)
                ])
              ], 10, _hoisted_4$h);
            }), 128))
          ])
        ], 4)), [
          [_directive_click_outside, $options.hideSuggest]
        ]) : createCommentVNode("", true)
      ]);
    }
    const ExpressionInput = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m], ["__scopeId", "data-v-f0381051"]]);
    const _sfc_main$l = {
      name: "ConfigureColumn",
      components: {
        Selectlist,
        ExpressionInput,
        // slds vue
        Checkbox,
        RadioButtonGroup,
        TextInput
      },
      props: ["column", "at"],
      data() {
        return {
          localColumn: SPM.Utils.Quota.Column.defaults(),
          typeOptions: Object.entries(SPM.Utils.Quota.Column.types()).map(([id, column]) => ({ id, ...column })),
          includeTargetColumn: true,
          targetType: "Numeric",
          targetTypeOptions: [
            { label: "Numeric", value: "Numeric" },
            { label: "Formula", value: "Formula" }
          ],
          errors: {
            label: [],
            expression: [],
            targetLabel: []
          }
        };
      },
      computed: {
        isDirty() {
          return !SPM.Utils.Obj.shallowCompare(this.column, this.localColumn);
        },
        isNew() {
          return !this.column.id;
        },
        expressionColumnOptions() {
          return SPM.Components.Root.plan._columns.reduce((arr, c) => {
            if (SPM.Components.Root.preferences.columns.some(({ id }) => id === c.id)) {
              if (c.type === "Quota") {
                arr.push(`${c.id}:Quota`);
                if (c.targetLabel) {
                  arr.push(`${c.id}:Target`);
                }
              } else if (c.type === "Numeric" || c.type === "Formula") {
                arr.push(c.id);
              }
            }
            return arr;
          }, []);
        }
      },
      watch: {
        column: {
          handler() {
            this.localColumn = Object.assign(SPM.Utils.Quota.Column.defaults(), this.column);
            if (this.localColumn.type === "Quota") {
              this.includeTargetColumn = !!this.localColumn.targetLabel;
              this.targetType = this.localColumn.expression ? "Formula" : "Numeric";
            }
          },
          immediate: true
        },
        includeTargetColumn() {
          if (!this.includeTargetColumn) {
            this.targetType = "Numeric";
            this.localColumn.targetLabel = "";
            this.localColumn.expression = "";
          } else {
            this.localColumn.targetLabel = this.localColumn.targetLabel || "Target";
          }
        },
        targetType() {
          if (this.targetType !== "Formula") {
            this.localColumn.expression = "";
          }
        }
      },
      async mounted() {
        SPM.Components.ConfigureColumn = this;
      },
      methods: {
        cancel() {
          SPM.Components.RightPanel.close();
        },
        async save() {
          if (this.localColumn.type === "Quota") {
            if (!this.includeTargetColumn)
              this.localColumn.targetLabel = "";
            if (this.targetType === "Numeric")
              this.localColumn.expression = "";
          }
          Object.keys(this.errors).forEach((key) => this.errors[key] = []);
          if (!this.localColumn.id) {
            this.errors.label.push("Label is required");
          }
          if (this.isNew) {
            if (SPM.Components.Root.plan._columns.some((c) => c.id === this.localColumn.id) || this.localColumn.id.includes(":") && SPM.Utils.Quota.helperUtils.isColumnNameInvalid(this.localColumn.id, SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota")))
              this.errors.label.push("Label must be unique");
          }
          if (this.localColumn.type === "Formula" || this.localColumn.type === "Quota" && this.includeTargetColumn && this.targetType === "Formula") {
            try {
              new MathParser(this.localColumn.expression).parse();
            } catch (e) {
              this.errors.expression.push(e.position ? `${e.error} (at character ${e.position + 1}).` : `${e.error}.`);
            }
          }
          if (this.localColumn.type === "Quota" && this.includeTargetColumn && !this.localColumn.targetLabel) {
            this.errors.targetLabel.push("Target Label is required");
          }
          if (Object.values(this.errors).some((errors) => errors.length))
            return;
          this.localColumn.width = 140;
          SPM.Components.RightPanel.loadingMsg = "Saving...";
          const existingColumnIndex = SPM.Components.Root.plan._columns.findIndex((c) => c === this.column);
          if (existingColumnIndex !== -1) {
            SPM.Components.Root.plan._columns.splice(existingColumnIndex, 1, this.localColumn);
          } else {
            SPM.Components.Root.plan._columns.push(this.localColumn);
            SPM.Components.Root.preferences.columns.splice(this.at + 1, 0, { id: this.localColumn.id });
          }
          if (["Formula", "Quota"].includes(this.localColumn.type))
            Object.values(SPM.Components.Root.nodeMap).forEach((node) => SPM.Utils.Quota.Node.calculateColumn({ node, column: this.localColumn }));
          SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
          await SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
          SPM.Components.RightPanel.close();
        }
      }
    };
    const _hoisted_1$k = {
      class: "slds-p-around_small",
      style: { "padding-bottom": "60px", "overflow-y": "auto" }
    };
    const _hoisted_2$k = {
      key: 1,
      class: "slds-form-element slds-m-top_small"
    };
    const _hoisted_3$g = /* @__PURE__ */ createBaseVNode("label", { class: "slds-form-element__label slds-m-top_small" }, "Target Type", -1);
    const _hoisted_4$g = {
      class: "slds-docked-form-footer slds-col_bump-top",
      style: { "position": "absolute" }
    };
    const _hoisted_5$f = ["disabled"];
    function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_TextInput = resolveComponent("TextInput");
      const _component_Selectlist = resolveComponent("Selectlist");
      const _component_ExpressionInput = resolveComponent("ExpressionInput");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_RadioButtonGroup = resolveComponent("RadioButtonGroup");
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", _hoisted_1$k, [
          createVNode(_component_TextInput, {
            ref: "label",
            modelValue: $data.localColumn.id,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.localColumn.id = $event),
            labels: { name: "Label" },
            errors: $data.errors.label,
            disabled: !$options.isNew,
            onInput: _cache[1] || (_cache[1] = ($event) => $data.errors.label = [])
          }, null, 8, ["modelValue", "errors", "disabled"]),
          createVNode(_component_Selectlist, {
            modelValue: $data.localColumn.type,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.localColumn.type = $event),
            labels: { name: "Type" },
            options: $data.typeOptions,
            disabled: !$options.isNew,
            class: "slds-m-vertical_medium",
            size: "xx-small"
          }, null, 8, ["modelValue", "options", "disabled"]),
          $data.localColumn.type === "Formula" ? (openBlock(), createBlock(_component_ExpressionInput, {
            key: 0,
            modelValue: $data.localColumn.expression,
            "onUpdate:modelValue": [
              _cache[3] || (_cache[3] = ($event) => $data.localColumn.expression = $event),
              _cache[4] || (_cache[4] = ($event) => $data.errors.expression = [])
            ],
            labels: { name: "Formula Expression" },
            options: $options.expressionColumnOptions,
            errors: $data.errors.expression
          }, null, 8, ["modelValue", "options", "errors"])) : createCommentVNode("", true),
          $data.localColumn.type === "Quota" ? (openBlock(), createElementBlock("div", _hoisted_2$k, [
            createVNode(_component_Checkbox, {
              modelValue: $data.includeTargetColumn,
              "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.includeTargetColumn = $event),
              labels: { name: "Include Target Column" },
              slide: ""
            }, null, 8, ["modelValue"]),
            $data.includeTargetColumn ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _hoisted_3$g,
              createVNode(_component_RadioButtonGroup, {
                modelValue: $data.targetType,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.targetType = $event),
                options: $data.targetTypeOptions
              }, null, 8, ["modelValue", "options"]),
              createVNode(_component_TextInput, {
                modelValue: $data.localColumn.targetLabel,
                "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.localColumn.targetLabel = $event),
                labels: { name: "Target Label" },
                class: "slds-m-vertical_small",
                errors: $data.errors.targetLabel,
                onInput: _cache[8] || (_cache[8] = ($event) => $data.errors.targetLabel = [])
              }, null, 8, ["modelValue", "errors"]),
              $data.targetType === "Formula" ? (openBlock(), createBlock(_component_ExpressionInput, {
                key: 0,
                modelValue: $data.localColumn.expression,
                "onUpdate:modelValue": [
                  _cache[9] || (_cache[9] = ($event) => $data.localColumn.expression = $event),
                  _cache[10] || (_cache[10] = ($event) => $data.errors.expression = [])
                ],
                labels: { name: "Target Formula Expression" },
                options: $options.expressionColumnOptions,
                errors: $data.errors.expression
              }, null, 8, ["modelValue", "options", "errors"])) : createCommentVNode("", true)
            ], 64)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", _hoisted_4$g, [
          createBaseVNode("button", {
            class: "slds-button slds-button_neutral slds-grow slds-m-horizontal_large",
            onClick: _cache[11] || (_cache[11] = (...args) => $options.cancel && $options.cancel(...args))
          }, "Cancel"),
          createBaseVNode("button", {
            class: "slds-button slds-button_brand slds-grow slds-m-horizontal_large",
            disabled: !$options.isDirty,
            onClick: _cache[12] || (_cache[12] = (...args) => $options.save && $options.save(...args))
          }, "Save", 8, _hoisted_5$f)
        ])
      ], 64);
    }
    const ConfigureColumn = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
    const _sfc_main$k = {
      name: "RightPanel",
      components: {
        ConfigureColumn,
        // slds vue
        ButtonIcon,
        Spinner
      },
      props: ["config"],
      data() {
        return {
          loadingMsg: ""
        };
      },
      computed: {
        title() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.column) == null ? void 0 : _b.id) ? `Edit ${this.config.column.id} Column` : "New Column";
        }
      },
      async mounted() {
        SPM.Components.RightPanel = this;
      },
      methods: {
        // panel
        close() {
          SPM.Components.Root.rightPanelConfig = null;
        }
      }
    };
    const _hoisted_1$j = { class: "slds-panel slds-panel_docked slds-panel_docked-right slds-size_large slds-grid slds-grid_vertical" };
    const _hoisted_2$j = { class: "slds-panel__header" };
    const _hoisted_3$f = { class: "slds-panel__header-title slds-text-heading_small slds-truncate" };
    const _hoisted_4$f = { class: "slds-panel__header-actions" };
    const _hoisted_5$e = {
      class: "slds-grid slds-grid_vertical slds-grow",
      style: { "overflow": "hidden" }
    };
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ConfigureColumn = resolveComponent("ConfigureColumn");
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$j, [
          createBaseVNode("h2", _hoisted_3$f, toDisplayString($options.title), 1),
          createBaseVNode("div", _hoisted_4$f, [
            createVNode(_component_ButtonIcon, {
              iconCategory: "utility",
              iconName: "close",
              title: "Collapse Panel",
              assistiveText: "Collapse Panel",
              onClick: $options.close
            }, null, 8, ["onClick"])
          ])
        ]),
        createBaseVNode("div", _hoisted_5$e, [
          createVNode(_component_ConfigureColumn, {
            column: $props.config.column,
            at: $props.config.at
          }, null, 8, ["column", "at"])
        ])
      ]);
    }
    const RightPanel = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-066e0b94"]]);
    const _sfc_main$j = {
      name: "BuilderHeader",
      components: {
        Icon,
        Button: SLDSButton
      },
      props: ["plan"],
      data() {
        return {
          planName: "",
          editingPlanName: false
        };
      },
      computed: {
        showConfigureButtons() {
          return SPM.Components.Root.nodeHierarchy.sfsp__SalesNodes__r.length > 0;
        }
      },
      mounted() {
        SPM.Components.BuilderHeader = this;
      },
      methods: {
        // name
        startEditName() {
          if (this.editingPlanName)
            return;
          this.planName = this.plan.Name;
          this.editingPlanName = true;
          this.$nextTick(() => this.$refs.planName.select());
        },
        finishEditName() {
          if (!this.editingPlanName)
            return;
          if (this.planName && this.planName !== this.plan.Name) {
            this.plan.Name = this.planName;
            SPM.Utils.CRM.upsert({ records: [this.plan] });
          }
          this.editingPlanName = false;
        },
        cancelEditName() {
          this.editingPlanName = false;
        },
        // csv
        importCSV() {
          SPM.Components.Root.importModalConfig = {};
        },
        exportCSV() {
          const columnsToExport = SPM.Components.Root.preferences.columns.map(({ id }) => SPM.Components.Root.plan._columns.find((c) => c.id === id));
          const rows = [[
            "Territory",
            "Parent",
            "Owner",
            ...columnsToExport.reduce((arr, c) => {
              if (c.type === "Quota")
                arr.push(`${c.id}:Target`, `${c.id}:Quota`, `${c.id}:Remaining`);
              else
                arr.push(c.id);
              return arr;
            }, [])
          ]];
          const addRows = (nodes) => {
            nodes.forEach((node) => {
              var _a, _b;
              rows.push([
                node.Name,
                ((_a = SPM.Components.Root.nodeMap[node._parentId.replace("all_org", "")]) == null ? void 0 : _a.Name) || "",
                ((_b = node == null ? void 0 : node.sfsp__Owner__r) == null ? void 0 : _b.Name) || "TBH",
                ...columnsToExport.reduce((arr, c) => {
                  if (c.type === "Quota") {
                    arr.push(
                      node._data[`${c.id}:Target`] || 0,
                      node._data[`${c.id}:Quota`] || 0,
                      node._data[`${c.id}:Remaining`] || 0
                    );
                  } else {
                    arr.push(node._data[c.id] || (c.type === "Text" ? "" : 0));
                  }
                  return arr;
                }, [])
              ]);
              addRows(node.sfsp__SalesNodes__r);
            });
          };
          addRows(SPM.Components.Root.nodeHierarchy.sfsp__SalesNodes__r);
          const csvFile = rows.reduce((fileContents, row) => {
            let finalVal = "";
            for (let j = 0; j < row.length; j++) {
              let innerValue = row[j] === null || row[j] === void 0 ? "" : row[j].toString();
              if (row[j] instanceof Date) {
                innerValue = row[j].toLocaleString();
              }
              let result = innerValue.replace(/"/g, '""');
              if (result.search(/("|,|;|\n)/g) >= 0 || row[j] instanceof String || typeof row[j] === "string") {
                result = `"${result}"`;
              }
              if (j > 0) {
                finalVal += ",";
              }
              finalVal += result;
            }
            return `${fileContents}${finalVal}
`;
          }, "");
          const link2 = document.createElement("a");
          link2.href = `data:text/csv;charset=utf-8,${encodeURIComponent(csvFile)}`;
          link2.target = "_blank";
          link2.download = `${this.plan.Name}.csv`;
          document.body.appendChild(link2);
          link2.click();
        },
        // columns
        toggleColumnsPanel() {
          SPM.Components.Root.leftPanelConfig = SPM.Components.Root.leftPanelConfig ? null : {};
        }
      }
    };
    const _withScopeId$7 = (n) => (pushScopeId("data-v-cf9ba34a"), n = n(), popScopeId(), n);
    const _hoisted_1$i = {
      class: "slds-builder-header_container",
      style: { "position": "relative" }
    };
    const _hoisted_2$i = { class: "slds-builder-header" };
    const _hoisted_3$e = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-builder-header__item" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "slds-builder-header__item-label slds-grid slds-grid_vertical-align-center" }, [
        /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-color_inverse" }, "Quota Plan Builder")
      ])
    ], -1));
    const _hoisted_4$e = { class: "slds-builder-header__item-label slds-grid slds-grid_vertical-align-center" };
    const _hoisted_5$d = ["title"];
    const _hoisted_6$9 = {
      key: 0,
      class: "slds-builder-header__item slds-builder-header__utilities"
    };
    const _hoisted_7$7 = { class: "slds-builder-header__utilities-item" };
    const _hoisted_8$6 = { class: "slds-builder-header__utilities-item" };
    const _hoisted_9$6 = { class: "slds-builder-header__utilities-item" };
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Button = resolveComponent("Button");
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("header", _hoisted_2$i, [
          _hoisted_3$e,
          createBaseVNode("div", {
            id: "plan-name",
            class: "slds-builder-header__item",
            onClick: _cache[4] || (_cache[4] = (...args) => $options.startEditName && $options.startEditName(...args))
          }, [
            createBaseVNode("div", _hoisted_4$e, [
              !$data.editingPlanName ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "slds-text-color_inverse",
                title: $props.plan.Name
              }, toDisplayString($props.plan.Name), 9, _hoisted_5$d)) : withDirectives((openBlock(), createElementBlock("input", {
                key: 1,
                ref: "planName",
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.planName = $event),
                type: "text",
                onBlur: _cache[1] || (_cache[1] = (...args) => $options.finishEditName && $options.finishEditName(...args)),
                onKeydown: [
                  _cache[2] || (_cache[2] = withKeys((...args) => $options.finishEditName && $options.finishEditName(...args), ["enter"])),
                  _cache[3] || (_cache[3] = withKeys((...args) => $options.cancelEditName && $options.cancelEditName(...args), ["esc"]))
                ]
              }, null, 544)), [
                [vModelText, $data.planName]
              ]),
              createVNode(_component_Icon, {
                category: "utility",
                name: "edit",
                class: "slds-current-color slds-m-left_small",
                size: "x-small",
                assistiveText: "Edit"
              })
            ])
          ]),
          $options.showConfigureButtons ? (openBlock(), createElementBlock("div", _hoisted_6$9, [
            createBaseVNode("div", _hoisted_7$7, [
              createVNode(_component_Button, {
                class: "slds-builder-header__item-action slds-media slds-media_center",
                iconCategory: "utility",
                iconName: "download",
                variant: "base",
                label: "Import",
                onClick: $options.importCSV
              }, null, 8, ["onClick"])
            ]),
            createBaseVNode("div", _hoisted_8$6, [
              createVNode(_component_Button, {
                class: "slds-builder-header__item-action slds-media slds-media_center",
                iconCategory: "utility",
                iconName: "share",
                variant: "base",
                label: "Export",
                onClick: $options.exportCSV
              }, null, 8, ["onClick"])
            ]),
            createBaseVNode("div", _hoisted_9$6, [
              createVNode(_component_Button, {
                class: "slds-builder-header__item-action slds-media slds-media_center",
                iconCategory: "utility",
                iconName: "settings",
                variant: "base",
                label: "Columns",
                onClick: $options.toggleColumnsPanel
              }, null, 8, ["onClick"])
            ])
          ])) : createCommentVNode("", true)
        ])
      ]);
    }
    const BuilderHeader = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__scopeId", "data-v-cf9ba34a"]]);
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    /*!
     * GSAP 3.12.5
     * https://gsap.com
     *
     * @license Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var _config = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    }, _defaults = {
      duration: 0.5,
      overwrite: false,
      delay: 0
    }, _suppressOverwrites, _reverting$1, _context, _bigNum$1 = 1e8, _tinyNum = 1 / _bigNum$1, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString2(value) {
      return typeof value === "string";
    }, _isFunction = function _isFunction2(value) {
      return typeof value === "function";
    }, _isNumber = function _isNumber2(value) {
      return typeof value === "number";
    }, _isUndefined = function _isUndefined2(value) {
      return typeof value === "undefined";
    }, _isObject = function _isObject2(value) {
      return typeof value === "object";
    }, _isNotFalse = function _isNotFalse2(value) {
      return value !== false;
    }, _windowExists$1 = function _windowExists2() {
      return typeof window !== "undefined";
    }, _isFuncOrString = function _isFuncOrString2(value) {
      return _isFunction(value) || _isString(value);
    }, _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
    }, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$1, _coreInitted, _doc$1, _globals = {}, _installScope = {}, _coreReady, _install = function _install2(scope) {
      return (_installScope = _merge(scope, _globals)) && gsap;
    }, _missingPlugin = function _missingPlugin2(property, value) {
      return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
    }, _warn = function _warn2(message, suppress) {
      return !suppress && console.warn(message);
    }, _addGlobal = function _addGlobal2(name, obj) {
      return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
    }, _emptyFunc = function _emptyFunc2() {
      return 0;
    }, _startAtRevertConfig = {
      suppressEvents: true,
      isStart: true,
      kill: false
    }, _revertConfigNoKill = {
      suppressEvents: true,
      kill: false
    }, _revertConfig = {
      suppressEvents: true
    }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function _harness2(targets) {
      var target = targets[0], harnessPlugin, i;
      _isObject(target) || _isFunction(target) || (targets = [targets]);
      if (!(harnessPlugin = (target._gsap || {}).harness)) {
        i = _harnessPlugins.length;
        while (i-- && !_harnessPlugins[i].targetTest(target)) {
        }
        harnessPlugin = _harnessPlugins[i];
      }
      i = targets.length;
      while (i--) {
        targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
      }
      return targets;
    }, _getCache = function _getCache2(target) {
      return target._gsap || _harness(toArray(target))[0]._gsap;
    }, _getProperty = function _getProperty2(target, property, v) {
      return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
    }, _forEachName = function _forEachName2(names, func) {
      return (names = names.split(",")).forEach(func) || names;
    }, _round = function _round2(value) {
      return Math.round(value * 1e5) / 1e5 || 0;
    }, _roundPrecise = function _roundPrecise2(value) {
      return Math.round(value * 1e7) / 1e7 || 0;
    }, _parseRelative = function _parseRelative2(start2, value) {
      var operator = value.charAt(0), end2 = parseFloat(value.substr(2));
      start2 = parseFloat(start2);
      return operator === "+" ? start2 + end2 : operator === "-" ? start2 - end2 : operator === "*" ? start2 * end2 : start2 / end2;
    }, _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
      var l = toFind.length, i = 0;
      for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
      }
      return i < l;
    }, _lazyRender = function _lazyRender2() {
      var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
      _lazyLookup = {};
      _lazyTweens.length = 0;
      for (i = 0; i < l; i++) {
        tween = a[i];
        tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
      }
    }, _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
      _lazyTweens.length && !_reverting$1 && _lazyRender();
      animation.render(time, suppressEvents, force || _reverting$1 && time < 0 && (animation._initted || animation._startAt));
      _lazyTweens.length && !_reverting$1 && _lazyRender();
    }, _numericIfPossible = function _numericIfPossible2(value) {
      var n = parseFloat(value);
      return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
    }, _passThrough = function _passThrough2(p2) {
      return p2;
    }, _setDefaults = function _setDefaults2(obj, defaults2) {
      for (var p2 in defaults2) {
        p2 in obj || (obj[p2] = defaults2[p2]);
      }
      return obj;
    }, _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
      return function(obj, defaults2) {
        for (var p2 in defaults2) {
          p2 in obj || p2 === "duration" && excludeDuration || p2 === "ease" || (obj[p2] = defaults2[p2]);
        }
      };
    }, _merge = function _merge2(base, toMerge) {
      for (var p2 in toMerge) {
        base[p2] = toMerge[p2];
      }
      return base;
    }, _mergeDeep = function _mergeDeep2(base, toMerge) {
      for (var p2 in toMerge) {
        p2 !== "__proto__" && p2 !== "constructor" && p2 !== "prototype" && (base[p2] = _isObject(toMerge[p2]) ? _mergeDeep2(base[p2] || (base[p2] = {}), toMerge[p2]) : toMerge[p2]);
      }
      return base;
    }, _copyExcluding = function _copyExcluding2(obj, excluding) {
      var copy = {}, p2;
      for (p2 in obj) {
        p2 in excluding || (copy[p2] = obj[p2]);
      }
      return copy;
    }, _inheritDefaults = function _inheritDefaults2(vars) {
      var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
      if (_isNotFalse(vars.inherit)) {
        while (parent) {
          func(vars, parent.vars.defaults);
          parent = parent.parent || parent._dp;
        }
      }
      return vars;
    }, _arraysMatch = function _arraysMatch2(a1, a2) {
      var i = a1.length, match = i === a2.length;
      while (match && i-- && a1[i] === a2[i]) {
      }
      return i < 0;
    }, _addLinkedListItem = function _addLinkedListItem2(parent, child, firstProp, lastProp, sortBy) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
      if (lastProp === void 0) {
        lastProp = "_last";
      }
      var prev = parent[lastProp], t;
      if (sortBy) {
        t = child[sortBy];
        while (prev && prev[sortBy] > t) {
          prev = prev._prev;
        }
      }
      if (prev) {
        child._next = prev._next;
        prev._next = child;
      } else {
        child._next = parent[firstProp];
        parent[firstProp] = child;
      }
      if (child._next) {
        child._next._prev = child;
      } else {
        parent[lastProp] = child;
      }
      child._prev = prev;
      child.parent = child._dp = parent;
      return child;
    }, _removeLinkedListItem = function _removeLinkedListItem2(parent, child, firstProp, lastProp) {
      if (firstProp === void 0) {
        firstProp = "_first";
      }
      if (lastProp === void 0) {
        lastProp = "_last";
      }
      var prev = child._prev, next = child._next;
      if (prev) {
        prev._next = next;
      } else if (parent[firstProp] === child) {
        parent[firstProp] = next;
      }
      if (next) {
        next._prev = prev;
      } else if (parent[lastProp] === child) {
        parent[lastProp] = prev;
      }
      child._next = child._prev = child.parent = null;
    }, _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
      child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
      child._act = 0;
    }, _uncache = function _uncache2(animation, child) {
      if (animation && (!child || child._end > animation._dur || child._start < 0)) {
        var a = animation;
        while (a) {
          a._dirty = 1;
          a = a.parent;
        }
      }
      return animation;
    }, _recacheAncestors = function _recacheAncestors2(animation) {
      var parent = animation.parent;
      while (parent && parent.parent) {
        parent._dirty = 1;
        parent.totalDuration();
        parent = parent.parent;
      }
      return animation;
    }, _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
      return tween._startAt && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
    }, _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
      return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
    }, _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
      return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
    }, _animationCycle = function _animationCycle2(tTime, cycleDuration) {
      var whole = Math.floor(tTime /= cycleDuration);
      return tTime && whole === tTime ? whole - 1 : whole;
    }, _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
      return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
    }, _setEnd = function _setEnd2(animation) {
      return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
    }, _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
      var parent = animation._dp;
      if (parent && parent.smoothChildTiming && animation._ts) {
        animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
        _setEnd(animation);
        parent._dirty || _uncache(parent, animation);
      }
      return animation;
    }, _postAddChecks = function _postAddChecks2(timeline, child) {
      var t;
      if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
        t = _parentToChildTotalTime(timeline.rawTime(), child);
        if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
          child.render(t, true);
        }
      }
      if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
        if (timeline._dur < timeline.duration()) {
          t = timeline;
          while (t._dp) {
            t.rawTime() >= 0 && t.totalTime(t._tTime);
            t = t._dp;
          }
        }
        timeline._zTime = -_tinyNum;
      }
    }, _addToTimeline = function _addToTimeline2(timeline, child, position, skipChecks) {
      child.parent && _removeFromParent(child);
      child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
      child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
      _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
      _isFromOrFromStart(child) || (timeline._recent = child);
      skipChecks || _postAddChecks(timeline, child);
      timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
      return timeline;
    }, _scrollTrigger = function _scrollTrigger2(animation, trigger2) {
      return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger2)) && _globals.ScrollTrigger.create(trigger2, animation);
    }, _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
      _initTween(tween, time, tTime);
      if (!tween._initted) {
        return 1;
      }
      if (!force && tween._pt && !_reverting$1 && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
        _lazyTweens.push(tween);
        tween._lazy = [tTime, suppressEvents];
        return 1;
      }
    }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
      var parent = _ref.parent;
      return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent));
    }, _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
      var data = _ref2.data;
      return data === "isFromStart" || data === "isStart";
    }, _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
      var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
      if (repeatDelay && tween._repeat) {
        tTime = _clamp(0, tween._tDur, totalTime);
        iteration = _animationCycle(tTime, repeatDelay);
        tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
        if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
          prevRatio = 1 - ratio;
          tween.vars.repeatRefresh && tween._initted && tween.invalidate();
        }
      }
      if (ratio !== prevRatio || _reverting$1 || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
        if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
          return;
        }
        prevIteration = tween._zTime;
        tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
        suppressEvents || (suppressEvents = totalTime && !prevIteration);
        tween.ratio = ratio;
        tween._from && (ratio = 1 - ratio);
        tween._time = 0;
        tween._tTime = tTime;
        pt = tween._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
        tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
        tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
        if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
          ratio && _removeFromParent(tween, 1);
          if (!suppressEvents && !_reverting$1) {
            _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
            tween._prom && tween._prom();
          }
        }
      } else if (!tween._zTime) {
        tween._zTime = totalTime;
      }
    }, _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
      var child;
      if (time > prevTime) {
        child = animation._first;
        while (child && child._start <= time) {
          if (child.data === "isPause" && child._start > prevTime) {
            return child;
          }
          child = child._next;
        }
      } else {
        child = animation._last;
        while (child && child._start >= time) {
          if (child.data === "isPause" && child._start < prevTime) {
            return child;
          }
          child = child._prev;
        }
      }
    }, _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
      var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
      totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
      animation._dur = dur;
      animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
      totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
      animation.parent && _setEnd(animation);
      skipUncache || _uncache(animation.parent, animation);
      return animation;
    }, _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
      return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
    }, _zeroPosition = {
      _start: 0,
      endTime: _emptyFunc,
      totalDuration: _emptyFunc
    }, _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
      var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum$1 ? recent.endTime(false) : animation._dur, i, offset2, isPercent;
      if (_isString(position) && (isNaN(position) || position in labels)) {
        offset2 = position.charAt(0);
        isPercent = position.substr(-1) === "%";
        i = position.indexOf("=");
        if (offset2 === "<" || offset2 === ">") {
          i >= 0 && (position = position.replace(/=/, ""));
          return (offset2 === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
        }
        if (i < 0) {
          position in labels || (labels[position] = clippedDuration);
          return labels[position];
        }
        offset2 = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
        if (isPercent && percentAnimation) {
          offset2 = offset2 / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
        }
        return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset2 : clippedDuration + offset2;
      }
      return position == null ? clippedDuration : +position;
    }, _createTweenType = function _createTweenType2(type, params, timeline) {
      var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;
      isLegacy && (vars.duration = params[1]);
      vars.parent = timeline;
      if (type) {
        irVars = vars;
        parent = timeline;
        while (parent && !("immediateRender" in irVars)) {
          irVars = parent.vars.defaults || {};
          parent = _isNotFalse(parent.vars.inherit) && parent.parent;
        }
        vars.immediateRender = _isNotFalse(irVars.immediateRender);
        type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
      }
      return new Tween(params[0], vars, params[varsIndex + 1]);
    }, _conditionalReturn = function _conditionalReturn2(value, func) {
      return value || value === 0 ? func(value) : func;
    }, _clamp = function _clamp2(min2, max2, value) {
      return value < min2 ? min2 : value > max2 ? max2 : value;
    }, getUnit = function getUnit2(value, v) {
      return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
    }, clamp = function clamp2(min2, max2, value) {
      return _conditionalReturn(value, function(v) {
        return _clamp(min2, max2, v);
      });
    }, _slice = [].slice, _isArrayLike = function _isArrayLike2(value, nonEmpty) {
      return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win$1;
    }, _flatten = function _flatten2(ar, leaveStrings, accumulator) {
      if (accumulator === void 0) {
        accumulator = [];
      }
      return ar.forEach(function(value) {
        var _accumulator;
        return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
      }) || accumulator;
    }, toArray = function toArray2(value, scope, leaveStrings) {
      return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc$1).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
    }, selector = function selector2(value) {
      value = toArray(value)[0] || _warn("Invalid scope") || {};
      return function(v) {
        var el = value.current || value.nativeElement || value;
        return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc$1.createElement("div") : value);
      };
    }, shuffle = function shuffle2(a) {
      return a.sort(function() {
        return 0.5 - Math.random();
      });
    }, distribute = function distribute2(v) {
      if (_isFunction(v)) {
        return v;
      }
      var vars = _isObject(v) ? v : {
        each: v
      }, ease = _parseEase(vars.ease), from2 = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from2 > 0 && from2 < 1, ratios = isNaN(from2) || isDecimal, axis = vars.axis, ratioX = from2, ratioY = from2;
      if (_isString(from2)) {
        ratioX = ratioY = {
          center: 0.5,
          edges: 0.5,
          end: 1
        }[from2] || 0;
      } else if (!isDecimal && ratios) {
        ratioX = from2[0];
        ratioY = from2[1];
      }
      return function(i, target, a) {
        var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max2, min2, wrapAt;
        if (!distances) {
          wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum$1])[1];
          if (!wrapAt) {
            max2 = -_bigNum$1;
            while (max2 < (max2 = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
            }
            wrapAt < l && wrapAt--;
          }
          distances = cache[l] = [];
          originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from2 % wrapAt;
          originY = wrapAt === _bigNum$1 ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from2 / wrapAt | 0;
          max2 = 0;
          min2 = _bigNum$1;
          for (j = 0; j < l; j++) {
            x = j % wrapAt - originX;
            y = originY - (j / wrapAt | 0);
            distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
            d > max2 && (max2 = d);
            d < min2 && (min2 = d);
          }
          from2 === "random" && shuffle(distances);
          distances.max = max2 - min2;
          distances.min = min2;
          distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from2 === "edges" ? -1 : 1);
          distances.b = l < 0 ? base - l : base;
          distances.u = getUnit(vars.amount || vars.each) || 0;
          ease = ease && l < 0 ? _invertEase(ease) : ease;
        }
        l = (distances[i] - distances.min) / distances.max || 0;
        return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
      };
    }, _roundModifier = function _roundModifier2(v) {
      var p2 = Math.pow(10, ((v + "").split(".")[1] || "").length);
      return function(raw) {
        var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p2);
        return (n - n % 1) / p2 + (_isNumber(raw) ? 0 : getUnit(raw));
      };
    }, snap = function snap2(snapTo, value) {
      var isArray2 = _isArray(snapTo), radius, is2D;
      if (!isArray2 && _isObject(snapTo)) {
        radius = isArray2 = snapTo.radius || _bigNum$1;
        if (snapTo.values) {
          snapTo = toArray(snapTo.values);
          if (is2D = !_isNumber(snapTo[0])) {
            radius *= radius;
          }
        } else {
          snapTo = _roundModifier(snapTo.increment);
        }
      }
      return _conditionalReturn(value, !isArray2 ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
        is2D = snapTo(raw);
        return Math.abs(is2D - raw) <= radius ? is2D : raw;
      } : function(raw) {
        var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min2 = _bigNum$1, closest = 0, i = snapTo.length, dx, dy;
        while (i--) {
          if (is2D) {
            dx = snapTo[i].x - x;
            dy = snapTo[i].y - y;
            dx = dx * dx + dy * dy;
          } else {
            dx = Math.abs(snapTo[i] - x);
          }
          if (dx < min2) {
            min2 = dx;
            closest = i;
          }
        }
        closest = !radius || min2 <= radius ? snapTo[closest] : raw;
        return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
      });
    }, random = function random2(min2, max2, roundingIncrement, returnFunction) {
      return _conditionalReturn(_isArray(min2) ? !max2 : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
        return _isArray(min2) ? min2[~~(Math.random() * min2.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min2 - roundingIncrement / 2 + Math.random() * (max2 - min2 + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
      });
    }, pipe = function pipe2() {
      for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
        functions[_key] = arguments[_key];
      }
      return function(value) {
        return functions.reduce(function(v, f) {
          return f(v);
        }, value);
      };
    }, unitize = function unitize2(func, unit) {
      return function(value) {
        return func(parseFloat(value)) + (unit || getUnit(value));
      };
    }, normalize = function normalize2(min2, max2, value) {
      return mapRange(min2, max2, 0, 1, value);
    }, _wrapArray = function _wrapArray2(a, wrapper, value) {
      return _conditionalReturn(value, function(index) {
        return a[~~wrapper(index)];
      });
    }, wrap = function wrap2(min2, max2, value) {
      var range = max2 - min2;
      return _isArray(min2) ? _wrapArray(min2, wrap2(0, min2.length), max2) : _conditionalReturn(value, function(value2) {
        return (range + (value2 - min2) % range) % range + min2;
      });
    }, wrapYoyo = function wrapYoyo2(min2, max2, value) {
      var range = max2 - min2, total = range * 2;
      return _isArray(min2) ? _wrapArray(min2, wrapYoyo2(0, min2.length - 1), max2) : _conditionalReturn(value, function(value2) {
        value2 = (total + (value2 - min2) % total) % total || 0;
        return min2 + (value2 > range ? total - value2 : value2);
      });
    }, _replaceRandom = function _replaceRandom2(value) {
      var prev = 0, s = "", i, nums, end2, isArray2;
      while (~(i = value.indexOf("random(", prev))) {
        end2 = value.indexOf(")", i);
        isArray2 = value.charAt(i + 7) === "[";
        nums = value.substr(i + 7, end2 - i - 7).match(isArray2 ? _delimitedValueExp : _strictNumExp);
        s += value.substr(prev, i - prev) + random(isArray2 ? nums : +nums[0], isArray2 ? 0 : +nums[1], +nums[2] || 1e-5);
        prev = end2 + 1;
      }
      return s + value.substr(prev, value.length - prev);
    }, mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
      var inRange = inMax - inMin, outRange = outMax - outMin;
      return _conditionalReturn(value, function(value2) {
        return outMin + ((value2 - inMin) / inRange * outRange || 0);
      });
    }, interpolate = function interpolate2(start2, end2, progress, mutate) {
      var func = isNaN(start2 + end2) ? 0 : function(p3) {
        return (1 - p3) * start2 + p3 * end2;
      };
      if (!func) {
        var isString2 = _isString(start2), master = {}, p2, i, interpolators, l, il;
        progress === true && (mutate = 1) && (progress = null);
        if (isString2) {
          start2 = {
            p: start2
          };
          end2 = {
            p: end2
          };
        } else if (_isArray(start2) && !_isArray(end2)) {
          interpolators = [];
          l = start2.length;
          il = l - 2;
          for (i = 1; i < l; i++) {
            interpolators.push(interpolate2(start2[i - 1], start2[i]));
          }
          l--;
          func = function func2(p3) {
            p3 *= l;
            var i2 = Math.min(il, ~~p3);
            return interpolators[i2](p3 - i2);
          };
          progress = end2;
        } else if (!mutate) {
          start2 = _merge(_isArray(start2) ? [] : {}, start2);
        }
        if (!interpolators) {
          for (p2 in end2) {
            _addPropTween.call(master, start2, p2, "get", end2[p2]);
          }
          func = function func2(p3) {
            return _renderPropTweens(p3, master) || (isString2 ? start2.p : start2);
          };
        }
      }
      return _conditionalReturn(progress, func);
    }, _getLabelInDirection = function _getLabelInDirection2(timeline, fromTime, backward) {
      var labels = timeline.labels, min2 = _bigNum$1, p2, distance, label;
      for (p2 in labels) {
        distance = labels[p2] - fromTime;
        if (distance < 0 === !!backward && distance && min2 > (distance = Math.abs(distance))) {
          label = p2;
          min2 = distance;
        }
      }
      return label;
    }, _callback = function _callback2(animation, type, executeLazyFirst) {
      var v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx, params, scope, result;
      if (!callback) {
        return;
      }
      params = v[type + "Params"];
      scope = v.callbackScope || animation;
      executeLazyFirst && _lazyTweens.length && _lazyRender();
      context && (_context = context);
      result = params ? callback.apply(scope, params) : callback.call(scope);
      _context = prevContext;
      return result;
    }, _interrupt = function _interrupt2(animation) {
      _removeFromParent(animation);
      animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting$1);
      animation.progress() < 1 && _callback(animation, "onInterrupt");
      return animation;
    }, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin2(config) {
      if (!config)
        return;
      config = !config.name && config["default"] || config;
      if (_windowExists$1() || config.headless) {
        var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {
          this._props = [];
        } : config, instanceDefaults = {
          init: _emptyFunc,
          render: _renderPropTweens,
          add: _addPropTween,
          kill: _killPropTweensOf,
          modifier: _addPluginModifier,
          rawVars: 0
        }, statics = {
          targetTest: 0,
          get: 0,
          getSetter: _getSetter,
          aliases: {},
          register: 0
        };
        _wake();
        if (config !== Plugin) {
          if (_plugins[name]) {
            return;
          }
          _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
          _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
          _plugins[Plugin.prop = name] = Plugin;
          if (config.targetTest) {
            _harnessPlugins.push(Plugin);
            _reservedProps[name] = 1;
          }
          name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
        }
        _addGlobal(name, Plugin);
        config.register && config.register(gsap, Plugin, PropTween);
      } else {
        _registerPluginQueue.push(config);
      }
    }, _255 = 255, _colorLookup = {
      aqua: [0, _255, _255],
      lime: [0, _255, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, _255],
      navy: [0, 0, 128],
      white: [_255, _255, _255],
      olive: [128, 128, 0],
      yellow: [_255, _255, 0],
      orange: [_255, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [_255, 0, 0],
      pink: [_255, 192, 203],
      cyan: [0, _255, _255],
      transparent: [_255, _255, _255, 0]
    }, _hue = function _hue2(h2, m1, m2) {
      h2 += h2 < 0 ? 1 : h2 > 1 ? -1 : 0;
      return (h2 * 6 < 1 ? m1 + (m2 - m1) * h2 * 6 : h2 < 0.5 ? m2 : h2 * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h2) * 6 : m1) * _255 + 0.5 | 0;
    }, splitColor = function splitColor2(v, toHSL, forceAlpha) {
      var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0, r, g, b, h2, s, l, max2, min2, d, wasHSL;
      if (!a) {
        if (v.substr(-1) === ",") {
          v = v.substr(0, v.length - 1);
        }
        if (_colorLookup[v]) {
          a = _colorLookup[v];
        } else if (v.charAt(0) === "#") {
          if (v.length < 6) {
            r = v.charAt(1);
            g = v.charAt(2);
            b = v.charAt(3);
            v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
          }
          if (v.length === 9) {
            a = parseInt(v.substr(1, 6), 16);
            return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
          }
          v = parseInt(v.substr(1), 16);
          a = [v >> 16, v >> 8 & _255, v & _255];
        } else if (v.substr(0, 3) === "hsl") {
          a = wasHSL = v.match(_strictNumExp);
          if (!toHSL) {
            h2 = +a[0] % 360 / 360;
            s = +a[1] / 100;
            l = +a[2] / 100;
            g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
            r = l * 2 - g;
            a.length > 3 && (a[3] *= 1);
            a[0] = _hue(h2 + 1 / 3, r, g);
            a[1] = _hue(h2, r, g);
            a[2] = _hue(h2 - 1 / 3, r, g);
          } else if (~v.indexOf("=")) {
            a = v.match(_numExp);
            forceAlpha && a.length < 4 && (a[3] = 1);
            return a;
          }
        } else {
          a = v.match(_strictNumExp) || _colorLookup.transparent;
        }
        a = a.map(Number);
      }
      if (toHSL && !wasHSL) {
        r = a[0] / _255;
        g = a[1] / _255;
        b = a[2] / _255;
        max2 = Math.max(r, g, b);
        min2 = Math.min(r, g, b);
        l = (max2 + min2) / 2;
        if (max2 === min2) {
          h2 = s = 0;
        } else {
          d = max2 - min2;
          s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
          h2 = max2 === r ? (g - b) / d + (g < b ? 6 : 0) : max2 === g ? (b - r) / d + 2 : (r - g) / d + 4;
          h2 *= 60;
        }
        a[0] = ~~(h2 + 0.5);
        a[1] = ~~(s * 100 + 0.5);
        a[2] = ~~(l * 100 + 0.5);
      }
      forceAlpha && a.length < 4 && (a[3] = 1);
      return a;
    }, _colorOrderData = function _colorOrderData2(v) {
      var values = [], c = [], i = -1;
      v.split(_colorExp).forEach(function(v2) {
        var a = v2.match(_numWithUnitExp) || [];
        values.push.apply(values, a);
        c.push(i += a.length + 1);
      });
      values.c = c;
      return values;
    }, _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
      var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
      if (!colors) {
        return s;
      }
      colors = colors.map(function(color) {
        return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
      });
      if (orderMatchData) {
        d = _colorOrderData(s);
        c = orderMatchData.c;
        if (c.join(result) !== d.c.join(result)) {
          shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
          l = shell.length - 1;
          for (; i < l; i++) {
            result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
          }
        }
      }
      if (!shell) {
        shell = s.split(_colorExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + colors[i];
        }
      }
      return result + shell[l];
    }, _colorExp = function() {
      var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p2;
      for (p2 in _colorLookup) {
        s += "|" + p2 + "\\b";
      }
      return new RegExp(s + ")", "gi");
    }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function _colorStringFilter2(a) {
      var combined = a.join(" "), toHSL;
      _colorExp.lastIndex = 0;
      if (_colorExp.test(combined)) {
        toHSL = _hslExp.test(combined);
        a[1] = _formatColors(a[1], toHSL);
        a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
        return true;
      }
    }, _tickerActive, _ticker = function() {
      var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v) {
        var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;
        (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
        _lastUpdate += elapsed;
        time = _lastUpdate - _startTime;
        overlap = time - _nextTime;
        if (overlap > 0 || manual) {
          frame = ++_self.frame;
          _delta = time - _self.time * 1e3;
          _self.time = time = time / 1e3;
          _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
          dispatch = 1;
        }
        manual || (_id = _req(_tick2));
        if (dispatch) {
          for (_i = 0; _i < _listeners2.length; _i++) {
            _listeners2[_i](time, _delta, frame, v);
          }
        }
      };
      _self = {
        time: 0,
        frame: 0,
        tick: function tick() {
          _tick(true);
        },
        deltaRatio: function deltaRatio(fps) {
          return _delta / (1e3 / (fps || 60));
        },
        wake: function wake() {
          if (_coreReady) {
            if (!_coreInitted && _windowExists$1()) {
              _win$1 = _coreInitted = window;
              _doc$1 = _win$1.document || {};
              _globals.gsap = gsap;
              (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(gsap.version);
              _install(_installScope || _win$1.GreenSockGlobals || !_win$1.gsap && _win$1 || {});
              _registerPluginQueue.forEach(_createPlugin);
            }
            _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
            _id && _self.sleep();
            _req = _raf || function(f) {
              return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
            };
            _tickerActive = 1;
            _tick(2);
          }
        },
        sleep: function sleep() {
          (_raf ? cancelAnimationFrame : clearTimeout)(_id);
          _tickerActive = 0;
          _req = _emptyFunc;
        },
        lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
          _lagThreshold = threshold || Infinity;
          _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
        },
        fps: function fps(_fps) {
          _gap = 1e3 / (_fps || 240);
          _nextTime = _self.time * 1e3 + _gap;
        },
        add: function add2(callback, once, prioritize) {
          var func = once ? function(t, d, f, v) {
            callback(t, d, f, v);
            _self.remove(func);
          } : callback;
          _self.remove(callback);
          _listeners2[prioritize ? "unshift" : "push"](func);
          _wake();
          return func;
        },
        remove: function remove2(callback, i) {
          ~(i = _listeners2.indexOf(callback)) && _listeners2.splice(i, 1) && _i >= i && _i--;
        },
        _listeners: _listeners2
      };
      return _self;
    }(), _wake = function _wake2() {
      return !_tickerActive && _ticker.wake();
    }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function _parseObjectInString2(value) {
      var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index, val, parsedVal;
      for (; i < l; i++) {
        val = split[i];
        index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
        parsedVal = val.substr(0, index);
        obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
        key = val.substr(index + 1).trim();
      }
      return obj;
    }, _valueInParentheses = function _valueInParentheses2(value) {
      var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
      return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
    }, _configEaseFromString = function _configEaseFromString2(name) {
      var split = (name + "").split("("), ease = _easeMap[split[0]];
      return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
    }, _invertEase = function _invertEase2(ease) {
      return function(p2) {
        return 1 - ease(1 - p2);
      };
    }, _propagateYoyoEase = function _propagateYoyoEase2(timeline, isYoyo) {
      var child = timeline._first, ease;
      while (child) {
        if (child instanceof Timeline) {
          _propagateYoyoEase2(child, isYoyo);
        } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
          if (child.timeline) {
            _propagateYoyoEase2(child.timeline, isYoyo);
          } else {
            ease = child._ease;
            child._ease = child._yEase;
            child._yEase = ease;
            child._yoyo = isYoyo;
          }
        }
        child = child._next;
      }
    }, _parseEase = function _parseEase2(ease, defaultEase) {
      return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
    }, _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
      if (easeOut === void 0) {
        easeOut = function easeOut2(p2) {
          return 1 - easeIn(1 - p2);
        };
      }
      if (easeInOut === void 0) {
        easeInOut = function easeInOut2(p2) {
          return p2 < 0.5 ? easeIn(p2 * 2) / 2 : 1 - easeIn((1 - p2) * 2) / 2;
        };
      }
      var ease = {
        easeIn,
        easeOut,
        easeInOut
      }, lowercaseName;
      _forEachName(names, function(name) {
        _easeMap[name] = _globals[name] = ease;
        _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
        for (var p2 in ease) {
          _easeMap[lowercaseName + (p2 === "easeIn" ? ".in" : p2 === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p2] = ease[p2];
        }
      });
      return ease;
    }, _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
      return function(p2) {
        return p2 < 0.5 ? (1 - easeOut(1 - p2 * 2)) / 2 : 0.5 + easeOut((p2 - 0.5) * 2) / 2;
      };
    }, _configElastic = function _configElastic2(type, amplitude, period) {
      var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p4) {
        return p4 === 1 ? 1 : p1 * Math.pow(2, -10 * p4) * _sin((p4 - p3) * p2) + 1;
      }, ease = type === "out" ? easeOut : type === "in" ? function(p4) {
        return 1 - easeOut(1 - p4);
      } : _easeInOutFromOut(easeOut);
      p2 = _2PI / p2;
      ease.config = function(amplitude2, period2) {
        return _configElastic2(type, amplitude2, period2);
      };
      return ease;
    }, _configBack = function _configBack2(type, overshoot) {
      if (overshoot === void 0) {
        overshoot = 1.70158;
      }
      var easeOut = function easeOut2(p2) {
        return p2 ? --p2 * p2 * ((overshoot + 1) * p2 + overshoot) + 1 : 0;
      }, ease = type === "out" ? easeOut : type === "in" ? function(p2) {
        return 1 - easeOut(1 - p2);
      } : _easeInOutFromOut(easeOut);
      ease.config = function(overshoot2) {
        return _configBack2(type, overshoot2);
      };
      return ease;
    };
    _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
      var power = i < 5 ? i + 1 : i;
      _insertEase(name + ",Power" + (power - 1), i ? function(p2) {
        return Math.pow(p2, power);
      } : function(p2) {
        return p2;
      }, function(p2) {
        return 1 - Math.pow(1 - p2, power);
      }, function(p2) {
        return p2 < 0.5 ? Math.pow(p2 * 2, power) / 2 : 1 - Math.pow((1 - p2) * 2, power) / 2;
      });
    });
    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
    _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
    (function(n, c) {
      var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p2) {
        return p2 < n1 ? n * p2 * p2 : p2 < n2 ? n * Math.pow(p2 - 1.5 / c, 2) + 0.75 : p2 < n3 ? n * (p2 -= 2.25 / c) * p2 + 0.9375 : n * Math.pow(p2 - 2.625 / c, 2) + 0.984375;
      };
      _insertEase("Bounce", function(p2) {
        return 1 - easeOut(1 - p2);
      }, easeOut);
    })(7.5625, 2.75);
    _insertEase("Expo", function(p2) {
      return p2 ? Math.pow(2, 10 * (p2 - 1)) : 0;
    });
    _insertEase("Circ", function(p2) {
      return -(_sqrt(1 - p2 * p2) - 1);
    });
    _insertEase("Sine", function(p2) {
      return p2 === 1 ? 1 : -_cos(p2 * _HALF_PI) + 1;
    });
    _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
      config: function config(steps, immediateStart) {
        if (steps === void 0) {
          steps = 1;
        }
        var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max2 = 1 - _tinyNum;
        return function(p4) {
          return ((p2 * _clamp(0, max2, p4) | 0) + p3) * p1;
        };
      }
    };
    _defaults.ease = _easeMap["quad.out"];
    _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
      return _callbackNames += name + "," + name + "Params,";
    });
    var GSCache = function GSCache2(target, harness) {
      this.id = _gsID++;
      target._gsap = this;
      this.target = target;
      this.harness = harness;
      this.get = harness ? harness.get : _getProperty;
      this.set = harness ? harness.getSetter : _getSetter;
    };
    var Animation = /* @__PURE__ */ function() {
      function Animation2(vars) {
        this.vars = vars;
        this._delay = +vars.delay || 0;
        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
          this._rDelay = vars.repeatDelay || 0;
          this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
        }
        this._ts = 1;
        _setDuration(this, +vars.duration, 1, 1);
        this.data = vars.data;
        if (_context) {
          this._ctx = _context;
          _context.data.push(this);
        }
        _tickerActive || _ticker.wake();
      }
      var _proto = Animation2.prototype;
      _proto.delay = function delay(value) {
        if (value || value === 0) {
          this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
          this._delay = value;
          return this;
        }
        return this._delay;
      };
      _proto.duration = function duration(value) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
      };
      _proto.totalDuration = function totalDuration(value) {
        if (!arguments.length) {
          return this._tDur;
        }
        this._dirty = 0;
        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
      };
      _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
        _wake();
        if (!arguments.length) {
          return this._tTime;
        }
        var parent = this._dp;
        if (parent && parent.smoothChildTiming && this._ts) {
          _alignPlayhead(this, _totalTime);
          !parent._dp || parent.parent || _postAddChecks(parent, this);
          while (parent && parent.parent) {
            if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
              parent.totalTime(parent._tTime, true);
            }
            parent = parent.parent;
          }
          if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
            _addToTimeline(this._dp, this, this._start - this._delay);
          }
        }
        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
          this._ts || (this._pTime = _totalTime);
          _lazySafeRender(this, _totalTime, suppressEvents);
        }
        return this;
      };
      _proto.time = function time(value, suppressEvents) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
      };
      _proto.totalProgress = function totalProgress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
      };
      _proto.progress = function progress(value, suppressEvents) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
      };
      _proto.iteration = function iteration(value, suppressEvents) {
        var cycleDuration = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
      };
      _proto.timeScale = function timeScale(value, suppressEvents) {
        if (!arguments.length) {
          return this._rts === -_tinyNum ? 0 : this._rts;
        }
        if (this._rts === value) {
          return this;
        }
        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
        this._rts = +value || 0;
        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
        this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== false);
        _setEnd(this);
        return _recacheAncestors(this);
      };
      _proto.paused = function paused(value) {
        if (!arguments.length) {
          return this._ps;
        }
        if (this._ps !== value) {
          this._ps = value;
          if (value) {
            this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
            this._ts = this._act = 0;
          } else {
            _wake();
            this._ts = this._rts;
            this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
          }
        }
        return this;
      };
      _proto.startTime = function startTime(value) {
        if (arguments.length) {
          this._start = value;
          var parent = this.parent || this._dp;
          parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
          return this;
        }
        return this._start;
      };
      _proto.endTime = function endTime(includeRepeats) {
        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
      };
      _proto.rawTime = function rawTime(wrapRepeats) {
        var parent = this.parent || this._dp;
        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
      };
      _proto.revert = function revert(config) {
        if (config === void 0) {
          config = _revertConfig;
        }
        var prevIsReverting = _reverting$1;
        _reverting$1 = config;
        if (this._initted || this._startAt) {
          this.timeline && this.timeline.revert(config);
          this.totalTime(-0.01, config.suppressEvents);
        }
        this.data !== "nested" && config.kill !== false && this.kill();
        _reverting$1 = prevIsReverting;
        return this;
      };
      _proto.globalTime = function globalTime(rawTime) {
        var animation = this, time = arguments.length ? rawTime : animation.rawTime();
        while (animation) {
          time = animation._start + time / (Math.abs(animation._ts) || 1);
          animation = animation._dp;
        }
        return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
      };
      _proto.repeat = function repeat(value) {
        if (arguments.length) {
          this._repeat = value === Infinity ? -2 : value;
          return _onUpdateTotalDuration(this);
        }
        return this._repeat === -2 ? Infinity : this._repeat;
      };
      _proto.repeatDelay = function repeatDelay(value) {
        if (arguments.length) {
          var time = this._time;
          this._rDelay = value;
          _onUpdateTotalDuration(this);
          return time ? this.time(time) : this;
        }
        return this._rDelay;
      };
      _proto.yoyo = function yoyo(value) {
        if (arguments.length) {
          this._yoyo = value;
          return this;
        }
        return this._yoyo;
      };
      _proto.seek = function seek(position, suppressEvents) {
        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
      };
      _proto.restart = function restart(includeDelay, suppressEvents) {
        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      };
      _proto.play = function play(from2, suppressEvents) {
        from2 != null && this.seek(from2, suppressEvents);
        return this.reversed(false).paused(false);
      };
      _proto.reverse = function reverse(from2, suppressEvents) {
        from2 != null && this.seek(from2 || this.totalDuration(), suppressEvents);
        return this.reversed(true).paused(false);
      };
      _proto.pause = function pause(atTime, suppressEvents) {
        atTime != null && this.seek(atTime, suppressEvents);
        return this.paused(true);
      };
      _proto.resume = function resume() {
        return this.paused(false);
      };
      _proto.reversed = function reversed(value) {
        if (arguments.length) {
          !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
          return this;
        }
        return this._rts < 0;
      };
      _proto.invalidate = function invalidate() {
        this._initted = this._act = 0;
        this._zTime = -_tinyNum;
        return this;
      };
      _proto.isActive = function isActive() {
        var parent = this.parent || this._dp, start2 = this._start, rawTime;
        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start2 && rawTime < this.endTime(true) - _tinyNum);
      };
      _proto.eventCallback = function eventCallback(type, callback, params) {
        var vars = this.vars;
        if (arguments.length > 1) {
          if (!callback) {
            delete vars[type];
          } else {
            vars[type] = callback;
            params && (vars[type + "Params"] = params);
            type === "onUpdate" && (this._onUpdate = callback);
          }
          return this;
        }
        return vars[type];
      };
      _proto.then = function then(onFulfilled) {
        var self2 = this;
        return new Promise(function(resolve2) {
          var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
            var _then = self2.then;
            self2.then = null;
            _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
            resolve2(f);
            self2.then = _then;
          };
          if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
            _resolve();
          } else {
            self2._prom = _resolve;
          }
        });
      };
      _proto.kill = function kill() {
        _interrupt(this);
      };
      return Animation2;
    }();
    _setDefaults(Animation.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -_tinyNum,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
    var Timeline = /* @__PURE__ */ function(_Animation) {
      _inheritsLoose(Timeline2, _Animation);
      function Timeline2(vars, position) {
        var _this;
        if (vars === void 0) {
          vars = {};
        }
        _this = _Animation.call(this, vars) || this;
        _this.labels = {};
        _this.smoothChildTiming = !!vars.smoothChildTiming;
        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
        _this._sort = _isNotFalse(vars.sortChildren);
        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
        vars.reversed && _this.reverse();
        vars.paused && _this.paused(true);
        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
        return _this;
      }
      var _proto2 = Timeline2.prototype;
      _proto2.to = function to2(targets, vars, position) {
        _createTweenType(0, arguments, this);
        return this;
      };
      _proto2.from = function from2(targets, vars, position) {
        _createTweenType(1, arguments, this);
        return this;
      };
      _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
        _createTweenType(2, arguments, this);
        return this;
      };
      _proto2.set = function set2(targets, vars, position) {
        vars.duration = 0;
        vars.parent = this;
        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
        vars.immediateRender = !!vars.immediateRender;
        new Tween(targets, vars, _parsePosition(this, position), 1);
        return this;
      };
      _proto2.call = function call(callback, params, position) {
        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
      };
      _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.duration = duration;
        vars.stagger = vars.stagger || stagger;
        vars.onComplete = onCompleteAll;
        vars.onCompleteParams = onCompleteAllParams;
        vars.parent = this;
        new Tween(targets, vars, _parsePosition(this, position));
        return this;
      };
      _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
        vars.runBackwards = 1;
        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
      _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
        toVars.startAt = fromVars;
        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
      };
      _proto2.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
        if (tTime !== this._tTime || force || crossingStart) {
          if (prevTime !== this._time && dur) {
            tTime += this._time - prevTime;
            totalTime += this._time - prevTime;
          }
          time = tTime;
          prevStart = this._start;
          timeScale = this._ts;
          prevPaused = !timeScale;
          if (crossingStart) {
            dur || (prevTime = this._zTime);
            (totalTime || !suppressEvents) && (this._zTime = totalTime);
          }
          if (this._repeat) {
            yoyo = this._yoyo;
            cycleDuration = dur + this._rDelay;
            if (this._repeat < -1 && totalTime < 0) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
            time = _roundPrecise(tTime % cycleDuration);
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
              if (iteration && iteration === tTime / cycleDuration) {
                time = dur;
                iteration--;
              }
              time > dur && (time = dur);
            }
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
            if (yoyo && iteration & 1) {
              time = dur - time;
              isYoyo = 1;
            }
            if (iteration !== prevIteration && !this._lock) {
              var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
              iteration < prevIteration && (rewinding = !rewinding);
              prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
              this._lock = 1;
              this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
              this._tTime = tTime;
              !suppressEvents && this.parent && _callback(this, "onRepeat");
              this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
              if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                return this;
              }
              dur = this._dur;
              tDur = this._tDur;
              if (doesWrap) {
                this._lock = 2;
                prevTime = rewinding ? dur : -1e-4;
                this.render(prevTime, true);
                this.vars.repeatRefresh && !isYoyo && this.invalidate();
              }
              this._lock = 0;
              if (!this._ts && !prevPaused) {
                return this;
              }
              _propagateYoyoEase(this, isYoyo);
            }
          }
          if (this._hasPause && !this._forcing && this._lock < 2) {
            pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
            if (pauseTween) {
              tTime -= time - (time = pauseTween._start);
            }
          }
          this._tTime = tTime;
          this._time = time;
          this._act = !timeScale;
          if (!this._initted) {
            this._onUpdate = this.vars.onUpdate;
            this._initted = 1;
            this._zTime = totalTime;
            prevTime = 0;
          }
          if (!prevTime && time && !suppressEvents && !iteration) {
            _callback(this, "onStart");
            if (this._tTime !== tTime) {
              return this;
            }
          }
          if (time >= prevTime && totalTime >= 0) {
            child = this._first;
            while (child) {
              next = child._next;
              if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
                child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = -_tinyNum);
                  break;
                }
              }
              child = next;
            }
          } else {
            child = this._last;
            var adjustedTime = totalTime < 0 ? totalTime : time;
            while (child) {
              next = child._prev;
              if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                if (child.parent !== this) {
                  return this.render(totalTime, suppressEvents, force);
                }
                child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting$1 && (child._initted || child._startAt));
                if (time !== this._time || !this._ts && !prevPaused) {
                  pauseTween = 0;
                  next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                  break;
                }
              }
              child = next;
            }
          }
          if (pauseTween && !suppressEvents) {
            this.pause();
            pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
            if (this._ts) {
              this._start = prevStart;
              _setEnd(this);
              return this.render(totalTime, suppressEvents, force);
            }
          }
          this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
          if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
            if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
              if (!this._lock) {
                (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                  _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                  this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                }
              }
            }
          }
        }
        return this;
      };
      _proto2.add = function add2(child, position) {
        var _this2 = this;
        _isNumber(position) || (position = _parsePosition(this, position, child));
        if (!(child instanceof Animation)) {
          if (_isArray(child)) {
            child.forEach(function(obj) {
              return _this2.add(obj, position);
            });
            return this;
          }
          if (_isString(child)) {
            return this.addLabel(child, position);
          }
          if (_isFunction(child)) {
            child = Tween.delayedCall(0, child);
          } else {
            return this;
          }
        }
        return this !== child ? _addToTimeline(this, child, position) : this;
      };
      _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
        if (nested === void 0) {
          nested = true;
        }
        if (tweens === void 0) {
          tweens = true;
        }
        if (timelines === void 0) {
          timelines = true;
        }
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = -_bigNum$1;
        }
        var a = [], child = this._first;
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            if (child instanceof Tween) {
              tweens && a.push(child);
            } else {
              timelines && a.push(child);
              nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
            }
          }
          child = child._next;
        }
        return a;
      };
      _proto2.getById = function getById(id) {
        var animations = this.getChildren(1, 1, 1), i = animations.length;
        while (i--) {
          if (animations[i].vars.id === id) {
            return animations[i];
          }
        }
      };
      _proto2.remove = function remove2(child) {
        if (_isString(child)) {
          return this.removeLabel(child);
        }
        if (_isFunction(child)) {
          return this.killTweensOf(child);
        }
        _removeLinkedListItem(this, child);
        if (child === this._recent) {
          this._recent = this._last;
        }
        return _uncache(this);
      };
      _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
        if (!arguments.length) {
          return this._tTime;
        }
        this._forcing = 1;
        if (!this._dp && this._ts) {
          this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
        }
        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
        this._forcing = 0;
        return this;
      };
      _proto2.addLabel = function addLabel(label, position) {
        this.labels[label] = _parsePosition(this, position);
        return this;
      };
      _proto2.removeLabel = function removeLabel(label) {
        delete this.labels[label];
        return this;
      };
      _proto2.addPause = function addPause(position, callback, params) {
        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
        t.data = "isPause";
        this._hasPause = 1;
        return _addToTimeline(this, t, _parsePosition(this, position));
      };
      _proto2.removePause = function removePause(position) {
        var child = this._first;
        position = _parsePosition(this, position);
        while (child) {
          if (child._start === position && child.data === "isPause") {
            _removeFromParent(child);
          }
          child = child._next;
        }
      };
      _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
        while (i--) {
          _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
        }
        return this;
      };
      _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
        var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
        while (child) {
          if (child instanceof Tween) {
            if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
              a.push(child);
            }
          } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
            a.push.apply(a, children);
          }
          child = child._next;
        }
        return a;
      };
      _proto2.tweenTo = function tweenTo(position, vars) {
        vars = vars || {};
        var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
          ease: vars.ease || "none",
          lazy: false,
          immediateRender: false,
          time: endTime,
          overwrite: "auto",
          duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
          onStart: function onStart() {
            tl.pause();
            if (!initted) {
              var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
              tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
              initted = 1;
            }
            _onStart && _onStart.apply(tween, onStartParams || []);
          }
        }, vars));
        return immediateRender ? tween.render(0) : tween;
      };
      _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
        return this.tweenTo(toPosition, _setDefaults({
          startAt: {
            time: _parsePosition(this, fromPosition)
          }
        }, vars));
      };
      _proto2.recent = function recent() {
        return this._recent;
      };
      _proto2.nextLabel = function nextLabel(afterTime) {
        if (afterTime === void 0) {
          afterTime = this._time;
        }
        return _getLabelInDirection(this, _parsePosition(this, afterTime));
      };
      _proto2.previousLabel = function previousLabel(beforeTime) {
        if (beforeTime === void 0) {
          beforeTime = this._time;
        }
        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
      };
      _proto2.currentLabel = function currentLabel(value) {
        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
      };
      _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
        if (ignoreBeforeTime === void 0) {
          ignoreBeforeTime = 0;
        }
        var child = this._first, labels = this.labels, p2;
        while (child) {
          if (child._start >= ignoreBeforeTime) {
            child._start += amount;
            child._end += amount;
          }
          child = child._next;
        }
        if (adjustLabels) {
          for (p2 in labels) {
            if (labels[p2] >= ignoreBeforeTime) {
              labels[p2] += amount;
            }
          }
        }
        return _uncache(this);
      };
      _proto2.invalidate = function invalidate(soft) {
        var child = this._first;
        this._lock = 0;
        while (child) {
          child.invalidate(soft);
          child = child._next;
        }
        return _Animation.prototype.invalidate.call(this, soft);
      };
      _proto2.clear = function clear2(includeLabels) {
        if (includeLabels === void 0) {
          includeLabels = true;
        }
        var child = this._first, next;
        while (child) {
          next = child._next;
          this.remove(child);
          child = next;
        }
        this._dp && (this._time = this._tTime = this._pTime = 0);
        includeLabels && (this.labels = {});
        return _uncache(this);
      };
      _proto2.totalDuration = function totalDuration(value) {
        var max2 = 0, self2 = this, child = self2._last, prevStart = _bigNum$1, prev, start2, parent;
        if (arguments.length) {
          return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
        }
        if (self2._dirty) {
          parent = self2.parent;
          while (child) {
            prev = child._prev;
            child._dirty && child.totalDuration();
            start2 = child._start;
            if (start2 > prevStart && self2._sort && child._ts && !self2._lock) {
              self2._lock = 1;
              _addToTimeline(self2, child, start2 - child._delay, 1)._lock = 0;
            } else {
              prevStart = start2;
            }
            if (start2 < 0 && child._ts) {
              max2 -= start2;
              if (!parent && !self2._dp || parent && parent.smoothChildTiming) {
                self2._start += start2 / self2._ts;
                self2._time -= start2;
                self2._tTime -= start2;
              }
              self2.shiftChildren(-start2, false, -Infinity);
              prevStart = 0;
            }
            child._end > max2 && child._ts && (max2 = child._end);
            child = prev;
          }
          _setDuration(self2, self2 === _globalTimeline && self2._time > max2 ? self2._time : max2, 1, 1);
          self2._dirty = 0;
        }
        return self2._tDur;
      };
      Timeline2.updateRoot = function updateRoot(time) {
        if (_globalTimeline._ts) {
          _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
          _lastRenderedFrame = _ticker.frame;
        }
        if (_ticker.frame >= _nextGCFrame) {
          _nextGCFrame += _config.autoSleep || 120;
          var child = _globalTimeline._first;
          if (!child || !child._ts) {
            if (_config.autoSleep && _ticker._listeners.length < 2) {
              while (child && !child._ts) {
                child = child._next;
              }
              child || _ticker.sleep();
            }
          }
        }
      };
      return Timeline2;
    }(Animation);
    _setDefaults(Timeline.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });
    var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start2, end2, setter, stringFilter, funcParam) {
      var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
      pt.b = start2;
      pt.e = end2;
      start2 += "";
      end2 += "";
      if (hasRandom = ~end2.indexOf("random(")) {
        end2 = _replaceRandom(end2);
      }
      if (stringFilter) {
        a = [start2, end2];
        stringFilter(a, target, prop);
        start2 = a[0];
        end2 = a[1];
      }
      startNums = start2.match(_complexStringNumExp) || [];
      while (result = _complexStringNumExp.exec(end2)) {
        endNum = result[0];
        chunk = end2.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(") {
          color = 1;
        }
        if (endNum !== startNums[matchIndex++]) {
          startNum = parseFloat(startNums[matchIndex - 1]) || 0;
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
            m: color && color < 4 ? Math.round : 0
          };
          index = _complexStringNumExp.lastIndex;
        }
      }
      pt.c = index < end2.length ? end2.substring(index, end2.length) : "";
      pt.fp = funcParam;
      if (_relExp.test(end2) || hasRandom) {
        pt.e = 0;
      }
      this._pt = pt;
      return pt;
    }, _addPropTween = function _addPropTween2(target, prop, start2, end2, index, targets, modifier, stringFilter, funcParam, optional) {
      _isFunction(end2) && (end2 = end2(index || 0, target, targets));
      var currentValue = target[prop], parsedStart = start2 !== "get" ? start2 : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
      if (_isString(end2)) {
        if (~end2.indexOf("random(")) {
          end2 = _replaceRandom(end2);
        }
        if (end2.charAt(1) === "=") {
          pt = _parseRelative(parsedStart, end2) + (getUnit(parsedStart) || 0);
          if (pt || pt === 0) {
            end2 = pt;
          }
        }
      }
      if (!optional || parsedStart !== end2 || _forceAllPropTweens) {
        if (!isNaN(parsedStart * end2) && end2 !== "") {
          pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end2 - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
          funcParam && (pt.fp = funcParam);
          modifier && pt.modifier(modifier, this, target);
          return this._pt = pt;
        }
        !currentValue && !(prop in target) && _missingPlugin(prop, end2);
        return _addComplexStringPropTween.call(this, target, prop, parsedStart, end2, setter, stringFilter || _config.stringFilter, funcParam);
      }
    }, _processVars = function _processVars2(vars, index, target, targets, tween) {
      _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
      if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
        return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
      }
      var copy = {}, p2;
      for (p2 in vars) {
        copy[p2] = _parseFuncOrString(vars[p2], tween, index, target, targets);
      }
      return copy;
    }, _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
      var plugin, pt, ptLookup, i;
      if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
        if (tween !== _quickTween) {
          ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
          i = plugin._props.length;
          while (i--) {
            ptLookup[plugin._props[i]] = pt;
          }
        }
      }
      return plugin;
    }, _overwritingTween, _forceAllPropTweens, _initTween = function _initTween2(tween, time, tTime) {
      var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p2, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
      tl && (!keyframes || !ease) && (ease = "none");
      tween._ease = _parseEase(ease, _defaults.ease);
      tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
      if (yoyoEase && tween._yoyo && !tween._repeat) {
        yoyoEase = tween._yEase;
        tween._yEase = tween._ease;
        tween._ease = yoyoEase;
      }
      tween._from = !tl && !!vars.runBackwards;
      if (!tl || keyframes && !vars.stagger) {
        harness = targets[0] ? _getCache(targets[0]).harness : 0;
        harnessVars = harness && vars[harness.prop];
        cleanVars = _copyExcluding(vars, _reservedProps);
        if (prevStartAt) {
          prevStartAt._zTime < 0 && prevStartAt.progress(1);
          time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
          prevStartAt._lazy = 0;
        }
        if (startAt) {
          _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
            data: "isStart",
            overwrite: false,
            parent,
            immediateRender: true,
            lazy: !prevStartAt && _isNotFalse(lazy),
            startAt: null,
            delay: 0,
            onUpdate: onUpdate && function() {
              return _callback(tween, "onUpdate");
            },
            stagger: 0
          }, startAt)));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting$1 || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
          if (immediateRender) {
            if (dur && time <= 0 && tTime <= 0) {
              time && (tween._zTime = time);
              return;
            }
          }
        } else if (runBackwards && dur) {
          if (!prevStartAt) {
            time && (immediateRender = false);
            p2 = _setDefaults({
              overwrite: false,
              data: "isFromStart",
              //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
              lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
              immediateRender,
              //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
              stagger: 0,
              parent
              //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
            }, cleanVars);
            harnessVars && (p2[harness.prop] = harnessVars);
            _removeFromParent(tween._startAt = Tween.set(targets, p2));
            tween._startAt._dp = 0;
            tween._startAt._sat = tween;
            time < 0 && (_reverting$1 ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
            tween._zTime = time;
            if (!immediateRender) {
              _initTween2(tween._startAt, _tinyNum, _tinyNum);
            } else if (!time) {
              return;
            }
          }
        }
        tween._pt = tween._ptCache = 0;
        lazy = dur && _isNotFalse(lazy) || lazy && !dur;
        for (i = 0; i < targets.length; i++) {
          target = targets[i];
          gsData = target._gsap || _harness(targets)[i]._gsap;
          tween._ptLookup[i] = ptLookup = {};
          _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
          index = fullTargets === targets ? i : fullTargets.indexOf(target);
          if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
            tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
            plugin._props.forEach(function(name) {
              ptLookup[name] = pt;
            });
            plugin.priority && (hasPriority = 1);
          }
          if (!harness || harnessVars) {
            for (p2 in cleanVars) {
              if (_plugins[p2] && (plugin = _checkPlugin(p2, cleanVars, tween, index, target, fullTargets))) {
                plugin.priority && (hasPriority = 1);
              } else {
                ptLookup[p2] = pt = _addPropTween.call(tween, target, p2, "get", cleanVars[p2], index, fullTargets, 0, vars.stringFilter);
              }
            }
          }
          tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
          if (autoOverwrite && tween._pt) {
            _overwritingTween = tween;
            _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
            overwritten = !tween.parent;
            _overwritingTween = 0;
          }
          tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
        }
        hasPriority && _sortPropTweensByPriority(tween);
        tween._onInit && tween._onInit(tween);
      }
      tween._onUpdate = onUpdate;
      tween._initted = (!tween._op || tween._pt) && !overwritten;
      keyframes && time <= 0 && tl.render(_bigNum$1, true, true);
    }, _updatePropTweens = function _updatePropTweens2(tween, property, value, start2, startIsRelative, ratio, time, skipRecursion) {
      var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
      if (!ptCache) {
        ptCache = tween._ptCache[property] = [];
        lookup = tween._ptLookup;
        i = tween._targets.length;
        while (i--) {
          pt = lookup[i][property];
          if (pt && pt.d && pt.d._pt) {
            pt = pt.d._pt;
            while (pt && pt.p !== property && pt.fp !== property) {
              pt = pt._next;
            }
          }
          if (!pt) {
            _forceAllPropTweens = 1;
            tween.vars[property] = "+=0";
            _initTween(tween, time);
            _forceAllPropTweens = 0;
            return skipRecursion ? _warn(property + " not eligible for reset") : 1;
          }
          ptCache.push(pt);
        }
      }
      i = ptCache.length;
      while (i--) {
        rootPT = ptCache[i];
        pt = rootPT._pt || rootPT;
        pt.s = (start2 || start2 === 0) && !startIsRelative ? start2 : pt.s + (start2 || 0) + ratio * pt.c;
        pt.c = value - pt.s;
        rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
        rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
      }
    }, _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
      var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p2, i, aliases2;
      if (!propertyAliases) {
        return vars;
      }
      copy = _merge({}, vars);
      for (p2 in propertyAliases) {
        if (p2 in copy) {
          aliases2 = propertyAliases[p2].split(",");
          i = aliases2.length;
          while (i--) {
            copy[aliases2[i]] = copy[p2];
          }
        }
      }
      return copy;
    }, _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
      var ease = obj.ease || easeEach || "power1.inOut", p2, a;
      if (_isArray(obj)) {
        a = allProps[prop] || (allProps[prop] = []);
        obj.forEach(function(value, i) {
          return a.push({
            t: i / (obj.length - 1) * 100,
            v: value,
            e: ease
          });
        });
      } else {
        for (p2 in obj) {
          a = allProps[p2] || (allProps[p2] = []);
          p2 === "ease" || a.push({
            t: parseFloat(prop),
            v: obj[p2],
            e: ease
          });
        }
      }
    }, _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
      return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
    }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {};
    _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
      return _staggerPropsToSkip[name] = 1;
    });
    var Tween = /* @__PURE__ */ function(_Animation2) {
      _inheritsLoose(Tween2, _Animation2);
      function Tween2(targets, vars, position, skipInherit) {
        var _this3;
        if (typeof vars === "number") {
          position.duration = vars;
          vars = position;
          position = null;
        }
        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
        var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p2, curTarget, staggerFunc, staggerVarsToMerge;
        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
        _this3._ptLookup = [];
        _this3._overwrite = overwrite;
        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          vars = _this3.vars;
          tl = _this3.timeline = new Timeline({
            data: "nested",
            defaults: defaults2 || {},
            targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
          });
          tl.kill();
          tl.parent = tl._dp = _assertThisInitialized(_this3);
          tl._start = 0;
          if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
            l = parsedTargets.length;
            staggerFunc = stagger && distribute(stagger);
            if (_isObject(stagger)) {
              for (p2 in stagger) {
                if (~_staggerTweenProps.indexOf(p2)) {
                  staggerVarsToMerge || (staggerVarsToMerge = {});
                  staggerVarsToMerge[p2] = stagger[p2];
                }
              }
            }
            for (i = 0; i < l; i++) {
              copy = _copyExcluding(vars, _staggerPropsToSkip);
              copy.stagger = 0;
              yoyoEase && (copy.yoyoEase = yoyoEase);
              staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
              curTarget = parsedTargets[i];
              copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
              copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
              if (!stagger && l === 1 && copy.delay) {
                _this3._delay = delay = copy.delay;
                _this3._start += delay;
                copy.delay = 0;
              }
              tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
              tl._ease = _easeMap.none;
            }
            tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
          } else if (keyframes) {
            _inheritDefaults(_setDefaults(tl.vars.defaults, {
              ease: "none"
            }));
            tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
            var time = 0, a, kf, v;
            if (_isArray(keyframes)) {
              keyframes.forEach(function(frame) {
                return tl.to(parsedTargets, frame, ">");
              });
              tl.duration();
            } else {
              copy = {};
              for (p2 in keyframes) {
                p2 === "ease" || p2 === "easeEach" || _parseKeyframe(p2, keyframes[p2], copy, keyframes.easeEach);
              }
              for (p2 in copy) {
                a = copy[p2].sort(function(a2, b) {
                  return a2.t - b.t;
                });
                time = 0;
                for (i = 0; i < a.length; i++) {
                  kf = a[i];
                  v = {
                    ease: kf.e,
                    duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                  };
                  v[p2] = kf.v;
                  tl.to(parsedTargets, v, time);
                  time += v.duration;
                }
              }
              tl.duration() < duration && tl.to({}, {
                duration: duration - tl.duration()
              });
            }
          }
          duration || _this3.duration(duration = tl.duration());
        } else {
          _this3.timeline = 0;
        }
        if (overwrite === true && !_suppressOverwrites) {
          _overwritingTween = _assertThisInitialized(_this3);
          _globalTimeline.killTweensOf(parsedTargets);
          _overwritingTween = 0;
        }
        _addToTimeline(parent, _assertThisInitialized(_this3), position);
        vars.reversed && _this3.reverse();
        vars.paused && _this3.paused(true);
        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
          _this3._tTime = -_tinyNum;
          _this3.render(Math.max(0, -delay) || 0);
        }
        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
        return _this3;
      }
      var _proto3 = Tween2.prototype;
      _proto3.render = function render(totalTime, suppressEvents, force) {
        var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
        if (!dur) {
          _renderZeroDurationTween(this, totalTime, suppressEvents, force);
        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
          time = tTime;
          timeline = this.timeline;
          if (this._repeat) {
            cycleDuration = dur + this._rDelay;
            if (this._repeat < -1 && isNegative) {
              return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
            }
            time = _roundPrecise(tTime % cycleDuration);
            if (tTime === tDur) {
              iteration = this._repeat;
              time = dur;
            } else {
              iteration = ~~(tTime / cycleDuration);
              if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
                time = dur;
                iteration--;
              }
              time > dur && (time = dur);
            }
            isYoyo = this._yoyo && iteration & 1;
            if (isYoyo) {
              yoyoEase = this._yEase;
              time = dur - time;
            }
            prevIteration = _animationCycle(this._tTime, cycleDuration);
            if (time === prevTime && !force && this._initted && iteration === prevIteration) {
              this._tTime = tTime;
              return this;
            }
            if (iteration !== prevIteration) {
              timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
              if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
                this._lock = force = 1;
                this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
              }
            }
          }
          if (!this._initted) {
            if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
              this._tTime = 0;
              return this;
            }
            if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
              return this;
            }
            if (dur !== this._dur) {
              return this.render(totalTime, suppressEvents, force);
            }
          }
          this._tTime = tTime;
          this._time = time;
          if (!this._act && this._ts) {
            this._act = 1;
            this._lazy = 0;
          }
          this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
          if (this._from) {
            this.ratio = ratio = 1 - ratio;
          }
          if (time && !prevTime && !suppressEvents && !iteration) {
            _callback(this, "onStart");
            if (this._tTime !== tTime) {
              return this;
            }
          }
          pt = this._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
          timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
          if (this._onUpdate && !suppressEvents) {
            isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
            _callback(this, "onUpdate");
          }
          this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
          if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
            isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
            (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
            if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
              _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
              this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
            }
          }
        }
        return this;
      };
      _proto3.targets = function targets() {
        return this._targets;
      };
      _proto3.invalidate = function invalidate(soft) {
        (!soft || !this.vars.runBackwards) && (this._startAt = 0);
        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
        this._ptLookup = [];
        this.timeline && this.timeline.invalidate(soft);
        return _Animation2.prototype.invalidate.call(this, soft);
      };
      _proto3.resetTo = function resetTo(property, value, start2, startIsRelative, skipRecursion) {
        _tickerActive || _ticker.wake();
        this._ts || this.play();
        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
        this._initted || _initTween(this, time);
        ratio = this._ease(time / this._dur);
        if (_updatePropTweens(this, property, value, start2, startIsRelative, ratio, time, skipRecursion)) {
          return this.resetTo(property, value, start2, startIsRelative, 1);
        }
        _alignPlayhead(this, 0);
        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
        return this.render(0);
      };
      _proto3.kill = function kill(targets, vars) {
        if (vars === void 0) {
          vars = "all";
        }
        if (!targets && (!vars || vars === "all")) {
          this._lazy = this._pt = 0;
          return this.parent ? _interrupt(this) : this;
        }
        if (this.timeline) {
          var tDur = this.timeline.totalDuration();
          this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
          this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
          return this;
        }
        var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p2, pt, i;
        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
          vars === "all" && (this._pt = 0);
          return _interrupt(this);
        }
        overwrittenProps = this._op = this._op || [];
        if (vars !== "all") {
          if (_isString(vars)) {
            p2 = {};
            _forEachName(vars, function(name) {
              return p2[name] = 1;
            });
            vars = p2;
          }
          vars = _addAliasesToVars(parsedTargets, vars);
        }
        i = parsedTargets.length;
        while (i--) {
          if (~killingTargets.indexOf(parsedTargets[i])) {
            curLookup = propTweenLookup[i];
            if (vars === "all") {
              overwrittenProps[i] = vars;
              props = curLookup;
              curOverwriteProps = {};
            } else {
              curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
              props = vars;
            }
            for (p2 in props) {
              pt = curLookup && curLookup[p2];
              if (pt) {
                if (!("kill" in pt.d) || pt.d.kill(p2) === true) {
                  _removeLinkedListItem(this, pt, "_pt");
                }
                delete curLookup[p2];
              }
              if (curOverwriteProps !== "all") {
                curOverwriteProps[p2] = 1;
              }
            }
          }
        }
        this._initted && !this._pt && firstPT && _interrupt(this);
        return this;
      };
      Tween2.to = function to2(targets, vars) {
        return new Tween2(targets, vars, arguments[2]);
      };
      Tween2.from = function from2(targets, vars) {
        return _createTweenType(1, arguments);
      };
      Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
        return new Tween2(callback, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay,
          onComplete: callback,
          onReverseComplete: callback,
          onCompleteParams: params,
          onReverseCompleteParams: params,
          callbackScope: scope
        });
      };
      Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
        return _createTweenType(2, arguments);
      };
      Tween2.set = function set2(targets, vars) {
        vars.duration = 0;
        vars.repeatDelay || (vars.repeat = 0);
        return new Tween2(targets, vars);
      };
      Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
        return _globalTimeline.killTweensOf(targets, props, onlyActive);
      };
      return Tween2;
    }(Animation);
    _setDefaults(Tween.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    });
    _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
      Tween[name] = function() {
        var tl = new Timeline(), params = _slice.call(arguments, 0);
        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
        return tl[name].apply(tl, params);
      };
    });
    var _setterPlain = function _setterPlain2(target, property, value) {
      return target[property] = value;
    }, _setterFunc = function _setterFunc2(target, property, value) {
      return target[property](value);
    }, _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
      return target[property](data.fp, value);
    }, _setterAttribute = function _setterAttribute2(target, property, value) {
      return target.setAttribute(property, value);
    }, _getSetter = function _getSetter2(target, property) {
      return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
    }, _renderPlain = function _renderPlain2(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
    }, _renderBoolean = function _renderBoolean2(ratio, data) {
      return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
    }, _renderComplexString = function _renderComplexString2(ratio, data) {
      var pt = data._pt, s = "";
      if (!ratio && data.b) {
        s = data.b;
      } else if (ratio === 1 && data.e) {
        s = data.e;
      } else {
        while (pt) {
          s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
          pt = pt._next;
        }
        s += data.c;
      }
      data.set(data.t, data.p, s, data);
    }, _renderPropTweens = function _renderPropTweens2(ratio, data) {
      var pt = data._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }, _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
      var pt = this._pt, next;
      while (pt) {
        next = pt._next;
        pt.p === property && pt.modifier(modifier, tween, target);
        pt = next;
      }
    }, _killPropTweensOf = function _killPropTweensOf2(property) {
      var pt = this._pt, hasNonDependentRemaining, next;
      while (pt) {
        next = pt._next;
        if (pt.p === property && !pt.op || pt.op === property) {
          _removeLinkedListItem(this, pt, "_pt");
        } else if (!pt.dep) {
          hasNonDependentRemaining = 1;
        }
        pt = next;
      }
      return !hasNonDependentRemaining;
    }, _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
      data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
    }, _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent) {
      var pt = parent._pt, next, pt2, first, last;
      while (pt) {
        next = pt._next;
        pt2 = first;
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
        pt = next;
      }
      parent._pt = first;
    };
    var PropTween = /* @__PURE__ */ function() {
      function PropTween2(next, target, prop, start2, change, renderer2, data, setter, priority) {
        this.t = target;
        this.s = start2;
        this.c = change;
        this.p = prop;
        this.r = renderer2 || _renderPlain;
        this.d = data || this;
        this.set = setter || _setterPlain;
        this.pr = priority || 0;
        this._next = next;
        if (next) {
          next._prev = this;
        }
      }
      var _proto4 = PropTween2.prototype;
      _proto4.modifier = function modifier(func, tween, target) {
        this.mSet = this.mSet || this.set;
        this.set = _setterWithModifier;
        this.m = func;
        this.mt = target;
        this.tween = tween;
      };
      return PropTween2;
    }();
    _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
      return _reservedProps[name] = 1;
    });
    _globals.TweenMax = _globals.TweenLite = Tween;
    _globals.TimelineLite = _globals.TimelineMax = Timeline;
    _globalTimeline = new Timeline({
      sortChildren: false,
      defaults: _defaults,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    });
    _config.stringFilter = _colorStringFilter;
    var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch2(type) {
      return (_listeners[type] || _emptyArray).map(function(f) {
        return f();
      });
    }, _onMediaChange = function _onMediaChange2() {
      var time = Date.now(), matches = [];
      if (time - _lastMediaTime > 2) {
        _dispatch("matchMediaInit");
        _media.forEach(function(c) {
          var queries = c.queries, conditions = c.conditions, match, p2, anyMatch, toggled;
          for (p2 in queries) {
            match = _win$1.matchMedia(queries[p2]).matches;
            match && (anyMatch = 1);
            if (match !== conditions[p2]) {
              conditions[p2] = match;
              toggled = 1;
            }
          }
          if (toggled) {
            c.revert();
            anyMatch && matches.push(c);
          }
        });
        _dispatch("matchMediaRevert");
        matches.forEach(function(c) {
          return c.onMatch(c, function(func) {
            return c.add(null, func);
          });
        });
        _lastMediaTime = time;
        _dispatch("matchMedia");
      }
    };
    var Context = /* @__PURE__ */ function() {
      function Context2(func, scope) {
        this.selector = scope && selector(scope);
        this.data = [];
        this._r = [];
        this.isReverted = false;
        this.id = _contextID++;
        func && this.add(func);
      }
      var _proto5 = Context2.prototype;
      _proto5.add = function add2(name, func, scope) {
        if (_isFunction(name)) {
          scope = func;
          func = name;
          name = _isFunction;
        }
        var self2 = this, f = function f2() {
          var prev = _context, prevSelector = self2.selector, result;
          prev && prev !== self2 && prev.data.push(self2);
          scope && (self2.selector = selector(scope));
          _context = self2;
          result = func.apply(self2, arguments);
          _isFunction(result) && self2._r.push(result);
          _context = prev;
          self2.selector = prevSelector;
          self2.isReverted = false;
          return result;
        };
        self2.last = f;
        return name === _isFunction ? f(self2, function(func2) {
          return self2.add(null, func2);
        }) : name ? self2[name] = f : f;
      };
      _proto5.ignore = function ignore(func) {
        var prev = _context;
        _context = null;
        func(this);
        _context = prev;
      };
      _proto5.getTweens = function getTweens() {
        var a = [];
        this.data.forEach(function(e) {
          return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
        });
        return a;
      };
      _proto5.clear = function clear2() {
        this._r.length = this.data.length = 0;
      };
      _proto5.kill = function kill(revert, matchMedia) {
        var _this4 = this;
        if (revert) {
          (function() {
            var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
            while (i2--) {
              t = _this4.data[i2];
              if (t.data === "isFlip") {
                t.revert();
                t.getChildren(true, true, false).forEach(function(tween) {
                  return tweens.splice(tweens.indexOf(tween), 1);
                });
              }
            }
            tweens.map(function(t2) {
              return {
                g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
                t: t2
              };
            }).sort(function(a, b) {
              return b.g - a.g || -Infinity;
            }).forEach(function(o) {
              return o.t.revert(revert);
            });
            i2 = _this4.data.length;
            while (i2--) {
              t = _this4.data[i2];
              if (t instanceof Timeline) {
                if (t.data !== "nested") {
                  t.scrollTrigger && t.scrollTrigger.revert();
                  t.kill();
                }
              } else {
                !(t instanceof Tween) && t.revert && t.revert(revert);
              }
            }
            _this4._r.forEach(function(f) {
              return f(revert, _this4);
            });
            _this4.isReverted = true;
          })();
        } else {
          this.data.forEach(function(e) {
            return e.kill && e.kill();
          });
        }
        this.clear();
        if (matchMedia) {
          var i = _media.length;
          while (i--) {
            _media[i].id === this.id && _media.splice(i, 1);
          }
        }
      };
      _proto5.revert = function revert(config) {
        this.kill(config || {});
      };
      return Context2;
    }();
    var MatchMedia = /* @__PURE__ */ function() {
      function MatchMedia2(scope) {
        this.contexts = [];
        this.scope = scope;
        _context && _context.data.push(this);
      }
      var _proto6 = MatchMedia2.prototype;
      _proto6.add = function add2(conditions, func, scope) {
        _isObject(conditions) || (conditions = {
          matches: conditions
        });
        var context = new Context(0, scope || this.scope), cond = context.conditions = {}, mq, p2, active;
        _context && !context.selector && (context.selector = _context.selector);
        this.contexts.push(context);
        func = context.add("onMatch", func);
        context.queries = conditions;
        for (p2 in conditions) {
          if (p2 === "all") {
            active = 1;
          } else {
            mq = _win$1.matchMedia(conditions[p2]);
            if (mq) {
              _media.indexOf(context) < 0 && _media.push(context);
              (cond[p2] = mq.matches) && (active = 1);
              mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
            }
          }
        }
        active && func(context, function(f) {
          return context.add(null, f);
        });
        return this;
      };
      _proto6.revert = function revert(config) {
        this.kill(config || {});
      };
      _proto6.kill = function kill(revert) {
        this.contexts.forEach(function(c) {
          return c.kill(revert, true);
        });
      };
      return MatchMedia2;
    }();
    var _gsap = {
      registerPlugin: function registerPlugin() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        args.forEach(function(config) {
          return _createPlugin(config);
        });
      },
      timeline: function timeline(vars) {
        return new Timeline(vars);
      },
      getTweensOf: function getTweensOf(targets, onlyActive) {
        return _globalTimeline.getTweensOf(targets, onlyActive);
      },
      getProperty: function getProperty(target, property, unit, uncache) {
        _isString(target) && (target = toArray(target)[0]);
        var getter = _getCache(target || {}).get, format2 = unit ? _passThrough : _numericIfPossible;
        unit === "native" && (unit = "");
        return !target ? target : !property ? function(property2, unit2, uncache2) {
          return format2((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
        } : format2((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
      },
      quickSetter: function quickSetter(target, property, unit) {
        target = toArray(target);
        if (target.length > 1) {
          var setters = target.map(function(t) {
            return gsap.quickSetter(t, property, unit);
          }), l = setters.length;
          return function(value) {
            var i = l;
            while (i--) {
              setters[i](value);
            }
          };
        }
        target = target[0] || {};
        var Plugin = _plugins[property], cache = _getCache(target), p2 = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
          var p3 = new Plugin();
          _quickTween._pt = 0;
          p3.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
          p3.render(1, p3);
          _quickTween._pt && _renderPropTweens(1, _quickTween);
        } : cache.set(target, p2);
        return Plugin ? setter : function(value) {
          return setter(target, p2, unit ? value + unit : value, cache, 1);
        };
      },
      quickTo: function quickTo(target, property, vars) {
        var _merge2;
        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})), func = function func2(value, start2, startIsRelative) {
          return tween.resetTo(property, value, start2, startIsRelative);
        };
        func.tween = tween;
        return func;
      },
      isTweening: function isTweening(targets) {
        return _globalTimeline.getTweensOf(targets, true).length > 0;
      },
      defaults: function defaults2(value) {
        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
        return _mergeDeep(_defaults, value || {});
      },
      config: function config(value) {
        return _mergeDeep(_config, value || {});
      },
      registerEffect: function registerEffect(_ref3) {
        var name = _ref3.name, effect2 = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
        (plugins || "").split(",").forEach(function(pluginName) {
          return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
        });
        _effects[name] = function(targets, vars, tl) {
          return effect2(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
        };
        if (extendTimeline) {
          Timeline.prototype[name] = function(targets, vars, position) {
            return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
          };
        }
      },
      registerEase: function registerEase(name, ease) {
        _easeMap[name] = _parseEase(ease);
      },
      parseEase: function parseEase(ease, defaultEase) {
        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
      },
      getById: function getById(id) {
        return _globalTimeline.getById(id);
      },
      exportRoot: function exportRoot(vars, includeDelayedCalls) {
        if (vars === void 0) {
          vars = {};
        }
        var tl = new Timeline(vars), child, next;
        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
        _globalTimeline.remove(tl);
        tl._dp = 0;
        tl._time = tl._tTime = _globalTimeline._time;
        child = _globalTimeline._first;
        while (child) {
          next = child._next;
          if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
            _addToTimeline(tl, child, child._start - child._delay);
          }
          child = next;
        }
        _addToTimeline(_globalTimeline, tl, 0);
        return tl;
      },
      context: function context(func, scope) {
        return func ? new Context(func, scope) : _context;
      },
      matchMedia: function matchMedia(scope) {
        return new MatchMedia(scope);
      },
      matchMediaRefresh: function matchMediaRefresh() {
        return _media.forEach(function(c) {
          var cond = c.conditions, found, p2;
          for (p2 in cond) {
            if (cond[p2]) {
              cond[p2] = false;
              found = 1;
            }
          }
          found && c.revert();
        }) || _onMediaChange();
      },
      addEventListener: function addEventListener2(type, callback) {
        var a = _listeners[type] || (_listeners[type] = []);
        ~a.indexOf(callback) || a.push(callback);
      },
      removeEventListener: function removeEventListener2(type, callback) {
        var a = _listeners[type], i = a && a.indexOf(callback);
        i >= 0 && a.splice(i, 1);
      },
      utils: {
        wrap,
        wrapYoyo,
        distribute,
        random,
        snap,
        normalize,
        getUnit,
        clamp,
        splitColor,
        toArray,
        selector,
        mapRange,
        pipe,
        unitize,
        interpolate,
        shuffle
      },
      install: _install,
      effects: _effects,
      ticker: _ticker,
      updateRoot: Timeline.updateRoot,
      plugins: _plugins,
      globalTimeline: _globalTimeline,
      core: {
        PropTween,
        globals: _addGlobal,
        Tween,
        Timeline,
        Animation,
        getCache: _getCache,
        _removeLinkedListItem,
        reverting: function reverting() {
          return _reverting$1;
        },
        context: function context(toAdd) {
          if (toAdd && _context) {
            _context.data.push(toAdd);
            toAdd._ctx = _context;
          }
          return _context;
        },
        suppressOverwrites: function suppressOverwrites(value) {
          return _suppressOverwrites = value;
        }
      }
    };
    _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
      return _gsap[name] = Tween[name];
    });
    _ticker.add(Timeline.updateRoot);
    _quickTween = _gsap.to({}, {
      duration: 0
    });
    var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
      var pt = plugin._pt;
      while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
        pt = pt._next;
      }
      return pt;
    }, _addModifiers = function _addModifiers2(tween, modifiers) {
      var targets = tween._targets, p2, i, pt;
      for (p2 in modifiers) {
        i = targets.length;
        while (i--) {
          pt = tween._ptLookup[i][p2];
          if (pt && (pt = pt.d)) {
            if (pt._pt) {
              pt = _getPluginPropTween(pt, p2);
            }
            pt && pt.modifier && pt.modifier(modifiers[p2], tween, targets[i], p2);
          }
        }
      }
    }, _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
      return {
        name,
        rawVars: 1,
        //don't pre-process function-based values or "random()" strings.
        init: function init(target, vars, tween) {
          tween._onInit = function(tween2) {
            var temp, p2;
            if (_isString(vars)) {
              temp = {};
              _forEachName(vars, function(name2) {
                return temp[name2] = 1;
              });
              vars = temp;
            }
            if (modifier) {
              temp = {};
              for (p2 in vars) {
                temp[p2] = modifier(vars[p2]);
              }
              vars = temp;
            }
            _addModifiers(tween2, vars);
          };
        }
      };
    };
    var gsap = _gsap.registerPlugin({
      name: "attr",
      init: function init(target, vars, tween, index, targets) {
        var p2, pt, v;
        this.tween = tween;
        for (p2 in vars) {
          v = target.getAttribute(p2) || "";
          pt = this.add(target, "setAttribute", (v || 0) + "", vars[p2], index, targets, 0, 0, p2);
          pt.op = p2;
          pt.b = v;
          this._props.push(p2);
        }
      },
      render: function render(ratio, data) {
        var pt = data._pt;
        while (pt) {
          _reverting$1 ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
          pt = pt._next;
        }
      }
    }, {
      name: "endArray",
      init: function init(target, value) {
        var i = value.length;
        while (i--) {
          this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
        }
      }
    }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
    Tween.version = Timeline.version = gsap.version = "3.12.5";
    _coreReady = 1;
    _windowExists$1() && _wake();
    _easeMap.Power0;
    _easeMap.Power1;
    _easeMap.Power2;
    _easeMap.Power3;
    _easeMap.Power4;
    _easeMap.Linear;
    _easeMap.Quad;
    _easeMap.Cubic;
    _easeMap.Quart;
    _easeMap.Quint;
    _easeMap.Strong;
    _easeMap.Elastic;
    _easeMap.Back;
    _easeMap.SteppedEase;
    _easeMap.Bounce;
    _easeMap.Sine;
    _easeMap.Expo;
    _easeMap.Circ;
    /*!
     * CSSPlugin 3.12.5
     * https://gsap.com
     *
     * Copyright 2008-2024, GreenSock. All rights reserved.
     * Subject to the terms at https://gsap.com/standard-license or for
     * Club GSAP members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
    */
    var _win, _doc, _docElement, _pluginInitted, _tempDiv, _recentSetterPlugin, _reverting, _windowExists = function _windowExists2() {
      return typeof window !== "undefined";
    }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    }, _renderCSSProp = function _renderCSSProp2(ratio, data) {
      return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
    }, _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
      return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
    }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
      return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
    }, _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
      var value = data.s + data.c * ratio;
      data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
    }, _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
      return data.set(data.t, data.p, ratio ? data.e : data.b, data);
    }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
      return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
    }, _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
      return target.style[property] = value;
    }, _setterCSSProp = function _setterCSSProp2(target, property, value) {
      return target.style.setProperty(property, value);
    }, _setterTransform = function _setterTransform2(target, property, value) {
      return target._gsap[property] = value;
    }, _setterScale = function _setterScale2(target, property, value) {
      return target._gsap.scaleX = target._gsap.scaleY = value;
    }, _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache.scaleX = cache.scaleY = value;
      cache.renderTransform(ratio, cache);
    }, _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
      var cache = target._gsap;
      cache[property] = value;
      cache.renderTransform(ratio, cache);
    }, _transformProp = "transform", _transformOriginProp = _transformProp + "Origin", _saveStyle = function _saveStyle2(property, isNotCSS) {
      var _this = this;
      var target = this.target, style = target.style, cache = target._gsap;
      if (property in _transformProps && style) {
        this.tfm = this.tfm || {};
        if (property !== "transform") {
          property = _propertyAliases[property] || property;
          ~property.indexOf(",") ? property.split(",").forEach(function(a) {
            return _this.tfm[a] = _get(target, a);
          }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
          property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
        } else {
          return _propertyAliases.transform.split(",").forEach(function(p2) {
            return _saveStyle2.call(_this, p2, isNotCSS);
          });
        }
        if (this.props.indexOf(_transformProp) >= 0) {
          return;
        }
        if (cache.svg) {
          this.svgo = target.getAttribute("data-svg-origin");
          this.props.push(_transformOriginProp, isNotCSS, "");
        }
        property = _transformProp;
      }
      (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
    }, _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
      if (style.translate) {
        style.removeProperty("translate");
        style.removeProperty("scale");
        style.removeProperty("rotate");
      }
    }, _revertStyle = function _revertStyle2() {
      var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p2;
      for (i = 0; i < props.length; i += 3) {
        props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
      }
      if (this.tfm) {
        for (p2 in this.tfm) {
          cache[p2] = this.tfm[p2];
        }
        if (cache.svg) {
          cache.renderTransform();
          target.setAttribute("data-svg-origin", this.svgo || "");
        }
        i = _reverting();
        if ((!i || !i.isStart) && !style[_transformProp]) {
          _removeIndependentTransforms(style);
          if (cache.zOrigin && style[_transformOriginProp]) {
            style[_transformOriginProp] += " " + cache.zOrigin + "px";
            cache.zOrigin = 0;
            cache.renderTransform();
          }
          cache.uncache = 1;
        }
      }
    }, _getStyleSaver = function _getStyleSaver2(target, properties) {
      var saver = {
        target,
        props: [],
        revert: _revertStyle,
        save: _saveStyle
      };
      target._gsap || gsap.core.getCache(target);
      properties && properties.split(",").forEach(function(p2) {
        return saver.save(p2);
      });
      return saver;
    }, _supports3D, _createElement = function _createElement2(type, ns) {
      var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type);
      return e && e.style ? e : _doc.createElement(type);
    }, _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
      var cs = getComputedStyle(target);
      return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
    }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
      var e = element || _tempDiv, s = e.style, i = 5;
      if (property in s && !preferPrefix) {
        return property;
      }
      property = property.charAt(0).toUpperCase() + property.substr(1);
      while (i-- && !(_prefixes[i] + property in s)) {
      }
      return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
    }, _initCore = function _initCore2() {
      if (_windowExists() && window.document) {
        _win = window;
        _doc = _win.document;
        _docElement = _doc.documentElement;
        _tempDiv = _createElement("div") || {
          style: {}
        };
        _createElement("div");
        _transformProp = _checkPropPrefix(_transformProp);
        _transformOriginProp = _transformProp + "Origin";
        _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
        _supports3D = !!_checkPropPrefix("perspective");
        _reverting = gsap.core.reverting;
        _pluginInitted = 1;
      }
    }, _getBBoxHack = function _getBBoxHack2(swapIfPossible) {
      var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), oldParent = this.parentNode, oldSibling = this.nextSibling, oldCSS = this.style.cssText, bbox;
      _docElement.appendChild(svg);
      svg.appendChild(this);
      this.style.display = "block";
      if (swapIfPossible) {
        try {
          bbox = this.getBBox();
          this._gsapBBox = this.getBBox;
          this.getBBox = _getBBoxHack2;
        } catch (e) {
        }
      } else if (this._gsapBBox) {
        bbox = this._gsapBBox();
      }
      if (oldParent) {
        if (oldSibling) {
          oldParent.insertBefore(this, oldSibling);
        } else {
          oldParent.appendChild(this);
        }
      }
      _docElement.removeChild(svg);
      this.style.cssText = oldCSS;
      return bbox;
    }, _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
      var i = attributesArray.length;
      while (i--) {
        if (target.hasAttribute(attributesArray[i])) {
          return target.getAttribute(attributesArray[i]);
        }
      }
    }, _getBBox = function _getBBox2(target) {
      var bounds;
      try {
        bounds = target.getBBox();
      } catch (error) {
        bounds = _getBBoxHack.call(target, true);
      }
      bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true));
      return bounds && !bounds.width && !bounds.x && !bounds.y ? {
        x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
        y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
        width: 0,
        height: 0
      } : bounds;
    }, _isSVG = function _isSVG2(e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
    }, _removeProperty = function _removeProperty2(target, property) {
      if (property) {
        var style = target.style, first2Chars;
        if (property in _transformProps && property !== _transformOriginProp) {
          property = _transformProp;
        }
        if (style.removeProperty) {
          first2Chars = property.substr(0, 2);
          if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
            property = "-" + property;
          }
          style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
        } else {
          style.removeAttribute(property);
        }
      }
    }, _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end2, onlySetAtEnd) {
      var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
      plugin._pt = pt;
      pt.b = beginning;
      pt.e = end2;
      plugin._props.push(property);
      return pt;
    }, _nonConvertibleUnits = {
      deg: 1,
      rad: 1,
      turn: 1
    }, _nonStandardLayouts = {
      grid: 1,
      flex: 1
    }, _convertToUnit = function _convertToUnit2(target, property, value, unit) {
      var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent, cache, isSVG;
      if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
        return curValue;
      }
      curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
      isSVG = target.getCTM && _isSVG(target);
      if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
        px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
        return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
      }
      style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
      parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
      if (isSVG) {
        parent = (target.ownerSVGElement || {}).parentNode;
      }
      if (!parent || parent === _doc || !parent.appendChild) {
        parent = _doc.body;
      }
      cache = parent._gsap;
      if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
        return _round(curValue / cache.width * amount);
      } else {
        if (toPercent && (property === "height" || property === "width")) {
          var v = target.style[property];
          target.style[property] = amount + unit;
          px = target[measureProperty];
          v ? target.style[property] = v : _removeProperty(target, property);
        } else {
          (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
          parent === target && (style.position = "static");
          parent.appendChild(_tempDiv);
          px = _tempDiv[measureProperty];
          parent.removeChild(_tempDiv);
          style.position = "absolute";
        }
        if (horizontal && toPercent) {
          cache = _getCache(parent);
          cache.time = _ticker.time;
          cache.width = parent[measureProperty];
        }
      }
      return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
    }, _get = function _get2(target, property, unit, uncache) {
      var value;
      _pluginInitted || _initCore();
      if (property in _propertyAliases && property !== "transform") {
        property = _propertyAliases[property];
        if (~property.indexOf(",")) {
          property = property.split(",")[0];
        }
      }
      if (_transformProps[property] && property !== "transform") {
        value = _parseTransform(target, uncache);
        value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
      } else {
        value = target.style[property];
        if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
          value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
        }
      }
      return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
    }, _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start2, end2) {
      if (!start2 || start2 === "none") {
        var p2 = _checkPropPrefix(prop, target, 1), s = p2 && _getComputedProperty(target, p2, 1);
        if (s && s !== start2) {
          prop = p2;
          start2 = s;
        } else if (prop === "borderColor") {
          start2 = _getComputedProperty(target, "borderTopColor");
        }
      }
      var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
      pt.b = start2;
      pt.e = end2;
      start2 += "";
      end2 += "";
      if (end2 === "auto") {
        startValue = target.style[prop];
        target.style[prop] = end2;
        end2 = _getComputedProperty(target, prop) || end2;
        startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
      }
      a = [start2, end2];
      _colorStringFilter(a);
      start2 = a[0];
      end2 = a[1];
      startValues = start2.match(_numWithUnitExp) || [];
      endValues = end2.match(_numWithUnitExp) || [];
      if (endValues.length) {
        while (result = _numWithUnitExp.exec(end2)) {
          endValue = result[0];
          chunk = end2.substring(index, result.index);
          if (color) {
            color = (color + 1) % 5;
          } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
            color = 1;
          }
          if (endValue !== (startValue = startValues[matchIndex++] || "")) {
            startNum = parseFloat(startValue) || 0;
            startUnit = startValue.substr((startNum + "").length);
            endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
            endNum = parseFloat(endValue);
            endUnit = endValue.substr((endNum + "").length);
            index = _numWithUnitExp.lastIndex - endUnit.length;
            if (!endUnit) {
              endUnit = endUnit || _config.units[prop] || startUnit;
              if (index === end2.length) {
                end2 += endUnit;
                pt.e += endUnit;
              }
            }
            if (startUnit !== endUnit) {
              startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
            }
            pt._pt = {
              _next: pt._pt,
              p: chunk || matchIndex === 1 ? chunk : ",",
              //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
              s: startNum,
              c: endNum - startNum,
              m: color && color < 4 || prop === "zIndex" ? Math.round : 0
            };
          }
        }
        pt.c = index < end2.length ? end2.substring(index, end2.length) : "";
      } else {
        pt.r = prop === "display" && end2 === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
      }
      _relExp.test(end2) && (pt.e = 0);
      this._pt = pt;
      return pt;
    }, _keywordToPercent = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
      var split = value.split(" "), x = split[0], y = split[1] || "50%";
      if (x === "top" || x === "bottom" || y === "left" || y === "right") {
        value = x;
        x = y;
        y = value;
      }
      split[0] = _keywordToPercent[x] || x;
      split[1] = _keywordToPercent[y] || y;
      return split.join(" ");
    }, _renderClearProps = function _renderClearProps2(ratio, data) {
      if (data.tween && data.tween._time === data.tween._dur) {
        var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
        if (props === "all" || props === true) {
          style.cssText = "";
          clearTransforms = 1;
        } else {
          props = props.split(",");
          i = props.length;
          while (--i > -1) {
            prop = props[i];
            if (_transformProps[prop]) {
              clearTransforms = 1;
              prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
            }
            _removeProperty(target, prop);
          }
        }
        if (clearTransforms) {
          _removeProperty(target, _transformProp);
          if (cache) {
            cache.svg && target.removeAttribute("transform");
            _parseTransform(target, 1);
            cache.uncache = 1;
            _removeIndependentTransforms(style);
          }
        }
      }
    }, _specialProps = {
      clearProps: function clearProps(plugin, target, property, endValue, tween) {
        if (tween.data !== "isFromStart") {
          var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
          pt.u = endValue;
          pt.pr = -10;
          pt.tween = tween;
          plugin._props.push(property);
          return 1;
        }
      }
      /* className feature (about 0.4kb gzipped).
      , className(plugin, target, property, endValue, tween) {
      	let _renderClassName = (ratio, data) => {
      			data.css.render(ratio, data.css);
      			if (!ratio || ratio === 1) {
      				let inline = data.rmv,
      					target = data.t,
      					p;
      				target.setAttribute("class", ratio ? data.e : data.b);
      				for (p in inline) {
      					_removeProperty(target, p);
      				}
      			}
      		},
      		_getAllStyles = (target) => {
      			let styles = {},
      				computed = getComputedStyle(target),
      				p;
      			for (p in computed) {
      				if (isNaN(p) && p !== "cssText" && p !== "length") {
      					styles[p] = computed[p];
      				}
      			}
      			_setDefaults(styles, _parseTransform(target, 1));
      			return styles;
      		},
      		startClassList = target.getAttribute("class"),
      		style = target.style,
      		cssText = style.cssText,
      		cache = target._gsap,
      		classPT = cache.classPT,
      		inlineToRemoveAtEnd = {},
      		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
      		changingVars = {},
      		startVars = _getAllStyles(target),
      		transformRelated = /(transform|perspective)/i,
      		endVars, p;
      	if (classPT) {
      		classPT.r(1, classPT.d);
      		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
      	}
      	target.setAttribute("class", data.e);
      	endVars = _getAllStyles(target, true);
      	target.setAttribute("class", startClassList);
      	for (p in endVars) {
      		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
      			changingVars[p] = endVars[p];
      			if (!style[p] && style[p] !== "0") {
      				inlineToRemoveAtEnd[p] = 1;
      			}
      		}
      	}
      	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
      	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
      		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
      	}
      	_parseTransform(target, true); //to clear the caching of transforms
      	data.css = new gsap.plugins.css();
      	data.css.init(target, changingVars, tween);
      	plugin._props.push(...data.css._props);
      	return 1;
      }
      */
    }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function _isNullTransform2(value) {
      return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
    }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
      var matrixString = _getComputedProperty(target, _transformProp);
      return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
    }, _getMatrix = function _getMatrix2(target, force2D) {
      var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;
      if (cache.svg && target.getAttribute("transform")) {
        temp = target.transform.baseVal.consolidate().matrix;
        matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
        return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
      } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
        temp = style.display;
        style.display = "block";
        parent = target.parentNode;
        if (!parent || !target.offsetParent) {
          addedToDOM = 1;
          nextSibling = target.nextElementSibling;
          _docElement.appendChild(target);
        }
        matrix = _getComputedTransformMatrixAsArray(target);
        temp ? style.display = temp : _removeProperty(target, "display");
        if (addedToDOM) {
          nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
        }
      }
      return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
    }, _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
      var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
      if (!originIsAbsolute) {
        bounds = _getBBox(target);
        xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
        yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
      } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
        x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
        y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
        xOrigin = x;
        yOrigin = y;
      }
      if (smooth || smooth !== false && cache.smooth) {
        tx = xOrigin - xOriginOld;
        ty = yOrigin - yOriginOld;
        cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
        cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
      } else {
        cache.xOffset = cache.yOffset = 0;
      }
      cache.xOrigin = xOrigin;
      cache.yOrigin = yOrigin;
      cache.smooth = !!smooth;
      cache.origin = origin;
      cache.originIsAbsolute = !!originIsAbsolute;
      target.style[_transformOriginProp] = "0px 0px";
      if (pluginToAddPropTweensTo) {
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
        _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
      }
      target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
    }, _parseTransform = function _parseTransform2(target, uncache) {
      var cache = target._gsap || new GSCache(target);
      if ("x" in cache && !uncache && !cache.uncache) {
        return cache;
      }
      var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
      x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
      scaleX = scaleY = 1;
      cache.svg = !!(target.getCTM && _isSVG(target));
      if (cs.translate) {
        if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
          style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
        }
        style.scale = style.rotate = style.translate = "none";
      }
      matrix = _getMatrix(target, cache.svg);
      if (cache.svg) {
        if (cache.uncache) {
          t2 = target.getBBox();
          origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
          t1 = "";
        } else {
          t1 = !uncache && target.getAttribute("data-svg-origin");
        }
        _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
      }
      xOrigin = cache.xOrigin || 0;
      yOrigin = cache.yOrigin || 0;
      if (matrix !== _identity2DMatrix) {
        a = matrix[0];
        b = matrix[1];
        c = matrix[2];
        d = matrix[3];
        x = a12 = matrix[4];
        y = a22 = matrix[5];
        if (matrix.length === 6) {
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
          skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
          skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
          if (cache.svg) {
            x -= xOrigin - (xOrigin * a + yOrigin * c);
            y -= yOrigin - (xOrigin * b + yOrigin * d);
          }
        } else {
          a32 = matrix[6];
          a42 = matrix[7];
          a13 = matrix[8];
          a23 = matrix[9];
          a33 = matrix[10];
          a43 = matrix[11];
          x = matrix[12];
          y = matrix[13];
          z = matrix[14];
          angle = _atan2(a32, a33);
          rotationX = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a12 * cos + a13 * sin;
            t2 = a22 * cos + a23 * sin;
            t3 = a32 * cos + a33 * sin;
            a13 = a12 * -sin + a13 * cos;
            a23 = a22 * -sin + a23 * cos;
            a33 = a32 * -sin + a33 * cos;
            a43 = a42 * -sin + a43 * cos;
            a12 = t1;
            a22 = t2;
            a32 = t3;
          }
          angle = _atan2(-c, a33);
          rotationY = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(-angle);
            sin = Math.sin(-angle);
            t1 = a * cos - a13 * sin;
            t2 = b * cos - a23 * sin;
            t3 = c * cos - a33 * sin;
            a43 = d * sin + a43 * cos;
            a = t1;
            b = t2;
            c = t3;
          }
          angle = _atan2(b, a);
          rotation = angle * _RAD2DEG;
          if (angle) {
            cos = Math.cos(angle);
            sin = Math.sin(angle);
            t1 = a * cos + b * sin;
            t2 = a12 * cos + a22 * sin;
            b = b * cos - a * sin;
            a22 = a22 * cos - a12 * sin;
            a = t1;
            a12 = t2;
          }
          if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
            rotationX = rotation = 0;
            rotationY = 180 - rotationY;
          }
          scaleX = _round(Math.sqrt(a * a + b * b + c * c));
          scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
          angle = _atan2(a12, a22);
          skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
          perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
        }
        if (cache.svg) {
          t1 = target.getAttribute("transform");
          cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
          t1 && target.setAttribute("transform", t1);
        }
      }
      if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
        if (invertedScaleX) {
          scaleX *= -1;
          skewX += rotation <= 0 ? 180 : -180;
          rotation += rotation <= 0 ? 180 : -180;
        } else {
          scaleY *= -1;
          skewX += skewX <= 0 ? 180 : -180;
        }
      }
      uncache = uncache || cache.uncache;
      cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
      cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
      cache.z = z + px;
      cache.scaleX = _round(scaleX);
      cache.scaleY = _round(scaleY);
      cache.rotation = _round(rotation) + deg;
      cache.rotationX = _round(rotationX) + deg;
      cache.rotationY = _round(rotationY) + deg;
      cache.skewX = skewX + deg;
      cache.skewY = skewY + deg;
      cache.transformPerspective = perspective + px;
      if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
        style[_transformOriginProp] = _firstTwoOnly(origin);
      }
      cache.xOffset = cache.yOffset = 0;
      cache.force3D = _config.force3D;
      cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
      cache.uncache = 0;
      return cache;
    }, _firstTwoOnly = function _firstTwoOnly2(value) {
      return (value = value.split(" "))[0] + " " + value[1];
    }, _addPxTranslate = function _addPxTranslate2(target, start2, value) {
      var unit = getUnit(start2);
      return _round(parseFloat(start2) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
    }, _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
      cache.z = "0px";
      cache.rotationY = cache.rotationX = "0deg";
      cache.force3D = 0;
      _renderCSSTransforms(ratio, cache);
    }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
      var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
      if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
        var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
        angle = parseFloat(rotationX) * _DEG2RAD;
        cos = Math.cos(angle);
        x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
        y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
        z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
      }
      if (transformPerspective !== _zeroPx) {
        transforms += "perspective(" + transformPerspective + _endParenthesis;
      }
      if (xPercent || yPercent) {
        transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
      }
      if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
        transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
      }
      if (rotation !== _zeroDeg) {
        transforms += "rotate(" + rotation + _endParenthesis;
      }
      if (rotationY !== _zeroDeg) {
        transforms += "rotateY(" + rotationY + _endParenthesis;
      }
      if (rotationX !== _zeroDeg) {
        transforms += "rotateX(" + rotationX + _endParenthesis;
      }
      if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
        transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
      }
      if (scaleX !== 1 || scaleY !== 1) {
        transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
      }
      target.style[_transformProp] = transforms || "translate(0, 0)";
    }, _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
      var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
      rotation = parseFloat(rotation);
      skewX = parseFloat(skewX);
      skewY = parseFloat(skewY);
      if (skewY) {
        skewY = parseFloat(skewY);
        skewX += skewY;
        rotation += skewY;
      }
      if (rotation || skewX) {
        rotation *= _DEG2RAD;
        skewX *= _DEG2RAD;
        a11 = Math.cos(rotation) * scaleX;
        a21 = Math.sin(rotation) * scaleX;
        a12 = Math.sin(rotation - skewX) * -scaleY;
        a22 = Math.cos(rotation - skewX) * scaleY;
        if (skewX) {
          skewY *= _DEG2RAD;
          temp = Math.tan(skewX - skewY);
          temp = Math.sqrt(1 + temp * temp);
          a12 *= temp;
          a22 *= temp;
          if (skewY) {
            temp = Math.tan(skewY);
            temp = Math.sqrt(1 + temp * temp);
            a11 *= temp;
            a21 *= temp;
          }
        }
        a11 = _round(a11);
        a21 = _round(a21);
        a12 = _round(a12);
        a22 = _round(a22);
      } else {
        a11 = scaleX;
        a22 = scaleY;
        a21 = a12 = 0;
      }
      if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
        tx = _convertToUnit(target, "x", x, "px");
        ty = _convertToUnit(target, "y", y, "px");
      }
      if (xOrigin || yOrigin || xOffset || yOffset) {
        tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
        ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
      }
      if (xPercent || yPercent) {
        temp = target.getBBox();
        tx = _round(tx + xPercent / 100 * temp.width);
        ty = _round(ty + yPercent / 100 * temp.height);
      }
      temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
      target.setAttribute("transform", temp);
      forceCSS && (target.style[_transformProp] = temp);
    }, _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
      var cap = 360, isString2 = _isString(endValue), endNum = parseFloat(endValue) * (isString2 && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
      if (isString2) {
        direction = endValue.split("_")[1];
        if (direction === "short") {
          change %= cap;
          if (change !== change % (cap / 2)) {
            change += change < 0 ? cap : -cap;
          }
        }
        if (direction === "cw" && change < 0) {
          change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
        } else if (direction === "ccw" && change > 0) {
          change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
        }
      }
      plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
      pt.e = finalValue;
      pt.u = "deg";
      plugin._props.push(property);
      return pt;
    }, _assign = function _assign2(target, source) {
      for (var p2 in source) {
        target[p2] = source[p2];
      }
      return target;
    }, _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
      var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p2, startValue, endValue, startNum, endNum, startUnit, endUnit;
      if (startCache.svg) {
        startValue = target.getAttribute("transform");
        target.setAttribute("transform", "");
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        _removeProperty(target, _transformProp);
        target.setAttribute("transform", startValue);
      } else {
        startValue = getComputedStyle(target)[_transformProp];
        style[_transformProp] = transforms;
        endCache = _parseTransform(target, 1);
        style[_transformProp] = startValue;
      }
      for (p2 in _transformProps) {
        startValue = startCache[p2];
        endValue = endCache[p2];
        if (startValue !== endValue && exclude.indexOf(p2) < 0) {
          startUnit = getUnit(startValue);
          endUnit = getUnit(endValue);
          startNum = startUnit !== endUnit ? _convertToUnit(target, p2, startValue, endUnit) : parseFloat(startValue);
          endNum = parseFloat(endValue);
          plugin._pt = new PropTween(plugin._pt, endCache, p2, startNum, endNum - startNum, _renderCSSProp);
          plugin._pt.u = endUnit || 0;
          plugin._props.push(p2);
        }
      }
      _assign(endCache, startCache);
    };
    _forEachName("padding,margin,Width,Radius", function(name, index) {
      var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
        return index < 2 ? name + side : "border" + side + name;
      });
      _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
        var a, vars;
        if (arguments.length < 4) {
          a = props.map(function(prop) {
            return _get(plugin, prop, property);
          });
          vars = a.join(" ");
          return vars.split(a[0]).length === 5 ? a[0] : vars;
        }
        a = (endValue + "").split(" ");
        vars = {};
        props.forEach(function(prop, i) {
          return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
        });
        plugin.init(target, vars, tween);
      };
    });
    var CSSPlugin = {
      name: "css",
      register: _initCore,
      targetTest: function targetTest(target) {
        return target.style && target.nodeType;
      },
      init: function init(target, vars, tween, index, targets) {
        var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p2, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
        _pluginInitted || _initCore();
        this.styles = this.styles || _getStyleSaver(target);
        inlineProps = this.styles.props;
        this.tween = tween;
        for (p2 in vars) {
          if (p2 === "autoRound") {
            continue;
          }
          endValue = vars[p2];
          if (_plugins[p2] && _checkPlugin(p2, vars, tween, index, target, targets)) {
            continue;
          }
          type = typeof endValue;
          specialProp = _specialProps[p2];
          if (type === "function") {
            endValue = endValue.call(tween, index, target, targets);
            type = typeof endValue;
          }
          if (type === "string" && ~endValue.indexOf("random(")) {
            endValue = _replaceRandom(endValue);
          }
          if (specialProp) {
            specialProp(this, target, p2, endValue, tween) && (hasPriority = 1);
          } else if (p2.substr(0, 2) === "--") {
            startValue = (getComputedStyle(target).getPropertyValue(p2) + "").trim();
            endValue += "";
            _colorExp.lastIndex = 0;
            if (!_colorExp.test(startValue)) {
              startUnit = getUnit(startValue);
              endUnit = getUnit(endValue);
            }
            endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p2, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
            this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p2);
            props.push(p2);
            inlineProps.push(p2, 0, style[p2]);
          } else if (type !== "undefined") {
            if (startAt && p2 in startAt) {
              startValue = typeof startAt[p2] === "function" ? startAt[p2].call(tween, index, target, targets) : startAt[p2];
              _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
              getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p2] || getUnit(_get(target, p2)) || "");
              (startValue + "").charAt(1) === "=" && (startValue = _get(target, p2));
            } else {
              startValue = _get(target, p2);
            }
            startNum = parseFloat(startValue);
            relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
            relative && (endValue = endValue.substr(2));
            endNum = parseFloat(endValue);
            if (p2 in _propertyAliases) {
              if (p2 === "autoAlpha") {
                if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                  startNum = 0;
                }
                inlineProps.push("visibility", 0, style.visibility);
                _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
              }
              if (p2 !== "scale" && p2 !== "transform") {
                p2 = _propertyAliases[p2];
                ~p2.indexOf(",") && (p2 = p2.split(",")[0]);
              }
            }
            isTransformRelated = p2 in _transformProps;
            if (isTransformRelated) {
              this.styles.save(p2);
              if (!transformPropTween) {
                cache = target._gsap;
                cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                smooth = vars.smoothOrigin !== false && cache.smooth;
                transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                transformPropTween.dep = 1;
              }
              if (p2 === "scale") {
                this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                this._pt.u = 0;
                props.push("scaleY", p2);
                p2 += "X";
              } else if (p2 === "transformOrigin") {
                inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                endValue = _convertKeywordsToPercentages(endValue);
                if (cache.svg) {
                  _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                } else {
                  endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                  endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                  _addNonTweeningPT(this, style, p2, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                }
                continue;
              } else if (p2 === "svgOrigin") {
                _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                continue;
              } else if (p2 in _rotationalProperties) {
                _addRotationalPropTween(this, cache, p2, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
                continue;
              } else if (p2 === "smoothOrigin") {
                _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                continue;
              } else if (p2 === "force3D") {
                cache[p2] = endValue;
                continue;
              } else if (p2 === "transform") {
                _addRawTransformPTs(this, endValue, target);
                continue;
              }
            } else if (!(p2 in style)) {
              p2 = _checkPropPrefix(p2) || p2;
            }
            if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p2 in style) {
              startUnit = (startValue + "").substr((startNum + "").length);
              endNum || (endNum = 0);
              endUnit = getUnit(endValue) || (p2 in _config.units ? _config.units[p2] : startUnit);
              startUnit !== endUnit && (startNum = _convertToUnit(target, p2, startValue, endUnit));
              this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p2, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p2 === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
              this._pt.u = endUnit || 0;
              if (startUnit !== endUnit && endUnit !== "%") {
                this._pt.b = startValue;
                this._pt.r = _renderCSSPropWithBeginning;
              }
            } else if (!(p2 in style)) {
              if (p2 in target) {
                this.add(target, p2, startValue || target[p2], relative ? relative + endValue : endValue, index, targets);
              } else if (p2 !== "parseTransform") {
                _missingPlugin(p2, endValue);
                continue;
              }
            } else {
              _tweenComplexCSSString.call(this, target, p2, startValue, relative ? relative + endValue : endValue);
            }
            isTransformRelated || (p2 in style ? inlineProps.push(p2, 0, style[p2]) : inlineProps.push(p2, 1, startValue || target[p2]));
            props.push(p2);
          }
        }
        hasPriority && _sortPropTweensByPriority(this);
      },
      render: function render(ratio, data) {
        if (data.tween._time || !_reverting()) {
          var pt = data._pt;
          while (pt) {
            pt.r(ratio, pt.d);
            pt = pt._next;
          }
        } else {
          data.styles.revert();
        }
      },
      get: _get,
      aliases: _propertyAliases,
      getSetter: function getSetter(target, property, plugin) {
        var p2 = _propertyAliases[property];
        p2 && p2.indexOf(",") < 0 && (property = p2);
        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
      },
      core: {
        _removeProperty,
        _getMatrix
      }
    };
    gsap.utils.checkPrefix = _checkPropPrefix;
    gsap.core.getStyleSaver = _getStyleSaver;
    (function(positionAndScale, rotation, others, aliases2) {
      var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
        _transformProps[name] = 1;
      });
      _forEachName(rotation, function(name) {
        _config.units[name] = "deg";
        _rotationalProperties[name] = 1;
      });
      _propertyAliases[all[13]] = positionAndScale + "," + rotation;
      _forEachName(aliases2, function(name) {
        var split = name.split(":");
        _propertyAliases[split[1]] = all[split[0]];
      });
    })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
    _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
      _config.units[name] = "px";
    });
    gsap.registerPlugin(CSSPlugin);
    var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
    gsapWithCSS.core.Tween;
    const _sfc_main$i = {
      name: "NumberAnimator",
      props: {
        value: {
          type: Number,
          default: 0
        },
        duration: {
          type: Number,
          default: 0.5
        },
        formatType: {
          type: String,
          default: ""
        }
      },
      data() {
        return {
          displayValue: Math.ceil(this.value),
          tweenValue: this.value
        };
      },
      computed: {
        formatted() {
          return this.formatType ? SPM.app.config.globalProperties.$F(this.formatType, this.displayValue) : this.displayValue;
        }
      },
      watch: {
        value() {
          gsapWithCSS.to(this, {
            tweenValue: Math.ceil(this.value),
            duration: this.duration,
            onUpdate: () => {
              this.displayValue = Math.round(this.tweenValue);
            },
            onComplete: () => {
              this.displayValue = Math.round(this.value);
            }
          });
        }
      }
    };
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", null, toDisplayString($options.formatted), 1);
    }
    const NumberAnimator = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
    const _sfc_main$h = {
      name: "ProgressBar",
      props: {
        assistiveText: {
          type: String,
          default: ""
        },
        color: {
          type: String,
          default: ""
        },
        description: {
          type: String,
          required: true
        },
        radius: Boolean,
        thickness: {
          type: String,
          default: "medium"
        },
        value: {
          type: Number,
          default: 0
        },
        vertical: Boolean
      },
      data() {
        return {
          progressBarId: getGUID()
        };
      },
      computed: {
        themeClasses() {
          const classes = [`slds-progress-bar_${this.$props.thickness}`];
          if (this.$props.radius)
            classes.push("slds-progress-bar_circular");
          if (this.$props.vertical)
            classes.push("slds-progress-bar_vertical");
          return classes;
        },
        progressBarStyle() {
          const orientationStyleProperty = this.$props.vertical ? "height" : "width";
          const style = { [orientationStyleProperty]: `${Math.min(100, this.$props.value)}%` };
          if (this.$props.color)
            style.backgroundColor = this.$props.color;
          return style;
        },
        computedAssistiveText() {
          return this.$props.assistiveText || `Progress: ${this.$props.value}%`;
        }
      }
    };
    const _hoisted_1$h = ["aria-valuenow", "aria-label"];
    const _hoisted_2$h = { class: "slds-assistive-text" };
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slds-progress-bar", $options.themeClasses]),
        "aria-valuemin": "0",
        "aria-valuemax": "100",
        "aria-valuenow": _ctx.$props.value,
        "aria-label": _ctx.$props.description,
        role: "progressbar"
      }, [
        createBaseVNode("span", {
          class: normalizeClass(["slds-progress-bar__value", { "slds-progress-bar__value_success": !_ctx.$props.color && _ctx.$props.value >= 100 }]),
          style: normalizeStyle($options.progressBarStyle)
        }, [
          createBaseVNode("span", _hoisted_2$h, toDisplayString($options.computedAssistiveText), 1)
        ], 6)
      ], 10, _hoisted_1$h);
    }
    const ProgressBar = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
    const _sfc_main$g = {
      name: "TargetProgress",
      components: {
        NumberAnimator,
        ProgressBar,
        // slds vue
        ActionMenu,
        ActionMenuItem,
        Button: SLDSButton,
        ButtonIcon,
        Checkbox,
        Modal
      },
      data() {
        return {
          quotaSetupModalConfig: null
        };
      },
      computed: {
        target() {
          return SPM.Components.Root.plan._target;
        },
        hideTarget() {
          return !!SPM.Components.Root.preferences.hideTarget;
        },
        quotasToInclude() {
          return SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota" && c.includeInQuota).map((c) => c.id);
        },
        quotaRollup() {
          return SPM.Components.Root.nodeHierarchy.sfsp__SalesNodes__r.reduce((total, node) => {
            this.quotasToInclude.forEach((dataId) => total += node._data[`${dataId}:Quota`] || 0);
            return total;
          }, 0);
        },
        formattedTarget() {
          return this.$F("Numeric", this.target);
        },
        progressPercentage() {
          return Math.floor(100 * this.quotaRollup / this.target) || 0;
        },
        progressColor() {
          return this.progressPercentage <= 20 ? "#ba0717" : this.progressPercentage < 100 ? "#1b96ff" : "#44c65a";
        }
      },
      methods: {
        hide() {
          SPM.Components.Root.preferences.hideTarget = true;
        },
        show() {
          delete SPM.Components.Root.preferences.hideTarget;
        },
        // quota setup
        launchQuotaSetup() {
          this.quotaSetupModalConfig = {
            columns: SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota").map((c) => ({ label: c.id, selected: c.includeInQuota }))
          };
        },
        saveQuotaSetup() {
          this.quotaSetupModalConfig.columns.forEach((localColumn) => SPM.Components.Root.plan._columns.find((c) => c.id === localColumn.label).includeInQuota = localColumn.selected);
          SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
          SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
          this.quotaSetupModalConfig = null;
        }
      }
    };
    const _withScopeId$6 = (n) => (pushScopeId("data-v-de016166"), n = n(), popScopeId(), n);
    const _hoisted_1$g = {
      class: "spm-box slds-p-around_small slds-is-relative",
      style: { "width": "300px" }
    };
    const _hoisted_2$g = { class: "slds-card__header-title slds-grid slds-grid_vertical-align-center" };
    const _hoisted_3$d = {
      class: "slds-m-top_x-small",
      style: { fontWeight: "600" }
    };
    const _hoisted_4$d = ["title"];
    const _hoisted_5$c = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_6$8 = {
      class: "slds-m-left_x-small",
      style: { "font-size": "12px", "font-weight": "300" }
    };
    const _hoisted_7$6 = {
      class: "slds-m-top_x-small",
      style: { "font-size": "12px", "font-weight": "300" }
    };
    const _hoisted_8$5 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", null, "Select quota columns to be included in rollup", -1));
    const _hoisted_9$5 = { class: "slds-grid" };
    const _hoisted_10$4 = { class: "slds-col_bump-left" };
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_NumberAnimator = resolveComponent("NumberAnimator");
      const _component_ProgressBar = resolveComponent("ProgressBar");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$g, [
          createTextVNode(" Target "),
          createVNode(_component_ActionMenu, { class: "slds-col_bump-left" }, {
            button: withCtx(() => [
              createVNode(_component_ButtonIcon, {
                iconCategory: "utility",
                iconName: "down",
                variant: "border-filled",
                size: "xx-small",
                assistiveText: `View Actions`,
                title: `View Actions`
              })
            ]),
            default: withCtx(() => [
              createVNode(_component_ActionMenuItem, {
                label: "Set Up Quota",
                onClick: $options.launchQuotaSetup
              }, null, 8, ["onClick"]),
              !$options.hideTarget ? (openBlock(), createBlock(_component_ActionMenuItem, {
                key: 0,
                label: "Hide Details",
                onClick: $options.hide
              }, null, 8, ["onClick"])) : createCommentVNode("", true),
              $options.hideTarget ? (openBlock(), createBlock(_component_ActionMenuItem, {
                key: 1,
                label: "Show Details",
                onClick: $options.show
              }, null, 8, ["onClick"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ]),
        !$options.hideTarget ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", _hoisted_3$d, [
            createTextVNode(" $"),
            createVNode(_component_NumberAnimator, {
              title: `${_ctx.$F("Currency", $options.quotaRollup)}`,
              formatType: "Numeric",
              value: $options.quotaRollup || 0
            }, null, 8, ["title", "value"]),
            createBaseVNode("span", {
              title: `${_ctx.$F("Currency", $options.quotaRollup)}`,
              style: { "font-size": "80%", "font-weight": "400" }
            }, toDisplayString(` / $${$options.formattedTarget}`), 9, _hoisted_4$d)
          ]),
          createBaseVNode("div", _hoisted_5$c, [
            createVNode(_component_ProgressBar, {
              description: "Progress bar for target",
              value: $options.progressPercentage,
              color: $options.progressColor,
              radius: ""
            }, null, 8, ["value", "color"]),
            createBaseVNode("span", _hoisted_6$8, toDisplayString(_ctx.$F("Numeric", $options.progressPercentage)) + "%", 1)
          ]),
          createBaseVNode("div", _hoisted_7$6, toDisplayString($options.quotasToInclude.join(" + ") || "No rollup specified yet"), 1)
        ], 64)) : createCommentVNode("", true),
        $data.quotaSetupModalConfig ? (openBlock(), createBlock(_component_Modal, {
          key: 1,
          ref: "modal",
          size: "base",
          title: "Quota Setup",
          onClose: _cache[1] || (_cache[1] = ($event) => $data.quotaSetupModalConfig = null)
        }, {
          content: withCtx(() => [
            _hoisted_8$5,
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.quotaSetupModalConfig.columns, (column) => {
              return openBlock(), createBlock(_component_Checkbox, {
                key: column.id,
                modelValue: column.selected,
                "onUpdate:modelValue": ($event) => column.selected = $event,
                labels: { name: column.label }
              }, null, 8, ["modelValue", "onUpdate:modelValue", "labels"]);
            }), 128))
          ]),
          footer: withCtx(() => [
            createBaseVNode("div", _hoisted_9$5, [
              createBaseVNode("div", _hoisted_10$4, [
                createVNode(_component_Button, {
                  class: "slds-button",
                  onClick: _cache[0] || (_cache[0] = ($event) => $data.quotaSetupModalConfig = null)
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }),
                createVNode(_component_Button, {
                  class: "slds-button",
                  variant: "brand",
                  onClick: $options.saveQuotaSetup
                }, {
                  default: withCtx(() => [
                    createTextVNode("Save")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ]),
          _: 1
        }, 512)) : createCommentVNode("", true)
      ]);
    }
    const TargetProgress = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g], ["__scopeId", "data-v-de016166"]]);
    /**
     * Vue Currency Input 3.1.0
     * (c) 2018-2024 Matthias Stiller
     * @license MIT
     */
    var CurrencyDisplay;
    (function(CurrencyDisplay2) {
      CurrencyDisplay2["symbol"] = "symbol";
      CurrencyDisplay2["narrowSymbol"] = "narrowSymbol";
      CurrencyDisplay2["code"] = "code";
      CurrencyDisplay2["name"] = "name";
      CurrencyDisplay2["hidden"] = "hidden";
    })(CurrencyDisplay || (CurrencyDisplay = {}));
    var ValueScaling;
    (function(ValueScaling2) {
      ValueScaling2["precision"] = "precision";
      ValueScaling2["thousands"] = "thousands";
      ValueScaling2["millions"] = "millions";
      ValueScaling2["billions"] = "billions";
    })(ValueScaling || (ValueScaling = {}));
    const escapeRegExp = (str) => {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    const removeLeadingZeros = (str) => {
      return str.replace(/^0+(0$|[^0])/, "$1");
    };
    const count = (str, search) => {
      return (str.match(new RegExp(escapeRegExp(search), "g")) || []).length;
    };
    const substringBefore = (str, search) => {
      return str.substring(0, str.indexOf(search));
    };
    const DECIMAL_SEPARATORS = [
      ",",
      ".",
      "٫",
      "。"
    ];
    const INTEGER_PATTERN = "(0|[1-9]\\d*)";
    class CurrencyFormat {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        const { currency, currencyDisplay, locale: locale2, precision, accountingSign, useGrouping } = options;
        this.locale = locale2;
        this.options = {
          currency,
          useGrouping,
          style: "currency",
          currencySign: accountingSign ? "accounting" : void 0,
          currencyDisplay: currencyDisplay !== CurrencyDisplay.hidden ? currencyDisplay : void 0
        };
        const numberFormat = new Intl.NumberFormat(locale2, this.options);
        const formatParts = numberFormat.formatToParts(123456);
        this.currency = (_a = formatParts.find(({ type }) => type === "currency")) === null || _a === void 0 ? void 0 : _a.value;
        this.digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((i) => i.toLocaleString(locale2));
        this.decimalSymbol = (_b = formatParts.find(({ type }) => type === "decimal")) === null || _b === void 0 ? void 0 : _b.value;
        this.groupingSymbol = (_c = formatParts.find(({ type }) => type === "group")) === null || _c === void 0 ? void 0 : _c.value;
        this.minusSign = (_d = numberFormat.formatToParts(-1).find(({ type }) => type === "minusSign")) === null || _d === void 0 ? void 0 : _d.value;
        if (this.decimalSymbol === void 0) {
          this.minimumFractionDigits = this.maximumFractionDigits = 0;
        } else if (typeof precision === "number") {
          this.minimumFractionDigits = this.maximumFractionDigits = precision;
        } else {
          this.minimumFractionDigits = (_e = precision === null || precision === void 0 ? void 0 : precision.min) !== null && _e !== void 0 ? _e : numberFormat.resolvedOptions().minimumFractionDigits;
          this.maximumFractionDigits = (_f = precision === null || precision === void 0 ? void 0 : precision.max) !== null && _f !== void 0 ? _f : numberFormat.resolvedOptions().maximumFractionDigits;
        }
        const getPrefix = (str) => {
          return substringBefore(str, this.digits[1]);
        };
        const getSuffix = (str) => {
          return str.substring(str.lastIndexOf(this.decimalSymbol ? this.digits[0] : this.digits[1]) + 1);
        };
        this.prefix = getPrefix(numberFormat.format(1));
        this.suffix = getSuffix(numberFormat.format(1));
        this.negativePrefix = getPrefix(numberFormat.format(-1));
        this.negativeSuffix = getSuffix(numberFormat.format(-1));
      }
      parse(str) {
        if (str) {
          const negative = this.isNegative(str);
          str = this.normalizeDigits(str);
          str = this.stripCurrency(str, negative);
          str = this.stripSignLiterals(str);
          const fraction = this.decimalSymbol ? `(?:${escapeRegExp(this.decimalSymbol)}(\\d*))?` : "";
          const match = this.stripGroupingSeparator(str).match(new RegExp(`^${INTEGER_PATTERN}${fraction}$`));
          if (match && this.isValidIntegerFormat(this.decimalSymbol ? str.split(this.decimalSymbol)[0] : str, Number(match[1]))) {
            return Number(`${negative ? "-" : ""}${this.onlyDigits(match[1])}.${this.onlyDigits(match[2] || "")}`);
          }
        }
        return null;
      }
      isValidIntegerFormat(formattedNumber, integerNumber) {
        const options = { ...this.options, minimumFractionDigits: 0 };
        return [
          this.stripCurrency(this.normalizeDigits(integerNumber.toLocaleString(this.locale, { ...options, useGrouping: true })), false),
          this.stripCurrency(this.normalizeDigits(integerNumber.toLocaleString(this.locale, { ...options, useGrouping: false })), false)
        ].includes(formattedNumber);
      }
      format(value, options = {
        minimumFractionDigits: this.minimumFractionDigits,
        maximumFractionDigits: this.maximumFractionDigits
      }) {
        return value != null ? value.toLocaleString(this.locale, { ...this.options, ...options }) : "";
      }
      toFraction(str) {
        return `${this.digits[0]}${this.decimalSymbol}${this.onlyLocaleDigits(str.substring(1)).substring(0, this.maximumFractionDigits)}`;
      }
      isFractionIncomplete(str) {
        return !!this.normalizeDigits(this.stripGroupingSeparator(str)).match(new RegExp(`^${INTEGER_PATTERN}${escapeRegExp(this.decimalSymbol)}$`));
      }
      isNegative(str) {
        return str.startsWith(this.negativePrefix) || this.minusSign === void 0 && (str.startsWith("(") || str.startsWith("-")) || this.minusSign !== void 0 && str.replace("-", this.minusSign).startsWith(this.minusSign);
      }
      insertCurrency(str, negative) {
        return `${negative ? this.negativePrefix : this.prefix}${str}${negative ? this.negativeSuffix : this.suffix}`;
      }
      stripGroupingSeparator(str) {
        return this.groupingSymbol !== void 0 ? str.replace(new RegExp(escapeRegExp(this.groupingSymbol), "g"), "") : str;
      }
      stripSignLiterals(str) {
        if (this.minusSign !== void 0) {
          return str.replace("-", this.minusSign).replace(this.minusSign, "");
        } else {
          return str.replace(/[-()]/g, "");
        }
      }
      stripCurrency(str, negative) {
        return str.replace(negative ? this.negativePrefix : this.prefix, "").replace(negative ? this.negativeSuffix : this.suffix, "");
      }
      normalizeDecimalSeparator(str, from2) {
        DECIMAL_SEPARATORS.forEach((s) => {
          str = str.substring(0, from2) + str.substring(from2).replace(s, this.decimalSymbol);
        });
        return str;
      }
      normalizeDigits(str) {
        if (this.digits[0] !== "0") {
          this.digits.forEach((digit, index) => {
            str = str.replace(new RegExp(digit, "g"), String(index));
          });
        }
        return str;
      }
      onlyDigits(str) {
        return this.normalizeDigits(str).replace(/\D+/g, "");
      }
      onlyLocaleDigits(str) {
        return str.replace(new RegExp(`[^${this.digits.join("")}]*`, "g"), "");
      }
    }
    class AbstractInputMask {
      constructor(currencyFormat) {
        this.currencyFormat = currencyFormat;
      }
    }
    class DefaultInputMask extends AbstractInputMask {
      conformToMask(str, previousConformedValue = "") {
        const negative = this.currencyFormat.isNegative(str);
        const isEmptyNegativeValue = (str2) => str2 === "" && negative && !(this.currencyFormat.minusSign === void 0 ? previousConformedValue === this.currencyFormat.negativePrefix + this.currencyFormat.negativeSuffix : previousConformedValue === this.currencyFormat.negativePrefix);
        const checkIncompleteValue = (str2) => {
          if (isEmptyNegativeValue(str2)) {
            return "";
          } else if (this.currencyFormat.maximumFractionDigits > 0) {
            if (this.currencyFormat.isFractionIncomplete(str2)) {
              return str2;
            } else if (str2.startsWith(this.currencyFormat.decimalSymbol)) {
              return this.currencyFormat.toFraction(str2);
            }
          }
          return null;
        };
        let value = str;
        value = this.currencyFormat.stripCurrency(value, negative);
        value = this.currencyFormat.stripSignLiterals(value);
        const incompleteValue = checkIncompleteValue(value);
        if (incompleteValue != null) {
          return this.currencyFormat.insertCurrency(incompleteValue, negative);
        }
        const [integer, ...fraction] = value.split(this.currencyFormat.decimalSymbol);
        const integerDigits = removeLeadingZeros(this.currencyFormat.onlyDigits(integer));
        const fractionDigits = this.currencyFormat.onlyDigits(fraction.join("")).substring(0, this.currencyFormat.maximumFractionDigits);
        const invalidFraction = fraction.length > 0 && fractionDigits.length === 0;
        const invalidNegativeValue = integerDigits === "" && negative && (this.currencyFormat.minusSign === void 0 ? previousConformedValue === str.slice(0, -2) + this.currencyFormat.negativeSuffix : previousConformedValue === str.slice(0, -1));
        if (invalidFraction || invalidNegativeValue || isEmptyNegativeValue(integerDigits)) {
          return previousConformedValue;
        } else if (integerDigits.match(/\d+/)) {
          return {
            numberValue: Number(`${negative ? "-" : ""}${integerDigits}.${fractionDigits}`),
            fractionDigits
          };
        } else {
          return "";
        }
      }
    }
    class AutoDecimalDigitsInputMask extends AbstractInputMask {
      conformToMask(str, previousConformedValue = "") {
        if (str === "" || this.currencyFormat.parse(previousConformedValue) === 0 && this.currencyFormat.stripCurrency(previousConformedValue, true).slice(0, -1) === this.currencyFormat.stripCurrency(str, true)) {
          return "";
        }
        const negative = this.currencyFormat.isNegative(str);
        const numberValue = this.currencyFormat.stripSignLiterals(str) === "" ? -0 : Number(`${negative ? "-" : ""}${removeLeadingZeros(this.currencyFormat.onlyDigits(str))}`) / Math.pow(10, this.currencyFormat.maximumFractionDigits);
        return {
          numberValue,
          fractionDigits: numberValue.toFixed(this.currencyFormat.maximumFractionDigits).slice(-this.currencyFormat.maximumFractionDigits)
        };
      }
    }
    const DEFAULT_OPTIONS = {
      locale: void 0,
      currency: void 0,
      currencyDisplay: void 0,
      hideGroupingSeparatorOnFocus: true,
      hideCurrencySymbolOnFocus: true,
      hideNegligibleDecimalDigitsOnFocus: true,
      precision: void 0,
      autoDecimalDigits: false,
      valueRange: void 0,
      useGrouping: void 0,
      valueScaling: void 0
    };
    class CurrencyInput {
      constructor(args) {
        this.el = args.el;
        this.onInput = args.onInput;
        this.onChange = args.onChange;
        this.addEventListener();
        this.init(args.options);
      }
      setOptions(options) {
        this.init(options);
        this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue)));
        this.onChange(this.getValue());
      }
      getValue() {
        const numberValue = this.valueScaling && this.numberValue != null ? this.toInteger(this.numberValue, this.valueScaling) : this.numberValue;
        return { number: numberValue, formatted: this.formattedValue };
      }
      setValue(value) {
        const newValue = this.valueScaling !== void 0 && value != null ? this.toFloat(value, this.valueScaling) : value;
        if (newValue !== this.numberValue) {
          this.format(this.currencyFormat.format(this.validateValueRange(newValue)));
          this.onChange(this.getValue());
        }
      }
      init(options) {
        this.options = {
          ...DEFAULT_OPTIONS,
          ...options
        };
        if (this.options.autoDecimalDigits) {
          this.options.hideNegligibleDecimalDigitsOnFocus = false;
        }
        if (!this.el.getAttribute("inputmode")) {
          this.el.setAttribute("inputmode", this.options.autoDecimalDigits ? "numeric" : "decimal");
        }
        this.currencyFormat = new CurrencyFormat(this.options);
        this.numberMask = this.options.autoDecimalDigits ? new AutoDecimalDigitsInputMask(this.currencyFormat) : new DefaultInputMask(this.currencyFormat);
        const valueScalingOptions = {
          [ValueScaling.precision]: this.currencyFormat.maximumFractionDigits,
          [ValueScaling.thousands]: 3,
          [ValueScaling.millions]: 6,
          [ValueScaling.billions]: 9
        };
        this.valueScaling = this.options.valueScaling ? valueScalingOptions[this.options.valueScaling] : void 0;
        this.valueScalingFractionDigits = this.valueScaling !== void 0 && this.options.valueScaling !== ValueScaling.precision ? this.valueScaling + this.currencyFormat.maximumFractionDigits : this.currencyFormat.maximumFractionDigits;
        this.minValue = this.getMinValue();
        this.maxValue = this.getMaxValue();
      }
      getMinValue() {
        var _a, _b;
        let min2 = this.toFloat(-Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.min) !== void 0) {
          min2 = Math.max((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.min, this.toFloat(-Number.MAX_SAFE_INTEGER));
        }
        return min2;
      }
      getMaxValue() {
        var _a, _b;
        let max2 = this.toFloat(Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.max) !== void 0) {
          max2 = Math.min((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.max, this.toFloat(Number.MAX_SAFE_INTEGER));
        }
        return max2;
      }
      toFloat(value, maxFractionDigits) {
        return value / Math.pow(10, maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits);
      }
      toInteger(value, maxFractionDigits) {
        return Number(value.toFixed(maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits).split(".").join(""));
      }
      validateValueRange(value) {
        return value != null ? Math.min(Math.max(value, this.minValue), this.maxValue) : value;
      }
      format(value, hideNegligibleDecimalDigits = false) {
        if (value != null) {
          if (this.decimalSymbolInsertedAt !== void 0) {
            value = this.currencyFormat.normalizeDecimalSeparator(value, this.decimalSymbolInsertedAt);
            this.decimalSymbolInsertedAt = void 0;
          }
          const conformedValue = this.numberMask.conformToMask(value, this.formattedValue);
          let formattedValue;
          if (typeof conformedValue === "object") {
            const { numberValue, fractionDigits } = conformedValue;
            let { maximumFractionDigits, minimumFractionDigits } = this.currencyFormat;
            if (this.focus) {
              minimumFractionDigits = hideNegligibleDecimalDigits ? fractionDigits.replace(/0+$/, "").length : Math.min(maximumFractionDigits, fractionDigits.length);
            } else if (Number.isInteger(numberValue) && !this.options.autoDecimalDigits && (this.options.precision === void 0 || minimumFractionDigits === 0)) {
              minimumFractionDigits = maximumFractionDigits = 0;
            }
            formattedValue = this.toInteger(Math.abs(numberValue)) > Number.MAX_SAFE_INTEGER ? this.formattedValue : this.currencyFormat.format(numberValue, {
              useGrouping: this.options.useGrouping !== false && !(this.focus && this.options.hideGroupingSeparatorOnFocus),
              minimumFractionDigits,
              maximumFractionDigits
            });
          } else {
            formattedValue = conformedValue;
          }
          if (this.maxValue <= 0 && !this.currencyFormat.isNegative(formattedValue) && this.currencyFormat.parse(formattedValue) !== 0) {
            formattedValue = formattedValue.replace(this.currencyFormat.prefix, this.currencyFormat.negativePrefix);
          }
          if (this.minValue >= 0) {
            formattedValue = formattedValue.replace(this.currencyFormat.negativePrefix, this.currencyFormat.prefix);
          }
          if (this.options.currencyDisplay === CurrencyDisplay.hidden || this.focus && this.options.hideCurrencySymbolOnFocus) {
            formattedValue = formattedValue.replace(this.currencyFormat.negativePrefix, this.currencyFormat.minusSign !== void 0 ? this.currencyFormat.minusSign : "(").replace(this.currencyFormat.negativeSuffix, this.currencyFormat.minusSign !== void 0 ? "" : ")").replace(this.currencyFormat.prefix, "").replace(this.currencyFormat.suffix, "");
          }
          this.el.value = formattedValue;
          this.numberValue = this.currencyFormat.parse(formattedValue);
        } else {
          this.el.value = "";
          this.numberValue = null;
        }
        this.formattedValue = this.el.value;
        this.onInput(this.getValue());
      }
      addEventListener() {
        this.el.addEventListener("input", (e) => {
          const { value, selectionStart } = this.el;
          const inputEvent = e;
          if (selectionStart && inputEvent.data && DECIMAL_SEPARATORS.includes(inputEvent.data)) {
            this.decimalSymbolInsertedAt = selectionStart - 1;
          }
          this.format(value);
          if (this.focus && selectionStart != null) {
            const getCaretPositionAfterFormat = () => {
              const { prefix, suffix, decimalSymbol, maximumFractionDigits, groupingSymbol } = this.currencyFormat;
              let caretPositionFromLeft = value.length - selectionStart;
              const newValueLength = this.formattedValue.length;
              if (this.currencyFormat.minusSign === void 0 && (value.startsWith("(") || value.startsWith("-")) && !value.endsWith(")")) {
                return newValueLength - this.currencyFormat.negativeSuffix.length > 1 ? this.formattedValue.substring(selectionStart).length : 1;
              }
              if (this.formattedValue.substring(selectionStart, 1) === groupingSymbol && count(this.formattedValue, groupingSymbol) === count(value, groupingSymbol) + 1) {
                return newValueLength - caretPositionFromLeft - 1;
              }
              if (newValueLength < caretPositionFromLeft) {
                return selectionStart;
              }
              if (decimalSymbol !== void 0 && value.indexOf(decimalSymbol) !== -1) {
                const decimalSymbolPosition = value.indexOf(decimalSymbol) + 1;
                if (Math.abs(newValueLength - value.length) > 1 && selectionStart <= decimalSymbolPosition) {
                  return this.formattedValue.indexOf(decimalSymbol) + 1;
                } else {
                  if (!this.options.autoDecimalDigits && selectionStart > decimalSymbolPosition) {
                    if (this.currencyFormat.onlyDigits(value.substring(decimalSymbolPosition)).length - 1 === maximumFractionDigits) {
                      caretPositionFromLeft -= 1;
                    }
                  }
                }
              }
              return this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === CurrencyDisplay.hidden ? newValueLength - caretPositionFromLeft : Math.max(newValueLength - Math.max(caretPositionFromLeft, suffix.length), prefix.length);
            };
            this.setCaretPosition(getCaretPositionAfterFormat());
          }
        });
        this.el.addEventListener("focus", () => {
          this.focus = true;
          this.numberValueOnFocus = this.numberValue;
          setTimeout(() => {
            const { value, selectionStart, selectionEnd } = this.el;
            this.format(value, this.options.hideNegligibleDecimalDigitsOnFocus);
            if (selectionStart != null && selectionEnd != null && Math.abs(selectionStart - selectionEnd) > 0) {
              this.setCaretPosition(0, this.el.value.length);
            } else if (selectionStart != null) {
              const caretPositionOnFocus = this.getCaretPositionOnFocus(value, selectionStart);
              this.setCaretPosition(caretPositionOnFocus);
            }
          });
        });
        this.el.addEventListener("blur", () => {
          this.focus = false;
          this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue)));
          if (this.numberValueOnFocus !== this.numberValue) {
            this.onChange(this.getValue());
          }
        });
      }
      getCaretPositionOnFocus(value, selectionStart) {
        if (this.numberValue == null) {
          return selectionStart;
        }
        const { prefix, negativePrefix, suffix, negativeSuffix, groupingSymbol, currency } = this.currencyFormat;
        const isNegative = this.numberValue < 0;
        const currentPrefix = isNegative ? negativePrefix : prefix;
        const prefixLength = currentPrefix.length;
        if (this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === CurrencyDisplay.hidden) {
          if (isNegative) {
            if (selectionStart <= 1) {
              return 1;
            } else if (value.endsWith(")") && selectionStart > value.indexOf(")")) {
              return this.formattedValue.length - 1;
            }
          }
        } else {
          const suffixLength = isNegative ? negativeSuffix.length : suffix.length;
          if (selectionStart >= value.length - suffixLength) {
            return this.formattedValue.length - suffixLength;
          } else if (selectionStart < prefixLength) {
            return prefixLength;
          }
        }
        let result = selectionStart;
        if (this.options.hideCurrencySymbolOnFocus && this.options.currencyDisplay !== CurrencyDisplay.hidden && selectionStart >= prefixLength && currency !== void 0 && currentPrefix.includes(currency)) {
          result -= prefixLength;
          if (isNegative) {
            result += 1;
          }
        }
        if (this.options.hideGroupingSeparatorOnFocus && groupingSymbol !== void 0) {
          result -= count(value.substring(0, selectionStart), groupingSymbol);
        }
        return result;
      }
      setCaretPosition(start2, end2 = start2) {
        this.el.setSelectionRange(start2, end2);
      }
    }
    const findInput = (el) => (el === null || el === void 0 ? void 0 : el.matches("input")) ? el : el === null || el === void 0 ? void 0 : el.querySelector("input");
    function useCurrencyInput(options, autoEmit) {
      var _a, _b, _c, _d;
      let currencyInput;
      const inputRef = ref(null);
      const formattedValue = ref(null);
      const numberValue = ref(null);
      const vm = getCurrentInstance();
      const emit2 = (vm === null || vm === void 0 ? void 0 : vm.emit) || ((_b = (_a = vm === null || vm === void 0 ? void 0 : vm.proxy) === null || _a === void 0 ? void 0 : _a.$emit) === null || _b === void 0 ? void 0 : _b.bind(vm === null || vm === void 0 ? void 0 : vm.proxy));
      const props = (vm === null || vm === void 0 ? void 0 : vm.props) || ((_c = vm === null || vm === void 0 ? void 0 : vm.proxy) === null || _c === void 0 ? void 0 : _c.$props);
      const isVue3 = version.startsWith("3");
      const lazyModel = isVue3 && ((_d = vm === null || vm === void 0 ? void 0 : vm.attrs.modelModifiers) === null || _d === void 0 ? void 0 : _d.lazy);
      const modelValue = computed(() => props === null || props === void 0 ? void 0 : props[isVue3 ? "modelValue" : "value"]);
      const inputEvent = isVue3 ? "update:modelValue" : "input";
      const changeEvent = lazyModel ? "update:modelValue" : "change";
      watch(inputRef, (value) => {
        var _a2;
        if (value) {
          const el = findInput((_a2 = value === null || value === void 0 ? void 0 : value.$el) !== null && _a2 !== void 0 ? _a2 : value);
          if (el) {
            currencyInput = new CurrencyInput({
              el,
              options,
              onInput: (value2) => {
                if (!lazyModel && autoEmit !== false && modelValue.value !== value2.number) {
                  emit2 === null || emit2 === void 0 ? void 0 : emit2(inputEvent, value2.number);
                }
                numberValue.value = value2.number;
                formattedValue.value = value2.formatted;
              },
              onChange: (value2) => {
                if (autoEmit !== false) {
                  emit2 === null || emit2 === void 0 ? void 0 : emit2(changeEvent, value2.number);
                }
              }
            });
            currencyInput.setValue(modelValue.value);
          } else {
            console.error('No input element found. Please make sure that the "inputRef" template ref is properly assigned.');
          }
        } else {
          currencyInput = null;
        }
      });
      return {
        inputRef,
        numberValue,
        formattedValue,
        setValue: (value) => currencyInput === null || currencyInput === void 0 ? void 0 : currencyInput.setValue(value),
        setOptions: (options2) => currencyInput === null || currencyInput === void 0 ? void 0 : currencyInput.setOptions(options2)
      };
    }
    const _sfc_main$f = {
      name: "CurrencyInput",
      props: {
        hideLabel: Boolean,
        inputId: {
          type: String,
          required: true
        },
        label: {
          type: String,
          default: "Input Label"
        },
        modelValue: {
          type: Number,
          default: NaN
        },
        options: {
          type: Object,
          default: () => {
          }
        }
      },
      emits: ["update-value", "update:modelValue"],
      setup(props) {
        const { inputRef, setValue } = useCurrencyInput({
          currency: "USD",
          locale: "en",
          currencyDisplay: "hidden",
          hideCurrencySymbolOnFocus: false,
          hideGroupingSeparatorOnFocus: false,
          ...props.options
        });
        watch(() => props.modelValue, setValue);
        return { inputRef };
      }
    };
    const _hoisted_1$f = { class: "slds-form-element" };
    const _hoisted_2$f = ["for"];
    const _hoisted_3$c = { class: "slds-form-element__control" };
    const _hoisted_4$c = ["id"];
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        createBaseVNode("label", {
          class: normalizeClass([{ "slds-assistive-text": $props.hideLabel }, "slds-form-element__label"]),
          for: $props.inputId
        }, toDisplayString($props.label), 11, _hoisted_2$f),
        createBaseVNode("div", _hoisted_3$c, [
          createBaseVNode("input", {
            id: $props.inputId,
            ref: "inputRef",
            class: "slds-input"
          }, null, 8, _hoisted_4$c)
        ])
      ]);
    }
    const MaskedInput = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
    const _sfc_main$e = {
      name: "AllocationModal",
      components: {
        Icon,
        Modal,
        Picklist,
        RadioGroup,
        Spinner,
        MaskedInput
      },
      props: ["territory"],
      emits: ["close"],
      data() {
        var _a;
        return {
          loadingMsg: "",
          columnId: (_a = SPM.Components.Root.plan._columns.find((c) => c.type === "Quota" && SPM.Components.Root.preferences.columns.some(({ id }) => id === c.id))) == null ? void 0 : _a.id,
          proportionalColumnDataId: "",
          amount: 0,
          target: "All",
          distribution: "Equal",
          valuesToUpdate: [],
          valuesToUpdateMap: {}
        };
      },
      computed: {
        columnOptions() {
          const opts = SPM.Components.Root.plan._columns.filter((c) => ["Numeric", "Quota"].includes(c.type) && SPM.Components.Root.preferences.columns.some(({ id }) => id === c.id));
          const targetCols = opts.filter((c) => c.type === "Quota" && c.targetLabel && !c.expression);
          targetCols.forEach((c) => {
            opts.push({ id: `${c.id}:Target`, label: `${c.id} (Target)`, type: "Quota", isTargetCol: true });
          });
          return opts;
        },
        proportionalColumnOptions() {
          return SPM.Components.Root.plan._columns.reduce((arr, c) => {
            if (SPM.Components.Root.preferences.columns.some(({ id }) => id === c.id)) {
              if (c.type === "Quota") {
                arr.push({ id: `${c.id}:Quota`, label: `${c.id} (Quota)` });
                if (c.targetLabel) {
                  arr.push({ id: `${c.id}:Target`, label: `${c.id} (Target)` });
                }
              } else if (c.type === "Numeric" || c.type === "Formula") {
                arr.push({ id: c.id, label: c.id });
              }
            }
            return arr;
          }, []);
        },
        column() {
          return SPM.Components.Root.plan._columns.find((c) => c.id === this.columnId);
        },
        dataId() {
          var _a;
          return ((_a = this.column) == null ? void 0 : _a.type) === "Quota" ? `${this.columnId}:Quota` : this.columnId;
        },
        remaining() {
          var _a, _b;
          if (((_a = this.column) == null ? void 0 : _a.type) === "Quota") {
            return Math.max(0, this.territory._data[`${this.columnId}:Remaining`] || 0);
          }
          if (((_b = this.column) == null ? void 0 : _b.type) === "Numeric") {
            const rollup = (nodes) => nodes.reduce((total, node) => total + rollup(node.sfsp__SalesNodes__r) + (node._data[this.columnId] || 0), 0);
            return Math.max(0, (this.territory._data[this.columnId] || 0) - rollup(this.territory.sfsp__SalesNodes__r));
          }
          return 0;
        }
      },
      watch: {
        columnId() {
          this.calculateValues();
        },
        amount() {
          this.calculateValues();
        },
        target() {
          this.buildValues();
        },
        distribution() {
          this.buildWeights();
        },
        proportionalColumnDataId() {
          this.buildWeights();
        }
      },
      async mounted() {
        SPM.Components.AllocationModal = this;
        this.buildValues();
        this.amount = this.remaining;
      },
      methods: {
        buildValues() {
          this.valuesToUpdate = [];
          this.valuesToUpdateMap = {};
          const addValues = (nodes, level) => {
            nodes.forEach((node) => {
              const valueToUpdate = {
                node,
                level,
                isLeaf: node.sfsp__SalesNodes__r.length === 0,
                weight: 0,
                currentValue: node._data[this.dataId] || 0,
                newValue: 0
              };
              this.valuesToUpdate.push(valueToUpdate);
              this.valuesToUpdateMap[node.Id] = valueToUpdate;
              addValues(node.sfsp__SalesNodes__r, level + 1);
            });
          };
          addValues(this.target === "All" ? this.territory.sfsp__SalesNodes__r : SPM.Utils.Quota.Node.getLeafNodes({ nodes: [this.territory] }), 0);
          this.buildWeights();
        },
        buildWeights() {
          const leafValues = this.valuesToUpdate.filter((v) => v.isLeaf);
          if (this.distribution === "Equal") {
            const weightPer = 100 / leafValues.length;
            leafValues.forEach((v) => v.weight = weightPer);
          } else if (this.distribution === "Fixed") {
            leafValues.forEach((v) => v.weight = 100);
          } else if (this.distribution === "Proportional") {
            const totalValue = leafValues.reduce((total, v) => total + (v.node._data[this.proportionalColumnDataId] || 0), 0);
            leafValues.forEach((v) => v.weight = (v.node._data[this.proportionalColumnDataId] || 0) * 100 / totalValue || 0);
          }
          this.calculateValues();
        },
        calculateValues() {
          const leafValues = this.valuesToUpdate.filter((v) => v.isLeaf);
          leafValues.forEach((v) => {
            v.currentValue = v.node._data[this.dataId] || 0;
            v.newValue = Math.floor(v.currentValue + v.weight / 100 * this.amount);
          });
          if (this.distribution !== "Fixed") {
            const amountAllocated = leafValues.slice(0, -1).reduce((total, v) => total + (v.newValue - v.currentValue), 0);
            leafValues.at(-1).newValue = leafValues.at(-1).currentValue + this.amount - amountAllocated;
          }
          if (this.target === "All") {
            const rollValues = (nodes) => {
              let valueRollup = 0;
              nodes.forEach((node) => {
                const valueToUpdate = this.valuesToUpdateMap[node.Id];
                if (node.sfsp__SalesNodes__r.length) {
                  valueToUpdate.currentValue = node._data[this.dataId] || 0;
                  valueToUpdate.newValue = rollValues(node.sfsp__SalesNodes__r);
                }
                valueRollup += valueToUpdate.newValue;
              });
              return valueRollup;
            };
            rollValues(this.territory.sfsp__SalesNodes__r);
          }
        },
        async save() {
          this.loadingMsg = "Saving...";
          const nodesToCalculate = [];
          this.valuesToUpdate.forEach(({ node, newValue }) => {
            SPM.Utils.Quota.Node.update(node, { [this.dataId]: newValue });
            nodesToCalculate.push(node);
          });
          const column = this.columnOptions.find((c) => c.id === this.columnId);
          if (column.type === "Quota") {
            column.isTargetCol ? SPM.Utils.Quota.Column.calculateRollups(this.columnOptions.find((c) => c.id === column.id.split(":")[0])) : SPM.Utils.Quota.Column.calculateRollups(column);
            SPM.Components.Root.calculateNodes();
          } else {
            SPM.Components.Root.calculateNodes(nodesToCalculate);
          }
          SPM.Utils.CRM.upsert({ records: nodesToCalculate });
          this.$emit("close");
        }
      }
    };
    const _withScopeId$5 = (n) => (pushScopeId("data-v-fabfbf4a"), n = n(), popScopeId(), n);
    const _hoisted_1$e = { class: "slds-grid" };
    const _hoisted_2$e = { style: { "width": "300px", "background": "#f3f3f3", "padding": ".75rem" } };
    const _hoisted_3$b = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { style: { "font-weight": "bold" } }, "Options", -1));
    const _hoisted_4$b = { class: "slds-m-vertical_small" };
    const _hoisted_5$b = { class: "slds-m-vertical_small" };
    const _hoisted_6$7 = { class: "slds-m-vertical_small" };
    const _hoisted_7$5 = { class: "slds-m-vertical_small" };
    const _hoisted_8$4 = { class: "slds-grow slds-p-around_large" };
    const _hoisted_9$4 = { class: "slds-table" };
    const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("th", { class: "header-blank" }, null, -1));
    const _hoisted_11$2 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("th", { class: "header-blank" }, null, -1));
    const _hoisted_12$2 = {
      style: { "text-align": "center" },
      colspan: "3"
    };
    const _hoisted_13$1 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("tr", null, [
      /* @__PURE__ */ createBaseVNode("th", { style: { "text-align": "left" } }, "Territory"),
      /* @__PURE__ */ createBaseVNode("th", null, "Owner"),
      /* @__PURE__ */ createBaseVNode("th", null, "Current"),
      /* @__PURE__ */ createBaseVNode("th", null, "New"),
      /* @__PURE__ */ createBaseVNode("th", null, "Change")
    ], -1));
    const _hoisted_14$1 = { style: { "text-align": "left" } };
    const _hoisted_15$2 = { style: { "width": "1px" } };
    const _hoisted_16$2 = { class: "slds-grid" };
    const _hoisted_17$2 = {
      class: "slds-grow slds-m-horizontal_small",
      style: { "text-align": "center" }
    };
    const _hoisted_18$2 = { style: { "width": "60px", "text-align": "right" } };
    const _hoisted_19$2 = { class: "slds-grid" };
    const _hoisted_20$2 = { class: "slds-col_bump-left" };
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_MaskedInput = resolveComponent("MaskedInput");
      const _component_RadioGroup = resolveComponent("RadioGroup");
      const _component_Icon = resolveComponent("Icon");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: `Allocate ${$props.territory.Name}`,
        size: "medium",
        detach: "",
        onClose: _cache[8] || (_cache[8] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => {
          var _a;
          return [
            $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
              description: withCtx(() => [
                createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
              ]),
              _: 1
            })) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_1$e, [
              createBaseVNode("div", _hoisted_2$e, [
                _hoisted_3$b,
                createBaseVNode("div", _hoisted_4$b, [
                  createVNode(_component_Picklist, {
                    modelValue: $data.columnId,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.columnId = $event),
                    labels: { name: "Column" },
                    options: $options.columnOptions,
                    idKey: "id",
                    titleKey: "id",
                    filterable: ""
                  }, null, 8, ["modelValue", "options"])
                ]),
                createBaseVNode("div", _hoisted_5$b, [
                  createVNode(_component_MaskedInput, {
                    modelValue: $data.amount,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.amount = $event),
                    label: "Amount",
                    inputId: "allocation-amount"
                  }, null, 8, ["modelValue"]),
                  createBaseVNode("button", {
                    class: "slds-button",
                    onClick: _cache[2] || (_cache[2] = ($event) => $data.amount = $options.remaining)
                  }, "Remaining")
                ]),
                createBaseVNode("div", _hoisted_6$7, [
                  createVNode(_component_RadioGroup, {
                    modelValue: $data.target,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.target = $event),
                    labels: { name: "Allocate to" },
                    options: [{ label: "All descendants", value: "All" }, { label: "Terminal descendants", value: "Leaf" }]
                  }, null, 8, ["modelValue"])
                ]),
                createBaseVNode("div", _hoisted_7$5, [
                  createVNode(_component_RadioGroup, {
                    modelValue: $data.distribution,
                    "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.distribution = $event),
                    labels: { name: "Distribution" },
                    options: [{ label: "Equal", value: "Equal" }, { label: "Fixed", value: "Fixed" }, { label: "Proportional to another column", value: "Proportional" }]
                  }, null, 8, ["modelValue"]),
                  $data.distribution === "Proportional" ? (openBlock(), createBlock(_component_Picklist, {
                    key: 0,
                    modelValue: $data.proportionalColumnDataId,
                    "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.proportionalColumnDataId = $event),
                    options: $options.proportionalColumnOptions,
                    idKey: "id",
                    titleKey: "label",
                    filterable: ""
                  }, null, 8, ["modelValue", "options"])) : createCommentVNode("", true)
                ])
              ]),
              createBaseVNode("div", _hoisted_8$4, [
                createBaseVNode("table", _hoisted_9$4, [
                  createBaseVNode("thead", null, [
                    createBaseVNode("tr", null, [
                      _hoisted_10$3,
                      _hoisted_11$2,
                      createBaseVNode("th", _hoisted_12$2, toDisplayString(((_a = $options.column) == null ? void 0 : _a.id) || ""), 1)
                    ]),
                    _hoisted_13$1
                  ]),
                  createBaseVNode("tbody", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.valuesToUpdate, (value) => {
                      var _a2, _b;
                      return openBlock(), createElementBlock("tr", {
                        key: value.node.Id
                      }, [
                        createBaseVNode("td", _hoisted_14$1, [
                          createBaseVNode("div", {
                            class: "slds-truncate",
                            style: normalizeStyle({ maxWidth: "150px", paddingLeft: `${value.level * 15}px` })
                          }, toDisplayString(value.node.Name), 5)
                        ]),
                        createBaseVNode("td", null, toDisplayString(((_b = (_a2 = value.node) == null ? void 0 : _a2.Owner) == null ? void 0 : _b.Name) || "TBH"), 1),
                        createBaseVNode("td", null, toDisplayString(_ctx.$F("Numeric", value.currentValue)), 1),
                        createBaseVNode("td", null, toDisplayString(_ctx.$F("Numeric", value.newValue)), 1),
                        createBaseVNode("td", _hoisted_15$2, [
                          createBaseVNode("div", _hoisted_16$2, [
                            createVNode(_component_Icon, {
                              category: "utility",
                              name: value.newValue > value.currentValue ? "arrowup" : "arrowdown",
                              size: "x-small",
                              style: { "width": "30px", "text-align": "left" }
                            }, null, 8, ["name"]),
                            createBaseVNode("div", _hoisted_17$2, toDisplayString(_ctx.$F("Numeric", value.newValue - value.currentValue)), 1),
                            createBaseVNode("div", _hoisted_18$2, toDisplayString(value.currentValue === 0 ? "" : `(${Math.round((value.newValue - value.currentValue) * 100 / value.currentValue)}%)`), 1)
                          ])
                        ])
                      ]);
                    }), 128))
                  ])
                ])
              ])
            ])
          ];
        }),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_19$2, [
              createBaseVNode("div", _hoisted_20$2, [
                createBaseVNode("button", {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("close"))
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "slds-button slds-button_brand",
                  onClick: _cache[7] || (_cache[7] = (...args) => $options.save && $options.save(...args))
                }, "Save")
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const AllocationModal = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-fabfbf4a"]]);
    const _sfc_main$d = {
      name: "TerritoryModal",
      components: {
        Picklist,
        TextInput,
        Modal,
        Spinner
      },
      props: ["territory"],
      emits: ["close"],
      data() {
        var _a, _b, _c, _d;
        return {
          loadingMsg: "Loading...",
          name: this.territory.Name || "",
          originalName: this.territory.Name || "",
          useOwnerName: false,
          // owner
          ownerId: (_b = (_a = this.territory) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Id,
          originalOwnerId: (_d = (_c = this.territory) == null ? void 0 : _c.sfsp__Owner__r) == null ? void 0 : _d.Id,
          ownerRecord: null,
          originalOwnerRecord: null,
          ownerOptions: [
            {
              options: async (term) => {
                term = term.replace(/'/g, "\\'");
                return SPM.Utils.Rest.invoke("Query", { query: `SELECT Id, Name, FirstName, LastName, SmallPhotoUrl, Title FROM User WHERE Name LIKE '%${term}%' LIMIT 10` });
              }
            }
          ],
          errors: {
            name: []
          }
        };
      },
      async mounted() {
        SPM.Components.TerritoryModal = this;
        this.ownerRecord = this.territory.sfsp__Owner__r;
        this.originalOwnerRecord = this.territory.sfsp__Owner__r;
        this.$nextTick(() => {
          var _a, _b;
          return this.$refs.owner.input = ((_b = (_a = this.territory) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Name) || "";
        });
        this.loadingMsg = "";
      },
      methods: {
        async save() {
          this.loadingMsg = "Saving...";
          Object.values(this.errors).forEach((errors) => errors.splice(0));
          if (!this.name)
            this.errors.name.push("Name is required");
          if (Object.values(this.errors).find((errors) => errors.length)) {
            this.loadingMsg = "";
            return;
          }
          Object.assign(this.territory, {
            Name: this.name,
            sfsp__Owner__c: this.ownerId,
            sfsp__Owner__r: this.ownerRecord
          });
          try {
            await SPM.Utils.CRM.upsert({ records: [this.territory] });
          } catch (err) {
            Object.assign(this.territory, {
              Name: this.originalName,
              sfsp__Owner__c: this.originalOwnerId,
              sfsp__Owner__r: this.originalOwnerRecord
            });
            this.name = this.originalName;
            this.ownerId = this.originalOwnerId;
            this.ownerRecord = this.originalOwnerRecord;
            this.$nextTick(() => {
              var _a, _b;
              return this.$refs.owner.input = ((_b = (_a = this.territory) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Name) || "";
            });
            SPM.Components.Root.toast({ state: "error", message: err.error.message, duration: null });
            this.loadingMsg = "";
            return;
          }
          if (!SPM.Components.Root.nodeMap[this.territory.Id]) {
            this.territory._parentId = this.territory.sfsp__Parent__c || "all_org";
            SPM.Components.Root.nodeMap[this.territory._parentId].sfsp__SalesNodes__r.push(this.territory);
            SPM.Components.Root.nodeMap[this.territory.Id] = this.territory;
          }
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$d = { style: { "width": "50%" } };
    const _hoisted_2$d = { style: { "font-size": "12px", "line-height": "20px", "font-weight": "500", "color": "#000" } };
    const _hoisted_3$a = { style: { "font-size": "10px", "line-height": "20px", "font-weight": "400", "color": "#444" } };
    const _hoisted_4$a = { class: "slds-grid" };
    const _hoisted_5$a = { class: "slds-col_bump-left" };
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_TextInput = resolveComponent("TextInput");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: $props.territory.Id ? $props.territory.Name : "New territory",
        size: "small",
        detach: "",
        onClose: _cache[7] || (_cache[7] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_1$d, [
            createVNode(_component_TextInput, {
              modelValue: $data.name,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.name = $event),
              class: "slds-grow",
              labels: { name: "Name" },
              errors: $data.errors.name,
              onInput: _cache[1] || (_cache[1] = ($event) => $data.errors.name = [])
            }, null, 8, ["modelValue", "errors"]),
            createVNode(_component_Picklist, {
              ref: "owner",
              modelValue: $data.ownerId,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.ownerId = $event),
              labels: { name: "Owner", search: "Search users..." },
              options: $data.ownerOptions,
              idKey: "Id",
              titleKey: "Name",
              filterable: "",
              onSelectedOption: _cache[3] || (_cache[3] = (opt) => $data.ownerRecord = opt),
              onClear: _cache[4] || (_cache[4] = ($event) => $data.ownerRecord = null)
            }, {
              option: withCtx(({ option: { Name, Title } }) => [
                createBaseVNode("div", null, [
                  createBaseVNode("div", _hoisted_2$d, toDisplayString(Name), 1),
                  createBaseVNode("div", _hoisted_3$a, toDisplayString(Title), 1)
                ])
              ]),
              _: 1
            }, 8, ["modelValue", "labels", "options"])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_4$a, [
              createBaseVNode("div", _hoisted_5$a, [
                createBaseVNode("button", {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "slds-button slds-button_brand",
                  onClick: _cache[6] || (_cache[6] = (...args) => $options.save && $options.save(...args))
                }, "Save")
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const TerritoryModal = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-26ed2618"]]);
    const _sfc_main$c = {
      name: "TerritoryCell",
      components: {
        NumberAnimator,
        ProgressBar
      },
      props: ["territory", "column", "subcolumn"],
      data() {
        return {
          editField: "",
          editValue: "",
          originalValue: ""
        };
      },
      computed: {
        isLeaf() {
          return this.territory.sfsp__SalesNodes__r.length === 0;
        },
        type() {
          if (this.column.type === "Quota") {
            if (this.subcolumn === "Target")
              return this.column.expression ? "Formula" : "Numeric";
            return this.isLeaf ? "Numeric" : "Formula";
          }
          return this.column.type;
        },
        value() {
          var _a, _b;
          if (this.column.type === "Quota")
            return ((_a = this.territory._data) == null ? void 0 : _a[`${this.column.id}:${this.subcolumn}`]) || 0;
          return ((_b = this.territory._data) == null ? void 0 : _b[this.column.id]) || (this.type === "Text" ? "" : 0);
        },
        remaining() {
          var _a;
          return ((_a = this.territory._data) == null ? void 0 : _a[`${this.column.id}:Remaining`]) || 0;
        },
        progress() {
          var _a;
          return ((_a = this.territory._data) == null ? void 0 : _a[`${this.column.id}:Progress`]) || 0;
        }
      },
      methods: {
        // editing
        startEdit() {
          if (this.type === "Formula")
            return;
          this.editField = this.column.type === "Quota" ? `${this.column.id}:${this.subcolumn}` : this.column.id;
          this.editValue = this.value;
          this.originalValue = this.value;
          this.$nextTick(() => this.$refs.input.select());
        },
        async finishEdit() {
          if (!this.editField)
            return;
          const updatedColumns = SPM.Utils.Quota.Node.update(this.territory, { [this.editField]: this.editValue });
          const editedField = this.editField;
          this.editField = "";
          if (updatedColumns.length) {
            if (this.column.type === "Quota") {
              SPM.Utils.Quota.Column.calculateRollups(this.column);
              SPM.Components.Root.calculateNodes();
            } else {
              SPM.Components.Root.calculateNodes([this.territory]);
            }
            try {
              await SPM.Utils.CRM.upsert({ records: [this.territory] });
            } catch (error) {
              SPM.Utils.Quota.Node.update(this.territory, { [editedField]: this.originalValue });
              SPM.Components.Root.toast({ state: "error", message: error.error.message, duration: null });
            }
          }
        },
        cancelEdit() {
          this.editField = "";
        },
        // moving
        moveLeft() {
          var _a, _b;
          (_b = (_a = this.$el) == null ? void 0 : _a.previousElementSibling) == null ? void 0 : _b.focus();
        },
        moveRight() {
          var _a, _b;
          (_b = (_a = this.$el) == null ? void 0 : _a.nextElementSibling) == null ? void 0 : _b.focus();
        },
        moveUp() {
          const parentSibling = this.$el.parentElement.previousElementSibling;
          if (!parentSibling)
            return this.$el.focus();
          const columnIndex = [...this.$el.parentElement.children].indexOf(this.$el);
          parentSibling.children[columnIndex].focus();
        },
        moveDown() {
          const parentSibling = this.$el.parentElement.nextElementSibling;
          if (!parentSibling)
            return this.$el.focus();
          const columnIndex = [...this.$el.parentElement.children].indexOf(this.$el);
          parentSibling.children[columnIndex].focus();
        }
      }
    };
    const _hoisted_1$c = {
      key: 1,
      class: "slds-truncate"
    };
    const _hoisted_2$c = {
      key: 3,
      class: "slds-truncate"
    };
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_NumberAnimator = resolveComponent("NumberAnimator");
      const _component_ProgressBar = resolveComponent("ProgressBar");
      return openBlock(), createElementBlock("td", {
        tabindex: "0",
        onKeydown: [
          _cache[8] || (_cache[8] = withKeys((...args) => $options.startEdit && $options.startEdit(...args), ["enter"])),
          _cache[9] || (_cache[9] = withKeys((...args) => $options.moveUp && $options.moveUp(...args), ["up"])),
          _cache[10] || (_cache[10] = withKeys((...args) => $options.moveDown && $options.moveDown(...args), ["down"])),
          _cache[11] || (_cache[11] = withKeys((...args) => $options.moveLeft && $options.moveLeft(...args), ["left"])),
          _cache[12] || (_cache[12] = withKeys((...args) => $options.moveRight && $options.moveRight(...args), ["right"]))
        ],
        onDblclick: _cache[13] || (_cache[13] = (...args) => $options.startEdit && $options.startEdit(...args))
      }, [
        $data.editField ? withDirectives((openBlock(), createElementBlock("input", {
          key: 0,
          ref: "input",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.editValue = $event),
          type: "text",
          onBlur: _cache[1] || (_cache[1] = (...args) => $options.finishEdit && $options.finishEdit(...args)),
          onKeydown: [
            _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => {
              $options.finishEdit();
              $options.moveDown();
            }, ["stop"]), ["enter"])),
            _cache[3] || (_cache[3] = withKeys((...args) => $options.cancelEdit && $options.cancelEdit(...args), ["esc"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers(() => {
            }, ["stop"]), ["up"])),
            _cache[5] || (_cache[5] = withKeys(withModifiers(() => {
            }, ["stop"]), ["down"])),
            _cache[6] || (_cache[6] = withKeys(withModifiers(() => {
            }, ["stop"]), ["left"])),
            _cache[7] || (_cache[7] = withKeys(withModifiers(() => {
            }, ["stop"]), ["right"]))
          ]
        }, null, 544)), [
          [vModelText, $data.editValue]
        ]) : $options.type === "Numeric" ? (openBlock(), createElementBlock("div", _hoisted_1$c, toDisplayString(_ctx.$F("Numeric", $options.value)), 1)) : $options.type === "Formula" ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          $props.subcolumn === "Quota" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("div", {
              class: normalizeClass(["slds-grid slds-grid_align-spread slds-grid_vertical-align-center", [$options.remaining > 0 ? "quota-has-remaining" : ""]])
            }, [
              createVNode(_component_NumberAnimator, {
                class: "quota-rollup slds-truncate",
                value: $options.value,
                formatType: "Numeric"
              }, null, 8, ["value"]),
              !!$props.column.targetLabel ? (openBlock(), createBlock(_component_NumberAnimator, {
                key: 0,
                class: "quota-remaining slds-truncate",
                value: $options.remaining,
                formatType: "Numeric"
              }, null, 8, ["value"])) : createCommentVNode("", true)
            ], 2),
            !!$props.column.targetLabel ? (openBlock(), createBlock(_component_ProgressBar, {
              key: 0,
              description: "Quota allocation progress",
              value: $options.progress,
              thickness: "small",
              radius: ""
            }, null, 8, ["value"])) : createCommentVNode("", true)
          ], 64)) : (openBlock(), createBlock(_component_NumberAnimator, {
            key: 1,
            class: "slds-truncate",
            value: $options.value,
            formatType: "Numeric"
          }, null, 8, ["value"]))
        ], 64)) : $options.type === "Text" ? (openBlock(), createElementBlock("div", _hoisted_2$c, toDisplayString($options.value), 1)) : createCommentVNode("", true)
      ], 32);
    }
    const TerritoryCell = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-92ca84c9"]]);
    const _sfc_main$b = {
      name: "TemplateCard",
      components: { SLDSButton },
      props: {
        template: {
          type: Object,
          required: true
        }
      },
      emits: ["select-template"],
      data() {
        return {
          templateHoverX: "0px",
          templateHoverY: "0px",
          buttonHovered: false,
          buttonFocused: false
        };
      },
      computed: {
        templateBackground() {
          return this.template.background || "#0250D9";
        },
        templateShadow() {
          return this.template.shadow || "#066AFE";
        },
        templateClasses() {
          const classes = ["spm-kondo-template-card", "spm-kondo", "slds-grid"];
          if (this.$props.template.stretched) {
            classes.push("slds-grid_vertical-align-center spm-kondo-template-card-stretched");
          } else {
            classes.push("slds-grid_vertical");
          }
          if (this.$props.template.disabled)
            classes.push("template-disabled");
          if (this.buttonHovered)
            classes.push("template-button-hover");
          if (this.buttonFocused)
            classes.push("template-button-hover");
          return classes;
        }
      },
      methods: {
        onTemplateMouseMove(e) {
          const { x, y } = this.$el.getBoundingClientRect();
          this.templateHoverX = `${e.clientX - x}px`;
          this.templateHoverY = `${e.clientY - y}px`;
        },
        onTemplateButtonClick(isAdvanced) {
          this.$emit("select-template", this.template, isAdvanced);
        }
      }
    };
    const __injectCSSVars__ = () => {
      useCssVars((_ctx) => ({
        "496b8690": _ctx.templateBackground,
        "1e3ac9b4": _ctx.templateHoverX,
        "1e3ac9b2": _ctx.templateHoverY,
        "033bb5aa": _ctx.templateShadow
      }));
    };
    const __setup__ = _sfc_main$b.setup;
    _sfc_main$b.setup = __setup__ ? (props, ctx) => {
      __injectCSSVars__();
      return __setup__(props, ctx);
    } : __injectCSSVars__;
    const _hoisted_1$b = ["id"];
    const _hoisted_2$b = { key: 0 };
    const _hoisted_3$9 = { class: "template-name" };
    const _hoisted_4$9 = { class: "template-description" };
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_SLDSButton = resolveComponent("SLDSButton");
      return openBlock(), createElementBlock("article", {
        id: `${$props.template.name.replaceAll(" ", "-").toLowerCase()}-card`,
        class: normalizeClass($options.templateClasses),
        onMousemove: _cache[6] || (_cache[6] = (...args) => $options.onTemplateMouseMove && $options.onTemplateMouseMove(...args))
      }, [
        $props.template.icon ? (openBlock(), createElementBlock("div", _hoisted_2$b, [
          (openBlock(), createBlock(resolveDynamicComponent($props.template.icon), {
            template: $props.template.name
          }, null, 8, ["template"]))
        ])) : createCommentVNode("", true),
        createBaseVNode("div", null, [
          createBaseVNode("div", _hoisted_3$9, toDisplayString($props.template.label), 1),
          createBaseVNode("div", _hoisted_4$9, toDisplayString($props.template.description), 1)
        ]),
        createBaseVNode("div", {
          class: normalizeClass($props.template.stretched ? "slds-col_bump-left" : "slds-col_bump-top")
        }, [
          $props.template.advancedButtonLabel ? (openBlock(), createBlock(_component_SLDSButton, {
            key: 0,
            label: $props.template.advancedButtonLabel,
            disabled: $props.template.disabled,
            class: "spm-link-button",
            onClick: _cache[0] || (_cache[0] = ($event) => $options.onTemplateButtonClick(true))
          }, null, 8, ["label", "disabled"])) : createCommentVNode("", true),
          createVNode(_component_SLDSButton, {
            label: $props.template.buttonLabel,
            disabled: $props.template.disabled,
            onClick: _cache[1] || (_cache[1] = ($event) => $options.onTemplateButtonClick(false)),
            onMouseover: _cache[2] || (_cache[2] = ($event) => $data.buttonHovered = true),
            onFocus: _cache[3] || (_cache[3] = ($event) => $data.buttonFocused = true),
            onMouseleave: _cache[4] || (_cache[4] = ($event) => $data.buttonHovered = false),
            onBlur: _cache[5] || (_cache[5] = ($event) => $data.buttonFocused = false)
          }, null, 8, ["label", "disabled"])
        ], 2)
      ], 42, _hoisted_1$b);
    }
    const TemplateCard = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
    const _sfc_main$a = {
      name: "ArrowIcon"
    };
    const _withScopeId$4 = (n) => (pushScopeId("data-v-d9488b59"), n = n(), popScopeId(), n);
    const _hoisted_1$a = {
      xmlns: "http://www.w3.org/2000/svg",
      class: "spm-kondo-icon-arrow",
      width: "100%",
      height: "100%",
      viewBox: "0 0 72 72"
    };
    const _hoisted_2$a = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("path", {
      class: "animate-scale-bounce",
      d: "M20.0002 51.9999L38.2858 33.7144"
    }, null, -1));
    const _hoisted_3$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("path", {
      class: "animate-scale-bounce",
      d: "M26.8575 33.7144H38.2859V45.1428"
    }, null, -1));
    const _hoisted_4$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("path", {
      class: "animate-scale-bounce",
      d: "M33.7141 26.8569H45.1426V38.2854"
    }, null, -1));
    const _hoisted_5$9 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("path", {
      class: "animate-scale-bounce",
      d: "M40.5713 20H51.9998V31.4285"
    }, null, -1));
    const _hoisted_6$6 = [
      _hoisted_2$a,
      _hoisted_3$8,
      _hoisted_4$8,
      _hoisted_5$9
    ];
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1$a, _hoisted_6$6);
    }
    const ArrowIcon = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-d9488b59"]]);
    const _sfc_main$9 = {
      name: "BudgetAllocationIcon"
    };
    const _withScopeId$3 = (n) => (pushScopeId("data-v-b71ddf6e"), n = n(), popScopeId(), n);
    const _hoisted_1$9 = {
      xmlns: "http://www.w3.org/2000/svg",
      class: "spm-kondo-icon-budget-allocation",
      width: "100%",
      height: "100%",
      viewBox: "0 0 1000 1000"
    };
    const _hoisted_2$9 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("path", {
      class: "animate-budget-allocation-bounce",
      d: "M620 200H380a9 9 0 0 0-9 9v29a9 9 0 0 0 9 9h240a9 9 0 0 0 9-9v-29a9 9 0 0 0-9-9Zm-187 70h-53a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h53a9 9 0 0 0 8-9v-17a9 9 0 0 0-8-9Zm93 0h-52a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h52a9 9 0 0 0 9-9v-17a9 9 0 0 0-9-9Zm94 0h-53a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h53a9 9 0 0 0 9-9v-17a9 9 0 0 0-9-9Zm-187 58h-53a9 9 0 0 0-9 9v18a9 9 0 0 0 9 8h53a9 9 0 0 0 8-8v-18a9 9 0 0 0-8-9Zm93 0h-52a9 9 0 0 0-9 9v18a9 9 0 0 0 9 8h52a9 9 0 0 0 9-8v-18a9 9 0 0 0-9-9Zm94 0h-53a9 9 0 0 0-9 9v18a9 9 0 0 0 9 8h53a9 9 0 0 0 9-8v-18a9 9 0 0 0-9-9Zm-187 59h-53a9 9 0 0 0-9 8v18a9 9 0 0 0 9 9h53a9 9 0 0 0 8-9v-18a9 9 0 0 0-8-8Zm93 0h-52a9 9 0 0 0-9 8v18a9 9 0 0 0 9 9h52a9 9 0 0 0 9-9v-18a9 9 0 0 0-9-8Zm94 0h-53a9 9 0 0 0-9 8v18a9 9 0 0 0 9 9h53a9 9 0 0 0 9-9v-18a9 9 0 0 0-9-8Zm-187 58h-53a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h53a9 9 0 0 0 8-9v-17a9 9 0 0 0-8-9Zm93 0h-52a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h52a9 9 0 0 0 9-9v-17a9 9 0 0 0-9-9Zm94 0h-53a9 9 0 0 0-9 9v17a9 9 0 0 0 9 9h53a9 9 0 0 0 9-9v-17a9 9 0 0 0-9-9Zm131 130H515v-54a15 15 0 1 0-30 0v54H249a15 15 0 0 0-15 15v78a15 15 0 0 0 30 0v-63h221v51a15 15 0 0 0 30 0v-51h221v63a15 15 0 0 0 30 0v-78a15 15 0 0 0-15-15Z"
    }, null, -1));
    const _hoisted_3$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("circle", {
      class: "animate-budget-allocation-bounce",
      cx: "249",
      cy: "747",
      r: "49"
    }, null, -1));
    const _hoisted_4$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("circle", {
      class: "animate-budget-allocation-bounce",
      cx: "498",
      cy: "747",
      r: "49"
    }, null, -1));
    const _hoisted_5$8 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("circle", {
      class: "animate-budget-allocation-bounce",
      cx: "751",
      cy: "747",
      r: "49"
    }, null, -1));
    const _hoisted_6$5 = [
      _hoisted_2$9,
      _hoisted_3$7,
      _hoisted_4$7,
      _hoisted_5$8
    ];
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1$9, _hoisted_6$5);
    }
    const BudgetAllocationIcon = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-b71ddf6e"]]);
    const _sfc_main$8 = {
      name: "StackIcon"
    };
    const _hoisted_1$8 = {
      class: "spm-kondo-icon-stack",
      width: "100%",
      height: "100%",
      viewBox: "0 0 72 72"
    };
    const _hoisted_2$8 = /* @__PURE__ */ createStaticVNode('<path class="plus-anim element animate-stack-icon-bounce" d="M51.8 24.432V23.168C51.8 20.912 50.776 20 48.232 20H23.768C21.224 20 20.2 20.912 20.2 23.168V24.416C20.2 26.688    21.224 27.584 23.768 27.584H48.232C50.776 27.6 51.8 26.688 51.8 24.432Z"></path><path class="plus-anim element animate-stack-icon-bounce" d="M51.8 37.432V36.168C51.8 33.912 50.776 33 48.232 33H23.768C21.224 33 20.2 33.912 20.2 36.168V37.416C20.2 39.688 21.224 40.584 23.768 40.584H48.232C50.776 40.6 51.8 39.688 51.8 37.432Z"></path><g class="plus plus-anim animate-stack-icon-bounce"><path d="M33.2 49H39.2"></path><path d="M36.2 52V46"></path></g>', 3);
    const _hoisted_5$7 = [
      _hoisted_2$8
    ];
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_5$7);
    }
    const StackIcon = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
    const _sfc_main$7 = {
      name: "TemplateSelector",
      components: {
        Icon,
        Spinner,
        TemplateCard
      },
      props: ["showClose"],
      data() {
        return {
          loadingMsg: "",
          visible: false,
          selectedTemplate: null,
          templates: [
            {
              name: "Sample Quota",
              label: "Sample Quota",
              background: "#7526E3",
              shadow: "#9050E9",
              icon: markRaw(ArrowIcon),
              buttonLabel: "Start",
              description: "Assemble a quota plan using common elements and sample data. Replace that data with your own."
            },
            {
              name: "From Scratch",
              label: "From Scratch",
              background: "#0B5CAB",
              shadow: "#0176D3",
              icon: markRaw(StackIcon),
              buttonLabel: "Start",
              description: "Take your own path and build a quota plan based on your company's unique characteristics."
            }
          ],
          showSalesPlanModal: false,
          focusableElements: []
        };
      },
      mounted() {
        SPM.Components.TemplateSelector = this;
        if (SPM.Components.Root.territoryStampRoot.Name) {
          this.templates.unshift({
            name: "Territory Data",
            label: "Territory Data",
            background: "#107CAD",
            shadow: "#0494d6",
            icon: markRaw(BudgetAllocationIcon),
            buttonLabel: "Start",
            description: "Create a quota plan that uses the territory and attribute data that has been stamped on the segment."
          });
        }
        setTimeout(() => this.visible = true, 10);
      },
      methods: {
        async launchTemplate(template) {
          if (template.name === "From Scratch") {
            this.loadingMsg = "Creating Hierarchy...";
            await SPM.Utils.Quota.Plan.import([
              { Territory: SPM.Components.Root.plan.Name, Parent: "" }
            ]);
          } else if (template.name === "Sample Quota") {
            this.loadingMsg = "Creating Columns...";
            SPM.Components.Root.plan._columns = [
              { id: "Role", type: "Text", width: 140 },
              { id: "PY Attainment", type: "Numeric", width: 140 },
              { id: "Target", type: "Numeric", width: 140 },
              { id: "Quota", type: "Quota", targetLabel: "Target+10%", expression: "[Target] * 1.1", width: 240 }
            ];
            SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
            await SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
            this.loadingMsg = "Creating Hierarchy...";
            await SPM.Utils.Quota.Plan.import([
              { "Territory": "SVP", "Parent": "", "Role": "SVP", "PY Attainment": 9e5, "Target": 1e6 },
              { "Territory": "East", "Parent": "SVP", "Role": "RVP 1", "PY Attainment": 425e3, "Target": 49e4 },
              { "Territory": "West", "Parent": "SVP", "Role": "RVP 2", "PY Attainment": 475e3, "Target": 51e4 },
              { "Territory": "West 1", "Parent": "West", "Role": "AE 6", "PY Attainment": 8e4, "Target": 8e4, "Quota:Quota": 86e3 },
              { "Territory": "West 2", "Parent": "West", "Role": "AE 7", "PY Attainment": 9e4, "Target": 1e5, "Quota:Quota": 1e5 },
              { "Territory": "West 3", "Parent": "West", "Role": "AE 7", "PY Attainment": 9e4, "Target": 1e5, "Quota:Quota": 111e3 },
              { "Territory": "West 4", "Parent": "West", "Role": "AE 8", "PY Attainment": 105e3, "Target": 11e4, "Quota:Quota": 125e3 },
              { "Territory": "West 5", "Parent": "West", "Role": "AE 8", "PY Attainment": 11e4, "Target": 12e4, "Quota:Quota": 136e3 },
              { "Territory": "East 1", "Parent": "East", "Role": "AE 6", "PY Attainment": 65e3, "Target": 7e4, "Quota:Quota": 77e3 },
              { "Territory": "East 2", "Parent": "East", "Role": "AE 6", "PY Attainment": 7e4, "Target": 7e4, "Quota:Quota": 79e3 },
              { "Territory": "East 3", "Parent": "East", "Role": "AE 7", "PY Attainment": 9e4, "Target": 12e4, "Quota:Quota": 132500 },
              { "Territory": "East 4", "Parent": "East", "Role": "AE 7", "PY Attainment": 9e4, "Target": 11e4, "Quota:Quota": 12e4 },
              { "Territory": "East 5", "Parent": "East", "Role": "AE 8", "PY Attainment": 11e4, "Target": 12e4, "Quota:Quota": 134e3 }
            ]);
            SPM.Components.Root.preferences.columns = SPM.Components.Root.plan._columns.map((c) => ({ id: c.id }));
          } else if (template.name === "Territory Data") {
            this.loadingMsg = "Creating Columns...";
            const referenceFields = JSON.parse(SPM.Components.Root.segment.sfsp__ReferenceFields__c).filter((r) => r.type === "Territory");
            SPM.Components.Root.plan._columns = [];
            referenceFields.filter((f) => f.type === "Territory").forEach((field) => {
              SPM.Components.Root.plan._columns.push({
                id: field.label,
                type: field.dataType === "Number" ? "Numeric" : "Text"
              });
            });
            SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
            await SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
            this.loadingMsg = "Creating Hierarchy...";
            const rowsToImport = [];
            let stampDetails = null;
            try {
              stampDetails = await SPM.Utils.Apex.invoke("Query", [
                `SELECT Id, Name, sfsp__HierarchyReferenceData__c, sfsp__Parent__c, sfsp__Owner__c, sfsp__Owner__r.Name, sfsp__ReferenceFields__c, sfsp__Segment__c FROM sfsp__SalesNode__c WHERE sfsp__Segment__c = '${SPM.Components.Root.segment.Id}'`
              ]);
            } catch (error) {
              SPM.Components.Root.toast({ state: "error", message: "Error fetching territory stamp details." });
            }
            stampDetails = SPM.Utils.Segment.TerritoryStampUtils.parsedStampDetails(stampDetails, referenceFields);
            stampDetails = SPM.Utils.Segment.TerritoryStampUtils.hierarchicalStampDetails(stampDetails);
            stampDetails.sort((a, b) => a.indent - b.indent);
            stampDetails.forEach((detail) => {
              var _a, _b;
              const row = {
                Territory: detail.Name,
                Owner: (_a = detail.sfsp__Owner__r) == null ? void 0 : _a.Name,
                Parent: detail.sfsp__Parent__c ? (_b = stampDetails.find((d) => d.Id === detail.sfsp__Parent__c)) == null ? void 0 : _b.Name : "",
                ...detail.data
              };
              rowsToImport.push(row);
            });
            await SPM.Utils.Quota.Plan.import(rowsToImport);
            SPM.Components.Root.preferences.columns = SPM.Components.Root.plan._columns.map((c) => ({ id: c.id }));
          }
          const actionTypeStr = "SP | QP - ".concat(template.name, " Template");
          SPM.Utils.Pendo.track(actionTypeStr, {
            segmentId: SPM.Components.Root.segment.Id,
            planId: SPM.Components.Root.plan.Id
          });
        },
        onFileChange(event) {
          var _a, _b;
          const file = (_b = (_a = event.target) == null ? void 0 : _a.files) == null ? void 0 : _b[0];
          if (file)
            SPM.Components.Root.importModalConfig = { file };
        }
      }
    };
    const _withScopeId$2 = (n) => (pushScopeId("data-v-ce3fe9fa"), n = n(), popScopeId(), n);
    const _hoisted_1$7 = { class: "spm-kondo" };
    const _hoisted_2$7 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "page-titles" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "page-title" }, "Build Your Quota Plan"),
      /* @__PURE__ */ createBaseVNode("div", { class: "page-sub-title" }, "Kick-start your quota planning efforts using a template that includes sample data. Or design a quota plan from scratch.")
    ], -1));
    const _hoisted_3$6 = { style: { "display": "inline-block" } };
    const _hoisted_4$6 = { class: "import-csv" };
    const _hoisted_5$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "page-sub-title" }, "Import CSV", -1));
    const _hoisted_6$4 = { for: "file-input" };
    const _hoisted_7$4 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", null, "Or drop it here", -1));
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_TemplateCard = resolveComponent("TemplateCard");
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        id: "template-selector",
        class: normalizeClass(["slds-grid slds-grid_vertical slds-grid_vertical-align-center", { visible: $data.visible }])
      }, [
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_1$7, [
          _hoisted_2$7,
          createBaseVNode("div", _hoisted_3$6, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.templates, (template) => {
              return openBlock(), createBlock(_component_TemplateCard, {
                key: template.name,
                class: "template-container",
                template,
                onSelectTemplate: $options.launchTemplate,
                stretched: ""
              }, null, 8, ["template", "onSelectTemplate"]);
            }), 128)),
            createBaseVNode("div", _hoisted_4$6, [
              _hoisted_5$6,
              createBaseVNode("input", {
                id: "file-input",
                type: "file",
                class: "slds-assistive-text",
                onChange: _cache[0] || (_cache[0] = (...args) => $options.onFileChange && $options.onFileChange(...args))
              }, null, 32),
              createBaseVNode("label", _hoisted_6$4, [
                createVNode(_component_Icon, {
                  category: "utility",
                  name: "upload",
                  size: "x-small",
                  class: "slds-m-right_xx-small"
                }),
                createTextVNode(" Upload ")
              ]),
              _hoisted_7$4
            ])
          ])
        ])
      ], 2);
    }
    const TemplateSelector = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-ce3fe9fa"]]);
    const userTBH = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAMAAAANxBKoAAAAhFBMVEWBma////+6x9OCmq/c4+nb4uidsMGTp7qqusnd5OmFnbKnt8fP2ODx9PbQ2eHS2+LCztj+/v6GnbLd4+n09vj5+vv3+PnZ4eegssO/y9ajtcSYq73J093f5eumt8ais8Tq7vLm6++nuMfi6O3e5OqSp7ns8PO5x9Ohs8OVqbu5xtLM1d4Yq4vjAAAAoklEQVQYGe3BBw6CQBQFwPfozQIo0uxd738/Y8jGiB93D8AMRqOPOHGTGGayGd9mGUy47LgwEFAJoBdSyaG3oLKAVsSPCFoTKhPoraisoFdSKWFgys4UJux5SjKd2zDTVM+qgZHtBp2bB51gT16u9b1+7MjjAf/4J37LzxjkLdm39DDAL/ir8CFrKWkhCykJIXMocSCzKLEgsy1n3edYNkajFz3SCC6If+b6AAAAAElFTkSuQmCC";
    const _sfc_main$6 = {
      name: "TerritoryTable",
      components: {
        AllocationModal,
        ConfirmationModal,
        TerritoryModal,
        TerritoryCell,
        TemplateSelector,
        // slds vue
        ActionMenu,
        ActionMenuItem,
        ButtonIcon,
        Icon
      },
      data() {
        return {
          rootNode: null,
          // columns
          droppingColumnIndex: -1,
          droppingColumnClass: "",
          // allocation modal
          allocatingTerritory: null,
          // territory modal
          editingTerritory: null,
          // images
          userTBH,
          // table data props
          currentElement: null,
          currentDragColumn: null,
          mouseStart: 0,
          oldWidth: 0,
          isDragging: false,
          showConfirmationModal: false,
          editingColumn: null
        };
      },
      computed: {
        territoryWidth() {
          var _a;
          return ((_a = SPM.Components.Root.plan._columns.find((c) => c.staticColumn === "territory")) == null ? void 0 : _a.width) || 140;
        },
        ownerWidth() {
          var _a;
          return ((_a = SPM.Components.Root.plan._columns.find((c) => c.staticColumn === "owner")) == null ? void 0 : _a.width) || 140;
        },
        columns() {
          return SPM.Components.Root.preferences.columns.reduce((arr, { id }) => {
            const column = SPM.Components.Root.plan._columns.find((c) => c.id === id);
            if (column && column.id)
              arr.push(column);
            return arr;
          }, []);
        },
        territories() {
          const territories = [];
          const addTerritories = (nodes, level) => {
            nodes.forEach((node) => {
              node._level = level;
              territories.push(node);
              addTerritories(node.sfsp__SalesNodes__r, level + 1);
            });
          };
          addTerritories(this.rootNode ? [this.rootNode] : SPM.Components.Root.nodeHierarchy.sfsp__SalesNodes__r, 0);
          return territories;
        },
        breadcrumbs() {
          const crumbs = [this.rootNode];
          let territory = this.rootNode;
          while (territory = SPM.Components.Root.nodeMap[territory == null ? void 0 : territory._parentId])
            crumbs.unshift(territory);
          return crumbs.filter((c) => !!c);
        },
        tableWidth() {
          const resizableHeaders = document.querySelectorAll("th.slds-is-resizable");
          let totalWidth = 0;
          resizableHeaders.forEach((header) => {
            const widthStyle = header.style.width;
            if (widthStyle) {
              const widthValue = parseInt(widthStyle, 10);
              if (!isNaN(widthValue)) {
                totalWidth += widthValue;
              }
            }
          });
          return totalWidth;
        }
      },
      beforeMount() {
        SPM.Components.Root.preferences.columns = SPM.Components.Root.preferences.columns || SPM.Components.Root.plan._columns.map((c) => ({ id: c.id }));
      },
      mounted() {
        SPM.Components.TerritoryTable = this;
      },
      methods: {
        // columns
        columnIcon({ type }) {
          var _a;
          return ((_a = SPM.Utils.Quota.Column.types()[type]) == null ? void 0 : _a.icon) || "question";
        },
        addColumn(at) {
          SPM.Components.Root.rightPanelConfig = { at, column: {} };
          this.$nextTick(() => SPM.Components.ConfigureColumn.$refs.label.$refs.input.focus({ preventScroll: true }));
        },
        editColumn(column) {
          SPM.Components.Root.rightPanelConfig = { column };
          this.$nextTick(() => SPM.Components.ConfigureColumn.$refs.label.$refs.input.focus({ preventScroll: true }));
        },
        showDeleteModal(column) {
          this.editingColumn = column;
          this.showConfirmationModal = true;
        },
        async fillColumnFromTarget(column) {
          const rowsToUpdate = [];
          const fill = (nodes) => {
            nodes.forEach((node) => {
              if (node.sfsp__SalesNodes__r.length > 0)
                fill(node.sfsp__SalesNodes__r);
              else
                rowsToUpdate.push({ Territory: node.Name, [`${column.id}:Quota`]: node._data[`${column.id}:Target`] });
            });
          };
          fill(SPM.Components.Root.nodeHierarchy.sfsp__SalesNodes__r);
          await SPM.Utils.Quota.Plan.import(rowsToUpdate);
        },
        moveColumn(from2, to2) {
          SPM.Utils.Arr.move(SPM.Components.Root.preferences.columns, from2, to2);
        },
        hideColumn(column) {
          SPM.Utils.Arr.splice(SPM.Components.Root.preferences.columns, (c) => c.id === column.id);
        },
        onDragStartColumn(e, column) {
          if (this.isDragging)
            return;
          e.dataTransfer.effectAllowed = "move";
          this.draggingColumnIndex = this.columns.indexOf(column);
        },
        onDragEnterColumn(e, column) {
          if (this.isDragging)
            return;
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          const dropIndex = this.columns.indexOf(column);
          this.droppingColumnIndex = this.draggingColumnIndex === dropIndex ? -1 : dropIndex;
          this.droppingColumnClass = this.draggingColumnIndex > this.droppingColumnIndex ? "moving-left" : "moving-right";
        },
        onDragEndColumn(e) {
          if (this.isDragging)
            return;
          if (e.dataTransfer.dropEffect !== "none" && this.droppingColumnIndex !== -1) {
            this.moveColumn(this.draggingColumnIndex, this.droppingColumnIndex);
          }
          this.draggingColumnIndex = -1;
          this.droppingColumnIndex = -1;
        },
        // territory
        addTerritory(territory) {
          this.editingTerritory = {
            ...SPM.Utils.Quota.Node.defaults(),
            sfsp__SalesPlan__c: SPM.Components.Root.plan.Id,
            sfsp__Parent__c: (territory == null ? void 0 : territory.Id) || ""
          };
        },
        editTerritory(territory) {
          this.editingTerritory = territory;
        },
        async deleteTerritory(territory) {
          const descendants = SPM.Utils.Quota.Node.getDescendants({ nodes: [territory] });
          descendants.forEach(({ Id }) => delete SPM.Components.Root.nodeMap[Id]);
          const childNodes = SPM.Components.Root.nodeMap[territory._parentId].sfsp__SalesNodes__r;
          childNodes.splice(childNodes.indexOf(territory), 1);
          if (territory === this.rootNode) {
            this.rootNode = territory._parentId === "all_org" ? null : SPM.Components.Root.nodeMap[territory._parentId];
          }
          SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota").forEach(SPM.Utils.Quota.Column.calculateRollups);
          SPM.Components.Root.calculateNodes();
          await SPM.Utils.CRM.delete({ records: descendants });
        },
        // allocation
        allocateTerritory(territory) {
          this.allocatingTerritory = territory;
        },
        async resetColumnWidth($event) {
          var _a;
          if (this.isDragging) {
            let newWidth = $event.clientX - parseFloat(this.mouseStart) + parseFloat(this.oldWidth);
            if (newWidth < 60)
              newWidth = 60;
            if (newWidth > 1e3)
              newWidth = 1e3;
            this.currentElement.style.width = `${newWidth}px`;
            if ((_a = this.currentDragColumn) == null ? void 0 : _a.id) {
              SPM.Components.Root.plan._columns.find((c) => c.id === this.currentDragColumn.id).width = newWidth;
            } else {
              const currentColumn = SPM.Components.Root.plan._columns.find((c) => c.staticColumn === this.currentDragColumn);
              if (currentColumn) {
                SPM.Components.Root.plan._columns.find((c) => c.staticColumn === this.currentDragColumn).width = newWidth;
              } else {
                SPM.Components.Root.plan._columns.push({ staticColumn: this.currentDragColumn, width: newWidth });
              }
            }
            const resizableHandle = this.currentElement.getElementsByClassName("slds-resizable__handle")[0];
            resizableHandle.style.removeProperty("transform");
            this.isDragging = false;
            this.currentElement = null;
            this.mouseStart = 0;
            this.oldWidth = 0;
            this.currentDragColumn = null;
            SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
            await SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
          }
        },
        calculateColumnWidth(e, column) {
          this.currentDragColumn = column;
          this.isDragging = true;
          const childObj = e.target;
          let parObj = childObj.parentNode;
          while (parObj.tagName !== "TH") {
            parObj = parObj.parentNode;
          }
          this.currentElement = parObj;
          this.mouseStart = e.clientX;
          this.oldWidth = parObj.offsetWidth;
        },
        dragColumnWidth(e) {
          if (!this.isDragging)
            return;
          const resizableHandle = this.currentElement.getElementsByClassName("slds-resizable__handle")[0];
          const amountMoved = e.clientX - this.mouseStart;
          const newWidth = e.clientX - parseFloat(this.mouseStart) + parseFloat(this.oldWidth);
          if (newWidth < 60)
            return;
          resizableHandle.style.transform = `translateX(${amountMoved}px)`;
        }
      }
    };
    const _withScopeId$1 = (n) => (pushScopeId("data-v-f17e98ef"), n = n(), popScopeId(), n);
    const _hoisted_1$6 = { style: { "overflow-x": "hidden" } };
    const _hoisted_2$6 = {
      key: 0,
      class: "spm-box slds-is-relative",
      style: { "overflow-y": "clip", "overflow-x": "scroll", "width": "100%" }
    };
    const _hoisted_3$5 = {
      key: 0,
      class: "breadcrumbs slds-grid slds-grid_vertical-align-center"
    };
    const _hoisted_4$5 = ["onClick"];
    const _hoisted_5$5 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-m-horizontal_xx-small" }, /* @__PURE__ */ toDisplayString(">"), -1));
    const _hoisted_6$3 = { key: 1 };
    const _hoisted_7$3 = { class: "slds-line-height_reset" };
    const _hoisted_8$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-resizable__divider" }, null, -1));
    const _hoisted_9$3 = [
      _hoisted_8$3
    ];
    const _hoisted_10$2 = { class: "slds-resizable" };
    const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-resizable__divider" }, null, -1));
    const _hoisted_12$1 = [
      _hoisted_11$1
    ];
    const _hoisted_13 = {
      class: "actions-cell",
      rowspan: "2",
      style: { "width": "133px" }
    };
    const _hoisted_14 = ["rowspan", "colspan", "draggable", "onDragstart", "onDragenter"];
    const _hoisted_15$1 = { class: "slds-grid slds-grid_vertical-align-middle slds-grid_align-spread" };
    const _hoisted_16$1 = { key: 0 };
    const _hoisted_17$1 = { class: "slds-truncate" };
    const _hoisted_18$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Edit", -1));
    const _hoisted_19$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Fill from Target", -1));
    const _hoisted_20$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Reorder Left", -1));
    const _hoisted_21$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Reorder Right", -1));
    const _hoisted_22 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Hide", -1));
    const _hoisted_23 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Delete", -1));
    const _hoisted_24 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Insert Column After", -1));
    const _hoisted_25 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { style: { "color": "#000" } }, "Insert Column Before", -1));
    const _hoisted_26 = { class: "slds-resizable" };
    const _hoisted_27 = ["onMousedown"];
    const _hoisted_28 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-resizable__divider" }, null, -1));
    const _hoisted_29 = [
      _hoisted_28
    ];
    const _hoisted_30 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("th", {
      rowspan: "2",
      style: { "width": "40px" }
    }, "   ", -1));
    const _hoisted_31 = { key: 0 };
    const _hoisted_32 = {
      class: "slds-grid slds-grid_vertical-align-middle",
      style: { "display": "inline-block" }
    };
    const _hoisted_33 = {
      class: "slds-grid slds-grid_vertical-align-middle",
      style: { "display": "inline-block" }
    };
    const _hoisted_34 = ["onClick"];
    const _hoisted_35 = ["title"];
    const _hoisted_36 = { class: "owner-cell" };
    const _hoisted_37 = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_38 = ["src"];
    const _hoisted_39 = ["title"];
    const _hoisted_40 = { class: "actions-cell" };
    const _hoisted_41 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("td", null, "   ", -1));
    const _hoisted_42 = {
      key: 1,
      class: "slds-p-around_small"
    };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_TerritoryCell = resolveComponent("TerritoryCell");
      const _component_TemplateSelector = resolveComponent("TemplateSelector");
      const _component_AllocationModal = resolveComponent("AllocationModal");
      const _component_TerritoryModal = resolveComponent("TerritoryModal");
      const _component_ConfirmationModal = resolveComponent("ConfirmationModal");
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        $options.territories.length ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
          $options.breadcrumbs.length ? (openBlock(), createElementBlock("div", _hoisted_3$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.breadcrumbs, (node, i) => {
              return openBlock(), createElementBlock("div", {
                key: node.Id
              }, [
                i !== $options.breadcrumbs.length - 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  createBaseVNode("button", {
                    class: "slds-button",
                    onClick: ($event) => $data.rootNode = node.Id === "all_org" ? null : node
                  }, toDisplayString(node.Name), 9, _hoisted_4$5),
                  _hoisted_5$5
                ], 64)) : (openBlock(), createElementBlock("span", _hoisted_6$3, toDisplayString(node.Name), 1))
              ]);
            }), 128))
          ])) : createCommentVNode("", true),
          createBaseVNode("table", {
            id: "territory-table",
            class: "slds-table slds-table_bordered slds-table_col-bordered slds-table_resizable-cols",
            role: "grid",
            style: normalizeStyle([`width: ${$options.tableWidth}px; `, { "table-layout": "fixed" }]),
            onMouseup: _cache[6] || (_cache[6] = ($event) => $options.resetColumnWidth($event)),
            onMouseleave: _cache[7] || (_cache[7] = ($event) => $options.resetColumnWidth($event))
          }, [
            createBaseVNode("thead", {
              style: normalizeStyle({ top: $options.breadcrumbs.length ? "51px" : "0px" }),
              onMousemove: _cache[5] || (_cache[5] = ($event) => $options.dragColumnWidth($event))
            }, [
              createBaseVNode("tr", _hoisted_7$3, [
                createBaseVNode("th", {
                  class: "territory-cell slds-is-resizable slds-cell_action-mode",
                  rowspan: "2",
                  style: normalizeStyle(`width: ${$options.territoryWidth}px; `)
                }, [
                  createTextVNode(" Territory "),
                  createBaseVNode("div", {
                    class: "slds-resizable",
                    style: normalizeStyle(`width: ${$options.territoryWidth}px; `)
                  }, [
                    createBaseVNode("span", {
                      class: "slds-resizable__handle",
                      style: { "will-change": "transform" },
                      onMousedown: _cache[0] || (_cache[0] = ($event) => $options.calculateColumnWidth($event, "territory"))
                    }, _hoisted_9$3, 32)
                  ], 4)
                ], 4),
                createBaseVNode("th", {
                  class: "owner-cell slds-is-resizable slds-cell_action-mode",
                  rowspan: "2",
                  style: normalizeStyle(`width: ${$options.ownerWidth}px; `)
                }, [
                  createTextVNode(" Owner "),
                  createBaseVNode("div", _hoisted_10$2, [
                    createBaseVNode("span", {
                      class: "slds-resizable__handle",
                      style: { "will-change": "transform" },
                      onMousedown: _cache[1] || (_cache[1] = ($event) => $options.calculateColumnWidth($event, "owner"))
                    }, _hoisted_12$1, 32)
                  ])
                ], 4),
                createBaseVNode("th", _hoisted_13, [
                  !$options.breadcrumbs.length ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    class: "slds-button slds-col_bump-left",
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.addTerritory && $options.addTerritory(...args))
                  }, "Add")) : createCommentVNode("", true)
                ]),
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column, i) => {
                  return openBlock(), createElementBlock("th", {
                    key: column.id,
                    rowspan: column.type === "Quota" && column.targetLabel ? "1" : "2",
                    colspan: column.type === "Quota" && column.targetLabel ? "2" : "1",
                    draggable: $data.isDragging ? false : true,
                    class: normalizeClass(["slds-is-resizable slds-cell_action-mode", { [$data.droppingColumnClass]: $data.droppingColumnIndex === i }]),
                    scope: "col",
                    style: normalizeStyle([{ "cursor": "pointer" }, `width:${column.type === "Quota" ? column.width || 240 : column.width || 140}px;`]),
                    onDragstart: (e) => $options.onDragStartColumn(e, column),
                    onDragenter: (e) => $options.onDragEnterColumn(e, column),
                    onDragover: _cache[3] || (_cache[3] = withModifiers(() => {
                    }, ["prevent"])),
                    onDragend: _cache[4] || (_cache[4] = (...args) => $options.onDragEndColumn && $options.onDragEndColumn(...args))
                  }, [
                    createBaseVNode("div", _hoisted_15$1, [
                      column.type === "Quota" && column.targetLabel ? (openBlock(), createElementBlock("div", _hoisted_16$1)) : createCommentVNode("", true),
                      createBaseVNode("div", _hoisted_17$1, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: $options.columnIcon(column),
                          size: "x-small",
                          class: "slds-m-right_xx-small"
                        }, null, 8, ["name"]),
                        createTextVNode(" " + toDisplayString(column.id), 1)
                      ]),
                      createVNode(_component_ActionMenu, null, {
                        button: withCtx(() => [
                          createVNode(_component_ButtonIcon, {
                            iconCategory: "utility",
                            iconName: "down",
                            variant: "border-filled",
                            size: "x-small",
                            class: "slds-m-left_small",
                            assistiveText: `${column.id} Actions`,
                            title: `${column.id} Actions`
                          }, null, 8, ["assistiveText", "title"])
                        ]),
                        default: withCtx(() => [
                          createVNode(_component_ActionMenuItem, {
                            label: "Edit",
                            onClick: ($event) => $options.editColumn(column)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "edit",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_18$1
                            ]),
                            _: 2
                          }, 1032, ["onClick"]),
                          column.type === "Quota" && column.targetLabel ? (openBlock(), createBlock(_component_ActionMenuItem, {
                            key: 0,
                            label: "Fill from Target",
                            onClick: ($event) => $options.fillColumnFromTarget(column)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "magicwand",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_19$1
                            ]),
                            _: 2
                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                          i !== 0 ? (openBlock(), createBlock(_component_ActionMenuItem, {
                            key: 1,
                            label: "Reorder Left",
                            onClick: ($event) => $options.moveColumn(i, i - 1)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "arrow_left",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_20$1
                            ]),
                            _: 2
                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                          i !== $options.columns.length ? (openBlock(), createBlock(_component_ActionMenuItem, {
                            key: 2,
                            label: "Reorder Right",
                            onClick: ($event) => $options.moveColumn(i, i + 1)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "arrow_right",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_21$1
                            ]),
                            _: 2
                          }, 1032, ["onClick"])) : createCommentVNode("", true),
                          createVNode(_component_ActionMenuItem, {
                            label: "Hide",
                            onClick: ($event) => $options.hideColumn(column)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "hide",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_22
                            ]),
                            _: 2
                          }, 1032, ["onClick"]),
                          createVNode(_component_ActionMenuItem, {
                            label: "Delete",
                            onClick: ($event) => $options.showDeleteModal(column)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "delete",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_23
                            ]),
                            _: 2
                          }, 1032, ["onClick"]),
                          createVNode(_component_ActionMenuItem, {
                            label: "Insert Column After",
                            onClick: ($event) => $options.addColumn(i)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "add",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_24
                            ]),
                            _: 2
                          }, 1032, ["onClick"]),
                          createVNode(_component_ActionMenuItem, {
                            label: "Insert Column Before",
                            onClick: ($event) => $options.addColumn(i - 1)
                          }, {
                            default: withCtx(() => [
                              createVNode(_component_Icon, {
                                category: "utility",
                                name: "add",
                                size: "x-small",
                                class: "slds-m-right_small"
                              }),
                              _hoisted_25
                            ]),
                            _: 2
                          }, 1032, ["onClick"])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    createBaseVNode("div", _hoisted_26, [
                      createBaseVNode("span", {
                        class: "slds-resizable__handle",
                        style: { "will-change": "transform" },
                        onMousedown: ($event) => $options.calculateColumnWidth($event, column)
                      }, _hoisted_29, 40, _hoisted_27)
                    ])
                  ], 46, _hoisted_14);
                }), 128)),
                _hoisted_30
              ]),
              createBaseVNode("tr", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns.filter((c) => c.type === "Quota" && c.targetLabel), (column, i) => {
                  return openBlock(), createElementBlock(Fragment, {
                    key: column.id
                  }, [
                    column.targetLabel ? (openBlock(), createElementBlock("th", _hoisted_31, [
                      createBaseVNode("div", _hoisted_32, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: column.expression ? "formula" : "topic2",
                          size: "x-small",
                          class: "slds-m-right_xx-small"
                        }, null, 8, ["name"]),
                        createTextVNode(" " + toDisplayString(column.targetLabel), 1)
                      ])
                    ])) : createCommentVNode("", true),
                    createBaseVNode("th", null, [
                      createBaseVNode("div", _hoisted_33, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: "topic2",
                          size: "x-small",
                          class: "slds-m-right_xx-small"
                        }),
                        createTextVNode(" Quota ")
                      ])
                    ])
                  ], 64);
                }), 128))
              ])
            ], 36),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.territories, (territory) => {
                var _a, _b, _c;
                return openBlock(), createElementBlock("tr", {
                  key: territory.Id,
                  class: "territory-row"
                }, [
                  createBaseVNode("td", {
                    class: "territory-cell",
                    onClick: ($event) => $data.rootNode = territory
                  }, [
                    createBaseVNode("div", {
                      class: "slds-truncate",
                      style: normalizeStyle({ paddingLeft: `${territory._level * 24}px` }),
                      title: territory.Name
                    }, toDisplayString(territory.Name), 13, _hoisted_35)
                  ], 8, _hoisted_34),
                  createBaseVNode("td", _hoisted_36, [
                    createBaseVNode("div", _hoisted_37, [
                      createBaseVNode("img", {
                        src: ((_a = territory == null ? void 0 : territory.sfsp__Owner__r) == null ? void 0 : _a.SmallPhotoUrl) || $data.userTBH
                      }, null, 8, _hoisted_38),
                      createBaseVNode("div", {
                        title: ((_b = territory == null ? void 0 : territory.sfsp__Owner__r) == null ? void 0 : _b.Name) || "TBH",
                        class: "name slds-m-left_x-small slds-truncate"
                      }, toDisplayString(((_c = territory == null ? void 0 : territory.sfsp__Owner__r) == null ? void 0 : _c.Name) || "TBH"), 9, _hoisted_39)
                    ])
                  ]),
                  createBaseVNode("td", _hoisted_40, [
                    createVNode(_component_ButtonIcon, {
                      iconCategory: "utility",
                      iconName: "add",
                      size: "small",
                      title: `Add Node to ${territory.Name}`,
                      assistiveText: `Add Node to ${territory.Name}`,
                      onClick: ($event) => $options.addTerritory(territory)
                    }, null, 8, ["title", "assistiveText", "onClick"]),
                    createVNode(_component_ButtonIcon, {
                      iconCategory: "utility",
                      iconName: "edit",
                      size: "small",
                      title: `Edit ${territory.Name}`,
                      assistiveText: `Edit ${territory.Name}`,
                      onClick: ($event) => $options.editTerritory(territory)
                    }, null, 8, ["title", "assistiveText", "onClick"]),
                    createVNode(_component_ButtonIcon, {
                      iconCategory: "utility",
                      iconName: "magicwand",
                      size: "small",
                      title: `Allocate ${territory.Name}`,
                      assistiveText: `Allocate ${territory.Name}`,
                      onClick: ($event) => $options.allocateTerritory(territory)
                    }, null, 8, ["title", "assistiveText", "onClick"]),
                    createVNode(_component_ButtonIcon, {
                      iconCategory: "utility",
                      iconName: "delete",
                      size: "small",
                      title: `Delete ${territory.Name}`,
                      assistiveText: `Delete ${territory.Name}`,
                      onClick: ($event) => $options.deleteTerritory(territory)
                    }, null, 8, ["title", "assistiveText", "onClick"])
                  ]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column) => {
                    return openBlock(), createElementBlock(Fragment, {
                      key: column.id
                    }, [
                      column.type === "Quota" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                        column.targetLabel ? (openBlock(), createBlock(_component_TerritoryCell, {
                          key: 0,
                          territory,
                          column,
                          subcolumn: "Target"
                        }, null, 8, ["territory", "column"])) : createCommentVNode("", true),
                        createVNode(_component_TerritoryCell, {
                          territory,
                          column,
                          subcolumn: "Quota"
                        }, null, 8, ["territory", "column"])
                      ], 64)) : (openBlock(), createBlock(_component_TerritoryCell, {
                        key: 1,
                        territory,
                        column
                      }, null, 8, ["territory", "column"]))
                    ], 64);
                  }), 128)),
                  _hoisted_41
                ]);
              }), 128))
            ])
          ], 36)
        ])) : (openBlock(), createElementBlock("div", _hoisted_42, [
          createVNode(_component_TemplateSelector)
        ])),
        $data.allocatingTerritory ? (openBlock(), createBlock(_component_AllocationModal, {
          key: 2,
          territory: $data.allocatingTerritory,
          onClose: _cache[8] || (_cache[8] = ($event) => $data.allocatingTerritory = null)
        }, null, 8, ["territory"])) : createCommentVNode("", true),
        $data.editingTerritory ? (openBlock(), createBlock(_component_TerritoryModal, {
          key: 3,
          territory: $data.editingTerritory,
          onClose: _cache[9] || (_cache[9] = ($event) => $data.editingTerritory = null)
        }, null, 8, ["territory"])) : createCommentVNode("", true),
        $data.showConfirmationModal ? (openBlock(), createBlock(_component_ConfirmationModal, {
          key: 4,
          column: $data.editingColumn,
          onClose: _cache[10] || (_cache[10] = ($event) => {
            $data.editingColumn = null;
            $data.showConfirmationModal = false;
          })
        }, null, 8, ["column"])) : createCommentVNode("", true)
      ]);
    }
    const TerritoryTable = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-f17e98ef"]]);
    var papaparse_min = { exports: {} };
    /* @license
    Papa Parse
    v5.4.1
    https://github.com/mholt/PapaParse
    License: MIT
    */
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function s() {
        var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
        var n = !f.document && !!f.postMessage, o = f.IS_PAPA_WORKER || false, a = {}, u = 0, b = { parse: function(e, t) {
          var r2 = (t = t || {}).dynamicTyping || false;
          J(r2) && (t.dynamicTypingFunction = r2, r2 = {});
          if (t.dynamicTyping = r2, t.transform = !!J(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
            var i = function() {
              if (!b.WORKERS_SUPPORTED)
                return false;
              var e2 = (r3 = f.URL || f.webkitURL || null, i2 = s.toString(), b.BLOB_URL || (b.BLOB_URL = r3.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i2, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
              var r3, i2;
              return t2.onmessage = _, t2.id = u++, a[t2.id] = t2;
            }();
            return i.userStep = t.step, i.userChunk = t.chunk, i.userComplete = t.complete, i.userError = t.error, t.step = J(t.step), t.chunk = J(t.chunk), t.complete = J(t.complete), t.error = J(t.error), delete t.worker, void i.postMessage({ input: e, config: t, workerId: i.id });
          }
          var n2 = null;
          b.NODE_STREAM_INPUT, "string" == typeof e ? (e = function(e2) {
            if (65279 === e2.charCodeAt(0))
              return e2.slice(1);
            return e2;
          }(e), n2 = t.download ? new l(t) : new p2(t)) : true === e.readable && J(e.read) && J(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
          return n2.stream(e);
        }, unparse: function(e, t) {
          var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, r2 = false, i = null, o2 = false;
          !function() {
            if ("object" != typeof t)
              return;
            "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function(e2) {
              return -1 !== t.delimiter.indexOf(e2);
            }).length || (m2 = t.delimiter);
            ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n2 = t.quotes);
            "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (r2 = t.skipEmptyLines);
            "string" == typeof t.newline && (y2 = t.newline);
            "string" == typeof t.quoteChar && (s2 = t.quoteChar);
            "boolean" == typeof t.header && (_2 = t.header);
            if (Array.isArray(t.columns)) {
              if (0 === t.columns.length)
                throw new Error("Option columns is empty");
              i = t.columns;
            }
            void 0 !== t.escapeChar && (a2 = t.escapeChar + s2);
            ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var u2 = new RegExp(Q(s2), "g");
          "string" == typeof e && (e = JSON.parse(e));
          if (Array.isArray(e)) {
            if (!e.length || Array.isArray(e[0]))
              return h3(null, e, r2);
            if ("object" == typeof e[0])
              return h3(i || Object.keys(e[0]), e, r2);
          } else if ("object" == typeof e)
            return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || i), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), h3(e.fields || [], e.data || [], r2);
          throw new Error("Unable to serialize unrecognized input");
          function h3(e2, t2, r3) {
            var i2 = "";
            "string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2));
            var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
            if (n3 && _2) {
              for (var a3 = 0; a3 < e2.length; a3++)
                0 < a3 && (i2 += m2), i2 += v2(e2[a3], a3);
              0 < t2.length && (i2 += y2);
            }
            for (var o3 = 0; o3 < t2.length; o3++) {
              var u3 = n3 ? e2.length : t2[o3].length, h4 = false, f2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
              if (r3 && !n3 && (h4 = "greedy" === r3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === r3 && n3) {
                for (var d2 = [], l2 = 0; l2 < u3; l2++) {
                  var c2 = s3 ? e2[l2] : l2;
                  d2.push(t2[o3][c2]);
                }
                h4 = "" === d2.join("").trim();
              }
              if (!h4) {
                for (var p3 = 0; p3 < u3; p3++) {
                  0 < p3 && !f2 && (i2 += m2);
                  var g2 = n3 && s3 ? e2[p3] : p3;
                  i2 += v2(t2[o3][g2], p3);
                }
                o3 < t2.length - 1 && (!r3 || 0 < u3 && !f2) && (i2 += y2);
              }
            }
            return i2;
          }
          function v2(e2, t2) {
            if (null == e2)
              return "";
            if (e2.constructor === Date)
              return JSON.stringify(e2).slice(1, 25);
            var r3 = false;
            o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, r3 = true);
            var i2 = e2.toString().replace(u2, a2);
            return (r3 = r3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
              for (var r4 = 0; r4 < t3.length; r4++)
                if (-1 < e3.indexOf(t3[r4]))
                  return true;
              return false;
            }(i2, b.BAD_DELIMITERS) || -1 < i2.indexOf(m2) || " " === i2.charAt(0) || " " === i2.charAt(i2.length - 1)) ? s2 + i2 + s2 : i2;
          }
        } };
        if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = r, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p2, b.ReadableStreamStreamer = g, f.jQuery) {
          var d = f.jQuery;
          d.fn.parse = function(o2) {
            var r2 = o2.config || {}, u2 = [];
            return this.each(function(e2) {
              if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t = 0; t < this.files.length; t++)
                u2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, r2) });
            }), e(), this;
            function e() {
              if (0 !== u2.length) {
                var e2, t, r3, i, n2 = u2[0];
                if (J(o2.before)) {
                  var s2 = o2.before(n2.file, n2.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e2 = "AbortError", t = n2.file, r3 = n2.inputElem, i = s2.reason, void (J(o2.error) && o2.error({ name: e2 }, t, r3, i));
                    if ("skip" === s2.action)
                      return void h3();
                    "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void h3();
                }
                var a2 = n2.instanceConfig.complete;
                n2.instanceConfig.complete = function(e3) {
                  J(a2) && a2(e3, n2.file, n2.inputElem), h3();
                }, b.parse(n2.file, n2.instanceConfig);
              } else
                J(o2.complete) && o2.complete();
            }
            function h3() {
              u2.splice(0, 1), e();
            }
          };
        }
        function h2(e) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, (function(e2) {
            var t = w(e2);
            t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
            this._handle = new r(t), (this._handle.streamer = this)._config = t;
          }).call(this, e), this.parseChunk = function(e2, t) {
            if (this.isFirstChunk && J(this._config.beforeFirstChunk)) {
              var r2 = this._config.beforeFirstChunk(e2);
              void 0 !== r2 && (e2 = r2);
            }
            this.isFirstChunk = false, this._halted = false;
            var i = this._partialLine + e2;
            this._partialLine = "";
            var n2 = this._handle.parse(i, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n2.meta.cursor;
              this._finished || (this._partialLine = i.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
              var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o)
                f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
              else if (J(this._config.chunk) && !t) {
                if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n2 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !J(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
            }
            this._halted = true;
          }, this._sendError = function(e2) {
            J(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
          };
        }
        function l(e) {
          var i;
          (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), h2.call(this, e), this._nextChunk = n ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e2) {
            this._input = e2, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (i = new XMLHttpRequest(), this._config.withCredentials && (i.withCredentials = this._config.withCredentials), n || (i.onload = v(this._chunkLoaded, this), i.onerror = v(this._chunkError, this)), i.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
                var e2 = this._config.downloadRequestHeaders;
                for (var t in e2)
                  i.setRequestHeader(t, e2[t]);
              }
              if (this._config.chunkSize) {
                var r2 = this._start + this._config.chunkSize - 1;
                i.setRequestHeader("Range", "bytes=" + this._start + "-" + r2);
              }
              try {
                i.send(this._config.downloadRequestBody);
              } catch (e3) {
                this._chunkError(e3.message);
              }
              n && 0 === i.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === i.readyState && (i.status < 200 || 400 <= i.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
              var t = e2.getResponseHeader("Content-Range");
              if (null === t)
                return -1;
              return parseInt(t.substring(t.lastIndexOf("/") + 1));
            }(i), this.parseChunk(i.responseText)));
          }, this._chunkError = function(e2) {
            var t = i.statusText || e2;
            this._sendError(new Error(t));
          };
        }
        function c(e) {
          var i, n2;
          (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), h2.call(this, e);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e2) {
            this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((i = new FileReader()).onload = v(this._chunkLoaded, this), i.onerror = v(this._chunkError, this)) : i = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e2 = this._input;
            if (this._config.chunkSize) {
              var t = Math.min(this._start + this._config.chunkSize, this._input.size);
              e2 = n2.call(e2, this._start, t);
            }
            var r2 = i.readAsText(e2, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: r2 } });
          }, this._chunkLoaded = function(e2) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
          }, this._chunkError = function() {
            this._sendError(i.error);
          };
        }
        function p2(e) {
          var r2;
          h2.call(this, e = e || {}), this.stream = function(e2) {
            return r2 = e2, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e2, t = this._config.chunkSize;
              return t ? (e2 = r2.substring(0, t), r2 = r2.substring(t)) : (e2 = r2, r2 = ""), this._finished = !r2, this.parseChunk(e2);
            }
          };
        }
        function g(e) {
          h2.call(this, e = e || {});
          var t = [], r2 = true, i = false;
          this.pause = function() {
            h2.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            h2.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e2) {
            this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            i && 1 === t.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : r2 = true;
          }, this._streamData = v(function(e2) {
            try {
              t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), r2 && (r2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
            } catch (e3) {
              this._streamError(e3);
            }
          }, this), this._streamError = v(function(e2) {
            this._streamCleanUp(), this._sendError(e2);
          }, this), this._streamEnd = v(function() {
            this._streamCleanUp(), i = true, this._streamData("");
          }, this), this._streamCleanUp = v(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function r(m2) {
          var a2, o2, u2, i = Math.pow(2, 53), n2 = -i, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t = this, r2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
          if (J(m2.step)) {
            var p3 = m2.step;
            m2.step = function(e2) {
              if (c2 = e2, _2())
                g2();
              else {
                if (g2(), 0 === c2.data.length)
                  return;
                r2 += e2.data.length, m2.preview && r2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p3(c2, t));
              }
            };
          }
          function y2(e2) {
            return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
          }
          function g2() {
            return c2 && u2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), u2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
              return !y2(e2);
            })), _2() && function() {
              if (!c2)
                return;
              function e2(e3, t3) {
                J(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
              }
              if (Array.isArray(c2.data[0])) {
                for (var t2 = 0; _2() && t2 < c2.data.length; t2++)
                  c2.data[t2].forEach(e2);
                c2.data.splice(0, 1);
              } else
                c2.data.forEach(e2);
            }(), function() {
              if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform)
                return c2;
              function e2(e3, t3) {
                var r3, i2 = m2.header ? {} : [];
                for (r3 = 0; r3 < e3.length; r3++) {
                  var n3 = r3, s3 = e3[r3];
                  m2.header && (n3 = r3 >= l2.length ? "__parsed_extra" : l2[r3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), "__parsed_extra" === n3 ? (i2[n3] = i2[n3] || [], i2[n3].push(s3)) : i2[n3] = s3;
                }
                return m2.header && (r3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3) : r3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3)), i2;
              }
              var t2 = 1;
              !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
              m2.header && c2.meta && (c2.meta.fields = l2);
              return f2 += t2, c2;
            }();
          }
          function _2() {
            return m2.header && 0 === l2.length;
          }
          function v2(e2, t2) {
            return r3 = e2, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[r3] && (m2.dynamicTyping[r3] = m2.dynamicTypingFunction(r3)), true === (m2.dynamicTyping[r3] || m2.dynamicTyping) ? "true" === t2 || "TRUE" === t2 || "false" !== t2 && "FALSE" !== t2 && (function(e3) {
              if (s2.test(e3)) {
                var t3 = parseFloat(e3);
                if (n2 < t3 && t3 < i)
                  return true;
              }
              return false;
            }(t2) ? parseFloat(t2) : h3.test(t2) ? new Date(t2) : "" === t2 ? null : t2) : t2;
            var r3;
          }
          function k(e2, t2, r3, i2) {
            var n3 = { type: e2, code: t2, message: r3 };
            void 0 !== i2 && (n3.row = i2), c2.errors.push(n3);
          }
          this.parse = function(e2, t2, r3) {
            var i2 = m2.quoteChar || '"';
            if (m2.newline || (m2.newline = function(e3, t3) {
              e3 = e3.substring(0, 1048576);
              var r4 = new RegExp(Q(t3) + "([^]*?)" + Q(t3), "gm"), i3 = (e3 = e3.replace(r4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < i3[0].length;
              if (1 === i3.length || s4)
                return "\n";
              for (var a3 = 0, o3 = 0; o3 < i3.length; o3++)
                "\n" === i3[o3][0] && a3++;
              return a3 >= i3.length / 2 ? "\r\n" : "\r";
            }(e2, i2)), u2 = false, m2.delimiter)
              J(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
            else {
              var n3 = function(e3, t3, r4, i3, n4) {
                var s4, a3, o3, u3;
                n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
                for (var h4 = 0; h4 < n4.length; h4++) {
                  var f3 = n4[h4], d3 = 0, l3 = 0, c3 = 0;
                  o3 = void 0;
                  for (var p4 = new E({ comments: i3, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p4.data.length; g3++)
                    if (r4 && y2(p4.data[g3]))
                      c3++;
                    else {
                      var _3 = p4.data[g3].length;
                      l3 += _3, void 0 !== o3 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                    }
                  0 < p4.data.length && (l3 /= p4.data.length - c3), (void 0 === a3 || d3 <= a3) && (void 0 === u3 || u3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, u3 = l3);
                }
                return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
              }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
              n3.successful ? m2.delimiter = n3.bestDelimiter : (u2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
            }
            var s3 = w(m2);
            return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, r3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
          }, this.paused = function() {
            return d2;
          }, this.pause = function() {
            d2 = true, o2.abort(), a2 = J(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
          }, this.resume = function() {
            t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
          }, this.aborted = function() {
            return e;
          }, this.abort = function() {
            e = true, o2.abort(), c2.meta.aborted = true, J(m2.complete) && m2.complete(c2), a2 = "";
          };
        }
        function Q(e) {
          return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E(j) {
          var z, M = (j = j || {}).delimiter, P = j.newline, U = j.comments, q = j.step, N = j.preview, B = j.fastMode, K = z = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
          if (void 0 !== j.escapeChar && (K = j.escapeChar), ("string" != typeof M || -1 < b.BAD_DELIMITERS.indexOf(M)) && (M = ","), U === M)
            throw new Error("Comment character same as delimiter");
          true === U ? U = "#" : ("string" != typeof U || -1 < b.BAD_DELIMITERS.indexOf(U)) && (U = false), "\n" !== P && "\r" !== P && "\r\n" !== P && (P = "\n");
          var W = 0, H = false;
          this.parse = function(i, t, r2) {
            if ("string" != typeof i)
              throw new Error("Input must be a string");
            var n2 = i.length, e = M.length, s2 = P.length, a2 = U.length, o2 = J(q), u2 = [], h3 = [], f2 = [], d2 = W = 0;
            if (!i)
              return L();
            if (j.header && !t) {
              var l2 = i.split(P)[0].split(M), c2 = [], p3 = {}, g2 = false;
              for (var _2 in l2) {
                var m2 = l2[_2];
                J(j.transformHeader) && (m2 = j.transformHeader(m2, _2));
                var y2 = m2, v2 = p3[m2] || 0;
                for (0 < v2 && (g2 = true, y2 = m2 + "_" + v2), p3[m2] = v2 + 1; c2.includes(y2); )
                  y2 = y2 + "_" + v2;
                c2.push(y2);
              }
              if (g2) {
                var k = i.split(P);
                k[0] = c2.join(M), i = k.join(P);
              }
            }
            if (B || false !== B && -1 === i.indexOf(z)) {
              for (var b2 = i.split(P), E2 = 0; E2 < b2.length; E2++) {
                if (f2 = b2[E2], W += f2.length, E2 !== b2.length - 1)
                  W += P.length;
                else if (r2)
                  return L();
                if (!U || f2.substring(0, a2) !== U) {
                  if (o2) {
                    if (u2 = [], I(f2.split(M)), F(), H)
                      return L();
                  } else
                    I(f2.split(M));
                  if (N && N <= E2)
                    return u2 = u2.slice(0, N), L(true);
                }
              }
              return L();
            }
            for (var w2 = i.indexOf(M, W), R = i.indexOf(P, W), C = new RegExp(Q(K) + Q(z), "g"), S = i.indexOf(z, W); ; )
              if (i[W] !== z)
                if (U && 0 === f2.length && i.substring(W, W + a2) === U) {
                  if (-1 === R)
                    return L();
                  W = R + s2, R = i.indexOf(P, W), w2 = i.indexOf(M, W);
                } else if (-1 !== w2 && (w2 < R || -1 === R))
                  f2.push(i.substring(W, w2)), W = w2 + e, w2 = i.indexOf(M, W);
                else {
                  if (-1 === R)
                    break;
                  if (f2.push(i.substring(W, R)), D(R + s2), o2 && (F(), H))
                    return L();
                  if (N && u2.length >= N)
                    return L(true);
                }
              else
                for (S = W, W++; ; ) {
                  if (-1 === (S = i.indexOf(z, S + 1)))
                    return r2 || h3.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u2.length, index: W }), T();
                  if (S === n2 - 1)
                    return T(i.substring(W, S).replace(C, z));
                  if (z !== K || i[S + 1] !== K) {
                    if (z === K || 0 === S || i[S - 1] !== K) {
                      -1 !== w2 && w2 < S + 1 && (w2 = i.indexOf(M, S + 1)), -1 !== R && R < S + 1 && (R = i.indexOf(P, S + 1));
                      var O = A(-1 === R ? w2 : Math.min(w2, R));
                      if (i.substr(S + 1 + O, e) === M) {
                        f2.push(i.substring(W, S).replace(C, z)), i[W = S + 1 + O + e] !== z && (S = i.indexOf(z, W)), w2 = i.indexOf(M, W), R = i.indexOf(P, W);
                        break;
                      }
                      var x = A(R);
                      if (i.substring(S + 1 + x, S + 1 + x + s2) === P) {
                        if (f2.push(i.substring(W, S).replace(C, z)), D(S + 1 + x + s2), w2 = i.indexOf(M, W), S = i.indexOf(z, W), o2 && (F(), H))
                          return L();
                        if (N && u2.length >= N)
                          return L(true);
                        break;
                      }
                      h3.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u2.length, index: W }), S++;
                    }
                  } else
                    S++;
                }
            return T();
            function I(e2) {
              u2.push(e2), d2 = W;
            }
            function A(e2) {
              var t2 = 0;
              if (-1 !== e2) {
                var r3 = i.substring(S + 1, e2);
                r3 && "" === r3.trim() && (t2 = r3.length);
              }
              return t2;
            }
            function T(e2) {
              return r2 || (void 0 === e2 && (e2 = i.substring(W)), f2.push(e2), W = n2, I(f2), o2 && F()), L();
            }
            function D(e2) {
              W = e2, I(f2), f2 = [], R = i.indexOf(P, W);
            }
            function L(e2) {
              return { data: u2, errors: h3, meta: { delimiter: M, linebreak: P, aborted: H, truncated: !!e2, cursor: d2 + (t || 0) } };
            }
            function F() {
              q(L()), u2 = [], h3 = [];
            }
          }, this.abort = function() {
            H = true;
          }, this.getCharIndex = function() {
            return W;
          };
        }
        function _(e) {
          var t = e.data, r2 = a[t.workerId], i = false;
          if (t.error)
            r2.userError(t.error, t.file);
          else if (t.results && t.results.data) {
            var n2 = { abort: function() {
              i = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y, resume: y };
            if (J(r2.userStep)) {
              for (var s2 = 0; s2 < t.results.data.length && (r2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !i); s2++)
                ;
              delete t.results;
            } else
              J(r2.userChunk) && (r2.userChunk(t.results, n2, t.file), delete t.results);
          }
          t.finished && !i && m(t.workerId, t.results);
        }
        function m(e, t) {
          var r2 = a[e];
          J(r2.userComplete) && r2.userComplete(t), r2.terminate(), delete a[e];
        }
        function y() {
          throw new Error("Not implemented.");
        }
        function w(e) {
          if ("object" != typeof e || null === e)
            return e;
          var t = Array.isArray(e) ? [] : {};
          for (var r2 in e)
            t[r2] = w(e[r2]);
          return t;
        }
        function v(e, t) {
          return function() {
            e.apply(t, arguments);
          };
        }
        function J(e) {
          return "function" == typeof e;
        }
        return o && (f.onmessage = function(e) {
          var t = e.data;
          void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
          if ("string" == typeof t.input)
            f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
          else if (f.File && t.input instanceof File || t.input instanceof Object) {
            var r2 = b.parse(t.input, t.config);
            r2 && f.postMessage({ workerId: b.WORKER_ID, results: r2, finished: true });
          }
        }), (l.prototype = Object.create(h2.prototype)).constructor = l, (c.prototype = Object.create(h2.prototype)).constructor = c, (p2.prototype = Object.create(p2.prototype)).constructor = p2, (g.prototype = Object.create(h2.prototype)).constructor = g, b;
      });
    })(papaparse_min);
    var papaparse_minExports = papaparse_min.exports;
    const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparse_minExports);
    const _sfc_main$5 = {
      name: "CheckboxButton",
      props: ["modelValue", "icon", "checkedIcon", "id", "title"],
      emits: ["update:modelValue"],
      data() {
        return {
          hasFocus: false
        };
      },
      computed: {
        computedIcon() {
          return this.modelValue && this.checkedIcon || this.icon;
        },
        labelClass() {
          return [
            "slds-checkbox-button",
            this.modelValue ? "slds-checkbox-button_is-checked" : "",
            this.hasFocus ? "slds-checkbox-button_is-focused" : ""
          ];
        },
        svgStyle() {
          return {
            transform: this.computedIcon === "burndown" ? "rotateX(180deg)" : ""
          };
        },
        svgViewBox() {
          return {
            add: "0 0 520 520",
            arrow_bottom: "0 0 520 520",
            check: "0 0 520 520",
            contract_alt: "0 0 520 520",
            settings: "0 0 520 520",
            search: "0 0 520 520"
          }[this.icon] || "0 0 52 52";
        }
      }
    };
    const _hoisted_1$5 = ["for"];
    const _hoisted_2$5 = ["id", "value"];
    const _hoisted_3$4 = ["title"];
    const _hoisted_4$4 = ["viewBox"];
    const _hoisted_5$4 = {
      key: 0,
      d: "M300 290h165c8 0 15-7 15-15v-30c0-8-7-15-15-15H300c-6 0-10-4-10-10V55c0-8-7-15-15-15h-30c-8 0-15 7-15 15v165c0 6-4 10-10 10H55c-8 0-15 7-15 15v30c0 8 7 15 15 15h165c6 0 10 4 10 10v165c0 8 7 15 15 15h30c8 0 15-7 15-15V300c0-6 4-10 10-10z"
    };
    const _hoisted_6$2 = {
      key: 1,
      d: "M50.1,30.56a1.16,1.16,0,0,1-2,.82L42.73,26,30.32,36.65a3.39,3.39,0,0,1-4.92,0l-7.49-8.54L4.57,39.81a1.13,1.13,0,0,1-1.64,0l-.59-.59a1.13,1.13,0,0,1,0-1.64L15.46,19.68a3.39,3.39,0,0,1,4.92,0l7.49,7.49,7.61-8.78-4.92-4.45a1.26,1.26,0,0,1,.82-2.11H47.76A2.35,2.35,0,0,1,50,14.3Z"
    };
    const _hoisted_7$2 = {
      key: 2,
      d: "M191 425 26 259c-6-6-6-16 0-22l22-22c6-6 16-6 22 0l124 125a10 10 0 0 0 15 0L452 95c6-6 16-6 22 0l22 22c6 6 6 16 0 22L213 425c-6 7-16 7-22 0z"
    };
    const _hoisted_8$2 = { key: 3 };
    const _hoisted_9$2 = /* @__PURE__ */ createStaticVNode('<path d="M8,10.5C8,9.7,7.3,9,6.5,9h-3C2.7,9,2,9.7,2,10.5v3C2,14.3,2.7,15,3.5,15h3C7.3,15,8,14.3,8,13.5V10.5z"></path><path d="M50,10.5C50,9.7,49.3,9,48.5,9h-35C12.7,9,12,9.7,12,10.5v3c0,0.8,0.7,1.5,1.5,1.5h35 c0.8,0,1.5-0.7,1.5-1.5V10.5z"></path><path d="M8,24.5C8,23.7,7.3,23,6.5,23h-3C2.7,23,2,23.7,2,24.5v3C2,28.3,2.7,29,3.5,29h3C7.3,29,8,28.3,8,27.5V24.5z"></path><path d="M46,24.5c0-0.8-0.7-1.5-1.5-1.5h-31c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h31c0.8,0,1.5-0.7,1.5-1.5V24.5z"></path><path d="M8,38.5C8,37.7,7.3,37,6.5,37h-3C2.7,37,2,37.7,2,38.5v3C2,42.3,2.7,43,3.5,43h3C7.3,43,8,42.3,8,41.5V38.5z"></path><path d="M50,38.5c0-0.8-0.7-1.5-1.5-1.5h-35c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h35c0.8,0,1.5-0.7,1.5-1.5V38.5z"></path>', 6);
    const _hoisted_15 = [
      _hoisted_9$2
    ];
    const _hoisted_16 = {
      key: 4,
      d: "M423 418a20 20 0 0 1 20 20v42a20 20 0 0 1-20 20H97a20 20 0 0 1-20-20v-41a20 20 0 0 1 20-20ZM280 20a21 21 0 0 1 20 20v174a13 13 0 0 0 23 10l48-48a20 20 0 0 1 28 0l30 28a19 19 0 0 1 0 27L274 381a20 20 0 0 1-29 0L92 231a19 19 0 0 1 0-27l28-28a20 20 0 0 1 29 0l48 47a13 13 0 0 0 22-9V40a22 22 0 0 1 21-20h40Z"
    };
    const _hoisted_17 = {
      key: 5,
      d: "M296 239h154c10 0 13-11 5-19l-49-50 90-91c5-5 5-14 0-19l-37-37c-5-4-13-4-19 1l-90 90-51-49c-8-8-19-5-19 5v154c0 7 9 15 16 15zm-72 41H70c-10 0-13 11-5 19l49 50-90 91c-5 5-5 14 0 19l37 37c5 5 13 5 19 0l91-91 51 49c7 9 18 6 18-4V297c0-7-9-17-16-17z"
    };
    const _hoisted_18 = {
      key: 6,
      d: "M261 191c-39 0-70 31-70 70s31 70 70 70 70-31 70-70-31-70-70-70zm210 133-37-31a195 195 0 0 0 0-68l37-31c12-10 16-28 8-42l-16-28a34 34 0 0 0-40-14l-46 17a168 168 0 0 0-59-34l-8-47c-3-16-17-25-33-25h-32c-16 0-30 9-33 25l-8 46a180 180 0 0 0-60 34l-46-17-11-2c-12 0-23 6-29 16l-16 28c-8 14-5 32 8 42l37 31a195 195 0 0 0 0 68l-37 31a34 34 0 0 0-8 42l16 28a34 34 0 0 0 40 14l46-17c18 16 38 27 59 34l8 48a33 33 0 0 0 33 27h32c16 0 30-12 33-28l8-48a170 170 0 0 0 62-37l43 17 12 2c12 0 23-6 29-16l15-26c9-11 5-29-7-39zm-210 47c-61 0-110-49-110-110s49-110 110-110 110 49 110 110-49 110-110 110z"
    };
    const _hoisted_19 = {
      key: 7,
      "fill-rule": "evenodd",
      d: "M44.863,44.863 L44.863,37.317 C44.863,36.59 45.453,36 46.179,36 L50.411,36 C51.137,36 51.727,36.59 51.727,37.317 L51.727,51.727 L37.317,51.727 C36.59,51.727 36,51.137 36,50.411 L36,46.179 C36,45.453 36.59,44.863 37.317,44.863 L44.863,44.863 Z M5.80799999,36 C6.53499999,36 7.12399999,36.59 7.12399999,37.317 L7.12399999,44.863 L14.67,44.863 C15.398,44.863 15.988,45.453 15.988,46.18 L15.988,50.411 C15.988,51.138 15.398,51.728 14.67,51.728 L0.25999999,51.728 L0.25999999,37.317 C0.25999999,36.59 0.84999999,36 1.57699999,36 L5.80799999,36 Z M36,1.57699999 C36,0.84999999 36.59,0.25999999 37.317,0.25999999 L51.728,0.25999999 L51.728,14.671 C51.728,15.398 51.138,15.987 50.411,15.987 L46.18,15.987 C45.453,15.987 44.863,15.398 44.863,14.671 L44.863,7.12399999 L37.317,7.12399999 C36.59,7.12399999 36,6.53499999 36,5.80699999 L36,1.57699999 Z M1.57599999,15.987 C0.84899999,15.987 0.25999999,15.398 0.25999999,14.671 L0.25999999,0.25999999 L14.67,0.25999999 C15.397,0.25999999 15.987,0.84999999 15.987,1.57699999 L15.987,5.80699999 C15.987,6.53499999 15.397,7.12399999 14.67,7.12399999 L7.12399999,7.12399999 L7.12399999,14.671 C7.12399999,15.398 6.53399999,15.987 5.80699999,15.987 L1.57599999,15.987 Z M39.457,36.919 C39.745,37.323 39.745,37.899 39.399,38.246 L38.187,39.457 C37.842,39.803 37.322,39.803 36.976,39.457 L30.343,32.823 C28.439,34.208 26.074,35.073 23.536,35.073 C17.191,35.073 12,29.882 12,23.536 C12,17.191 17.191,12 23.536,12 C29.882,12 35.073,17.191 35.073,23.536 C35.073,26.074 34.208,28.439 32.823,30.342 L39.457,36.919 Z M23.536,31.612 C27.977,31.612 31.612,27.978 31.612,23.536 C31.612,19.095 27.977,15.461 23.536,15.461 C19.095,15.461 15.461,19.095 15.461,23.536 C15.461,27.978 19.095,31.612 23.536,31.612 Z"
    };
    const _hoisted_20 = {
      key: 8,
      d: "M496 453 362 320a189 189 0 1 0-340-92 190 190 0 0 0 298 135l133 133a14 14 0 0 0 21 0l21-21a17 17 0 0 0 1-22ZM210 338a129 129 0 1 1 130-130 129 129 0 0 1-130 130Z"
    };
    const _hoisted_21 = { class: "slds-assistive-text" };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass($options.labelClass),
        for: $props.id
      }, [
        createBaseVNode("input", {
          id: $props.id,
          value: $props.id,
          type: "checkbox",
          class: "slds-assistive-text",
          checked: "",
          onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", !$props.modelValue)),
          onFocus: _cache[1] || (_cache[1] = ($event) => $data.hasFocus = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => $data.hasFocus = false)
        }, null, 40, _hoisted_2$5),
        createBaseVNode("span", {
          class: "slds-icon_container slds-current-color",
          title: $props.title
        }, [
          (openBlock(), createElementBlock("svg", {
            class: "slds-icon slds-icon_x-small",
            style: normalizeStyle($options.svgStyle),
            xmlns: "http://www.w3.org/2000/svg",
            width: "52",
            height: "52",
            viewBox: $options.svgViewBox
          }, [
            $options.computedIcon === "add" ? (openBlock(), createElementBlock("path", _hoisted_5$4)) : createCommentVNode("", true),
            $options.computedIcon === "burndown" ? (openBlock(), createElementBlock("path", _hoisted_6$2)) : createCommentVNode("", true),
            $options.computedIcon === "check" ? (openBlock(), createElementBlock("path", _hoisted_7$2)) : createCommentVNode("", true),
            $options.computedIcon === "list" ? (openBlock(), createElementBlock("g", _hoisted_8$2, _hoisted_15)) : createCommentVNode("", true),
            $options.computedIcon === "arrow_bottom" ? (openBlock(), createElementBlock("path", _hoisted_16)) : createCommentVNode("", true),
            $options.computedIcon === "contract_alt" ? (openBlock(), createElementBlock("path", _hoisted_17)) : createCommentVNode("", true),
            $options.computedIcon === "settings" ? (openBlock(), createElementBlock("path", _hoisted_18)) : createCommentVNode("", true),
            $options.computedIcon === "zoom_to_fit" ? (openBlock(), createElementBlock("path", _hoisted_19)) : createCommentVNode("", true),
            $options.computedIcon === "search" ? (openBlock(), createElementBlock("path", _hoisted_20)) : createCommentVNode("", true)
          ], 12, _hoisted_4$4)),
          createBaseVNode("span", _hoisted_21, toDisplayString($props.title), 1)
        ], 8, _hoisted_3$4)
      ], 10, _hoisted_1$5);
    }
    const CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      name: "Desert",
      props: ["header", "body"]
    };
    const _hoisted_1$4 = { class: "slds-illustration" };
    const _hoisted_2$4 = /* @__PURE__ */ createStaticVNode('<svg class="slds-illustration__svg" viewBox="0 0 468 194" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-67.000000, -112.000000)"><g><g transform="translate(245.000000, 200.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g><g transform="translate(135.000000, 152.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g><g transform="translate(69.000000, 256.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M14,36.5 L464,36.5"></path><path vector-effect="non-scaling-stroke" d="M0,36.5 L6,36.5"></path><polyline vector-effect="non-scaling-stroke" stroke-linejoin="round" points="234.5 36 279.5 0 313.5 26"></polyline><path vector-effect="non-scaling-stroke" d="M279.5,1 L279.5,35" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M313.5,11 C313.5,20.7437888 313.5,25.7437888 313.5,26 C313.5,25.7437888 313.5,20.7437888 313.5,11 Z" stroke-linejoin="round"></path><polyline vector-effect="non-scaling-stroke" stroke-linejoin="round" points="303.5 17 313.5 9 347.5 36"></polyline></g><g transform="translate(113.000000, 178.000000)"><g transform="translate(30.000000, 8.000000)" class="slds-illustration__fill-secondary"><path vector-effect="non-scaling-stroke" d="M29.5,60.5 L29.5,12 C29.5,5.372583 34.872583,0 41.5,0 C48.127417,0 53.5,5.372583 53.5,12 L53.5,40.5 L70.5,40.5 L70.5,27 C70.5,23.1340068 73.6340068,20 77.5,20 C81.3659932,20 84.5,23.1340068 84.5,27 L84.5,48.5 C84.5,51.8137085 81.8137085,54.5 78.5,54.5 L53.5,54.5 L53.5,118.5 L29.5,118.5 L29.5,74.5 L6.5,74.5 C3.1862915,74.5 0.5,71.8137085 0.5,68.5 L0.5,39 C0.5,35.1340068 3.63400675,32 7.5,32 C11.3659932,32 14.5,35.1340068 14.5,39 L14.5,60.5 L29.5,60.5 Z"></path></g><g transform="translate(59.000000, 7.000000)" fill="#FFFFFF"><path vector-effect="non-scaling-stroke" d="M2,11 C3.65332031,8.49145508 5.65181478,6.77364095 7.9954834,5.84655762 C11.5109863,4.45593262 15.2684326,4.95605469 17.8156738,6.2824707 C20.362915,7.60888672 22.3626709,9.64978027 23.2602539,11.81604 C23.8586426,13.2602132 23.8586426,11.7547201 23.2602539,7.29956055 L19.612793,3.56494141 L13.7923584,0.564331055 L8.765625,1.42663574 L4.67321777,3.19787598 C2.69893392,5.13902708 1.69559733,6.16722532 1.66320801,6.2824707 C1.61462402,6.45533878 0.856079102,9.49145508 0.813964844,9.66003418 C0.785888672,9.77242025 1.18123372,10.2190755 2,11 Z"></path></g><g class="slds-illustration__stroke-primary" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M0,126.5 L356,126.5" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M362.5,126.5 L372.013149,126.5" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M107.5,20 L107.5,28" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M113,30.6568542 L118.656854,25" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M37.5,32 L37.5,40" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M44,42.6568542 L49.6568542,37" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M25,42.6568542 L30.6568542,37" stroke-linecap="round" transform="translate(27.828427, 39.828427) scale(-1, 1) translate(-27.828427, -39.828427) "></path><path vector-effect="non-scaling-stroke" d="M71.5,0 L71.5,8" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M79,10.6568542 L84.6568542,5" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M58,10.6568542 L63.6568542,5" stroke-linecap="round" transform="translate(60.828427, 7.828427) scale(-1, 1) translate(-60.828427, -7.828427) "></path><path vector-effect="non-scaling-stroke" d="M59.5,68.5 L59.5,20 C59.5,13.372583 64.872583,8 71.5,8 C78.127417,8 83.5,13.372583 83.5,20 L83.5,48.5 L100.5,48.5 L100.5,35 C100.5,31.1340068 103.634007,28 107.5,28 C111.365993,28 114.5,31.1340068 114.5,35 L114.5,56.5 C114.5,59.8137085 111.813708,62.5 108.5,62.5 L83.5,62.5 L83.5,126.5 L59.5,126.5 L59.5,82.5 L36.5,82.5 C33.1862915,82.5 30.5,79.8137085 30.5,76.5 L30.5,47 C30.5,43.1340068 33.6340068,40 37.5,40 C41.3659932,40 44.5,43.1340068 44.5,47 L44.5,68.5 L59.5,68.5 Z"></path><path vector-effect="non-scaling-stroke" d="M77,88.5 L92.5,88.5 L92.5,81 C92.5,77.1340068 95.6340068,74 99.5,74 L99.5,74 C103.365993,74 106.5,77.1340068 106.5,81 L106.5,96.5 C106.5,99.8137085 103.813708,102.5 100.5,102.5 L77,102.5" class="slds-illustration__fill-secondary" stroke-linecap="round" stroke-linejoin="round"></path></g></g><g transform="translate(429.000000, 242.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><g><path vector-effect="non-scaling-stroke" d="M12.5,4 L12.5,50"></path><polyline vector-effect="non-scaling-stroke" stroke-linejoin="round" points="11 18.5 0.5 18.5 0.5 0"></polyline><polyline vector-effect="non-scaling-stroke" stroke-linejoin="round" points="14 25.5 24.5 25.5 24.5 8"></polyline><polyline vector-effect="non-scaling-stroke" stroke-linejoin="round" points="2.5 31 2.5 38.5 11 38.5"></polyline></g></g><g transform="translate(327.000000, 95.000000)"><g><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-secondary" cx="64" cy="64" r="23"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="135,1,1,18" transform="translate(64.000000, 64.000000) rotate(230.000000) translate(-64.000000, -64.000000) " cx="64" cy="64" r="45"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" stroke-dasharray="107,10" transform="translate(64.000000, 64.000000) rotate(150.000000) translate(-64.000000, -64.000000) " cx="64" cy="64" r="33"></circle></g><g transform="translate(41.000000, 41.000000)" class="slds-illustration__stroke-primary" stroke-width="3"><circle vector-effect="non-scaling-stroke" cx="23" cy="23" r="23"></circle></g></g></g></g></g></svg>', 1);
    const _hoisted_3$3 = {
      key: 0,
      class: "slds-text-longform"
    };
    const _hoisted_4$3 = {
      key: 0,
      class: "slds-illustration__header slds-text-heading_medium"
    };
    const _hoisted_5$3 = {
      key: 1,
      class: "slds-text-body_regular"
    };
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        _hoisted_2$4,
        $props.header || $props.body ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
          $props.header ? (openBlock(), createElementBlock("h3", _hoisted_4$3, toDisplayString($props.header), 1)) : createCommentVNode("", true),
          $props.body ? (openBlock(), createElementBlock("p", _hoisted_5$3, toDisplayString($props.body), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ]);
    }
    const Desert = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
    const _sfc_main$3 = {
      name: "FileImport",
      components: {
        Icon,
        ButtonIcon
      },
      data() {
        return {
          id: getGUID(),
          file: null
        };
      },
      methods: {
        async onFileChange(event, dropped = false) {
          var _a;
          const fileSource = dropped ? event.dataTransfer : event.target;
          this.file = (_a = fileSource == null ? void 0 : fileSource.files) == null ? void 0 : _a[0];
          this.$emit("file-change", { file: this.file });
        }
      }
    };
    const _hoisted_1$3 = ["id"];
    const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("abbr", {
      class: "slds-required",
      title: "required"
    }, "* ", -1);
    const _hoisted_3$2 = {
      class: "slds-file-selector slds-file-selector_files",
      style: { "display": "block" }
    };
    const _hoisted_4$2 = ["id", "aria-labelledby"];
    const _hoisted_5$2 = ["id", "for"];
    const _hoisted_6$1 = {
      class: "slds-file-selector__button slds-button slds-button_neutral",
      style: { "width": "100%" }
    };
    const _hoisted_7$1 = /* @__PURE__ */ createBaseVNode("span", {
      class: "slds-file-selector__text slds-text-color_weak slds-text-align_center slds-m-top_small",
      style: { "display": "block" }
    }, "Or drop file", -1);
    const _hoisted_8$1 = {
      key: 1,
      class: "slds-input slds-p-horizontal_xx-small slds-file-selector__body slds-grid_align-spread"
    };
    const _hoisted_9$1 = { class: "slds-file-selector__input slds-truncate" };
    const _hoisted_10$1 = { class: "slds-p-left_xx-small" };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("label", {
          class: "slds-form-element__label",
          id: `${$data.id}-file-selector-primary-label`
        }, [
          _hoisted_2$3,
          createTextVNode("CSV File")
        ], 8, _hoisted_1$3),
        createBaseVNode("div", _hoisted_3$2, [
          !$data.file ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "slds-file-selector__dropzone slds-theme_default",
            onDragenter: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["prevent", "stop"])),
            onDragover: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["prevent", "stop"])),
            onDragleave: _cache[3] || (_cache[3] = withModifiers(() => {
            }, ["prevent", "stop"])),
            onDrop: _cache[4] || (_cache[4] = withModifiers((e) => $options.onFileChange(e, true), ["prevent", "stop"]))
          }, [
            createBaseVNode("input", {
              id: `${$data.id}-csvFileInput`,
              type: "file",
              class: "slds-file-selector__input slds-assistive-text",
              "aria-labelledby": `${$data.id}-file-selector-primary-label ${$data.id}-file-selector-secondary-label`,
              onChange: _cache[0] || (_cache[0] = (...args) => $options.onFileChange && $options.onFileChange(...args))
            }, null, 40, _hoisted_4$2),
            createBaseVNode("label", {
              id: `${$data.id}-file-selector-secondary-label`,
              class: "slds-file-selector__body slds-p-around_small",
              style: { "display": "block" },
              for: `${$data.id}-csvFileInput`
            }, [
              createBaseVNode("span", _hoisted_6$1, [
                createVNode(_component_Icon, {
                  category: "utility",
                  name: "upload",
                  size: "xx-small",
                  class: "slds-current-color",
                  iconClass: ["slds-button__icon", "slds-button__icon_left"]
                }),
                createTextVNode(" Upload File ")
              ]),
              _hoisted_7$1
            ], 8, _hoisted_5$2)
          ], 32)) : (openBlock(), createElementBlock("label", _hoisted_8$1, [
            createBaseVNode("div", _hoisted_9$1, [
              createVNode(_component_Icon, {
                category: "doctype",
                name: "csv",
                size: "small",
                inheritFillFromParent: false,
                iconClass: ["slds-input__icon", "slds-input__icon_left", "slds-p-bottom_xx-small"]
              }),
              createBaseVNode("span", _hoisted_10$1, toDisplayString($data.file.name), 1)
            ]),
            createVNode(_component_ButtonIcon, {
              iconCategory: "utility",
              iconName: "clear",
              variant: "container",
              size: "small",
              title: "Remove CSV",
              assistiveText: "Remove CSV",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("file-change", { file: $data.file = null }))
            })
          ]))
        ])
      ]);
    }
    const FileImport = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
    const _sfc_main$2 = {
      name: "ErrorPopover",
      components: {
        ButtonIcon,
        Popover
      },
      props: {
        error: String,
        errors: Object,
        lazy: Boolean,
        refs: Object
      },
      data() {
        return {
          renderPopover: false
        };
      },
      mounted() {
        SPM.Components.FormErrorIndicator = this;
        if (!this.lazy)
          this.renderPopover = true;
      },
      methods: {
        focusElementWithError(error) {
          this.renderPopover = false;
          this.$nextTick(() => this.refs[error.ref].focus());
        }
      }
    };
    const _hoisted_1$2 = /* @__PURE__ */ createBaseVNode("span", null, "We hit a snag.", -1);
    const _hoisted_2$2 = { key: 0 };
    const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("div", { style: { "margin-bottom": "0.25rem", "margin-left": "-0.5rem", "font-weight": "600" } }, " Review the following fields ", -1);
    const _hoisted_4$1 = {
      class: "slds-m-left_medium",
      style: { "list-style": "disc" }
    };
    const _hoisted_5$1 = ["onClick"];
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Popover = resolveComponent("Popover");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_ButtonIcon, {
          ref: "errorButtonIcon",
          assistiveText: "Error",
          title: "Error",
          iconCategory: "utility",
          iconName: "error",
          iconSize: "large",
          class: "slds-button_icon-error",
          onClick: _cache[0] || (_cache[0] = ($event) => $data.renderPopover = !$data.renderPopover)
        }, null, 512),
        $data.renderPopover ? (openBlock(), createBlock(_component_Popover, {
          key: 0,
          ref: "errorPopover",
          bindTo: _ctx.$refs.errorButtonIcon.$el,
          theme: "error",
          width: "medium",
          class: "slds-text-align_left",
          onClose: _cache[1] || (_cache[1] = ($event) => $data.renderPopover = false)
        }, {
          header: withCtx(() => [
            _hoisted_1$2
          ]),
          content: withCtx(() => [
            $props.error ? (openBlock(), createElementBlock("div", _hoisted_2$2, toDisplayString($props.error), 1)) : createCommentVNode("", true),
            $props.errors ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _hoisted_3$1,
              createBaseVNode("ul", _hoisted_4$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    class: normalizeClass({ "slds-text-link": error.ref }),
                    onClick: ($event) => $options.focusElementWithError(error)
                  }, toDisplayString(error.message), 11, _hoisted_5$1);
                }), 128))
              ])
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["bindTo"])) : createCommentVNode("", true)
      ], 64);
    }
    const FormErrorIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
    const _sfc_main$1 = {
      name: "AllocationModal",
      components: {
        CheckboxButton,
        Desert,
        FileImport,
        FormErrorIndicator,
        // slds vue
        Checkbox,
        Modal,
        Picklist,
        Spinner
      },
      emits: ["close"],
      data() {
        return {
          loadingMsg: "",
          csvFile: null,
          csvKey: "",
          fileName: "",
          csvColumns: [],
          showOnlySelected: false,
          errors: []
        };
      },
      computed: {
        visibleCSVColumns() {
          return this.csvColumns.filter((c) => c.name !== this.csvKey && (c.selected || !this.showOnlySelected));
        },
        columnDataOptions() {
          return [
            { id: "Parent", label: "Parent", type: "Territory" },
            { id: "Owner", label: "Owner", type: "User" },
            ...SPM.Components.Root.plan._columns.reduce((arr, c) => {
              if (c.type === "Quota") {
                arr.push({ id: `${c.id}:Quota`, label: `${c.id} (Quota)`, type: "Numeric" });
                if (c.targetLabel && !c.expression) {
                  arr.push({ id: `${c.id}:Target`, label: `${c.id} (Target)`, type: "Numeric" });
                }
              } else if (c.type === "Numeric" || c.type === "Text") {
                arr.push({ id: c.id, label: c.id, type: c.type });
              }
              return arr;
            }, [])
          ];
        },
        config() {
          return SPM.Components.Root.importModalConfig;
        },
        quotaColumns() {
          return SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota");
        }
      },
      watch: {
        config: {
          async handler() {
            if (SPM.Components.Root.importModalConfig.file) {
              await this.$nextTick();
              this.$refs.fileImport.file = SPM.Components.Root.importModalConfig.file;
              this.onFileChange(SPM.Components.Root.importModalConfig);
            }
          },
          deep: true,
          immediate: true
        }
      },
      async mounted() {
        SPM.Components.ImportModal = this;
      },
      methods: {
        async onFileChange({ file }) {
          if (!file) {
            this.fileName = "";
            this.csvKey = "";
            return;
          }
          this.fileName = file.name;
          await this.$nextTick();
          Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            preview: 5,
            complete: async (results) => {
              this.csvColumns = results.meta.fields.map((name) => {
                const matchingColumn = this.columnDataOptions.find((c) => c.id === name);
                const defaultType = isNaN(parseFloat(results.data[0][name])) ? "Text" : "Numeric";
                return {
                  name,
                  columnId: (matchingColumn == null ? void 0 : matchingColumn.id) || "",
                  sampleData: results.data.map((d) => d[name] || "").join(", "),
                  type: (matchingColumn == null ? void 0 : matchingColumn.type) || defaultType,
                  defaultType,
                  selected: !!matchingColumn,
                  isNew: false
                };
              });
              if (results.meta.fields.includes("Territory")) {
                this.csvKey = "Territory";
              }
            }
          });
        },
        onImportChanged(csvColumn) {
          const matchingColumn = this.columnDataOptions.find((c) => c.id === csvColumn.name);
          if (csvColumn.selected && !csvColumn.columnId) {
            csvColumn.columnId = csvColumn.name;
            csvColumn.isNew = !matchingColumn;
          }
          if (csvColumn.selected && this.isColumnNameInvalid(csvColumn.columnId) && !matchingColumn) {
            this.errors.push({ message: csvColumn.name });
          } else {
            this.errors.splice(this.errors.findIndex((e) => e.message === csvColumn.name), 1);
          }
        },
        onQuotaPlanColumnChanged(csvColumn) {
          const matchingColumn = this.columnDataOptions.find((c) => c.id === csvColumn.columnId);
          if (csvColumn.columnId) {
            csvColumn.selected = true;
            csvColumn.isNew = !matchingColumn;
            csvColumn.type = (matchingColumn == null ? void 0 : matchingColumn.type) || csvColumn.defaultType;
          } else {
            csvColumn.selected = false;
            csvColumn.isNew = false;
            csvColumn.type = csvColumn.defaultType;
          }
          if (this.isColumnNameInvalid(csvColumn.columnId) && !matchingColumn) {
            this.errors.push({ message: csvColumn.name });
          } else {
            this.errors.splice(this.errors.findIndex((e) => e.message === csvColumn.name), 1);
          }
        },
        isColumnNameInvalid(name) {
          return name.includes(":") && SPM.Utils.Quota.helperUtils.isColumnNameInvalid(name, this.quotaColumns);
        },
        async save() {
          const columnIds = this.csvColumns.filter((c) => c.selected).map((c) => c.columnId);
          const hasDuplicates = new Set(columnIds).size !== columnIds.length;
          if (hasDuplicates) {
            this.errors.push({ message: "Select a unique quota plan column for each CSV column." });
            return;
          }
          Papa.parse(this.$refs.fileImport.file, {
            header: true,
            skipEmptyLines: true,
            complete: async (results) => {
              this.loadingMsg = "Importing...";
              const columnsToCreate = this.csvColumns.filter((c) => c.selected && c.isNew);
              if (columnsToCreate.length) {
                columnsToCreate.forEach(({ columnId, type }) => {
                  SPM.Components.Root.plan._columns.push({
                    ...SPM.Utils.Quota.Column.defaults(),
                    id: columnId,
                    label: columnId,
                    type
                  });
                  SPM.Components.Root.preferences.columns.splice(SPM.Components.Root.preferences.columns.length, 0, { id: columnId });
                });
                SPM.Components.Root.plan.sfsp__ReferenceFields__c = JSON.stringify(SPM.Components.Root.plan._columns);
                await SPM.Utils.CRM.upsert({ records: [SPM.Components.Root.plan] });
              }
              const columnsToImport = [...this.csvColumns.filter((c) => c.selected), { name: this.csvKey, columnId: "Territory" }];
              await SPM.Utils.Quota.Plan.import(
                results.data.map((d) => columnsToImport.reduce((row, { name, columnId }) => {
                  row[columnId] = d[name];
                  return row;
                }, {}))
              );
              this.close();
            }
          });
        },
        close() {
          SPM.Components.Root.importModalConfig = null;
        }
      }
    };
    const _withScopeId = (n) => (pushScopeId("data-v-9a502538"), n = n(), popScopeId(), n);
    const _hoisted_1$1 = { class: "slds-grid" };
    const _hoisted_2$1 = { style: { "width": "300px", "background": "#f3f3f3", "padding": ".75rem" } };
    const _hoisted_3 = {
      key: 0,
      class: "slds-grow slds-p-around_large"
    };
    const _hoisted_4 = { class: "slds-grid slds-grid_vertical-align-center slds-grid_align-spread" };
    const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", null, [
      /* @__PURE__ */ createBaseVNode("div", { style: { "font-weight": "bold" } }, "Columns to Import"),
      /* @__PURE__ */ createBaseVNode("p", null, "Name-matched columns are automatically mapped")
    ], -1));
    const _hoisted_6 = { class: "slds-table slds-m-top_large" };
    const _hoisted_7 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("thead", null, [
      /* @__PURE__ */ createBaseVNode("tr", null, [
        /* @__PURE__ */ createBaseVNode("th", null, "Import"),
        /* @__PURE__ */ createBaseVNode("th", null, "CSV Column"),
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "250px" } }, "Quota Plan Column"),
        /* @__PURE__ */ createBaseVNode("th", null, "Sample CSV Data"),
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "120px" } }, "Type")
      ])
    ], -1));
    const _hoisted_8 = {
      class: "slds-truncate",
      style: { "max-width": "10rem", "padding-right": "2rem" }
    };
    const _hoisted_9 = { class: "slds-grid" };
    const _hoisted_10 = { class: "slds-col_bump-left" };
    const _hoisted_11 = { class: "slds-m-right_x-small" };
    const _hoisted_12 = ["disabled"];
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_FileImport = resolveComponent("FileImport");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_CheckboxButton = resolveComponent("CheckboxButton");
      const _component_Desert = resolveComponent("Desert");
      const _component_FormErrorIndicator = resolveComponent("FormErrorIndicator");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: "Import",
        size: "large",
        detach: "",
        footless: !!$data.loadingMsg,
        onClose: $options.close
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_1$1, [
            createBaseVNode("div", _hoisted_2$1, [
              createVNode(_component_FileImport, {
                ref: "fileImport",
                class: "slds-m-bottom_large",
                onFileChange: $options.onFileChange
              }, null, 8, ["onFileChange"]),
              createVNode(_component_Picklist, {
                modelValue: $data.csvKey,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.csvKey = $event),
                required: "",
                filterable: "",
                labels: { name: "Territory Identifier Column", placeholder: "Select Field..." },
                options: $data.csvColumns,
                idKey: "name",
                titleKey: "name",
                disabled: !$data.fileName
              }, null, 8, ["modelValue", "labels", "options", "disabled"])
            ]),
            $data.csvKey ? (openBlock(), createElementBlock("div", _hoisted_3, [
              createBaseVNode("div", _hoisted_4, [
                _hoisted_5,
                createVNode(_component_Checkbox, {
                  modelValue: $data.showOnlySelected,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.showOnlySelected = $event),
                  labels: { name: "Show only selected rows" }
                }, null, 8, ["modelValue"])
              ]),
              createBaseVNode("table", _hoisted_6, [
                _hoisted_7,
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.visibleCSVColumns, (csvColumn, i) => {
                    return openBlock(), createElementBlock("tr", {
                      key: csvColumn.name
                    }, [
                      createBaseVNode("td", null, [
                        createVNode(_component_CheckboxButton, {
                          modelValue: csvColumn.selected,
                          "onUpdate:modelValue": [($event) => csvColumn.selected = $event, ($event) => $options.onImportChanged(csvColumn)],
                          icon: "add",
                          checkedIcon: "check",
                          title: `Select ${csvColumn.name}`
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "title"])
                      ]),
                      createBaseVNode("td", null, toDisplayString(csvColumn.name), 1),
                      createBaseVNode("td", null, [
                        createVNode(_component_Picklist, {
                          modelValue: csvColumn.columnId,
                          "onUpdate:modelValue": ($event) => csvColumn.columnId = $event,
                          labels: { search: "Select Column..." },
                          labelForId: `quota-plan-column-${i}`,
                          options: $options.columnDataOptions,
                          titleKey: "label",
                          filterable: "",
                          combobox: "",
                          style: { "width": "200px" },
                          onSelectedOption: ($event) => $options.onQuotaPlanColumnChanged(csvColumn),
                          onClear: ($event) => $options.onQuotaPlanColumnChanged(csvColumn)
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "labels", "labelForId", "options", "onSelectedOption", "onClear"])
                      ]),
                      createBaseVNode("td", _hoisted_8, toDisplayString(csvColumn.sampleData), 1),
                      createBaseVNode("td", null, [
                        csvColumn.columnId && !csvColumn.isNew ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                          createTextVNode(toDisplayString(csvColumn.type), 1)
                        ], 64)) : (openBlock(), createBlock(_component_Picklist, {
                          key: 1,
                          modelValue: csvColumn.type,
                          "onUpdate:modelValue": ($event) => csvColumn.type = $event,
                          options: [{ id: "Numeric", title: "Numeric" }, { id: "Text", title: "Text" }]
                        }, null, 8, ["modelValue", "onUpdate:modelValue"]))
                      ])
                    ]);
                  }), 128))
                ])
              ])
            ])) : (openBlock(), createBlock(_component_Desert, {
              key: 1,
              class: "slds-grow slds-illustration_large slds-m-top_large",
              body: "Select a file and the column that includes your territory names."
            }))
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_9, [
              createBaseVNode("div", _hoisted_10, [
                createBaseVNode("span", _hoisted_11, [
                  $data.errors.length ? (openBlock(), createBlock(_component_FormErrorIndicator, {
                    key: 0,
                    errors: $data.errors
                  }, null, 8, ["errors"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("button", {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[2] || (_cache[2] = (...args) => $options.close && $options.close(...args))
                }, "Cancel"),
                createBaseVNode("button", {
                  class: "slds-button slds-button_brand",
                  disabled: $data.errors.length,
                  onClick: _cache[3] || (_cache[3] = (...args) => $options.save && $options.save(...args))
                }, "Import", 8, _hoisted_12)
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["footless", "onClose"]);
    }
    const ImportModal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-9a502538"]]);
    const importCSV = "/resource/1730930681825/sfsp__QuotaBuilder/dist/import-csv.svg";
    const _sfc_main = {
      name: "AppRoot",
      components: {
        LeftPanel,
        RightPanel,
        BuilderHeader,
        TargetProgress,
        TerritoryTable,
        ImportModal,
        // slds
        Spinner,
        Toasts
      },
      data() {
        return {
          loadingMsg: "Loading plan...",
          modalConfig: {},
          toasts: [],
          // preferences
          preferences: {},
          // nodes
          nodeMap: {},
          nodeHierarchy: {
            ...SPM.Utils.Quota.Node.defaults(),
            Id: "all_org",
            Name: "All",
            _data: {}
          },
          // plan
          planReady: false,
          plan: SPM.Utils.Quota.Plan.defaults(),
          // users
          usersByName: {},
          // left panel
          leftPanelConfig: null,
          // right panel
          rightPanelConfig: null,
          // file drop
          lastDragTarget: null,
          importModalConfig: null,
          // images
          importCSV,
          // territory stamp
          segment: null,
          territoryStampRoot: {}
        };
      },
      computed: {
        canViewTarget() {
          return SPM.betaFlags.SP_Quota_Targets;
        }
      },
      watch: {
        preferences: {
          handler() {
            var _a, _b;
            if (!this.planReady)
              return;
            const newPreferences = JSON.stringify(this.preferences, 0, 4);
            if (this.plan.sfsp__Preferences__c !== newPreferences) {
              if (!((_b = (_a = this.plan) == null ? void 0 : _a.sfsp__SalesUserPreferences__r) == null ? void 0 : _b[0])) {
                this.plan.sfsp__SalesUserPreferences__r = [{
                  sobjectType: "sfsp__SalesUserPreference__c",
                  sfsp__SalesPlan__c: this.plan.Id,
                  sfsp__User__c: SPM.currentUser.Id
                }];
              }
              this.plan.sfsp__SalesUserPreferences__r[0].sfsp__Preferences__c = newPreferences;
              SPM.Utils.CRM.upsert({ records: [this.plan.sfsp__SalesUserPreferences__r[0]] });
            }
          },
          deep: true
        }
      },
      async created() {
        SPM.Components.Root = this;
        if (SPM.UITheme === "Theme4d") {
          document.body.style.marginTop = "-1.25rem";
        }
      },
      async mounted() {
        this.loadUsers();
        const params = new URLSearchParams(window.location.search);
        const planId = params.get("planId");
        try {
          await this.loadPlan(planId);
        } catch (err) {
          this.toast({ state: "error", message: "Plan not found. It may have been deleted or you may not have access.", duration: null });
          return;
        }
        try {
          const segmentId = params.get("segmentId");
          await this.getTerritoryStamp(segmentId);
        } catch (err) {
          this.toast({ state: "warning", message: "Unable to load territory stamp. It may have been deleted or you may not have access.", duration: null });
        }
        this.loadingMsg = "";
        this.planReady = true;
        window.addEventListener("dragenter", this.onDragenter);
        window.addEventListener("dragleave", this.onDragleave);
        window.addEventListener("dragover", this.onDragover);
        window.addEventListener("drop", this.onDrop);
      },
      unmounted() {
        window.removeEventListener("dragenter", this.onDragenter);
        window.removeEventListener("dragleave", this.onDragleave);
        window.removeEventListener("dragover", this.onDragover);
        window.removeEventListener("drop", this.onDrop);
      },
      methods: {
        // plan
        async loadPlan(planId) {
          var _a, _b, _c;
          this.plan = {
            ...SPM.Utils.Quota.Plan.defaults(),
            ...await SPM.Utils.Apex.invoke("GetQuotaPlan", [planId], { cls: "SPMSharingModel" })
          };
          const externalAssets = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__SalesNode__r.Name, sfsp__SalesNode__r.sfsp__Target__c FROM sfsp__SalesNodeExternalAsset__c WHERE sfsp__AssetType__c = 'Quota Plan' AND sfsp__AssetId__c = '${this.plan.Id}'`]);
          if (externalAssets.length === 1) {
            this.plan._target = externalAssets[0].sfsp__SalesNode__r.sfsp__Target__c || 0;
          } else {
            this.toast({ state: "warning", message: "This quota plan is tied to multiple segments so target cannot be determined", duration: null });
          }
          this.plan._columns = JSON.parse(this.plan.sfsp__ReferenceFields__c);
          Object.assign(this.preferences, JSON.parse(((_c = (_b = (_a = this.plan) == null ? void 0 : _a.sfsp__SalesUserPreferences__r) == null ? void 0 : _b[0]) == null ? void 0 : _c.sfsp__Preferences__c) || "{}"));
          const nodes = await SPM.Utils.Apex.invoke(
            "Query",
            [`
                    SELECT
                        Id,
                        Name,
                        sfsp__Parent__c,
                        sfsp__Owner__r.Name,
                        sfsp__Owner__r.SmallPhotoUrl,
                        sfsp__Owner__r.Title,
                        sfsp__HierarchyReferenceData__c
                    FROM sfsp__SalesNode__c
                    WHERE sfsp__SalesPlan__c = '${planId}'
                    ORDER BY sfsp__Priority__c ASC
                `]
          );
          this.nodeMap.all_org = this.nodeHierarchy;
          nodes.forEach((node) => {
            const parentNode = this.nodeMap[node.sfsp__Parent__c || "all_org"] = this.nodeMap[node.sfsp__Parent__c || "all_org"] || {
              ...SPM.Utils.Quota.Node.defaults(),
              Id: node.sfsp__Parent__c || "all_org"
            };
            const childNode = this.nodeMap[node.Id] = this.nodeMap[node.Id] || {
              ...SPM.Utils.Quota.Node.defaults(),
              Id: node.Id
            };
            Object.assign(this.nodeMap[node.Id], {
              ...node,
              _parentId: parentNode.Id,
              _data: JSON.parse(node.sfsp__HierarchyReferenceData__c || "{}")
            });
            this.nodeMap[parentNode.Id].sfsp__SalesNodes__r.push(childNode);
          });
          this.plan._columns.filter((c) => c.type === "Quota").forEach(SPM.Utils.Quota.Column.calculateRollups);
          this.calculateNodes();
        },
        calculateNodes(nodes) {
          nodes = nodes || Object.values(this.nodeMap);
          try {
            nodes.forEach(SPM.Utils.Quota.Node.calculateColumns);
          } catch (err) {
            SPM.Components.Root.toast({ state: "error", message: (err == null ? void 0 : err.message) || err, duration: null });
          }
        },
        // users
        async loadUsers(names = []) {
          names = names.filter((n) => !this.usersByName[n]);
          if (names.length) {
            const fixedNames = [];
            names.forEach((f) => fixedNames.push(f.replaceAll("'", "\\'")));
            const users = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, Name, SmallPhotoUrl FROM User WHERE Name IN ('${fixedNames.join("','")}')`]);
            users.forEach((u) => this.usersByName[u.Name] = u);
          } else if (Object.keys(this.usersByName).length === 0) {
            const users = await SPM.Utils.Apex.invoke("Query", ["SELECT Id, Name, SmallPhotoUrl FROM User LIMIT 1000"]);
            users.forEach((u) => this.usersByName[u.Name] = u);
          }
        },
        // territory stamp
        async getTerritoryStamp(segmentId) {
          var _a;
          const territoryStampSize = await SPM.Utils.Apex.invoke("CountQuery", [`
                SELECT
                    COUNT()
                FROM sfsp__SalesNode__c
                WHERE sfsp__Segment__c = '${segmentId}'
            `]);
          if (territoryStampSize > 0) {
            this.segment = (_a = await SPM.Utils.Apex.invoke(
              "Query",
              [`
                        SELECT
                            Id,
                            Name,
                            sfsp__ReferenceFields__c
                        FROM sfsp__SalesNode__c
                        WHERE Id = '${segmentId}'
                    `]
            )) == null ? void 0 : _a[0];
            const territoryStampMetadata = JSON.parse(this.segment.sfsp__ReferenceFields__c || "[]").find((f) => f.type === "Territory Stamp");
            this.territoryStampRoot = {
              Name: territoryStampMetadata == null ? void 0 : territoryStampMetadata.name,
              Id: territoryStampMetadata == null ? void 0 : territoryStampMetadata.id,
              CreatedDate: territoryStampMetadata == null ? void 0 : territoryStampMetadata.createdDate
            };
          }
        },
        // csv drop support
        onDragenter(e) {
          if (SPM.Components.TerritoryTable.draggingColumnIndex >= 0 || SPM.Components.TerritoryTable.isDragging)
            return;
          this.lastDragTarget = e.target;
        },
        onDragleave(e) {
          if (SPM.Components.TerritoryTable.isDragging)
            return;
          if (e.target === this.lastDragTarget || e.target === document) {
            this.lastDragTarget = null;
          }
        },
        onDragover(e) {
          e.preventDefault();
        },
        onDrop(e) {
          if (!this.lastDragTarget || SPM.Components.TerritoryTable.isDragging)
            return;
          this.lastDragTarget = null;
          this.importModalConfig = { file: e.dataTransfer.files[0] };
        },
        // toast
        toast(options) {
          this.toasts.push({
            ...{
              duration: 5e3,
              position: "top-center",
              state: "success"
            },
            ...options
          });
        }
      }
    };
    const _hoisted_1 = {
      key: 1,
      class: "slds-grid slds-grid_vertical slds-grow slds-is-relative",
      style: { "overflow": "hidden" }
    };
    const _hoisted_2 = ["src"];
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Toasts = resolveComponent("Toasts");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_BuilderHeader = resolveComponent("BuilderHeader");
      const _component_TargetProgress = resolveComponent("TargetProgress");
      const _component_TerritoryTable = resolveComponent("TerritoryTable");
      const _component_LeftPanel = resolveComponent("LeftPanel");
      const _component_RightPanel = resolveComponent("RightPanel");
      const _component_ImportModal = resolveComponent("ImportModal");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_Toasts, { toasts: $data.toasts }, null, 8, ["toasts"]),
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createVNode(_component_BuilderHeader, { plan: $data.plan }, null, 8, ["plan"]),
        $data.planReady ? (openBlock(), createElementBlock("div", _hoisted_1, [
          $options.canViewTarget && !$data.loadingMsg && $data.nodeHierarchy.sfsp__SalesNodes__r.length ? (openBlock(), createBlock(_component_TargetProgress, {
            key: 0,
            class: "slds-m-horizontal_small slds-m-top_small"
          })) : createCommentVNode("", true),
          !$data.loadingMsg ? (openBlock(), createBlock(_component_TerritoryTable, {
            key: 1,
            class: "slds-grow slds-m-around_small"
          })) : createCommentVNode("", true),
          createVNode(Transition, { name: "slide-fade-panel" }, {
            default: withCtx(() => [
              $data.leftPanelConfig ? (openBlock(), createBlock(_component_LeftPanel, {
                key: 0,
                config: $data.leftPanelConfig
              }, null, 8, ["config"])) : createCommentVNode("", true)
            ]),
            _: 1
          }),
          createVNode(Transition, { name: "slide-fade-panel" }, {
            default: withCtx(() => [
              $data.rightPanelConfig ? (openBlock(), createBlock(_component_RightPanel, {
                key: 0,
                config: $data.rightPanelConfig
              }, null, 8, ["config"])) : createCommentVNode("", true)
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true),
        !!$data.importModalConfig ? (openBlock(), createBlock(_component_ImportModal, { key: 2 })) : createCommentVNode("", true),
        createBaseVNode("div", {
          id: "file-drop-handler",
          class: normalizeClass(["slds-align_absolute-center", { dragging: !!$data.lastDragTarget }]),
          onDrop: _cache[0] || (_cache[0] = withModifiers(() => {
          }, ["prevent"]))
        }, [
          createBaseVNode("img", { src: $data.importCSV }, null, 8, _hoisted_2)
        ], 34)
      ], 64);
    }
    const Root = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-1cf7ff84"]]);
    SPM.Utils = UtilsClient();
    SPM.Utils.Quota = QuotaUtils;
    SPM.Utils.getGUID = getGUID;
    SPM.Components = {};
    SPM.$store = {
      txnId: SPM.Utils.getGUID()
    };
    SPM.app = createApp({
      components: { IconSettings },
      render() {
        return h(
          IconSettings,
          {
            iconPath: `/resource/${(/* @__PURE__ */ new Date()).getTime()}/sfsp__SLDSAssets/icons`
          },
          () => [h(Root)]
        );
      }
    });
    SPM.app.directive("click-outside", ClickOutside);
    const locale = SPM.currentUser.Locale.replace("sh_ME_USD", "sh-ME").replace("_", "-").slice(0, 5);
    const formatters = {
      Currency: new Intl.NumberFormat(locale, { style: "currency", currency: SPM.currentUser.CurrencyIsoCode, maximumFractionDigits: 0 }),
      Numeric: new Intl.NumberFormat(locale, { style: "decimal", maximumFractionDigits: 0 }),
      Compact: new Intl.NumberFormat(locale, { notation: "compact" }),
      DateTime: (options = {}) => new Intl.DateTimeFormat(locale, options)
    };
    SPM.app.config.globalProperties.$F = (type, value, options) => type === "DateTime" ? formatters[type](options).format(value) : formatters[type].format(value);
    SPM.app.mount("#vue-root");
    SPM.version = 246;
    SPM.app.config.errorHandler = (ex, vm, info) => {
      if ((ex == null ? void 0 : ex.type) === "RemoteActionException") {
        const { error } = ex;
        SPM.Components.Root.toast({
          message: error.type,
          subMessage: error.message,
          state: "error",
          duration: 0
        });
      }
      console.log("Vue Error", ex, vm, info);
    };
  }
});
export default require_bundle();
