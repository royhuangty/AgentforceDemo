var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_bundle = __commonJS({
  "bundle.js"(exports, module) {
    function makeMap(str, expectsLowerCase) {
      const map2 = /* @__PURE__ */ Object.create(null);
      const list = str.split(",");
      for (let i2 = 0; i2 < list.length; i2++) {
        map2[list[i2]] = true;
      }
      return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$2 = Object.assign;
    const remove = (arr, el) => {
      const i2 = arr.indexOf(el);
      if (i2 > -1) {
        arr.splice(i2, 1);
      }
    };
    const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
    const isArray$2 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString(val) === "[object Date]";
    const isFunction$2 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$3 = (val) => val !== null && typeof val === "object";
    const isPromise$1 = (val) => {
      return (isObject$3(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$2 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i2 = 0; i2 < fns.length; i2++) {
        fns[i2](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString$2(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$2(value)) {
        const res = {};
        for (let i2 = 0; i2 < value.length; i2++) {
          const item = value[i2];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$2(value) || isObject$3(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$2(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          const normalized = normalizeClass(value[i2]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$3(value)) {
        for (const name in value) {
          if (value[name]) {
            res += name + " ";
          }
        }
      }
      return res.trim();
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i2 = 0; equal && i2 < a.length; i2++) {
        equal = looseEqual(a[i2], b[i2]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate$2(a);
      let bValidType = isDate$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol(a);
      bValidType = isSymbol(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$2(a);
      bValidType = isArray$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$3(a);
      bValidType = isObject$3(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    const toDisplayString = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$3(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
            entries[`${key} =>`] = val2;
            return entries;
          }, {})
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()]
        };
      } else if (isObject$3(val) && !isArray$2(val) && !isPlainObject$2(val)) {
        return String(val);
      }
      return val;
    };
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i2, l;
          for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
            this.effects[i2].stop();
          }
          for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
            this.cleanups[i2]();
          }
          if (this.scopes) {
            for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
              this.scopes[i2].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function effectScope(detached) {
      return new EffectScope(detached);
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    function onScopeDispose(fn) {
      if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
      }
    }
    const createDep = (effects) => {
      const dep = new Set(effects);
      dep.w = 0;
      dep.n = 0;
      return dep;
    };
    const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
    const newTracked = (dep) => (dep.n & trackOpBit) > 0;
    const initDepMarkers = ({ deps }) => {
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].w |= trackOpBit;
        }
      }
    };
    const finalizeDepMarkers = (effect2) => {
      const { deps } = effect2;
      if (deps.length) {
        let ptr = 0;
        for (let i2 = 0; i2 < deps.length; i2++) {
          const dep = deps[i2];
          if (wasTracked(dep) && !newTracked(dep)) {
            dep.delete(effect2);
          } else {
            deps[ptr++] = dep;
          }
          dep.w &= ~trackOpBit;
          dep.n &= ~trackOpBit;
        }
        deps.length = ptr;
      }
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    let effectTrackDepth = 0;
    let trackOpBit = 1;
    const maxMarkerBits = 30;
    let activeEffect;
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    class ReactiveEffect {
      constructor(fn, scheduler2 = null, scope) {
        this.fn = fn;
        this.scheduler = scheduler2;
        this.active = true;
        this.deps = [];
        this.parent = void 0;
        recordEffectScope(this, scope);
      }
      run() {
        if (!this.active) {
          return this.fn();
        }
        let parent = activeEffect;
        let lastShouldTrack = shouldTrack;
        while (parent) {
          if (parent === this) {
            return;
          }
          parent = parent.parent;
        }
        try {
          this.parent = activeEffect;
          activeEffect = this;
          shouldTrack = true;
          trackOpBit = 1 << ++effectTrackDepth;
          if (effectTrackDepth <= maxMarkerBits) {
            initDepMarkers(this);
          } else {
            cleanupEffect(this);
          }
          return this.fn();
        } finally {
          if (effectTrackDepth <= maxMarkerBits) {
            finalizeDepMarkers(this);
          }
          trackOpBit = 1 << --effectTrackDepth;
          activeEffect = this.parent;
          shouldTrack = lastShouldTrack;
          this.parent = void 0;
          if (this.deferStop) {
            this.stop();
          }
        }
      }
      stop() {
        if (activeEffect === this) {
          this.deferStop = true;
        } else if (this.active) {
          cleanupEffect(this);
          if (this.onStop) {
            this.onStop();
          }
          this.active = false;
        }
      }
    }
    function cleanupEffect(effect2) {
      const { deps } = effect2;
      if (deps.length) {
        for (let i2 = 0; i2 < deps.length; i2++) {
          deps[i2].delete(effect2);
        }
        deps.length = 0;
      }
    }
    let shouldTrack = true;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep());
        }
        trackEffects(dep);
      }
    }
    function trackEffects(dep, debuggerEventExtraInfo) {
      let shouldTrack2 = false;
      if (effectTrackDepth <= maxMarkerBits) {
        if (!newTracked(dep)) {
          dep.n |= trackOpBit;
          shouldTrack2 = !wasTracked(dep);
        }
      } else {
        shouldTrack2 = !dep.has(activeEffect);
      }
      if (shouldTrack2) {
        dep.add(activeEffect);
        activeEffect.deps.push(dep);
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$2(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      if (deps.length === 1) {
        if (deps[0]) {
          {
            triggerEffects(deps[0]);
          }
        }
      } else {
        const effects = [];
        for (const dep of deps) {
          if (dep) {
            effects.push(...dep);
          }
        }
        {
          triggerEffects(createDep(effects));
        }
      }
    }
    function triggerEffects(dep, debuggerEventExtraInfo) {
      const effects = isArray$2(dep) ? dep : [...dep];
      for (const effect2 of effects) {
        if (effect2.computed) {
          triggerEffect(effect2);
        }
      }
      for (const effect2 of effects) {
        if (!effect2.computed) {
          triggerEffect(effect2);
        }
      }
    }
    function triggerEffect(effect2, debuggerEventExtraInfo) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
    function getDepFromReactive(object, key) {
      var _a;
      return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i2 = 0, l = this.length; i2 < l; i2++) {
            track(arr, "get", i2 + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          const res = toRaw(this)[key].apply(this, args);
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$2(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
          return target;
        }
        const targetIsArray = isArray$2(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$2;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$3(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
          return false;
        }
        if (!this._shallow) {
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
            oldValue.value = value;
            return true;
          }
        }
        const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$2(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add$2(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto2 = getProto(target);
      const hadKey = proto2.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$2(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$3(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$3(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$2,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$3(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      def(value, "__v_skip", true);
      return value;
    }
    const toReactive = (value) => isObject$3(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$3(value) ? readonly(value) : value;
    function trackRefValue(ref2) {
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        {
          trackEffects(ref2.dep || (ref2.dep = createDep()));
        }
      }
    }
    function triggerRefValue(ref2, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        {
          triggerEffects(dep);
        }
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function ref(value) {
      return createRef(value, false);
    }
    function createRef(rawValue, shallow) {
      if (isRef(rawValue)) {
        return rawValue;
      }
      return new RefImpl(rawValue, shallow);
    }
    class RefImpl {
      constructor(value, __v_isShallow) {
        this.__v_isShallow = __v_isShallow;
        this.dep = void 0;
        this.__v_isRef = true;
        this._rawValue = __v_isShallow ? value : toRaw(value);
        this._value = __v_isShallow ? value : toReactive(value);
      }
      get value() {
        trackRefValue(this);
        return this._value;
      }
      set value(newVal) {
        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
        newVal = useDirectValue ? newVal : toRaw(newVal);
        if (hasChanged(newVal, this._rawValue)) {
          this._rawValue = newVal;
          this._value = useDirectValue ? newVal : toReactive(newVal);
          triggerRefValue(this);
        }
      }
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    function toRefs(object) {
      const ret = isArray$2(object) ? new Array(object.length) : {};
      for (const key in object) {
        ret[key] = propertyToRef(object, key);
      }
      return ret;
    }
    class ObjectRefImpl {
      constructor(_object, _key, _defaultValue) {
        this._object = _object;
        this._key = _key;
        this._defaultValue = _defaultValue;
        this.__v_isRef = true;
      }
      get value() {
        const val = this._object[this._key];
        return val === void 0 ? this._defaultValue : val;
      }
      set value(newVal) {
        this._object[this._key] = newVal;
      }
      get dep() {
        return getDepFromReactive(toRaw(this._object), this._key);
      }
    }
    function propertyToRef(source, key, defaultValue) {
      const val = source[key];
      return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
    }
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this._dirty = true;
        this.effect = new ReactiveEffect(getter, () => {
          if (!this._dirty) {
            this._dirty = true;
            triggerRefValue(this);
          }
        });
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        trackRefValue(self2);
        if (self2._dirty || !self2._cacheable) {
          self2._dirty = false;
          self2._value = self2.effect.run();
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$2(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function warn$1(msg, ...args) {
      return;
    }
    function callWithErrorHandling(fn, instance, type, args) {
      let res;
      try {
        res = args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction$2(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise$1(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i2 = 0; i2 < fn.length; i2++) {
        values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = type;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
              if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id) {
      let start2 = flushIndex + 1;
      let end2 = queue.length;
      while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id || middleJobId === id && middleJob.pre) {
          start2 = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i2 = queue.indexOf(job);
      if (i2 > flushIndex) {
        queue.splice(i2, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$2(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(seen, i2 = isFlushing ? flushIndex + 1 : 0) {
      for (; i2 < queue.length; i2++) {
        const cb = queue[i2];
        if (cb && cb.pre) {
          queue.splice(i2, 1);
          i2--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)];
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff2 = getId(a) - getId(b);
      if (diff2 === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff2;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
        if (trim2) {
          args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$2(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$3(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$2(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$2(normalized, raw);
      }
      if (isObject$3(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id) {
      currentScopeId = id;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root = cloneVNode(root, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root = cloneVNode(root);
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root.transition = vnode.transition;
      }
      {
        result = root;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i2 = 0; i2 < dynamicProps.length; i2++) {
            const key = dynamicProps[i2];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i2 = 0; i2 < nextKeys.length; i2++) {
        const key = nextKeys[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent && parent.subTree === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name) {
      return resolveAsset(DIRECTIVES, name);
    }
    function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
            /* do not include inferred name to avoid breaking existing code */
          );
          if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name) || // global registration
          resolve(instance.appContext[type], name)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name) {
      return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$2(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    function watchPostEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "post" }
      );
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
      var _a;
      const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => source;
        deep = true;
      } else if (isArray$2(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return traverse(s);
          } else if (isFunction$2(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$2(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (instance && instance.isUnmounted) {
              return;
            }
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, scheduler);
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      const unwatch = () => {
        effect2.stop();
        if (instance && instance.scope) {
          remove(instance.scope.effects, effect2);
        }
      };
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$2(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const cur = currentInstance;
      setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      if (cur) {
        setCurrentInstance(cur);
      } else {
        unsetCurrentInstance();
      }
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i2 = 0; i2 < segments.length && cur; i2++) {
          cur = cur[segments[i2]];
        }
        return cur;
      };
    }
    function traverse(value, seen) {
      if (!isObject$3(value) || value["__v_skip"]) {
        return value;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, seen);
      } else if (isArray$2(value)) {
        for (let i2 = 0; i2 < value.length; i2++) {
          traverse(value[i2], seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, seen);
        });
      } else if (isPlainObject$2(value)) {
        for (const key in value) {
          traverse(value[key], seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      const internalInstance = currentRenderingInstance;
      if (internalInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i2 = 0; i2 < directives.length; i2++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
        if (dir) {
          if (isFunction$2(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i2 = 0; i2 < bindings.length; i2++) {
        const binding = bindings[i2];
        if (oldBindings) {
          binding.oldValue = oldBindings[i2].value;
        }
        let hook = binding.dir[name];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state2 = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state2.isMounted = true;
      });
      onBeforeUnmount(() => {
        state2.isUnmounting = true;
      });
      return state2;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    function getLeavingNodesForType(state2, vnode) {
      const { leavingVNodes } = state2;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state2, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state2, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$2(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks2 = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state2.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state2.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks2.delayedLeave) {
              hooks2.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state2.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state2, instance);
        }
      };
      return hooks2;
    }
    function setTransitionHooks(vnode, hooks2) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks2);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks2;
      }
    }
    function getTransitionRawChildren(children, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i2 = 0; i2 < children.length; i2++) {
        let child = children[i2];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i2 = 0; i2 < ret.length; i2++) {
          ret[i2].patchFlag = -2;
        }
      }
      return ret;
    }
    const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks2 = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          unsetCurrentInstance();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks2.unshift(wrappedHook);
        } else {
          hooks2.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (isArray$2(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i2 = 0, l = source.length; i2 < l; i2++) {
          ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i2 = 0; i2 < source; i2++) {
          ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
        }
      } else if (isObject$3(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i2) => renderItem(item, i2, void 0, cached && cached[i2])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i2 = 0, l = keys2.length; i2 < l; i2++) {
            const key = keys2[i2];
            ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function createSlots(slots, dynamicSlots) {
      for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
        const slot = dynamicSlots[i2];
        if (isArray$2(slot)) {
          for (let j = 0; j < slot.length; j++) {
            slots[slot[j].name] = slot[j].fn;
          }
        } else if (slot) {
          slots[slot.name] = slot.key ? (...args) => {
            const res = slot.fn(...args);
            if (res)
              res.key = slot.key;
            return res;
          } : slot.fn;
        }
      }
      return slots;
    }
    function renderSlot(slots, name, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name !== "default")
          props.name = name;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance = (i2) => {
      if (!i2)
        return null;
      if (isStatefulComponent(i2))
        return getExposeProxy(i2) || i2.proxy;
      return getPublicInstance(i2.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$2(/* @__PURE__ */ Object.create(null), {
        $: (i2) => i2,
        $el: (i2) => i2.vnode.el,
        $data: (i2) => i2.data,
        $props: (i2) => i2.props,
        $attrs: (i2) => i2.attrs,
        $slots: (i2) => i2.slots,
        $refs: (i2) => i2.refs,
        $parent: (i2) => getPublicInstance(i2.parent),
        $root: (i2) => getPublicInstance(i2.root),
        $emit: (i2) => i2.emit,
        $options: (i2) => resolveMergedOptions(i2),
        $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
        $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
        $watch: (i2) => instanceWatch.bind(i2)
      })
    );
    const hasSetupBinding = (state2, key) => state2 !== EMPTY_OBJ && !state2.__isScriptSetup && hasOwn(state2, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$2(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$2(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$3(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$2(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$2(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$2(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$3(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
              /* treat default function as factory */
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$2(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$2(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$3(raw)) {
        if (isArray$2(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$2(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject$3(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from2, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from2;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from2) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from2) {
      if (!from2) {
        return to2;
      }
      if (!to2) {
        return from2;
      }
      return function mergedDataFn() {
        return extend$2(
          isFunction$2(to2) ? to2.call(this, this) : to2,
          isFunction$2(from2) ? from2.call(this, this) : from2
        );
      };
    }
    function mergeInject(to2, from2) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
    }
    function normalizeInject(raw) {
      if (isArray$2(raw)) {
        const res = {};
        for (let i2 = 0; i2 < raw.length; i2++) {
          res[raw[i2]] = raw[i2];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from2) {
      return to2 ? [...new Set([].concat(to2, from2))] : from2;
    }
    function mergeObjectOptions(to2, from2) {
      return to2 ? extend$2(/* @__PURE__ */ Object.create(null), to2, from2) : from2;
    }
    function mergeEmitsOrPropsOptions(to2, from2) {
      if (to2) {
        if (isArray$2(to2) && isArray$2(from2)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from2])];
        }
        return extend$2(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from2 != null ? from2 : {})
        );
      } else {
        return from2;
      }
    }
    function mergeWatchOptions(to2, from2) {
      if (!to2)
        return from2;
      if (!from2)
        return to2;
      const merged = extend$2(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from2) {
        merged[key] = mergeAsArray(to2[key], from2[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$2(rootComponent)) {
          rootComponent = extend$2({}, rootComponent);
        }
        if (rootProps != null && !isObject$3(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$2(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$2(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name, component) {
            if (!component) {
              return context.components[name];
            }
            context.components[name] = component;
            return app;
          },
          directive(name, directive) {
            if (!directive) {
              return context.directives[name];
            }
            context.directives[name] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, isSVG) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, isSVG);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = null;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function hasInjectionContext() {
      return !!(currentInstance || currentRenderingInstance || currentApp);
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            let key = propsToUpdate[i2];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                  /* isAbsent */
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                  /* isAbsent */
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i2 = 0; i2 < needCastKeys.length; i2++) {
          const key = needCastKeys[i2];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              unsetCurrentInstance();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$2(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$3(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$2(raw)) {
        for (let i2 = 0; i2 < raw.length; i2++) {
          const normalizedKey = camelize(raw[i2]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$2({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$3(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$") {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$2(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$2(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$2(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children) => {
      const normalized = normalizeSlotValue(children);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          instance.slots = toRaw(children);
          def(children, "_", type);
        } else {
          normalizeObjectSlots(
            children,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children) {
          normalizeVNodeSlots(instance, children);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend$2(slots, children);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children.$stable;
          normalizeObjectSlots(children, slots);
        }
        deletionComparisonTarget = children;
      } else if (children) {
        normalizeVNodeSlots(instance, children);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$2(rawRef)) {
        rawRef.forEach(
          (r, i2) => setRef(
            r,
            oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i2] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$2(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$2(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$2(existing) && remove(existing, refValue);
              } else {
                if (!isArray$2(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, isSVG);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, isSVG) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          isSVG,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        isSVG = isSVG || n2.type === "svg";
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { type, props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          isSVG,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            isSVG && type !== "foreignObject",
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                isSVG,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
            hostSetScopeId(el, slotScopeIds[i2]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        const areChildrenSVG = isSVG && n2.type !== "foreignObject";
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            areChildrenSVG,
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              isSVG
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, isSVG);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
                const key = propsToUpdate[i2];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    isSVG,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            isSVG
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
        for (let i2 = 0; i2 < newChildren.length; i2++) {
          const oldVNode = oldChildren[i2];
          const newVNode = newChildren[i2];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  isSVG,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                isSVG,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            n2.children,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              isSVG,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
          return;
        }
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          isSVG,
          optimized
        );
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                isSVG
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              isSVG
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => effect2.run();
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs();
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i2;
        for (i2 = 0; i2 < commonLength; i2++) {
          const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          patch(
            c1[i2],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
        let i2 = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[i2];
          const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i2++;
        }
        while (i2 <= e1 && i2 <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i2 > e1) {
          if (i2 <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i2 <= e2) {
              patch(
                null,
                c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              i2++;
            }
          }
        } else if (i2 > e2) {
          while (i2 <= e1) {
            unmount(c1[i2], parentComponent, parentSuspense, true);
            i2++;
          }
        } else {
          const s1 = i2;
          const s2 = i2;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i2 = s2; i2 <= e2; i2++) {
            const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i2);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i2 = 0; i2 < toBePatched; i2++)
            newIndexToOldIndexMap[i2] = 0;
          for (i2 = s1; i2 <= e1; i2++) {
            const prevChild = c1[i2];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i2 = toBePatched - 1; i2 >= 0; i2--) {
            const nextIndex = s2 + i2;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i2] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i2 = 0; i2 < children.length; i2++) {
            move(children[i2], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i2 = start2; i2 < children.length; i2++) {
          unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      const render = (vnode, container, isSVG) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(container._vnode || null, vnode, container, null, null, null, isSVG);
        }
        flushPreFlushCbs();
        flushPostFlushCbs();
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$2(ch1) && isArray$2(ch2)) {
        for (let i2 = 0; i2 < ch1.length; i2++) {
          const c1 = ch1[i2];
          let c2 = ch2[i2];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i2, j, u, v, c;
      const len2 = arr.length;
      for (i2 = 0; i2 < len2; i2++) {
        const arrI = arr[i2];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i2] = j;
            result.push(i2);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i2] = result[u - 1];
            }
            result[u] = i2;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    const isTeleport = (type) => type.__isTeleport;
    const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
    const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
    const resolveTarget = (props, select) => {
      const targetSelector = props && props.to;
      if (isString$2(targetSelector)) {
        if (!select) {
          return null;
        } else {
          const target = select(targetSelector);
          return target;
        }
      } else {
        return targetSelector;
      }
    };
    const TeleportImpl = {
      name: "Teleport",
      __isTeleport: true,
      process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
        const {
          mc: mountChildren,
          pc: patchChildren,
          pbc: patchBlockChildren,
          o: { insert, querySelector, createText, createComment }
        } = internals;
        const disabled = isTeleportDisabled(n2.props);
        let { shapeFlag, children, dynamicChildren } = n2;
        if (n1 == null) {
          const placeholder = n2.el = createText("");
          const mainAnchor = n2.anchor = createText("");
          insert(placeholder, container, anchor);
          insert(mainAnchor, container, anchor);
          const target = n2.target = resolveTarget(n2.props, querySelector);
          const targetAnchor = n2.targetAnchor = createText("");
          if (target) {
            insert(targetAnchor, target);
            isSVG = isSVG || isTargetSVG(target);
          }
          const mount = (container2, anchor2) => {
            if (shapeFlag & 16) {
              mountChildren(
                children,
                container2,
                anchor2,
                parentComponent,
                parentSuspense,
                isSVG,
                slotScopeIds,
                optimized
              );
            }
          };
          if (disabled) {
            mount(container, mainAnchor);
          } else if (target) {
            mount(target, targetAnchor);
          }
        } else {
          n2.el = n1.el;
          const mainAnchor = n2.anchor = n1.anchor;
          const target = n2.target = n1.target;
          const targetAnchor = n2.targetAnchor = n1.targetAnchor;
          const wasDisabled = isTeleportDisabled(n1.props);
          const currentContainer = wasDisabled ? container : target;
          const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
          isSVG = isSVG || isTargetSVG(target);
          if (dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              currentContainer,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds
            );
            traverseStaticChildren(n1, n2, true);
          } else if (!optimized) {
            patchChildren(
              n1,
              n2,
              currentContainer,
              currentAnchor,
              parentComponent,
              parentSuspense,
              isSVG,
              slotScopeIds,
              false
            );
          }
          if (disabled) {
            if (!wasDisabled) {
              moveTeleport(
                n2,
                container,
                mainAnchor,
                internals,
                1
              );
            } else {
              if (n2.props && n1.props && n2.props.to !== n1.props.to) {
                n2.props.to = n1.props.to;
              }
            }
          } else {
            if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
              const nextTarget = n2.target = resolveTarget(
                n2.props,
                querySelector
              );
              if (nextTarget) {
                moveTeleport(
                  n2,
                  nextTarget,
                  null,
                  internals,
                  0
                );
              }
            } else if (wasDisabled) {
              moveTeleport(
                n2,
                target,
                targetAnchor,
                internals,
                1
              );
            }
          }
        }
        updateCssVars(n2);
      },
      remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
        const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
        if (target) {
          hostRemove(targetAnchor);
        }
        doRemove && hostRemove(anchor);
        if (shapeFlag & 16) {
          const shouldRemove = doRemove || !isTeleportDisabled(props);
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            unmount(
              child,
              parentComponent,
              parentSuspense,
              shouldRemove,
              !!child.dynamicChildren
            );
          }
        }
      },
      move: moveTeleport,
      hydrate: hydrateTeleport
    };
    function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
      if (moveType === 0) {
        insert(vnode.targetAnchor, container, parentAnchor);
      }
      const { el, anchor, shapeFlag, children, props } = vnode;
      const isReorder = moveType === 2;
      if (isReorder) {
        insert(el, container, parentAnchor);
      }
      if (!isReorder || isTeleportDisabled(props)) {
        if (shapeFlag & 16) {
          for (let i2 = 0; i2 < children.length; i2++) {
            move(
              children[i2],
              container,
              parentAnchor,
              2
            );
          }
        }
      }
      if (isReorder) {
        insert(anchor, container, parentAnchor);
      }
    }
    function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
      o: { nextSibling, parentNode, querySelector }
    }, hydrateChildren) {
      const target = vnode.target = resolveTarget(
        vnode.props,
        querySelector
      );
      if (target) {
        const targetNode = target._lpa || target.firstChild;
        if (vnode.shapeFlag & 16) {
          if (isTeleportDisabled(vnode.props)) {
            vnode.anchor = hydrateChildren(
              nextSibling(node),
              vnode,
              parentNode(node),
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
            vnode.targetAnchor = targetNode;
          } else {
            vnode.anchor = nextSibling(node);
            let targetAnchor = targetNode;
            while (targetAnchor) {
              targetAnchor = nextSibling(targetAnchor);
              if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
                vnode.targetAnchor = targetAnchor;
                target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
                break;
              }
            }
            hydrateChildren(
              targetNode,
              vnode,
              target,
              parentComponent,
              parentSuspense,
              slotScopeIds,
              optimized
            );
          }
        }
        updateCssVars(vnode);
      }
      return vnode.anchor && nextSibling(vnode.anchor);
    }
    const Teleport = TeleportImpl;
    function updateCssVars(vnode) {
      const ctx = vnode.ctx;
      if (ctx && ctx.ut) {
        let node = vnode.children[0].el;
        while (node && node !== vnode.targetAnchor) {
          if (node.nodeType === 1)
            node.setAttribute("data-v-owner", ctx.uid);
          node = node.nextSibling;
        }
        ctx.ut();
      }
    }
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
          /* isBlock */
        )
      );
    }
    function createBlock(type, props, children, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children,
          patchFlag,
          dynamicProps,
          true
          /* isBlock: prevent a block from tracking itself */
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children) {
        vnode.shapeFlag |= isString$2(children) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children) {
          normalizeChildren(cloned, children);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$3(style)) {
          if (isProxy(style) && !isArray$2(style)) {
            style = extend$2({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$3(type) ? 4 : isFunction$2(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$2({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$2(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children == null) {
        children = null;
      } else if (isArray$2(children)) {
        type = 16;
      } else if (typeof children === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children._;
          if (!slotFlag && !(InternalObjectKey in children)) {
            children._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children._ = 1;
            } else {
              children._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$2(children)) {
        children = { default: children, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children = String(children);
        if (shapeFlag & 64) {
          type = 16;
          children = [createTextVNode(children)];
        } else {
          type = 8;
        }
      }
      vnode.children = children;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i2 = 0; i2 < args.length; i2++) {
        const toMerge = args[i2];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let globalCurrentInstanceSetters;
    let settersKey = "__VUE_INSTANCE_SETTERS__";
    {
      if (!(globalCurrentInstanceSetters = getGlobalThis()[settersKey])) {
        globalCurrentInstanceSetters = getGlobalThis()[settersKey] = [];
      }
      globalCurrentInstanceSetters.push((i2) => currentInstance = i2);
      internalSetCurrentInstance = (instance) => {
        if (globalCurrentInstanceSetters.length > 1) {
          globalCurrentInstanceSetters.forEach((s) => s(instance));
        } else {
          globalCurrentInstanceSetters[0](instance);
        }
      };
    }
    const setCurrentInstance = (instance) => {
      internalSetCurrentInstance(instance);
      instance.scope.on();
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isInSSRComponentSetup = isSSR;
      const { props, children } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isInSSRComponentSetup = false;
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [instance.props, setupContext]
        );
        resetTracking();
        unsetCurrentInstance();
        if (isPromise$1(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$2(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$3(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$2(
              extend$2(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          unsetCurrentInstance();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    function getComponentName(Component, includeInferred = true) {
      return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function isClassComponent(value) {
      return isFunction$2(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$3(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children)) {
          children = [children];
        }
        return createVNode(type, propsOrChildren, children);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    const version = "3.3.10";
    const svgNS = "http://www.w3.org/2000/svg";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, isSVG, is, props) => {
        const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector) => doc.querySelector(selector),
      setScopeId(el, id) {
        el.setAttribute(id, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, isSVG, start2, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
          while (true) {
            parent.insertBefore(start2.cloneNode(true), anchor);
            if (start2 === end2 || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
          const template = templateContainer.content;
          if (isSVG) {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = /* @__PURE__ */ extend$2(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$2(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name = "v",
        type,
        duration,
        enterFromClass = `${name}-enter-from`,
        enterActiveClass = `${name}-enter-active`,
        enterToClass = `${name}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name}-leave-from`,
        leaveActiveClass = `${name}-leave-active`,
        leaveToClass = `${name}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$2(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$3(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i2) => toMs(d) + toMs(delays[i2])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue)
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOldKey] : "none";
    }
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$2(next);
      if (next && !isCssString) {
        if (prev && !isString$2(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          setStyle(style, key, next[key]);
        }
      } else {
        const currentDisplay = style.display;
        if (isCssString) {
          if (prev !== next) {
            style.cssText = next;
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
        if (vShowOldKey in el) {
          style.display = currentDisplay;
        }
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name, val) {
      if (isArray$2(val)) {
        val.forEach((v) => setStyle(style, name, v));
      } else {
        if (val == null)
          val = "";
        if (name.startsWith("--")) {
          style.setProperty(name, val);
        } else {
          const prefixed = autoPrefix(style, name);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name = camelize(rawName);
      if (name !== "filter" && name in style) {
        return prefixCache[rawName] = name;
      }
      name = capitalize(name);
      for (let i2 = 0; i2 < prefixes.length; i2++) {
        const prefixed = prefixes[i2] + name;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name) {
      let options;
      if (optionsModifierRE.test(name)) {
        options = {};
        let m;
        while (m = name.match(optionsModifierRE)) {
          name = name.slice(0, name.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$2(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$2(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        return !(tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE");
      }
      if (isNativeOn(key) && isString$2(value)) {
        return false;
      }
      return key in el;
    }
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      const setVars = () => {
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
      };
      watchPostEffect(setVars);
      onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor)
            break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        for (const key in vars) {
          style.setProperty(`--${key}`, vars[key]);
        }
      }
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$2({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state2 = useTransitionState();
        let prevChildren;
        let children;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children;
          children = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i2 = 0; i2 < children.length; i2++) {
            const child = children[i2];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state2, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i2 = 0; i2 < prevChildren.length; i2++) {
              const child = prevChildren[i2];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state2, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root.nodeType === 1 ? root : root.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    function getValue(el) {
      return "_value" in el ? el._value : el.value;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      return fn._withMods || (fn._withMods = (event, ...args) => {
        for (let i2 = 0; i2 < modifiers.length; i2++) {
          const guard = modifierGuards[modifiers[i2]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      return fn._withKeys || (fn._withKeys = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$2({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$2(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, container instanceof SVGElement);
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    var isVue2 = false;
    function getDevtoolsGlobalHook() {
      return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
    }
    function getTarget() {
      return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
    }
    const isProxyAvailable = typeof Proxy === "function";
    const HOOK_SETUP = "devtools-plugin:setup";
    const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
    let supported;
    let perf;
    function isPerformanceSupported() {
      var _a;
      if (supported !== void 0) {
        return supported;
      }
      if (typeof window !== "undefined" && window.performance) {
        supported = true;
        perf = window.performance;
      } else if (typeof globalThis !== "undefined" && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = globalThis.perf_hooks.performance;
      } else {
        supported = false;
      }
      return supported;
    }
    function now$1() {
      return isPerformanceSupported() ? perf.now() : Date.now();
    }
    class ApiProxy {
      constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
          for (const id in plugin.settings) {
            const item = plugin.settings[id];
            defaultSettings[id] = item.defaultValue;
          }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
          const raw = localStorage.getItem(localSettingsSaveId);
          const data = JSON.parse(raw);
          Object.assign(currentSettings, data);
        } catch (e) {
        }
        this.fallbacks = {
          getSettings() {
            return currentSettings;
          },
          setSettings(value) {
            try {
              localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
            } catch (e) {
            }
            currentSettings = value;
          },
          now() {
            return now$1();
          }
        };
        if (hook) {
          hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
            if (pluginId === this.plugin.id) {
              this.fallbacks.setSettings(value);
            }
          });
        }
        this.proxiedOn = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target.on[prop];
            } else {
              return (...args) => {
                this.onQueue.push({
                  method: prop,
                  args
                });
              };
            }
          }
        });
        this.proxiedTarget = new Proxy({}, {
          get: (_target, prop) => {
            if (this.target) {
              return this.target[prop];
            } else if (prop === "on") {
              return this.proxiedOn;
            } else if (Object.keys(this.fallbacks).includes(prop)) {
              return (...args) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve: () => {
                  }
                });
                return this.fallbacks[prop](...args);
              };
            } else {
              return (...args) => {
                return new Promise((resolve2) => {
                  this.targetQueue.push({
                    method: prop,
                    args,
                    resolve: resolve2
                  });
                });
              };
            }
          }
        });
      }
      async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
          this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
          item.resolve(await this.target[item.method](...item.args));
        }
      }
    }
    function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
      const descriptor = pluginDescriptor;
      const target = getTarget();
      const hook = getDevtoolsGlobalHook();
      const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
      if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
      } else {
        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
          pluginDescriptor: descriptor,
          setupFn,
          proxy
        });
        if (proxy) {
          setupFn(proxy.proxiedTarget);
        }
      }
    }
    /*!
     * pinia v2.1.7
     * (c) 2023 Eduardo San Martin Morote
     * @license MIT
     */
    let activePinia;
    const setActivePinia = (pinia2) => activePinia = pinia2;
    const piniaSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function isPlainObject$1(o) {
      return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
    }
    var MutationType;
    (function(MutationType2) {
      MutationType2["direct"] = "direct";
      MutationType2["patchObject"] = "patch object";
      MutationType2["patchFunction"] = "patch function";
    })(MutationType || (MutationType = {}));
    function createPinia() {
      const scope = effectScope(true);
      const state2 = scope.run(() => ref({}));
      let _p = [];
      let toBeInstalled = [];
      const pinia2 = markRaw({
        install(app) {
          setActivePinia(pinia2);
          {
            pinia2._a = app;
            app.provide(piniaSymbol, pinia2);
            app.config.globalProperties.$pinia = pinia2;
            toBeInstalled.forEach((plugin) => _p.push(plugin));
            toBeInstalled = [];
          }
        },
        use(plugin) {
          if (!this._a && !isVue2) {
            toBeInstalled.push(plugin);
          } else {
            _p.push(plugin);
          }
          return this;
        },
        _p,
        // it's actually undefined here
        // @ts-expect-error
        _a: null,
        _e: scope,
        _s: /* @__PURE__ */ new Map(),
        state: state2
      });
      return pinia2;
    }
    const noop$1 = () => {
    };
    function addSubscription(subscriptions, callback, detached, onCleanup = noop$1) {
      subscriptions.push(callback);
      const removeSubscription = () => {
        const idx = subscriptions.indexOf(callback);
        if (idx > -1) {
          subscriptions.splice(idx, 1);
          onCleanup();
        }
      };
      if (!detached && getCurrentScope()) {
        onScopeDispose(removeSubscription);
      }
      return removeSubscription;
    }
    function triggerSubscriptions(subscriptions, ...args) {
      subscriptions.slice().forEach((callback) => {
        callback(...args);
      });
    }
    const fallbackRunWithContext = (fn) => fn();
    function mergeReactiveObjects(target, patchToApply) {
      if (target instanceof Map && patchToApply instanceof Map) {
        patchToApply.forEach((value, key) => target.set(key, value));
      }
      if (target instanceof Set && patchToApply instanceof Set) {
        patchToApply.forEach(target.add, target);
      }
      for (const key in patchToApply) {
        if (!patchToApply.hasOwnProperty(key))
          continue;
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !isRef(subPatch) && !isReactive(subPatch)) {
          target[key] = mergeReactiveObjects(targetValue, subPatch);
        } else {
          target[key] = subPatch;
        }
      }
      return target;
    }
    const skipHydrateSymbol = (
      /* istanbul ignore next */
      Symbol()
    );
    function shouldHydrate(obj) {
      return !isPlainObject$1(obj) || !obj.hasOwnProperty(skipHydrateSymbol);
    }
    const { assign } = Object;
    function isComputed(o) {
      return !!(isRef(o) && o.effect);
    }
    function createOptionsStore(id, options, pinia2, hot) {
      const { state: state2, actions: actions2, getters: getters2 } = options;
      const initialState = pinia2.state.value[id];
      let store2;
      function setup() {
        if (!initialState && true) {
          {
            pinia2.state.value[id] = state2 ? state2() : {};
          }
        }
        const localState = toRefs(pinia2.state.value[id]);
        return assign(localState, actions2, Object.keys(getters2 || {}).reduce((computedGetters, name) => {
          computedGetters[name] = markRaw(computed(() => {
            setActivePinia(pinia2);
            const store22 = pinia2._s.get(id);
            return getters2[name].call(store22, store22);
          }));
          return computedGetters;
        }, {}));
      }
      store2 = createSetupStore(id, setup, options, pinia2, hot, true);
      return store2;
    }
    function createSetupStore($id, setup, options = {}, pinia2, hot, isOptionsStore) {
      let scope;
      const optionsForPlugin = assign({ actions: {} }, options);
      const $subscribeOptions = {
        deep: true
        // flush: 'post',
      };
      let isListening;
      let isSyncListening;
      let subscriptions = [];
      let actionSubscriptions = [];
      let debuggerEvents;
      const initialState = pinia2.state.value[$id];
      if (!isOptionsStore && !initialState && true) {
        {
          pinia2.state.value[$id] = {};
        }
      }
      ref({});
      let activeListener;
      function $patch(partialStateOrMutator) {
        let subscriptionMutation;
        isListening = isSyncListening = false;
        if (typeof partialStateOrMutator === "function") {
          partialStateOrMutator(pinia2.state.value[$id]);
          subscriptionMutation = {
            type: MutationType.patchFunction,
            storeId: $id,
            events: debuggerEvents
          };
        } else {
          mergeReactiveObjects(pinia2.state.value[$id], partialStateOrMutator);
          subscriptionMutation = {
            type: MutationType.patchObject,
            payload: partialStateOrMutator,
            storeId: $id,
            events: debuggerEvents
          };
        }
        const myListenerId = activeListener = Symbol();
        nextTick().then(() => {
          if (activeListener === myListenerId) {
            isListening = true;
          }
        });
        isSyncListening = true;
        triggerSubscriptions(subscriptions, subscriptionMutation, pinia2.state.value[$id]);
      }
      const $reset = isOptionsStore ? function $reset2() {
        const { state: state2 } = options;
        const newState = state2 ? state2() : {};
        this.$patch(($state) => {
          assign($state, newState);
        });
      } : (
        /* istanbul ignore next */
        noop$1
      );
      function $dispose() {
        scope.stop();
        subscriptions = [];
        actionSubscriptions = [];
        pinia2._s.delete($id);
      }
      function wrapAction(name, action) {
        return function() {
          setActivePinia(pinia2);
          const args = Array.from(arguments);
          const afterCallbackList = [];
          const onErrorCallbackList = [];
          function after(callback) {
            afterCallbackList.push(callback);
          }
          function onError(callback) {
            onErrorCallbackList.push(callback);
          }
          triggerSubscriptions(actionSubscriptions, {
            args,
            name,
            store: store2,
            after,
            onError
          });
          let ret;
          try {
            ret = action.apply(this && this.$id === $id ? this : store2, args);
          } catch (error) {
            triggerSubscriptions(onErrorCallbackList, error);
            throw error;
          }
          if (ret instanceof Promise) {
            return ret.then((value) => {
              triggerSubscriptions(afterCallbackList, value);
              return value;
            }).catch((error) => {
              triggerSubscriptions(onErrorCallbackList, error);
              return Promise.reject(error);
            });
          }
          triggerSubscriptions(afterCallbackList, ret);
          return ret;
        };
      }
      const partialStore = {
        _p: pinia2,
        // _s: scope,
        $id,
        $onAction: addSubscription.bind(null, actionSubscriptions),
        $patch,
        $reset,
        $subscribe(callback, options2 = {}) {
          const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
          const stopWatcher = scope.run(() => watch(() => pinia2.state.value[$id], (state2) => {
            if (options2.flush === "sync" ? isSyncListening : isListening) {
              callback({
                storeId: $id,
                type: MutationType.direct,
                events: debuggerEvents
              }, state2);
            }
          }, assign({}, $subscribeOptions, options2)));
          return removeSubscription;
        },
        $dispose
      };
      const store2 = reactive(partialStore);
      pinia2._s.set($id, store2);
      const runWithContext = pinia2._a && pinia2._a.runWithContext || fallbackRunWithContext;
      const setupStore = runWithContext(() => pinia2._e.run(() => (scope = effectScope()).run(setup)));
      for (const key in setupStore) {
        const prop = setupStore[key];
        if (isRef(prop) && !isComputed(prop) || isReactive(prop)) {
          if (!isOptionsStore) {
            if (initialState && shouldHydrate(prop)) {
              if (isRef(prop)) {
                prop.value = initialState[key];
              } else {
                mergeReactiveObjects(prop, initialState[key]);
              }
            }
            {
              pinia2.state.value[$id][key] = prop;
            }
          }
        } else if (typeof prop === "function") {
          const actionValue = wrapAction(key, prop);
          {
            setupStore[key] = actionValue;
          }
          optionsForPlugin.actions[key] = prop;
        } else
          ;
      }
      {
        assign(store2, setupStore);
        assign(toRaw(store2), setupStore);
      }
      Object.defineProperty(store2, "$state", {
        get: () => pinia2.state.value[$id],
        set: (state2) => {
          $patch(($state) => {
            assign($state, state2);
          });
        }
      });
      pinia2._p.forEach((extender) => {
        {
          assign(store2, scope.run(() => extender({
            store: store2,
            app: pinia2._a,
            pinia: pinia2,
            options: optionsForPlugin
          })));
        }
      });
      if (initialState && isOptionsStore && options.hydrate) {
        options.hydrate(store2.$state, initialState);
      }
      isListening = true;
      isSyncListening = true;
      return store2;
    }
    function defineStore(idOrOptions, setup, setupOptions) {
      let id;
      let options;
      const isSetupStore = typeof setup === "function";
      if (typeof idOrOptions === "string") {
        id = idOrOptions;
        options = isSetupStore ? setupOptions : setup;
      } else {
        options = idOrOptions;
        id = idOrOptions.id;
      }
      function useStore2(pinia2, hot) {
        const hasContext = hasInjectionContext();
        pinia2 = // in test mode, ignore the argument provided as we can always retrieve a
        // pinia instance with getActivePinia()
        pinia2 || (hasContext ? inject(piniaSymbol, null) : null);
        if (pinia2)
          setActivePinia(pinia2);
        pinia2 = activePinia;
        if (!pinia2._s.has(id)) {
          if (isSetupStore) {
            createSetupStore(id, setup, options, pinia2);
          } else {
            createOptionsStore(id, options, pinia2);
          }
        }
        const store2 = pinia2._s.get(id);
        return store2;
      }
      useStore2.$id = id;
      return useStore2;
    }
    function mitt(n) {
      return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
        var i2 = n.get(t);
        i2 ? i2.push(e) : n.set(t, [e]);
      }, off: function(t, e) {
        var i2 = n.get(t);
        i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
      }, emit: function(t, e) {
        var i2 = n.get(t);
        i2 && i2.slice().map(function(n2) {
          n2(e);
        }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
          n2(t, e);
        });
      } };
    }
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var buffer = {};
    var base64Js = {};
    base64Js.byteLength = byteLength;
    base64Js.toByteArray = toByteArray;
    base64Js.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start2, end2) {
      var tmp;
      var output = [];
      for (var i2 = start2; i2 < end2; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee754 = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset2 + i2];
      i2 += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset2 + i2], i2 += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset2 + i2], i2 += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset2 + i2] = m & 255, i2 += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset2 + i2] = e & 255, i2 += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset2 + i2 - d] |= s * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(exports2) {
      const base64 = base64Js;
      const ieee754$1 = ieee754;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer2;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto2 = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto2, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto2);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from2(arg, encodingOrOffset, length);
      }
      Buffer2.poolSize = 8192;
      function from2(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf2 = value.valueOf && value.valueOf();
        if (valueOf2 != null && valueOf2 !== value) {
          return Buffer2.from(valueOf2, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer2.from = function(value, encodingOrOffset, length) {
        return from2(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size2) {
        if (typeof size2 !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size2 < 0) {
          throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
        }
      }
      function alloc(size2, fill, encoding) {
        assertSize(size2);
        if (size2 <= 0) {
          return createBuffer(size2);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
        }
        return createBuffer(size2);
      }
      Buffer2.alloc = function(size2, fill, encoding) {
        return alloc(size2, fill, encoding);
      };
      function allocUnsafe(size2) {
        assertSize(size2);
        return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
      }
      Buffer2.allocUnsafe = function(size2) {
        return allocUnsafe(size2);
      };
      Buffer2.allocUnsafeSlow = function(size2) {
        return allocUnsafe(size2);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength2(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array);
        } else if (length === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer2.alloc(+length);
      }
      Buffer2.isBuffer = function isBuffer2(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i2 = 0, len2 = Math.min(x, y); i2 < len2; ++i2) {
          if (a[i2] !== b[i2]) {
            x = a[i2];
            y = b[i2];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        const buffer2 = Buffer2.allocUnsafe(length);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer2.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer2, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer2,
                buf,
                pos
              );
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer2, pos);
          }
          pos += buf.length;
        }
        return buffer2;
      };
      function byteLength2(string, encoding) {
        if (Buffer2.isBuffer(string)) {
          return string.length;
        }
        if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len2 = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength2;
      function slowToString(encoding, start2, end2) {
        let loweredCase = false;
        if (start2 === void 0 || start2 < 0) {
          start2 = 0;
        }
        if (start2 > this.length) {
          return "";
        }
        if (end2 === void 0 || end2 > this.length) {
          end2 = this.length;
        }
        if (end2 <= 0) {
          return "";
        }
        end2 >>>= 0;
        start2 >>>= 0;
        if (end2 <= start2) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start2, end2);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start2, end2);
            case "ascii":
              return asciiSlice(this, start2, end2);
            case "latin1":
            case "binary":
              return latin1Slice(this, start2, end2);
            case "base64":
              return base64Slice(this, start2, end2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start2, end2);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i2 = b[n];
        b[n] = b[m];
        b[m] = i2;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString2() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect2() {
        let str = "";
        const max2 = exports2.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start2, end2, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start2 === void 0) {
          start2 = 0;
        }
        if (end2 === void 0) {
          end2 = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start2 >= end2) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start2 >= end2) {
          return 1;
        }
        start2 >>>= 0;
        end2 >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end2 - start2;
        const len2 = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start2, end2);
        for (let i2 = 0; i2 < len2; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x = thisCopy[i2];
            y = targetCopy[i2];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
        if (buffer2.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer2.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer2.length + byteOffset;
        if (byteOffset >= buffer2.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer2.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read2(arr, i2 + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i2;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf2(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset2, length) {
        offset2 = Number(offset2) || 0;
        const remaining = buf.length - offset2;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          const parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i2;
          buf[offset2 + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset2, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length);
      }
      function asciiWrite(buf, string, offset2, length) {
        return blitBuffer(asciiToBytes(string), buf, offset2, length);
      }
      function base64Write(buf, string, offset2, length) {
        return blitBuffer(base64ToBytes(string), buf, offset2, length);
      }
      function ucs2Write(buf, string, offset2, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length);
      }
      Buffer2.prototype.write = function write2(string, offset2, length, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length = this.length;
          offset2 = 0;
        } else if (length === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset2;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset2, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset2, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset2, length);
            case "base64":
              return base64Write(this, string, offset2, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset2, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON2() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start2, end2) {
        if (start2 === 0 && end2 === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start2, end2));
        }
      }
      function utf8Slice(buf, start2, end2) {
        end2 = Math.min(buf.length, end2);
        const res = [];
        let i2 = start2;
        while (i2 < end2) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end2) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start2, end2) {
        let ret = "";
        end2 = Math.min(buf.length, end2);
        for (let i2 = start2; i2 < end2; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start2, end2) {
        let ret = "";
        end2 = Math.min(buf.length, end2);
        for (let i2 = start2; i2 < end2; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start2, end2) {
        const len2 = buf.length;
        if (!start2 || start2 < 0)
          start2 = 0;
        if (!end2 || end2 < 0 || end2 > len2)
          end2 = len2;
        let out = "";
        for (let i2 = start2; i2 < end2; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start2, end2) {
        const bytes = buf.slice(start2, end2);
        let res = "";
        for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start2, end2) {
        const len2 = this.length;
        start2 = ~~start2;
        end2 = end2 === void 0 ? len2 : ~~end2;
        if (start2 < 0) {
          start2 += len2;
          if (start2 < 0)
            start2 = 0;
        } else if (start2 > len2) {
          start2 = len2;
        }
        if (end2 < 0) {
          end2 += len2;
          if (end2 < 0)
            end2 = 0;
        } else if (end2 > len2) {
          end2 = len2;
        }
        if (end2 < start2)
          end2 = start2;
        const newBuf = this.subarray(start2, end2);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset2, ext, length) {
        if (offset2 % 1 !== 0 || offset2 < 0)
          throw new RangeError("offset is not uint");
        if (offset2 + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset2, byteLength3, this.length);
        let val = this[offset2];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset2 + i2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength3, this.length);
        }
        let val = this[offset2 + --byteLength3];
        let mul = 1;
        while (byteLength3 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength3] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
        const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset2, byteLength3, this.length);
        let val = this[offset2];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength3 && (mul *= 256)) {
          val += this[offset2 + i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert)
          checkOffset(offset2, byteLength3, this.length);
        let i2 = byteLength3;
        let mul = 1;
        let val = this[offset2 + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset2 + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength3);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128))
          return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 2, this.length);
        const val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 2, this.length);
        const val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first = this[offset2];
        const last = this[offset2 + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return ieee754$1.read(this, offset2, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 4, this.length);
        return ieee754$1.read(this, offset2, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 8, this.length);
        return ieee754$1.read(this, offset2, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkOffset(offset2, 8, this.length);
        return ieee754$1.read(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value, offset2, ext, max2, min2) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2)
          throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset2, byteLength3, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset2] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          this[offset2 + i2] = value / mul & 255;
        }
        return offset2 + byteLength3;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength3 = byteLength3 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
          checkInt(this, value, offset2, byteLength3, maxBytes, 0);
        }
        let i2 = byteLength3 - 1;
        let mul = 1;
        this[offset2 + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset2 + i2] = value / mul & 255;
        }
        return offset2 + byteLength3;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 1, 255, 0);
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2 + 3] = value >>> 24;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 1] = value >>> 8;
        this[offset2] = value & 255;
        return offset2 + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        return offset2;
      }
      function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2 + 7] = lo;
        lo = lo >> 8;
        buf[offset2 + 6] = lo;
        lo = lo >> 8;
        buf[offset2 + 5] = lo;
        lo = lo >> 8;
        buf[offset2 + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2 + 3] = hi;
        hi = hi >> 8;
        buf[offset2 + 2] = hi;
        hi = hi >> 8;
        buf[offset2 + 1] = hi;
        hi = hi >> 8;
        buf[offset2] = hi;
        return offset2 + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset2] = value & 255;
        while (++i2 < byteLength3 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength3;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength3 - 1);
          checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
        }
        let i2 = byteLength3 - 1;
        let mul = 1;
        let sub = 0;
        this[offset2 + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength3;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 3] = value >>> 24;
        return offset2 + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert)
          checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset2, ext, max2, min2) {
        if (offset2 + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset2 < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 4);
        }
        ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, false, noAssert);
      };
      function writeDouble(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 8);
        }
        ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start2, end2) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start2)
          start2 = 0;
        if (!end2 && end2 !== 0)
          end2 = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end2 > 0 && end2 < start2)
          end2 = start2;
        if (end2 === start2)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start2 < 0 || start2 >= this.length)
          throw new RangeError("Index out of range");
        if (end2 < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end2 > this.length)
          end2 = this.length;
        if (target.length - targetStart < end2 - start2) {
          end2 = target.length - targetStart + start2;
        }
        const len2 = end2 - start2;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start2, end2);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start2, end2),
            targetStart
          );
        }
        return len2;
      };
      Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
        if (typeof val === "string") {
          if (typeof start2 === "string") {
            encoding = start2;
            start2 = 0;
            end2 = this.length;
          } else if (typeof end2 === "string") {
            encoding = end2;
            end2 = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code2 = val.charCodeAt(0);
            if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
              val = code2;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start2 < 0 || this.length < start2 || this.length < end2) {
          throw new RangeError("Out of range index");
        }
        if (end2 <= start2) {
          return this;
        }
        start2 = start2 >>> 0;
        end2 = end2 === void 0 ? this.length : end2 >>> 0;
        if (!val)
          val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start2; i2 < end2; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end2 - start2; ++i2) {
            this[i2 + start2] = bytes[i2 % len2];
          }
        }
        return this;
      };
      const errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start2 = val[0] === "-" ? 1 : 0;
        for (; i2 >= start2 + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset2, byteLength3) {
        validateNumber(offset2, "offset");
        if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
          boundsError(offset2, buf.length - (byteLength3 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
        if (value > max2 || value < min2) {
          const n = typeof min2 === "bigint" ? "n" : "";
          let range;
          if (byteLength3 > 3) {
            if (min2 === 0 || min2 === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min2}${n} and <= ${max2}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset2, byteLength3);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i2);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset2, length) {
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          if (i2 + offset2 >= dst.length || i2 >= src.length)
            break;
          dst[i2 + offset2] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i2] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer);
    const IconSettings = {
      name: "IconSettings",
      render() {
        const _default = this.$slots.default ? this.$slots.default()[0] : null;
        return _default;
      },
      props: {
        iconPath: String,
        actionSpritePath: String,
        customSpritePath: String,
        doctypeSpritePath: String,
        standardSpritePath: String,
        utilitySpritePath: String
      },
      provide() {
        return {
          $__getIconSettings: () => this.$props
        };
      }
    };
    const getGUID = () => {
      function s4() {
        return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
      }
      return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
    };
    const hasOwnProperty$1 = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    const getMissingProps = (object, props) => {
      const missing = [];
      props.forEach((prop) => {
        if (!hasOwnProperty$1(object, prop)) {
          missing.push(prop);
        }
      });
      return missing;
    };
    var papaparse_min = { exports: {} };
    /* @license
    Papa Parse
    v5.4.1
    https://github.com/mholt/PapaParse
    License: MIT
    */
    (function(module2, exports2) {
      !function(e, t) {
        module2.exports = t();
      }(commonjsGlobal, function s() {
        var f = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f ? f : {};
        var n = !f.document && !!f.postMessage, o = f.IS_PAPA_WORKER || false, a = {}, u = 0, b = { parse: function(e, t) {
          var r2 = (t = t || {}).dynamicTyping || false;
          J(r2) && (t.dynamicTypingFunction = r2, r2 = {});
          if (t.dynamicTyping = r2, t.transform = !!J(t.transform) && t.transform, t.worker && b.WORKERS_SUPPORTED) {
            var i2 = function() {
              if (!b.WORKERS_SUPPORTED)
                return false;
              var e2 = (r3 = f.URL || f.webkitURL || null, i3 = s.toString(), b.BLOB_URL || (b.BLOB_URL = r3.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i3, ")();"], { type: "text/javascript" })))), t2 = new f.Worker(e2);
              var r3, i3;
              return t2.onmessage = _, t2.id = u++, a[t2.id] = t2;
            }();
            return i2.userStep = t.step, i2.userChunk = t.chunk, i2.userComplete = t.complete, i2.userError = t.error, t.step = J(t.step), t.chunk = J(t.chunk), t.complete = J(t.complete), t.error = J(t.error), delete t.worker, void i2.postMessage({ input: e, config: t, workerId: i2.id });
          }
          var n2 = null;
          b.NODE_STREAM_INPUT, "string" == typeof e ? (e = function(e2) {
            if (65279 === e2.charCodeAt(0))
              return e2.slice(1);
            return e2;
          }(e), n2 = t.download ? new l(t) : new p2(t)) : true === e.readable && J(e.read) && J(e.on) ? n2 = new g(t) : (f.File && e instanceof File || e instanceof Object) && (n2 = new c(t));
          return n2.stream(e);
        }, unparse: function(e, t) {
          var n2 = false, _2 = true, m2 = ",", y2 = "\r\n", s2 = '"', a2 = s2 + s2, r2 = false, i2 = null, o2 = false;
          !function() {
            if ("object" != typeof t)
              return;
            "string" != typeof t.delimiter || b.BAD_DELIMITERS.filter(function(e2) {
              return -1 !== t.delimiter.indexOf(e2);
            }).length || (m2 = t.delimiter);
            ("boolean" == typeof t.quotes || "function" == typeof t.quotes || Array.isArray(t.quotes)) && (n2 = t.quotes);
            "boolean" != typeof t.skipEmptyLines && "string" != typeof t.skipEmptyLines || (r2 = t.skipEmptyLines);
            "string" == typeof t.newline && (y2 = t.newline);
            "string" == typeof t.quoteChar && (s2 = t.quoteChar);
            "boolean" == typeof t.header && (_2 = t.header);
            if (Array.isArray(t.columns)) {
              if (0 === t.columns.length)
                throw new Error("Option columns is empty");
              i2 = t.columns;
            }
            void 0 !== t.escapeChar && (a2 = t.escapeChar + s2);
            ("boolean" == typeof t.escapeFormulae || t.escapeFormulae instanceof RegExp) && (o2 = t.escapeFormulae instanceof RegExp ? t.escapeFormulae : /^[=+\-@\t\r].*$/);
          }();
          var u2 = new RegExp(Q(s2), "g");
          "string" == typeof e && (e = JSON.parse(e));
          if (Array.isArray(e)) {
            if (!e.length || Array.isArray(e[0]))
              return h3(null, e, r2);
            if ("object" == typeof e[0])
              return h3(i2 || Object.keys(e[0]), e, r2);
          } else if ("object" == typeof e)
            return "string" == typeof e.data && (e.data = JSON.parse(e.data)), Array.isArray(e.data) && (e.fields || (e.fields = e.meta && e.meta.fields || i2), e.fields || (e.fields = Array.isArray(e.data[0]) ? e.fields : "object" == typeof e.data[0] ? Object.keys(e.data[0]) : []), Array.isArray(e.data[0]) || "object" == typeof e.data[0] || (e.data = [e.data])), h3(e.fields || [], e.data || [], r2);
          throw new Error("Unable to serialize unrecognized input");
          function h3(e2, t2, r3) {
            var i3 = "";
            "string" == typeof e2 && (e2 = JSON.parse(e2)), "string" == typeof t2 && (t2 = JSON.parse(t2));
            var n3 = Array.isArray(e2) && 0 < e2.length, s3 = !Array.isArray(t2[0]);
            if (n3 && _2) {
              for (var a3 = 0; a3 < e2.length; a3++)
                0 < a3 && (i3 += m2), i3 += v2(e2[a3], a3);
              0 < t2.length && (i3 += y2);
            }
            for (var o3 = 0; o3 < t2.length; o3++) {
              var u3 = n3 ? e2.length : t2[o3].length, h4 = false, f2 = n3 ? 0 === Object.keys(t2[o3]).length : 0 === t2[o3].length;
              if (r3 && !n3 && (h4 = "greedy" === r3 ? "" === t2[o3].join("").trim() : 1 === t2[o3].length && 0 === t2[o3][0].length), "greedy" === r3 && n3) {
                for (var d2 = [], l2 = 0; l2 < u3; l2++) {
                  var c2 = s3 ? e2[l2] : l2;
                  d2.push(t2[o3][c2]);
                }
                h4 = "" === d2.join("").trim();
              }
              if (!h4) {
                for (var p3 = 0; p3 < u3; p3++) {
                  0 < p3 && !f2 && (i3 += m2);
                  var g2 = n3 && s3 ? e2[p3] : p3;
                  i3 += v2(t2[o3][g2], p3);
                }
                o3 < t2.length - 1 && (!r3 || 0 < u3 && !f2) && (i3 += y2);
              }
            }
            return i3;
          }
          function v2(e2, t2) {
            if (null == e2)
              return "";
            if (e2.constructor === Date)
              return JSON.stringify(e2).slice(1, 25);
            var r3 = false;
            o2 && "string" == typeof e2 && o2.test(e2) && (e2 = "'" + e2, r3 = true);
            var i3 = e2.toString().replace(u2, a2);
            return (r3 = r3 || true === n2 || "function" == typeof n2 && n2(e2, t2) || Array.isArray(n2) && n2[t2] || function(e3, t3) {
              for (var r4 = 0; r4 < t3.length; r4++)
                if (-1 < e3.indexOf(t3[r4]))
                  return true;
              return false;
            }(i3, b.BAD_DELIMITERS) || -1 < i3.indexOf(m2) || " " === i3.charAt(0) || " " === i3.charAt(i3.length - 1)) ? s2 + i3 + s2 : i3;
          }
        } };
        if (b.RECORD_SEP = String.fromCharCode(30), b.UNIT_SEP = String.fromCharCode(31), b.BYTE_ORDER_MARK = "\uFEFF", b.BAD_DELIMITERS = ["\r", "\n", '"', b.BYTE_ORDER_MARK], b.WORKERS_SUPPORTED = !n && !!f.Worker, b.NODE_STREAM_INPUT = 1, b.LocalChunkSize = 10485760, b.RemoteChunkSize = 5242880, b.DefaultDelimiter = ",", b.Parser = E, b.ParserHandle = r, b.NetworkStreamer = l, b.FileStreamer = c, b.StringStreamer = p2, b.ReadableStreamStreamer = g, f.jQuery) {
          var d = f.jQuery;
          d.fn.parse = function(o2) {
            var r2 = o2.config || {}, u2 = [];
            return this.each(function(e2) {
              if (!("INPUT" === d(this).prop("tagName").toUpperCase() && "file" === d(this).attr("type").toLowerCase() && f.FileReader) || !this.files || 0 === this.files.length)
                return true;
              for (var t = 0; t < this.files.length; t++)
                u2.push({ file: this.files[t], inputElem: this, instanceConfig: d.extend({}, r2) });
            }), e(), this;
            function e() {
              if (0 !== u2.length) {
                var e2, t, r3, i2, n2 = u2[0];
                if (J(o2.before)) {
                  var s2 = o2.before(n2.file, n2.inputElem);
                  if ("object" == typeof s2) {
                    if ("abort" === s2.action)
                      return e2 = "AbortError", t = n2.file, r3 = n2.inputElem, i2 = s2.reason, void (J(o2.error) && o2.error({ name: e2 }, t, r3, i2));
                    if ("skip" === s2.action)
                      return void h3();
                    "object" == typeof s2.config && (n2.instanceConfig = d.extend(n2.instanceConfig, s2.config));
                  } else if ("skip" === s2)
                    return void h3();
                }
                var a2 = n2.instanceConfig.complete;
                n2.instanceConfig.complete = function(e3) {
                  J(a2) && a2(e3, n2.file, n2.inputElem), h3();
                }, b.parse(n2.file, n2.instanceConfig);
              } else
                J(o2.complete) && o2.complete();
            }
            function h3() {
              u2.splice(0, 1), e();
            }
          };
        }
        function h2(e) {
          this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, (function(e2) {
            var t = w(e2);
            t.chunkSize = parseInt(t.chunkSize), e2.step || e2.chunk || (t.chunkSize = null);
            this._handle = new r(t), (this._handle.streamer = this)._config = t;
          }).call(this, e), this.parseChunk = function(e2, t) {
            if (this.isFirstChunk && J(this._config.beforeFirstChunk)) {
              var r2 = this._config.beforeFirstChunk(e2);
              void 0 !== r2 && (e2 = r2);
            }
            this.isFirstChunk = false, this._halted = false;
            var i2 = this._partialLine + e2;
            this._partialLine = "";
            var n2 = this._handle.parse(i2, this._baseIndex, !this._finished);
            if (!this._handle.paused() && !this._handle.aborted()) {
              var s2 = n2.meta.cursor;
              this._finished || (this._partialLine = i2.substring(s2 - this._baseIndex), this._baseIndex = s2), n2 && n2.data && (this._rowCount += n2.data.length);
              var a2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
              if (o)
                f.postMessage({ results: n2, workerId: b.WORKER_ID, finished: a2 });
              else if (J(this._config.chunk) && !t) {
                if (this._config.chunk(n2, this._handle), this._handle.paused() || this._handle.aborted())
                  return void (this._halted = true);
                n2 = void 0, this._completeResults = void 0;
              }
              return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n2.data), this._completeResults.errors = this._completeResults.errors.concat(n2.errors), this._completeResults.meta = n2.meta), this._completed || !a2 || !J(this._config.complete) || n2 && n2.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a2 || n2 && n2.meta.paused || this._nextChunk(), n2;
            }
            this._halted = true;
          }, this._sendError = function(e2) {
            J(this._config.error) ? this._config.error(e2) : o && this._config.error && f.postMessage({ workerId: b.WORKER_ID, error: e2, finished: false });
          };
        }
        function l(e) {
          var i2;
          (e = e || {}).chunkSize || (e.chunkSize = b.RemoteChunkSize), h2.call(this, e), this._nextChunk = n ? function() {
            this._readChunk(), this._chunkLoaded();
          } : function() {
            this._readChunk();
          }, this.stream = function(e2) {
            this._input = e2, this._nextChunk();
          }, this._readChunk = function() {
            if (this._finished)
              this._chunkLoaded();
            else {
              if (i2 = new XMLHttpRequest(), this._config.withCredentials && (i2.withCredentials = this._config.withCredentials), n || (i2.onload = v(this._chunkLoaded, this), i2.onerror = v(this._chunkError, this)), i2.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n), this._config.downloadRequestHeaders) {
                var e2 = this._config.downloadRequestHeaders;
                for (var t in e2)
                  i2.setRequestHeader(t, e2[t]);
              }
              if (this._config.chunkSize) {
                var r2 = this._start + this._config.chunkSize - 1;
                i2.setRequestHeader("Range", "bytes=" + this._start + "-" + r2);
              }
              try {
                i2.send(this._config.downloadRequestBody);
              } catch (e3) {
                this._chunkError(e3.message);
              }
              n && 0 === i2.status && this._chunkError();
            }
          }, this._chunkLoaded = function() {
            4 === i2.readyState && (i2.status < 200 || 400 <= i2.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i2.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e2) {
              var t = e2.getResponseHeader("Content-Range");
              if (null === t)
                return -1;
              return parseInt(t.substring(t.lastIndexOf("/") + 1));
            }(i2), this.parseChunk(i2.responseText)));
          }, this._chunkError = function(e2) {
            var t = i2.statusText || e2;
            this._sendError(new Error(t));
          };
        }
        function c(e) {
          var i2, n2;
          (e = e || {}).chunkSize || (e.chunkSize = b.LocalChunkSize), h2.call(this, e);
          var s2 = "undefined" != typeof FileReader;
          this.stream = function(e2) {
            this._input = e2, n2 = e2.slice || e2.webkitSlice || e2.mozSlice, s2 ? ((i2 = new FileReader()).onload = v(this._chunkLoaded, this), i2.onerror = v(this._chunkError, this)) : i2 = new FileReaderSync(), this._nextChunk();
          }, this._nextChunk = function() {
            this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
          }, this._readChunk = function() {
            var e2 = this._input;
            if (this._config.chunkSize) {
              var t = Math.min(this._start + this._config.chunkSize, this._input.size);
              e2 = n2.call(e2, this._start, t);
            }
            var r2 = i2.readAsText(e2, this._config.encoding);
            s2 || this._chunkLoaded({ target: { result: r2 } });
          }, this._chunkLoaded = function(e2) {
            this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e2.target.result);
          }, this._chunkError = function() {
            this._sendError(i2.error);
          };
        }
        function p2(e) {
          var r2;
          h2.call(this, e = e || {}), this.stream = function(e2) {
            return r2 = e2, this._nextChunk();
          }, this._nextChunk = function() {
            if (!this._finished) {
              var e2, t = this._config.chunkSize;
              return t ? (e2 = r2.substring(0, t), r2 = r2.substring(t)) : (e2 = r2, r2 = ""), this._finished = !r2, this.parseChunk(e2);
            }
          };
        }
        function g(e) {
          h2.call(this, e = e || {});
          var t = [], r2 = true, i2 = false;
          this.pause = function() {
            h2.prototype.pause.apply(this, arguments), this._input.pause();
          }, this.resume = function() {
            h2.prototype.resume.apply(this, arguments), this._input.resume();
          }, this.stream = function(e2) {
            this._input = e2, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
          }, this._checkIsFinished = function() {
            i2 && 1 === t.length && (this._finished = true);
          }, this._nextChunk = function() {
            this._checkIsFinished(), t.length ? this.parseChunk(t.shift()) : r2 = true;
          }, this._streamData = v(function(e2) {
            try {
              t.push("string" == typeof e2 ? e2 : e2.toString(this._config.encoding)), r2 && (r2 = false, this._checkIsFinished(), this.parseChunk(t.shift()));
            } catch (e3) {
              this._streamError(e3);
            }
          }, this), this._streamError = v(function(e2) {
            this._streamCleanUp(), this._sendError(e2);
          }, this), this._streamEnd = v(function() {
            this._streamCleanUp(), i2 = true, this._streamData("");
          }, this), this._streamCleanUp = v(function() {
            this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
          }, this);
        }
        function r(m2) {
          var a2, o2, u2, i2 = Math.pow(2, 53), n2 = -i2, s2 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t = this, r2 = 0, f2 = 0, d2 = false, e = false, l2 = [], c2 = { data: [], errors: [], meta: {} };
          if (J(m2.step)) {
            var p3 = m2.step;
            m2.step = function(e2) {
              if (c2 = e2, _2())
                g2();
              else {
                if (g2(), 0 === c2.data.length)
                  return;
                r2 += e2.data.length, m2.preview && r2 > m2.preview ? o2.abort() : (c2.data = c2.data[0], p3(c2, t));
              }
            };
          }
          function y2(e2) {
            return "greedy" === m2.skipEmptyLines ? "" === e2.join("").trim() : 1 === e2.length && 0 === e2[0].length;
          }
          function g2() {
            return c2 && u2 && (k("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b.DefaultDelimiter + "'"), u2 = false), m2.skipEmptyLines && (c2.data = c2.data.filter(function(e2) {
              return !y2(e2);
            })), _2() && function() {
              if (!c2)
                return;
              function e2(e3, t3) {
                J(m2.transformHeader) && (e3 = m2.transformHeader(e3, t3)), l2.push(e3);
              }
              if (Array.isArray(c2.data[0])) {
                for (var t2 = 0; _2() && t2 < c2.data.length; t2++)
                  c2.data[t2].forEach(e2);
                c2.data.splice(0, 1);
              } else
                c2.data.forEach(e2);
            }(), function() {
              if (!c2 || !m2.header && !m2.dynamicTyping && !m2.transform)
                return c2;
              function e2(e3, t3) {
                var r3, i3 = m2.header ? {} : [];
                for (r3 = 0; r3 < e3.length; r3++) {
                  var n3 = r3, s3 = e3[r3];
                  m2.header && (n3 = r3 >= l2.length ? "__parsed_extra" : l2[r3]), m2.transform && (s3 = m2.transform(s3, n3)), s3 = v2(n3, s3), "__parsed_extra" === n3 ? (i3[n3] = i3[n3] || [], i3[n3].push(s3)) : i3[n3] = s3;
                }
                return m2.header && (r3 > l2.length ? k("FieldMismatch", "TooManyFields", "Too many fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3) : r3 < l2.length && k("FieldMismatch", "TooFewFields", "Too few fields: expected " + l2.length + " fields but parsed " + r3, f2 + t3)), i3;
              }
              var t2 = 1;
              !c2.data.length || Array.isArray(c2.data[0]) ? (c2.data = c2.data.map(e2), t2 = c2.data.length) : c2.data = e2(c2.data, 0);
              m2.header && c2.meta && (c2.meta.fields = l2);
              return f2 += t2, c2;
            }();
          }
          function _2() {
            return m2.header && 0 === l2.length;
          }
          function v2(e2, t2) {
            return r3 = e2, m2.dynamicTypingFunction && void 0 === m2.dynamicTyping[r3] && (m2.dynamicTyping[r3] = m2.dynamicTypingFunction(r3)), true === (m2.dynamicTyping[r3] || m2.dynamicTyping) ? "true" === t2 || "TRUE" === t2 || "false" !== t2 && "FALSE" !== t2 && (function(e3) {
              if (s2.test(e3)) {
                var t3 = parseFloat(e3);
                if (n2 < t3 && t3 < i2)
                  return true;
              }
              return false;
            }(t2) ? parseFloat(t2) : h3.test(t2) ? new Date(t2) : "" === t2 ? null : t2) : t2;
            var r3;
          }
          function k(e2, t2, r3, i3) {
            var n3 = { type: e2, code: t2, message: r3 };
            void 0 !== i3 && (n3.row = i3), c2.errors.push(n3);
          }
          this.parse = function(e2, t2, r3) {
            var i3 = m2.quoteChar || '"';
            if (m2.newline || (m2.newline = function(e3, t3) {
              e3 = e3.substring(0, 1048576);
              var r4 = new RegExp(Q(t3) + "([^]*?)" + Q(t3), "gm"), i4 = (e3 = e3.replace(r4, "")).split("\r"), n4 = e3.split("\n"), s4 = 1 < n4.length && n4[0].length < i4[0].length;
              if (1 === i4.length || s4)
                return "\n";
              for (var a3 = 0, o3 = 0; o3 < i4.length; o3++)
                "\n" === i4[o3][0] && a3++;
              return a3 >= i4.length / 2 ? "\r\n" : "\r";
            }(e2, i3)), u2 = false, m2.delimiter)
              J(m2.delimiter) && (m2.delimiter = m2.delimiter(e2), c2.meta.delimiter = m2.delimiter);
            else {
              var n3 = function(e3, t3, r4, i4, n4) {
                var s4, a3, o3, u3;
                n4 = n4 || [",", "	", "|", ";", b.RECORD_SEP, b.UNIT_SEP];
                for (var h4 = 0; h4 < n4.length; h4++) {
                  var f3 = n4[h4], d3 = 0, l3 = 0, c3 = 0;
                  o3 = void 0;
                  for (var p4 = new E({ comments: i4, delimiter: f3, newline: t3, preview: 10 }).parse(e3), g3 = 0; g3 < p4.data.length; g3++)
                    if (r4 && y2(p4.data[g3]))
                      c3++;
                    else {
                      var _3 = p4.data[g3].length;
                      l3 += _3, void 0 !== o3 ? 0 < _3 && (d3 += Math.abs(_3 - o3), o3 = _3) : o3 = _3;
                    }
                  0 < p4.data.length && (l3 /= p4.data.length - c3), (void 0 === a3 || d3 <= a3) && (void 0 === u3 || u3 < l3) && 1.99 < l3 && (a3 = d3, s4 = f3, u3 = l3);
                }
                return { successful: !!(m2.delimiter = s4), bestDelimiter: s4 };
              }(e2, m2.newline, m2.skipEmptyLines, m2.comments, m2.delimitersToGuess);
              n3.successful ? m2.delimiter = n3.bestDelimiter : (u2 = true, m2.delimiter = b.DefaultDelimiter), c2.meta.delimiter = m2.delimiter;
            }
            var s3 = w(m2);
            return m2.preview && m2.header && s3.preview++, a2 = e2, o2 = new E(s3), c2 = o2.parse(a2, t2, r3), g2(), d2 ? { meta: { paused: true } } : c2 || { meta: { paused: false } };
          }, this.paused = function() {
            return d2;
          }, this.pause = function() {
            d2 = true, o2.abort(), a2 = J(m2.chunk) ? "" : a2.substring(o2.getCharIndex());
          }, this.resume = function() {
            t.streamer._halted ? (d2 = false, t.streamer.parseChunk(a2, true)) : setTimeout(t.resume, 3);
          }, this.aborted = function() {
            return e;
          }, this.abort = function() {
            e = true, o2.abort(), c2.meta.aborted = true, J(m2.complete) && m2.complete(c2), a2 = "";
          };
        }
        function Q(e) {
          return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        function E(j) {
          var z, M = (j = j || {}).delimiter, P = j.newline, U = j.comments, q = j.step, N = j.preview, B = j.fastMode, K = z = void 0 === j.quoteChar || null === j.quoteChar ? '"' : j.quoteChar;
          if (void 0 !== j.escapeChar && (K = j.escapeChar), ("string" != typeof M || -1 < b.BAD_DELIMITERS.indexOf(M)) && (M = ","), U === M)
            throw new Error("Comment character same as delimiter");
          true === U ? U = "#" : ("string" != typeof U || -1 < b.BAD_DELIMITERS.indexOf(U)) && (U = false), "\n" !== P && "\r" !== P && "\r\n" !== P && (P = "\n");
          var W = 0, H = false;
          this.parse = function(i2, t, r2) {
            if ("string" != typeof i2)
              throw new Error("Input must be a string");
            var n2 = i2.length, e = M.length, s2 = P.length, a2 = U.length, o2 = J(q), u2 = [], h3 = [], f2 = [], d2 = W = 0;
            if (!i2)
              return L();
            if (j.header && !t) {
              var l2 = i2.split(P)[0].split(M), c2 = [], p3 = {}, g2 = false;
              for (var _2 in l2) {
                var m2 = l2[_2];
                J(j.transformHeader) && (m2 = j.transformHeader(m2, _2));
                var y2 = m2, v2 = p3[m2] || 0;
                for (0 < v2 && (g2 = true, y2 = m2 + "_" + v2), p3[m2] = v2 + 1; c2.includes(y2); )
                  y2 = y2 + "_" + v2;
                c2.push(y2);
              }
              if (g2) {
                var k = i2.split(P);
                k[0] = c2.join(M), i2 = k.join(P);
              }
            }
            if (B || false !== B && -1 === i2.indexOf(z)) {
              for (var b2 = i2.split(P), E2 = 0; E2 < b2.length; E2++) {
                if (f2 = b2[E2], W += f2.length, E2 !== b2.length - 1)
                  W += P.length;
                else if (r2)
                  return L();
                if (!U || f2.substring(0, a2) !== U) {
                  if (o2) {
                    if (u2 = [], I(f2.split(M)), F(), H)
                      return L();
                  } else
                    I(f2.split(M));
                  if (N && N <= E2)
                    return u2 = u2.slice(0, N), L(true);
                }
              }
              return L();
            }
            for (var w2 = i2.indexOf(M, W), R = i2.indexOf(P, W), C = new RegExp(Q(K) + Q(z), "g"), S = i2.indexOf(z, W); ; )
              if (i2[W] !== z)
                if (U && 0 === f2.length && i2.substring(W, W + a2) === U) {
                  if (-1 === R)
                    return L();
                  W = R + s2, R = i2.indexOf(P, W), w2 = i2.indexOf(M, W);
                } else if (-1 !== w2 && (w2 < R || -1 === R))
                  f2.push(i2.substring(W, w2)), W = w2 + e, w2 = i2.indexOf(M, W);
                else {
                  if (-1 === R)
                    break;
                  if (f2.push(i2.substring(W, R)), D(R + s2), o2 && (F(), H))
                    return L();
                  if (N && u2.length >= N)
                    return L(true);
                }
              else
                for (S = W, W++; ; ) {
                  if (-1 === (S = i2.indexOf(z, S + 1)))
                    return r2 || h3.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u2.length, index: W }), T();
                  if (S === n2 - 1)
                    return T(i2.substring(W, S).replace(C, z));
                  if (z !== K || i2[S + 1] !== K) {
                    if (z === K || 0 === S || i2[S - 1] !== K) {
                      -1 !== w2 && w2 < S + 1 && (w2 = i2.indexOf(M, S + 1)), -1 !== R && R < S + 1 && (R = i2.indexOf(P, S + 1));
                      var O = A(-1 === R ? w2 : Math.min(w2, R));
                      if (i2.substr(S + 1 + O, e) === M) {
                        f2.push(i2.substring(W, S).replace(C, z)), i2[W = S + 1 + O + e] !== z && (S = i2.indexOf(z, W)), w2 = i2.indexOf(M, W), R = i2.indexOf(P, W);
                        break;
                      }
                      var x = A(R);
                      if (i2.substring(S + 1 + x, S + 1 + x + s2) === P) {
                        if (f2.push(i2.substring(W, S).replace(C, z)), D(S + 1 + x + s2), w2 = i2.indexOf(M, W), S = i2.indexOf(z, W), o2 && (F(), H))
                          return L();
                        if (N && u2.length >= N)
                          return L(true);
                        break;
                      }
                      h3.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u2.length, index: W }), S++;
                    }
                  } else
                    S++;
                }
            return T();
            function I(e2) {
              u2.push(e2), d2 = W;
            }
            function A(e2) {
              var t2 = 0;
              if (-1 !== e2) {
                var r3 = i2.substring(S + 1, e2);
                r3 && "" === r3.trim() && (t2 = r3.length);
              }
              return t2;
            }
            function T(e2) {
              return r2 || (void 0 === e2 && (e2 = i2.substring(W)), f2.push(e2), W = n2, I(f2), o2 && F()), L();
            }
            function D(e2) {
              W = e2, I(f2), f2 = [], R = i2.indexOf(P, W);
            }
            function L(e2) {
              return { data: u2, errors: h3, meta: { delimiter: M, linebreak: P, aborted: H, truncated: !!e2, cursor: d2 + (t || 0) } };
            }
            function F() {
              q(L()), u2 = [], h3 = [];
            }
          }, this.abort = function() {
            H = true;
          }, this.getCharIndex = function() {
            return W;
          };
        }
        function _(e) {
          var t = e.data, r2 = a[t.workerId], i2 = false;
          if (t.error)
            r2.userError(t.error, t.file);
          else if (t.results && t.results.data) {
            var n2 = { abort: function() {
              i2 = true, m(t.workerId, { data: [], errors: [], meta: { aborted: true } });
            }, pause: y, resume: y };
            if (J(r2.userStep)) {
              for (var s2 = 0; s2 < t.results.data.length && (r2.userStep({ data: t.results.data[s2], errors: t.results.errors, meta: t.results.meta }, n2), !i2); s2++)
                ;
              delete t.results;
            } else
              J(r2.userChunk) && (r2.userChunk(t.results, n2, t.file), delete t.results);
          }
          t.finished && !i2 && m(t.workerId, t.results);
        }
        function m(e, t) {
          var r2 = a[e];
          J(r2.userComplete) && r2.userComplete(t), r2.terminate(), delete a[e];
        }
        function y() {
          throw new Error("Not implemented.");
        }
        function w(e) {
          if ("object" != typeof e || null === e)
            return e;
          var t = Array.isArray(e) ? [] : {};
          for (var r2 in e)
            t[r2] = w(e[r2]);
          return t;
        }
        function v(e, t) {
          return function() {
            e.apply(t, arguments);
          };
        }
        function J(e) {
          return "function" == typeof e;
        }
        return o && (f.onmessage = function(e) {
          var t = e.data;
          void 0 === b.WORKER_ID && t && (b.WORKER_ID = t.workerId);
          if ("string" == typeof t.input)
            f.postMessage({ workerId: b.WORKER_ID, results: b.parse(t.input, t.config), finished: true });
          else if (f.File && t.input instanceof File || t.input instanceof Object) {
            var r2 = b.parse(t.input, t.config);
            r2 && f.postMessage({ workerId: b.WORKER_ID, results: r2, finished: true });
          }
        }), (l.prototype = Object.create(h2.prototype)).constructor = l, (c.prototype = Object.create(h2.prototype)).constructor = c, (p2.prototype = Object.create(p2.prototype)).constructor = p2, (g.prototype = Object.create(h2.prototype)).constructor = g, b;
      });
    })(papaparse_min);
    var papaparse_minExports = papaparse_min.exports;
    const Papa = /* @__PURE__ */ getDefaultExportFromCjs(papaparse_minExports);
    function bind$1(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString: toString$1 } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString$1.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$1 } = Array;
    const isUndefined$1 = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$1 = typeOfTest("string");
    const isFunction$1 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$2 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$1 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$2(val) && isFunction$1(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i2;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (i2 = 0, l = obj.length; i2 < l; i2++) {
          fn.call(null, obj[i2], i2, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len2 = keys2.length;
        let key;
        for (i2 = 0; i2 < len2; i2++) {
          key = keys2[i2];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i2 = keys2.length;
      let _key;
      while (i2-- > 0) {
        _key = keys2[i2];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray$1(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
        arguments[i2] && forEach(arguments[i2], assignValue);
      }
      return result;
    }
    const extend$1 = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i2;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i2 = props.length;
        while (i2-- > 0) {
          prop = props[i2];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray$1 = (thing) => {
      if (!thing)
        return null;
      if (isArray$1(thing))
        return thing;
      let i2 = thing.length;
      if (!isNumber$1(i2))
        return null;
      const arr = new Array(i2);
      while (i2-- > 0) {
        arr[i2] = thing[i2];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$1(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i2) => {
        if (isObject$2(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack[i2] = source;
            const target = isArray$1(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i2 + 1);
              !isUndefined$1(reducedValue) && (target[key] = reducedValue);
            });
            stack[i2] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject$2(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    const utils$1 = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isBoolean,
      isObject: isObject$2,
      isPlainObject,
      isUndefined: isUndefined$1,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend: extend$1,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray$1,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code2, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code2 && (this.code = code2);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code2) => {
      descriptors[code2] = { value: code2 };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code2, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code2, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token2, i2) {
        token2 = removeBrackets(token2);
        return !dots && i2 ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const InterceptorManager$1 = InterceptorManager;
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i2;
      const len2 = keys2.length;
      let key;
      for (i2 = 0; i2 < len2; i2++) {
        key = keys2[i2];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$1 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          if (!hasJSONContentType) {
            return data;
          }
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$1.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults$1.headers[method] = {};
    });
    const defaults$2 = defaults$1;
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i2;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i2 = line.indexOf(":");
        key = line.substring(0, i2).trim().toLowerCase();
        val = line.substring(i2 + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens2[match[1]] = match[2];
      }
      return tokens2;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys2 = Object.keys(this);
        let i2 = keys2.length;
        let deleted = false;
        while (i2--) {
          const key = keys2[i2];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$2;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i2 = tail;
        let bytesCount = 0;
        while (i2 !== head) {
          bytesCount += bytes[i2++];
          i2 = i2 % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i2 = 0; i2 < length; i2++) {
          nameOrAdapter = adapters2[i2];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i2] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$2.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION = "1.6.2";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i2 = keys2.length;
      while (i2-- > 0) {
        const opt = keys2[i2];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i2 = 0;
        let len2;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len2 = chain.length;
          promise = Promise.resolve(config);
          while (i2 < len2) {
            promise = promise.then(chain[i2++], chain[i2++]);
          }
          return promise;
        }
        len2 = requestInterceptorChain.length;
        let newConfig = config;
        i2 = 0;
        while (i2 < len2) {
          const onFulfilled = requestInterceptorChain[i2++];
          const onRejected = requestInterceptorChain[i2++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i2 = 0;
        len2 = responseInterceptorChain.length;
        while (i2 < len2) {
          promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i2 = token2._listeners.length;
          while (i2-- > 0) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token2.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind$1(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$2);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const axios$1 = axios;
    const Node$2 = function() {
      this.keys = /* @__PURE__ */ new Map();
      this.childCount = 0;
      this.end = false;
      this.setEnd = function() {
        this.end = true;
      };
      this.isEnd = function() {
        return this.end;
      };
    };
    const Trie = function() {
      this.root = new Node$2();
      this.add = function(input, node = this.root) {
        if (input.length === 0) {
          node.setEnd();
          return;
        }
        node.childCount++;
        if (!node.keys.has(input[0])) {
          node.keys.set(input[0], new Node$2());
          return this.add(input.substr(1), node.keys.get(input[0]));
        }
        return this.add(input.substr(1), node.keys.get(input[0]));
      };
      this.countChildren = function(word) {
        let node = this.findNode(word);
        if (node === false)
          return -1;
        return node.childCount;
      };
      this.isWord = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        return !!(node.keys.has(word) && node.keys.get(word).isEnd());
      };
      this.findNode = (word) => {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (node.keys.get(word))
          return node.keys.get(word);
        else
          return false;
      };
      this.prefixMatchingWords = (prefix) => {
        const words = new Array();
        let node = this.findNode(prefix);
        if (!node)
          return words;
        if (node.childCount === 0)
          return [prefix];
        const search = function(node2, string) {
          if (node2.keys.size != 0) {
            for (const letter of node2.keys.keys()) {
              search(node2.keys.get(letter), string.concat(letter));
            }
            if (node2.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(node, new String());
        if (words.length > 0) {
          return words.map((word) => `${prefix}${word}`);
        }
        return [];
      };
      this.countDirectChildren = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (!node.keys.has(word))
          return false;
        if (node.keys.get(word).isEnd()) {
          return 0;
        }
        return node.keys.get(word).keys.size;
      };
      this.print = function() {
        const words = new Array();
        const search = function(node, string) {
          if (node.keys.size != 0) {
            for (const letter of node.keys.keys()) {
              search(node.keys.get(letter), string.concat(letter));
            }
            if (node.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(this.root, new String());
        return words.length > 0 ? words : mo;
      };
    };
    const Trie$1 = { Trie };
    const Symbols = {
      Circle: {
        label: "Circle",
        marker: "●",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <circle r="24" cy="26" cx="26" style="fill:#706e6b;stroke:#706e6b;stroke-width:3.847;stroke-linejoin:round;fill-opacity:1;stroke-opacity:1"/>
            </svg>
        `
      },
      Square: {
        label: "Square",
        marker: "■",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path style="fill:#706e6b;fill-opacity:1;stroke:#706e6b;stroke-width:3.77953;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="M1.889765 1.889765h48v48h-48z"/>
            </svg>
        `
      },
      Pyramid: {
        label: "Pyramid",
        marker: "▲",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path  d="M52 52 25 0 0 52Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Triangle: {
        label: "Triangle",
        marker: "▼",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="m0 0 27 52L52 0Z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Diamond: {
        label: "Diamond",
        marker: "◆",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M26 0 0 26l26 26 26-26Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Star: {
        label: "Star",
        marker: "★",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path transform="matrix(1.04945 0 0 1.10341 -.23623862 1.1584795)" d="m25.000001 0 7.347315 14.887288 16.429097 2.387288-11.888207 11.588136 2.806425 16.362713L25 37.5l-14.694632 7.725424 2.806426-16.362712L1.2235873 17.274575l16.4290967-2.387287Z" style="fill:#706e6b;fill-rule:evenodd;stroke:#706e6b;stroke-width:.929286;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Parallelogram: {
        label: "Parallelogram",
        marker: "▰",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52-2.6e-7H10L0 51.999999h43z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Rectangle: {
        label: "Rectangle",
        marker: "▬",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52 10H0v32h52z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Box: {
        label: "Box",
        marker: "▮",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M43 0 10-2.6e-7V52l33-.000001z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      }
    };
    const MapUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Symbols
    }, Symbol.toStringTag, { value: "Module" }));
    function SegClient({ Buffer: Buffer2, Papa: Papa2 } = {}) {
      const Rule = {
        toSaql(rule, dataSource) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: dataSource._referenceFields.find((f) => f.id === item.sfsp__Field__c).dataType === "Numeric" ? "Numeric" : "Text"
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        }
      };
      const Filter = {
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i2 = 0; i2 < booleanFilter.length; i2++) {
            const char = booleanFilter[i2];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        toSaql(filter) {
          const { field, operator, value = "", dataType } = filter;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] && ${field} is not null)` : `${field} not in ["${values.join('","')}"]` : value ? `${field} != "${value}"` : `(${field} != "" && ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              case "doesnotcontain":
                return values.length > 1 ? `(${values.map((v) => `!(${field} matches "${v}")`).join(" && ")})` : `!(${field} matches "${value}")`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: ""
        }),
        getDataSetCountSaql({ datasetId, versionId }) {
          return `
                -- load records
                q = load "${datasetId}/${versionId}";
    
                -- results
                results = group q by all;
                results = foreach results generate count() as count;
            `;
        },
        // saql generation
        generateHierarchySaql({ node, nodeMap, dataSource, fields = [] }) {
          if (!node._parentId) {
            return `
                    ------------------------------------
                    -- Records
                    ------------------------------------
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    ------------------------------------
                    -- Filters
                    ------------------------------------
    
                    -- all org
                    all_org = group q by all;
                    ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}
    
                    ------------------------------------
                    -- Projections
                    ------------------------------------
                    ${Object.keys(nodeMap).map((id) => `
                        ${id} = group ${id} by all;
                        ${id} = foreach ${id} generate ${[
              `"${id}" as __NodeId`,
              `count() as __Records`,
              ...fields.map((f) => `sum(${f}) as ${f}`)
            ].join(", ")};
                    `).join("")}
    
                    ------------------------------------
                    -- Results
                    ------------------------------------
                    ${Object.keys(nodeMap).length > 1 ? `results = union ${Object.keys(nodeMap).join(", ")};` : `results = limit ${Object.keys(nodeMap)[0]} 1;`}
                `.replace(/^ */gm, "");
          }
          return `
                -- ${node.Name}
                ${node.Id} = filter ${node._parentId} by ${this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id })};
                ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}`;
        },
        generateNodeFilterSaql({ node, nodeMap, dataSource, descendantFilters = [], isBurndown = false }) {
          descendantFilters.push(this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id, isBurndown }));
          if (!node._parentId) {
            return `
                    -- load records
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    -- filters
                    results = filter q by (${descendantFilters.join(") && (")});
                `;
          }
          return this.generateNodeFilterSaql({ node: nodeMap[node._parentId], nodeMap, dataSource, descendantFilters });
        },
        generateRules({ node, nodeMap, dataSource, uniqueIdField, isBurndown }) {
          const burndownNodes = isBurndown ? node.sfsp__SalesNodes__r : [];
          if (node.sfsp__SalesNodeRules__r.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} ${node.Id === "all_org" ? "is not null" : "is null"}`;
          const saqlParts = [];
          if (node.sfsp__SalesNodeRules__r.length) {
            const matchingRulesLogic = this.getRuleLogic({ node });
            const matchingRulesFilterExpression = Filter.mergeBooleanFilter(
              matchingRulesLogic,
              node.sfsp__SalesNodeRules__r.map((r) => Rule.toSaql(r, dataSource))
            );
            saqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${this.generateRules({ node: childNode, nodeMap, dataSource, uniqueIdField })})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        // rule logic
        getRuleLogic({ node }) {
          const existingRuleLogic = node.sfsp__RuleLogics__c;
          if (existingRuleLogic)
            return existingRuleLogic;
          return node.sfsp__SalesNodeRules__r.length === 0 ? "" : Array(node.sfsp__SalesNodeRules__r.length).fill().map((item, i2) => i2 + 1).join(" or ");
        },
        setRuleLogic({ node, logic }) {
          node.sfsp__RuleLogics__c = logic;
        },
        // hierarchy
        async buildNodeMap({ nodeId: nodeId2 }) {
          const nodeMap = {
            all_org: {
              ...SPM.Utils.Segment.Node.defaults(),
              Id: "all_org",
              Name: "All Org"
            }
          };
          const loadAncestors = async (parentId) => {
            let [node] = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        sfsp__SalesPlan__c,
                        sfsp__Parent__c,
                        ${Array(5).fill().map((item, i2) => {
              const prefix = Array(i2 + 1).fill().map(() => "sfsp__Parent__r").join(".");
              return `
                                ${prefix}.Name,
                                ${prefix}.sfsp__Parent__c,
                                ${prefix}.sfsp__RuleLogics__c,
                            `;
            }).join("")}
                        sfsp__RuleLogics__c
                    FROM sfsp__SalesNode__c
                    WHERE Id = '${parentId}'
                `]);
            while (node) {
              nodeMap[node.Id] = {
                ...SPM.Utils.Segment.Node.defaults(),
                ...node,
                _parentId: node.sfsp__Parent__c || "all_org"
              };
              if (node.sfsp__Parent__c && !node.sfsp__Parent__r) {
                await loadAncestors(node.sfsp__Parent__c);
              }
              node = node.sfsp__Parent__r;
            }
          };
          await loadAncestors(nodeId2);
          const rules = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c,
                    (
                        SELECT Id, sfsp__SalesNodeRule__r.sfsp__SalesNode__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                        FROM sfsp__SalesNodeRuleItems__r
                        ORDER BY sfsp__SortOrder__c
                    )
                FROM sfsp__SalesNodeRule__c
                WHERE sfsp__SalesNode__c IN ('${Object.keys(nodeMap).filter((id) => id !== "all_org").join(`','`)}')
                ORDER BY sfsp__SortOrder__c
            `]);
          rules.forEach((r) => nodeMap[r.sfsp__SalesNode__c].sfsp__SalesNodeRules__r.push(r));
          return nodeMap;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node._parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.sfsp__SalesNodes__r || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        compare({ node, compareNode, breadcrumbs = [] }) {
          const diff2 = [];
          const map2 = {};
          node.sfsp__SalesNodes__r.forEach((n) => {
            const matchingNodeIndex = compareNode.sfsp__SalesNodes__r.findIndex((n2) => n2.Name === n.Name);
            if (matchingNodeIndex !== -1) {
              const matchingNode = compareNode.sfsp__SalesNodes__r.splice(matchingNodeIndex, 1)[0];
              map2[n.Id] = matchingNode;
              const childCompareResults = Node2.compare({ node: n, compareNode: matchingNode, breadcrumbs: [...breadcrumbs, n] });
              diff2.push(...childCompareResults.diff);
              Object.assign(map2, childCompareResults.map);
            } else {
              diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Target Not Found" });
            }
          });
          compareNode.sfsp__SalesNodes__r.forEach((n) => {
            diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Source Not Found" });
          });
          return { diff: diff2, map: map2 };
        },
        // queries
        async getRecordCount({ segmentId, dataSource, nodeMap }) {
          var _a;
          nodeMap = nodeMap || await Node2.buildNodeMap({ segmentId });
          const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[nodeId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = group results by all;
                results = foreach results generate count() as count;
            `.replace(/^ */gm, "") });
          return ((_a = aggregateResults == null ? void 0 : aggregateResults.records[0]) == null ? void 0 : _a.count) || 0;
        },
        async resetStampedDataSource(segmentId) {
          await SPM.Utils.CRM.upsert({ records: [{
            Id: segmentId,
            sfsp__StampDataSourceId__c: ""
          }] });
        },
        async buildDataSource({ planId }) {
          const [dataSource] = await SPM.Utils.Apex.invoke("Query", [`
                SELECT Id, Name, sfsp__SourceId__c, sfsp__ReferenceFields__c
                FROM sfsp__SalesDataSource__c
                WHERE Id IN (SELECT sfsp__SalesDataSource__c FROM sfsp__SalesPlan__c WHERE Id = '${planId}')
            `]);
          dataSource._referenceFields = JSON.parse(dataSource.sfsp__ReferenceFields__c);
          dataSource._dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: dataSource.sfsp__SourceId__c });
          return dataSource;
        },
        async getRecords({ segmentId, dataSource, nodeMap, uniqueIds = [], limit = 1, offset: offset2 }) {
          nodeMap = nodeMap || await this.buildNodeMap({ segmentId });
          if (uniqueIds.length > 0)
            limit = uniqueIds.length;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", {
            query: `
                    ${Node2.generateNodeFilterSaql({
              node: nodeMap[segmentId],
              nodeMap,
              dataSource,
              uniqueIds
            })}

                    -- results
                    results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                    ${offset2 ? `results = offset results ${offset2};` : ""}
                    results = limit results ${limit};
                `.replace(/^ */gm, "")
          });
          return results.records;
        }
      };
      const ExternalData = {
        async getNumericScaleData({ dataSource }) {
          const scaleData = /* @__PURE__ */ new Map();
          const metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataSource._dataset.currentVersionUrl });
          metadata.measures.forEach((m) => {
            scaleData.set(m.fullyQualifiedName, m.format.decimalDigits);
          });
          return scaleData;
        },
        generateCsvMetadata({ segmentId, dataSource, scaleDataMap, datasetName, datasetLabel }) {
          const fields = [];
          dataSource._referenceFields.forEach((f) => {
            const field = {
              fullyQualifiedName: f.id,
              name: f.id,
              label: f.label,
              isUniqueId: false,
              type: f.dataType,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.dataType === "Numeric") {
              field.precision = 18;
              field.scale = scaleDataMap.get(f.id) || 0;
              field.defaultValue = 0;
            }
            fields.push(field);
          });
          const csvMetadata = {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: "SegmentData",
                label: "Segment Data",
                name: "SegmentData",
                description: "",
                fields
              }
            ]
          };
          return csvMetadata;
        },
        async waitDataflowJobComplete({ jobId, retries = 5 }) {
          let waitInMilliseconds = 1e4;
          while (retries > 0) {
            const response = await SPM.Utils.Rest.invoke("GetCurrentDataflowJob", { id: jobId });
            if (!["Failure", "Warning", "Success"].includes(response.status)) {
              await SPM.Utils.Async.wait(waitInMilliseconds);
              waitInMilliseconds *= 2;
              retries--;
            } else if (["Success", "Warning"].includes(response.status)) {
              return true;
            } else if (["Failure"].includes(response.status)) {
              return false;
            }
          }
          return false;
        },
        async stampDataSource({ segmentId, dataSource, planName, planId, segmentName }) {
          var _a;
          const nodeMap = await Node2.buildNodeMap({ nodeId: segmentId });
          const scaleDataMap = await ExternalData.getNumericScaleData({ dataSource });
          const datasetName = planId + "_" + segmentId;
          const datasetLabel = (planName + " - " + segmentName).slice(0, 80);
          const csvMetadata = ExternalData.generateCsvMetadata({
            segmentId,
            dataSource,
            scaleDataMap
          });
          const crmafolder = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id
                    FROM Folder
                    WHERE Type = 'Insights' AND Name = '${dataSource._dataset.folder.label}'
            `]);
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDatasetName: dataSource._dataset.name,
              stampDatasetName: datasetLabel,
              jobName: "Stamp Records"
            }
          });
          const stampJobStartTime = performance.now();
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: datasetName, label: datasetLabel, app: (_a = crmafolder[0]) == null ? void 0 : _a.Id, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const batchSize = 5e4;
          let batchNum = 0;
          let batchStats = [];
          let datasetRowMap = {};
          let csvParts = [];
          let recordBatches = [];
          let partNumber = 0;
          let offset2 = 0;
          let doMore = true;
          const uniqueIdField = dataSource._referenceFields.find((f) => f.isId).id;
          const saql = `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[segmentId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                results = order results by ${dataSource._referenceFields.find((f) => f.isId).id};
            `;
          while (doMore) {
            datasetRowMap = {};
            csvParts = [];
            const saqlBatch = saql + `
                results = offset results ${offset2};
                results = limit results ${batchSize};
                `;
            const downloadStartTime = performance.now();
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saqlBatch.replace(/^ */gm, "") });
            const downloadEndTime = performance.now();
            if (results.records.length === 0) {
              doMore = false;
              continue;
            }
            batchNum++;
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            const csv = Papa2.unparse(recordBatches[0]);
            const chunkSize = 9e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results2, parser) {
                csvParts.unshift(Papa2.unparse(results2.data));
              }
            });
            const uploadStartTime = performance.now();
            await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
              const base64String = Buffer2.from(`${data}\r
`).toString("base64");
              const csvPart = base64String;
              partNumber += 1;
              const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
              if (!partResponse.success)
                throw partResponse.errors[0] || "";
            }, 5);
            const uploadEndtime = performance.now();
            batchStats.push({
              numRows: results.records.length,
              downloadTime: downloadEndTime - downloadStartTime,
              uploadTime: uploadEndtime - uploadStartTime
            });
            offset2 += results.records.length;
          }
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDataset: {
                id: dataSource._dataset.id,
                name: dataSource._dataset.name,
                numRows: dataSource._dataset.currentVersionTotalRowCount,
                numColumns: csvMetadata.objects[0].fields.length
              },
              stampDataset: {
                name: datasetLabel,
                numRows: offset2,
                numColumns: csvMetadata.objects[0].fields.length
              },
              jobRunTime: Math.round(performance.now() - stampJobStartTime),
              numBatches: batchNum,
              batchStats,
              crmaJobId: jobResponse.id,
              status: "SUCCESS"
            }
          });
          return { jobId: jobResponse.id, datasetLabel, numRecords: offset2, numFields: csvMetadata.objects[0].fields.length };
        },
        async fetchStampJobResults(jobId, datasetId, datasetLabel, segmentId) {
          const jobStatus = await ExternalData.waitDataflowJobComplete({ jobId });
          if (!jobStatus) {
            SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
            return;
          }
          if (datasetId) {
            const datasetResponse = await SPM.Utils.Rest.invoke("GetDataset", { id: datasetId });
            try {
              if (datasetResponse.label !== datasetLabel) {
                await SPM.Utils.Rest.invoke("PatchDataset", { id: datasetId, metadata: { label: datasetLabel } });
              }
            } catch (err) {
            }
          } else {
            const datasetsResponse = await SPM.Utils.Rest.invoke("GetDatasets", { alias: datasetLabel.replaceAll("'", "%5C%27") });
            if (!(datasetsResponse == null ? void 0 : datasetsResponse.length)) {
              SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
              return;
            }
            const dataset = datasetsResponse[0];
            await SPM.Utils.CRM.upsert({ records: [{
              Id: segmentId,
              sfsp__StampDataSourceId__c: dataset.id
            }] });
          }
        }
      };
      const TPDataSet = {
        async fetchRelatedDataSets() {
          let dataSets = [];
          const externalAssets = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__AssetType__c, sfsp__AssetId__c FROM sfsp__SalesNodeExternalAsset__c WHERE sfsp__SalesNode__c = '${SPM.$store.segment.Id}'`]);
          try {
            dataSets = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        maps__Config__c,
                        (SELECT Id, Name, CreatedById, CreatedBy.Name, CreatedDate FROM maps__Alignments__r WHERE maps__Status__c != 'Deleted')
                    FROM maps__TPDataSet__c
                    WHERE Id IN ('${externalAssets.filter((a) => a.sfsp__AssetType__c === "Territory Plan").map((a) => a.sfsp__AssetId__c).join("','")}') AND maps__Status__c != 'Deleted'
                `]);
          } catch (err) {
          }
          const matchingDataSets = dataSets.filter((ds) => {
            return JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id);
          });
          SPM.$store.$patch((state2) => state2.TPDataSets = matchingDataSets);
          return matchingDataSets || [];
        },
        async fetchRelatedAlignments() {
          const alignments = [];
          const dataSets = await TPDataSet.fetchRelatedDataSets();
          dataSets.forEach((ds) => {
            if ((ds == null ? void 0 : ds.maps__Alignments__r) && JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id))
              alignments.push(...ds == null ? void 0 : ds.maps__Alignments__r);
          });
          SPM.$store.$patch((state2) => state2.TPAlignments = alignments);
          return alignments;
        }
      };
      const TerritoryStampUtils = {
        parsedStampDetails(stampDetails, referenceFields) {
          return stampDetails.map((detail) => {
            const hierarchyData = JSON.parse(detail.sfsp__HierarchyReferenceData__c);
            const parsedData = {};
            Object.keys(hierarchyData).forEach((key) => {
              const referenceMetadata = referenceFields.find((f) => f.type === "Territory" && f.id === key);
              parsedData[key] = "";
              if (referenceMetadata.dataType === "Number") {
                parsedData[key] = hierarchyData[key].SUM;
              } else if (referenceMetadata.dataType === "String") {
                parsedData[key] = hierarchyData[key].VALUE;
              }
            });
            const labeledData = referenceFields.reduce((acc, field) => {
              const keyValue = parsedData[field.id];
              if (keyValue === void 0) {
                if (field.dataType === "Number") {
                  acc[field.label] = 0;
                } else {
                  acc[field.label] = "";
                }
              } else {
                acc[field.label] = keyValue;
              }
              return acc;
            }, {});
            return {
              ...detail,
              data: labeledData
            };
          });
        },
        hierarchicalStampDetails(parsedStampDetails) {
          const detailsMap = /* @__PURE__ */ new Map();
          parsedStampDetails.forEach((detail) => {
            detail.children = [];
            detailsMap.set(detail.Id, detail);
          });
          const rootDetails = [];
          detailsMap.forEach((detail) => {
            if (detail.sfsp__Parent__c) {
              const parentDetail = detailsMap.get(detail.sfsp__Parent__c);
              if (parentDetail) {
                parentDetail.children.push(detail);
              }
            } else {
              rootDetails.push(detail);
            }
          });
          const result = [];
          const traverse2 = (details, indent) => {
            details.forEach((detail) => {
              detail.indent = indent;
              result.push(detail);
              traverse2(detail.children, indent + 1);
            });
          };
          traverse2(rootDetails, 0);
          return result;
        }
      };
      return {
        Rule,
        Filter,
        Node: Node2,
        ExternalData,
        TPDataSet,
        TerritoryStampUtils
      };
    }
    const deconstructFQAPIName = (field = []) => {
      const parts = field.split(".");
      return {
        field: parts[parts.length - 1],
        lookups: parts.splice(0, parts.length - 1)
      };
    };
    const getValueFromRecord = (fullyQualifiedApiName, record = {}) => {
      const { field, lookups = [] } = deconstructFQAPIName(fullyQualifiedApiName);
      const obj = lookups.reduce((r, l) => r == null ? void 0 : r[l], record);
      return obj == null ? void 0 : obj[field];
    };
    function UtilsClient({ Buffer: Buffer2, Papa: Papa2, randomLocation: randomLocation2 } = {}) {
      const Apex = {
        async invoke(action, params = [], { cls = "SPMRemoteActions" } = {}) {
          const startTime = window.performance.now();
          const promise = new Promise((resolve2) => {
            const args = [
              `sfsp.${cls}.${action}`,
              ...params,
              (data, event) => resolve2({ data, event })
            ];
            Visualforce.remoting.Manager.invokeAction(...args, { buffer: false, escape: false, timeout: 12e4 });
          });
          const result = await promise;
          if (!result.event.status) {
            throw {
              type: "RemoteActionException",
              error: result.event
            };
          } else {
            if (action === "Query") {
              SPM.Utils.Splunk.sendLog({
                logName: "spmAPEX",
                logPayload: {
                  query: params[0],
                  returnCount: result.data.length,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
            return result.data;
          }
        }
      };
      const Rest = {
        async invoke() {
          const [method, params = {}] = arguments;
          const headers = { Authorization: `Bearer ${SPM.SessionId}` };
          const promise = new SPM.Utils.DeferredPromise();
          const response = await this.Actions[method](headers, params);
          promise.resolve(response);
          if (SPM.Utils.Debug) {
            promise.then((r) => {
              console.groupCollapsed(method);
              [params, r].forEach((obj) => console.log(obj));
              console.groupEnd();
            }).catch((err) => {
              console.groupCollapsed(method);
              [params, err].forEach((obj) => console.log(obj));
              console.groupEnd();
            });
          }
          return promise;
        },
        Actions: {
          async Query(headers, { query }) {
            const startTime = window.performance.now();
            const records = [];
            let { data: results } = await axios$1({
              method: "GET",
              url: "/services/data/v53.0/query",
              params: {
                q: query
              },
              headers
            });
            records.push(...results.records);
            while (results.nextRecordsUrl) {
              results = (await axios$1({ method: "GET", url: results.nextRecordsUrl, headers })).data;
              records.push(...results.records);
            }
            records.forEach((r) => {
              Object.keys(r).forEach((key) => {
                var _a;
                if ((_a = r[key]) == null ? void 0 : _a.records) {
                  r[key] = r[key].records;
                }
              });
            });
            SPM.Utils.Splunk.sendLog({
              logName: "spmREST",
              logPayload: {
                query,
                returnCount: records.length,
                executionTime: window.performance.now() - startTime
              }
            });
            return records;
          },
          async Insert(headers, { records }) {
            if (records.length === 0)
              return [];
            const { data: results } = await axios$1({
              method: "POST",
              url: "/services/data/v53.0/composite/sobjects",
              data: {
                allOrNone: true,
                records
              },
              headers
            });
            return results;
          },
          async Delete(headers, { ids }) {
            const batches = [];
            while (ids.length)
              batches.push(ids.splice(0, 1e3));
            await Async.forEachParallel(batches, async (batch) => {
              await axios$1({
                method: "DELETE",
                url: "/services/data/v53.0/composite/sobjects",
                params: {
                  ids: batch.join(",")
                },
                headers
              });
            }, 5);
          },
          async tpRest(headers, { action, data }) {
            const { data: results } = await axios$1({
              method: "POST",
              url: `/services/apexrest/maps/TPRest/${action}`,
              data,
              headers
            });
            return results.data;
          },
          async ToolingQuery(headers, query) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/tooling/query/?q=${query}`,
              headers
            });
            return results;
          },
          async ToolingSObject(headers, { sObject }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/tooling/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async ToolingSObjectPatch(headers, { url, metadata }) {
            const { data: results } = await axios$1({
              method: "PATCH",
              url,
              data: metadata,
              headers
            });
            return results;
          },
          async SObjects(headers) {
            const { data: results } = await axios$1({
              method: "GET",
              url: "/services/data/v53.0/sobjects",
              headers
            });
            return results;
          },
          async SObject(headers, { sObject }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async RunSaql(headers, { query }) {
            var _a, _b;
            const startTime = window.performance.now();
            let res;
            try {
              const { data: results } = await axios$1({
                method: "POST",
                url: "/services/data/v53.0/wave/query",
                data: {
                  query
                },
                headers
              });
              res = results;
              return results;
            } catch (e) {
              SPM.$store.toast({ message: e.response.data[0].message, duration: 5e3, state: "error" });
              return { records: [] };
            } finally {
              SPM.Utils.Splunk.sendLog({
                logName: "spmSAQL",
                logPayload: {
                  query,
                  returnCount: ((_b = (_a = res == null ? void 0 : res.results) == null ? void 0 : _a.records) == null ? void 0 : _b.length) || 0,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
          },
          async GetDataflows(headers, { alias }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflows?hasCurrentOnly&q=${alias}`,
              headers
            });
            return results.dataflows || [];
          },
          async UpdateDataflow(headers, { dataflowId, definition }) {
            const { data: results } = await axios$1({
              method: "PATCH",
              url: `/services/data/v50.0/wave/dataflows/${dataflowId}`,
              data: {
                definition
              },
              headers
            });
            return results;
          },
          async RunDataflow(headers, { dataflowId }) {
            const { data: results } = await axios$1({
              method: "POST",
              url: "/services/data/v53.0/wave/dataflowjobs",
              data: {
                dataflowId,
                command: "Start"
              },
              headers
            });
            return results;
          },
          async GetDatasets(headers, { alias, hasCurrentOnly = true }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets?hasCurrentOnly=${hasCurrentOnly}&q=${alias}&filterGroup=Supplemental`,
              headers
            });
            return results.datasets || [];
          },
          async GetDataset(headers, { id }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets/${id}?t=${Date.now()}`,
              headers
            });
            return results;
          },
          async PatchDataset(headers, { id, metadata }) {
            await axios$1({
              method: "PATCH",
              url: `/services/data/v53.0/wave/datasets/${id}`,
              data: metadata,
              headers
            });
          },
          async GetDatasetMetadata(headers, { url }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `${url}/xmds/main`,
              headers
            });
            return results;
          },
          async GetCurrentDataflowJob(headers, { id }) {
            const { data: results } = await axios$1({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflowjobs/`,
              headers
            });
            results.dataflowJobs.filter((f) => f.label.includes(id));
            results.dataflowJobs.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
            return results.dataflowJobs[0];
          },
          async CreateExternalDataJob(headers, { metadata, alias, label, app, operation }) {
            const { data: results } = await axios$1({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalData",
              data: {
                Format: "Csv",
                LicenseType: SPM.isScratch ? "EinsteinAnalytics" : "Sonic",
                EdgemartAlias: alias,
                EdgemartLabel: label || alias,
                EdgemartContainer: app || "",
                Operation: operation,
                Action: "None",
                NotificationSent: "Always",
                MetadataJson: metadata
              },
              headers
            });
            return results;
          },
          async UploadCsvPart(headers, { parentId, csvPart, partNumber }) {
            const { data: results } = await axios$1({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalDataPart",
              data: {
                DataFile: csvPart,
                InsightsExternalDataId: parentId,
                PartNumber: partNumber
              },
              headers
            });
            return results;
          },
          async StartExternalDataJob(headers, { parentId }) {
            const { data: results } = await axios$1({
              method: "PATCH",
              url: `/services/data/v56.0/sobjects/InsightsExternalData/${parentId}`,
              data: {
                Action: "Process"
              },
              headers
            });
            return results;
          },
          async UploadAutoAssignmentData(headers, { scus, mapping }) {
            const uploadResponse = await Apex.invoke("GetAutoAssignmentUploadUrl", []);
            const data = {
              records: scus,
              mapping: mapping || {
                "Unique Id": "Id",
                "Assignment": "Assignment",
                "Boundaries": "Boundaries",
                "Locked": "Locked",
                "Latitude": "Latitude",
                "Longitude": "Longitude",
                "Weight": "Weight",
                "Volume": "Volume"
              }
            };
            await axios$1({
              method: "PUT",
              url: uploadResponse.externalDataUrl,
              headers: { "Content-Type": "application/json" },
              data
            });
            return uploadResponse.requestId;
          },
          async MoveDatasetToSharedFolder(headers, { datasetId }) {
            let response = await Apex.invoke("MoveDatasetToSharedFolder", [datasetId]);
            if (!response.success) {
              const folder = await Apex.invoke("Query", [`SELECT Id FROM Folder where Type = 'Insights' AND DeveloperName = 'Sales_Planning'`]);
              const data = {
                folder: { id: folder[0].Id }
              };
              ({ data: response } = await axios$1({
                method: "PATCH",
                url: `/services/data/v56.0/wave/datasets/${datasetId}`,
                headers,
                data
              }));
            }
            return response;
          }
        }
      };
      const HTTP = {
        async get({ url }) {
          const results = await axios$1({
            method: "GET",
            url
          });
          return results;
        }
      };
      const CRM = {
        MasterDetailRelationships: {
          sfsp__SalesNodeRuleItem__c: {
            sfsp__SalesNodeRule__c: true
          }
        },
        upsert: async ({ records, onProgress = () => {
        } }) => {
          const recordsToInsert = [];
          const recordsToUpdate = [];
          records.forEach((r) => (r.Id ? recordsToUpdate : recordsToInsert).push(r));
          const batches = [];
          while (recordsToInsert.length)
            batches.push({ type: "InsertSObjects", records: recordsToInsert.splice(0, 1e3) });
          while (recordsToUpdate.length)
            batches.push({ type: "UpdateSObjects", records: recordsToUpdate.splice(0, 1e3) });
          let recordsUpserted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            const primitiveRecords = batch.records.map((r) => {
              return Object.keys(r).reduce((obj, key) => {
                var _a, _b;
                const isPrivate = key.startsWith("_");
                const isTypeWithId = key === "sobjectType" && r.Id;
                const isChildRecords = key.endsWith("__r");
                const isUpdateMaster = batch.type === "UpdateSObjects" && ((_b = (_a = CRM.MasterDetailRelationships) == null ? void 0 : _a[r.sobjectType]) == null ? void 0 : _b[key]);
                const isReserved = ["CreatedBy", "CreatedById", "CreatedDate"].includes(key);
                if (!isPrivate && !isTypeWithId && !isChildRecords && !isUpdateMaster && !isReserved)
                  obj[key] = r[key];
                return obj;
              }, {});
            });
            const response = await Apex.invoke(batch.type, [primitiveRecords, true]);
            if (batch.type === "InsertSObjects") {
              response.forEach((r, i2) => batch.records[i2].Id = r.Id);
            }
            recordsUpserted += batch.records.length;
            onProgress(Math.floor(100 * recordsUpserted / records.length));
          }, 5);
        },
        delete: async ({ records, onProgress = () => {
        } }) => {
          const recordIdsToDelete = records.map((r) => r.Id).sort();
          const batches = [];
          while (recordIdsToDelete.length)
            batches.push(recordIdsToDelete.splice(0, 1e3));
          let recordsDeleted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            await Apex.invoke("DeleteIds", [batch, true]);
            recordsDeleted += batch.length;
            onProgress(Math.floor(100 * recordsDeleted / records.length));
          }, 5);
        }
      };
      const CRMA = {
        async checkDatasets(assignmentObject, options, callback = () => {
        }) {
          var _a, _b, _c;
          const toasts = [];
          const updateDatasets = async ({ recordsDataset, assignmentsDataset }) => {
            let canShare = true;
            await SPM.Utils.Async.forEachParallel([recordsDataset, assignmentsDataset], async (dataset) => {
              if (dataset.folder.name !== "Sales_Planning") {
                try {
                  const response = await SPM.Utils.Rest.invoke("MoveDatasetToSharedFolder", { datasetId: dataset.id });
                  if (response.folder)
                    dataset.folder = { name: "Sales_Planning" };
                } catch (err) {
                  canShare = false;
                }
              }
            });
            if (!canShare) {
              toasts.push({ showOnce: true, state: "warning", message: "This plan cannot be shared. Please see your admin about adding a Sales Planning app if you need to share with others." });
            }
            recordsDataset.dataflowStatus = "";
            assignmentsDataset.dataflowStatus = "";
            Object.assign(storeAssignment, { recordsDataset, assignmentsDataset, totalCount: recordsDataset.currentVersionTotalRowCount, assignmentCount: storeAssignment.assignmentCount || 0 });
            if (assignmentAsyncJob)
              Object.assign(assignmentAsyncJob, { status: "Success" });
            storeAssignment.asyncJob.status = "Success";
            callback();
          };
          const checkDataflowJobs = async (assignmentObject2, retries = 5) => {
            const { dataflowJobs } = await SPM.Utils.Apex.invoke("GetDataflowJobs", [SPM.$store.plan.Id, assignmentObject2.id]);
            const assignmentsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Assignments`);
            });
            const recordsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Records`);
            });
            if (!recordsJob || !assignmentsJob) {
              const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
              if (datasetResponse2) {
                await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                return 0;
              }
              await Async.wait(1e4);
              return retries;
            } else {
              assignmentObject2.recordsDataset.dataflowStatus = recordsJob.status;
              assignmentObject2.assignmentsDataset.dataflowStatus = assignmentsJob.status;
              if (!["Failure", "Warning", "Success"].includes(recordsJob.status) || !["Failure", "Warning", "Success"].includes(assignmentsJob.status)) {
                await Async.wait(1e4);
                return retries;
              } else if (["Success", "Warning"].includes(recordsJob.status) && ["Success", "Warning"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2) {
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                  if (["create", "update"].includes(options == null ? void 0 : options.type)) {
                    toasts.push(
                      recordsJob.status === "Warning" ? { message: `Assignment Object "${assignmentObject2.label}" was created with some warnings.`, duration: null, state: "warning", subMessage: `${SPM.orgDomainUrl}/analytics/dataManager` } : { message: `Assignment Object "${assignmentObject2.label}" was ${(options == null ? void 0 : options.type) === "create" ? "created" : "updated"}.`, duration: 3e3, state: "success" }
                    );
                    if (assignmentObject2.asyncJob.type === "Refresh Assignment Object")
                      await SPM.Utils.AssignmentObject.updateReferenceFields({ assignmentObject: assignmentObject2 });
                  }
                  return 0;
                }
                if (retries - 1 === 1) {
                  try {
                    await Promise.allSettled([
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
                    ]);
                  } catch (err) {
                  }
                }
                await Async.wait(1e4);
                return retries - 1;
              } else if (["Failure"].includes(recordsJob.status) || ["Failure"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2)
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                toasts.push({ message: `Assignment Object "${assignmentObject2.label}" dataflow had a failure ${(options == null ? void 0 : options.type) === "create" ? "creating" : options.type === "update" ? "updating" : "loading"}.`, duration: null, state: "error", subMessage: `Records: ${recordsJob.message}, Assignments: ${assignmentsJob.message}` });
                return 0;
              }
            }
          };
          const checkAsyncJobs = async (assignmentObject2) => {
            const latestJob = (await SPM.Utils.AssignmentObject.getSalesAsyncJobs({ objectId: assignmentObject2.id, statusFilter: ["Queued", "Running", "Waiting", "Failure"] }))[0] || false;
            if (!latestJob)
              return;
            SPM.$store.$patch((state2) => {
              const storeSalesAsyncJob = SPM.$store.salesAsyncJobs.find((job) => job.Id === latestJob.Id);
              if (storeSalesAsyncJob)
                Object.assign(storeSalesAsyncJob, latestJob);
              const storeAssignmentObject = state2.assignmentObjects.find((a) => a.id === assignmentObject2.id);
              if (storeAssignmentObject.recordsDataset && latestJob.sfsp__Status__c === "Waiting") {
                CRM.upsert({ records: [{ Id: latestJob.Id, sfsp__Status__c: "Success" }] });
                latestJob.sfsp__Status__c = "Success";
              }
              Object.assign(storeAssignmentObject.asyncJob, { id: latestJob.Id, type: latestJob.sfsp__Type__c, status: latestJob.sfsp__Status__c, details: latestJob.sfsp__Details__c });
              state2.hasChanged = true;
            });
            if (!["Success", "Warning"].includes(latestJob.sfsp__Status__c)) {
              if (["Failure"].includes(latestJob.sfsp__Status__c)) {
                return latestJob;
              } else {
                await Async.wait(5e3);
                return await checkAsyncJobs(assignmentObject2);
              }
            }
          };
          const assignmentAsyncJob = SPM.$store.salesAsyncJobs.find((s) => s.sfsp__SalesAssignmentObject__c === assignmentObject.Id);
          const storeAssignment = SPM.$store.assignmentObjects.find((a) => a.id === assignmentObject.Id);
          if (!storeAssignment) {
            const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
            if (asyncJobIndex > -1)
              SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            if (options.type === "delete") {
              callback();
              toasts.push({ message: `Assignment Object "${options.assignmentObject.sfsp__Label__c}" was deleted.`, duration: 3e3, state: "success" });
            }
            return;
          }
          let datasetResponse = null;
          try {
            datasetResponse = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject.Id, planId: SPM.$store.plan.Id });
          } catch (err) {
            const errorCode = ((_a = err.response) == null ? void 0 : _a.data[0].errorCode) || null;
            if (errorCode === "FUNCTIONALITY_NOT_ENABLED")
              toasts.push({ showOnce: true, state: "warning", message: "Some features may not work properly. Please contact your admin to ensure you are properly licensed.", duration: null });
          }
          if (datasetResponse)
            await updateDatasets({ recordsDataset: datasetResponse.recordsDataset, assignmentsDataset: datasetResponse.assignmentsDataset });
          if (assignmentAsyncJob) {
            const failedJob = await checkAsyncJobs(storeAssignment);
            if (!failedJob) {
              let retries = await checkDataflowJobs(storeAssignment, 5);
              while (retries !== 0) {
                retries = await checkDataflowJobs(storeAssignment, retries);
                await Async.wait(2e3);
              }
            } else {
              SPM.$store.toast({ message: `Can’t ${options.type === "create" ? "create" : "update"} the ${options.assignmentObject.sfsp__Label__c} assignment object. Try again or contact Salesforce Customer Support.`, duration: null, state: "error" });
            }
            if (failedJob || ["Warning", "Success"].includes(storeAssignment.asyncJob.status)) {
              if (assignmentAsyncJob.sfsp__Splunk__c)
                SPM.Utils.Splunk.sendLog(JSON.parse(assignmentAsyncJob.sfsp__Splunk__c));
              try {
                await SPM.Utils.CRM.delete({ records: [{ Id: assignmentAsyncJob.Id }] });
              } catch (err) {
              }
              const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
              if (asyncJobIndex > -1)
                SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            }
          }
          if (!((_b = storeAssignment == null ? void 0 : storeAssignment.recordsDataset) == null ? void 0 : _b.dimensions) || !((_c = storeAssignment == null ? void 0 : storeAssignment.assignmentsDataset) == null ? void 0 : _c.dimensions)) {
            try {
              const settle2 = await Promise.allSettled([
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
              ]);
              await checkDataflowJobs(storeAssignment, 1);
              if (settle2.some((s) => s.status === "rejected")) {
                toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
              }
            } catch (err) {
              toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
            }
          }
          toasts.forEach((toast) => {
            if (SPM.$store.showOnLoadToasts || !toast.showOnce)
              SPM.$store.toast(toast);
          });
          SPM.$store.showOnLoadToasts = false;
          return;
        }
      };
      const Async = {
        forEach: async (array, callback) => {
          for (let i2 = 0; i2 < array.length; i2++) {
            await callback(array[i2], i2, array);
          }
        },
        forEachParallel: (array, callback, threads) => {
          array = array.map((item) => item);
          return Promise.all(
            threads ? Array(threads).fill().map(() => (async () => {
              for (let item; item = array.shift(); )
                await callback(item);
            })()) : array.map((item, index) => (async () => callback(item, index, array))())
          );
        },
        forEachBulk: async (array, callback, blockCount) => {
          let blockStart = 0;
          while (blockStart < array.length) {
            const blockEnd = Math.min(blockStart + blockCount, array.length);
            for (let i2 = blockStart; i2 < blockEnd; i2++) {
              callback(array[i2]);
            }
            blockStart += blockCount;
            await Async.wait(1);
          }
        },
        wrapper: (callback) => (resolveAsync, rejectAsync) => {
          callback().then(resolveAsync).catch((err) => rejectAsync(err));
        },
        wait(milliseconds2, callback = async () => {
        }) {
          return new Promise((resolve2, reject) => setTimeout(() => {
            callback().then((val) => resolve2(val)).catch(reject);
          }, milliseconds2));
        }
      };
      const Store2 = {
        on(store2, event, callback) {
          store2.$onAction(async ({ name, args, after }) => {
            if (name === "emit" && args[0] === event)
              after(callback);
          });
        }
      };
      const Obj = {
        get(obj = {}, path, def2 = "") {
          const fullPath = path.replace(/\[/g, ".").replace(/]/g, "").split(".").filter(Boolean);
          return fullPath.every((part) => {
            obj = obj[part];
            return obj !== null && obj !== void 0;
          }) ? obj : def2;
        },
        compare(a, b, criteria) {
          const aVal = a[criteria];
          const bVal = b[criteria];
          if (aVal > bVal)
            return 1;
          if (aVal < bVal)
            return -1;
          return 0;
        },
        shallowCompare(a, b) {
          return Object.keys(a).length === Object.keys(b).length && Object.keys(a).every((key) => b.hasOwnProperty(key) && a[key] === b[key]);
        }
      };
      const Arr2 = {
        move(arr, from2, to2) {
          arr.splice(to2, 0, arr.splice(from2, 1)[0]);
        },
        splice(arr, fn) {
          if (arr.length === 0)
            return [];
          const spliced = [];
          arr.length - 1;
          for (let i2 = arr.length - 1; i2 >= 0; i2--) {
            if (fn(arr[i2]))
              spliced.push(arr.splice(i2, 1)[0]);
          }
          return spliced;
        }
      };
      const Tree2 = {
        inspect({ node, nodeCount = 1, depth = 1 }) {
          var _a;
          let maxDepth = depth;
          (_a = node == null ? void 0 : node.children) == null ? void 0 : _a.forEach((child) => {
            const childDetails = this.inspect({ node: child, depth: depth + 1 });
            nodeCount += childDetails.nodeCount;
            maxDepth = Math.max(maxDepth, childDetails.maxDepth);
          });
          return { nodeCount, maxDepth };
        }
      };
      const Rule = {
        RuleItem: {
          ETMOperators: {
            equals: "==",
            notEqual: "!=",
            lessThan: "<",
            lessOrEqual: "<=",
            greaterThan: ">",
            greaterOrEqual: ">=",
            contains: "like",
            notContain: "doesnotcontain",
            startsWith: "startsWith"
          },
          fromFilter(filter) {
            const isMeasure = typeof filter.value === "object";
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter.key,
              sfsp__Operator__c: isMeasure ? "between" : "==",
              sfsp__Value__c: isMeasure ? `${filter.value.from},${filter.value.to}` : filter.value
            };
          },
          fromRecordFilter(filter) {
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter.field,
              sfsp__Operator__c: filter.operator,
              sfsp__Value__c: filter.value
            };
          }
        },
        fromFilterSet(filterSet, assignmentObjectId, startItemIndex = 1) {
          const booleanFilterParts = [];
          const ruleItems = [];
          const ancestorFilters = filterSet[0].slice(0, filterSet[0].length - 1);
          const filters = filterSet.map((fs) => fs.slice(-1)[0]);
          if (ancestorFilters.length) {
            booleanFilterParts.push(ancestorFilters.map((f, index) => startItemIndex + index + ruleItems.length).join(" and "));
            ruleItems.push(...ancestorFilters.map((f) => Rule.RuleItem.fromFilter(f)));
          }
          const isMeasure = typeof filters[0].value === "object";
          if (isMeasure) {
            const indices = filters.map((f, index) => startItemIndex + index + ruleItems.length);
            booleanFilterParts.push(`(${indices.join(" or ")})`);
            ruleItems.push(...filters.map((f) => SPM.Utils.Rule.RuleItem.fromFilter(f)));
          } else {
            booleanFilterParts.push(String(startItemIndex + ruleItems.length));
            ruleItems.push({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filters[0].key,
              sfsp__Operator__c: "==",
              sfsp__Value__c: filters.map((f) => f.value).join(",")
            });
          }
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            sfsp__BooleanFilter__c: booleanFilterParts.join(" and "),
            sfsp__SalesNodeRuleItems__r: ruleItems.map((ruleItem, i2) => ({
              ...ruleItem,
              sfsp__SortOrder__c: i2 + 1
            }))
          };
        },
        fromBoundaries({ boundaries, boundaryObject }) {
          const containerSet = SPM.$store.containerSets[boundaryObject.containerSetId];
          let availableContainers = containerSet.containers;
          if (!boundaryObject.includesPoints) {
            availableContainers = Object.keys(availableContainers).filter((key) => !availableContainers[key].parent).reduce((res, key) => (res[key] = availableContainers[key], res), {});
          }
          const ruleItemOperator = "startsWith";
          boundaries = SPM.Utils.Rule.simplifyValues(Object.values(availableContainers).map((c) => c.name), boundaries);
          const ruleItemValues = [];
          let currentValue = "";
          boundaries.forEach((boundary) => {
            if (currentValue.length + boundary.length + 1 >= 1e3) {
              ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
              currentValue = "";
            }
            currentValue += `${boundary},`;
          });
          if (currentValue)
            ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            Name: containerSet.label,
            sfsp__SalesNodeBoundary__c: boundaryObject.id,
            sfsp__SortOrder__c: 1,
            sfsp__FilterLogic__c: "any",
            sfsp__BooleanFilter__c: Array(ruleItemValues.length).fill().map((v, i2) => i2 + 1).join(" or "),
            sfsp__SalesNodeRuleItems__r: ruleItemValues.map((value, i2) => ({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: boundaryObject.name,
              sfsp__Operator__c: ruleItemOperator,
              sfsp__Value__c: value,
              sfsp__SortOrder__c: i2 + 1
            }))
          };
        },
        toString(rule) {
          const expressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => `${item.sfsp__Field__c} ${item.sfsp__Operator__c} ${JSON.stringify(item.sfsp__Value__c)}`);
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, expressions);
        },
        toSaql(rule, assignmentObject) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: rule.sfsp__SalesNodeBoundary__c ? "Text" : assignmentObject.referenceFields.find((f) => f.id === item.sfsp__Field__c).type
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        },
        simplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const selectedTrie = new Trie$1.Trie();
          selectedValues.forEach((v) => selectedTrie.add(v));
          const simplifiedValues = /* @__PURE__ */ new Set();
          selectedValues.forEach((value) => {
            for (let i2 = 1; i2 <= value.length; i2++) {
              const matchString = value.slice(0, i2);
              if (selectedTrie.countChildren(matchString) === allTrie.countChildren(matchString)) {
                simplifiedValues.add(matchString);
                break;
              }
            }
          });
          return [...simplifiedValues];
        },
        unsimplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const unsimplifiedValues = selectedValues.map((v) => allTrie.prefixMatchingWords(v)).flat();
          return unsimplifiedValues;
        },
        validateCustomLogic(expression, numCriteria) {
          if (!expression || numCriteria == 0) {
            return false;
          }
          var numCritArr = [];
          for (let i2 = 1; i2 <= numCriteria; i2++) {
            numCritArr.push(i2.toString());
          }
          const pattern = /\d+/g;
          const values = expression.match(pattern);
          if (values) {
            for (let i2 = 0; i2 < values.length; i2++) {
              if (values[i2] < 1 || values[i2] > numCriteria) {
                return false;
              }
              let position = numCritArr.indexOf(values[i2]);
              if (position >= 0)
                numCritArr.splice(position, 1);
            }
          }
          if (numCritArr.length !== 0) {
            return false;
          }
          return this.validateBooleanExpr(expression);
        },
        validateBooleanExpr(expression) {
          let expressionLC = expression.toLowerCase();
          const pattern = /\(\d+\)|\d+ (?:and|or|\|\||\&\&) \d+|\d+/g;
          while (true) {
            const replaced = expressionLC.replace(pattern, "1");
            if (replaced == "1")
              return true;
            if (replaced == expressionLC)
              return false;
            expressionLC = replaced;
          }
        }
      };
      const Filter = {
        toSaql(filter) {
          const { field, operator, value = "", dataType } = filter;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] || ${field} is null)` : `${field} not in ["${values.join('","')}"]` : value ? `(${field} != "${value}" || ${field} is null)` : `(${field} != "" || ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        },
        evaluate({ filters, filterLogic, record }) {
          if (filters.length === 0)
            return true;
          const expressions = filters.map((filter) => {
            const { field, operator, value = "", dataType } = filter;
            const values = operator === "between" ? [value] : value.split(",");
            const recordValue = record[field];
            const recordValueLower = (recordValue || "").toString().toLowerCase();
            return values.some((v) => {
              switch (operator) {
                case "==":
                  return recordValue == v;
                case "!=":
                  return recordValue != v;
                case "like":
                  return recordValueLower.includes(v.toLowerCase());
                case "startsWith":
                  return recordValueLower.startsWith(v.toLowerCase());
                case "between":
                  const [from2, to2] = v.split(",");
                  return recordValue >= from2 && recordValue <= to2;
                case "<":
                  return recordValue < v;
                case "<=":
                  return recordValue <= v;
                case ">":
                  return recordValue > v;
                case ">=":
                  return recordValue >= v;
                default:
                  return false;
              }
            });
          });
          const mergedExpressions = Filter.mergeBooleanFilter(filterLogic, expressions);
          return Function(`"use strict";return (${mergedExpressions})`)();
        },
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i2 = 0; i2 < booleanFilter.length; i2++) {
            const char = booleanFilter[i2];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        removeBooleanFilterExpression(booleanFilter, expressionIndex, startIndex = 0) {
          booleanFilter = booleanFilter.toLowerCase();
          expressionIndex = String(expressionIndex);
          let currentToken = "";
          let matchingIndex;
          for (let i2 = startIndex; i2 < booleanFilter.length; i2++) {
            const char = booleanFilter[i2];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken === expressionIndex) {
              matchingIndex = i2 - String(expressionIndex).length;
              break;
            }
            if (Number(currentToken) > Number(expressionIndex)) {
              const newToken = String(Number(currentToken) - 1);
              booleanFilter = `${booleanFilter.slice(0, i2 - 1)}${newToken}${booleanFilter.slice(i2 - 1 + currentToken.length)}`;
              if (newToken.length < expressionIndex.length)
                i2--;
            }
            currentToken = "";
          }
          if (!matchingIndex && currentToken === expressionIndex) {
            matchingIndex = booleanFilter.length - String(expressionIndex).length;
          } else if (!matchingIndex && currentToken && Number(currentToken) > Number(expressionIndex)) {
            const newToken = String(Number(currentToken) - 1);
            booleanFilter = booleanFilter.replace(new RegExp(`${currentToken}$`), newToken);
          }
          if (matchingIndex) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, matchingIndex, expressionIndex.length);
            return Filter.removeBooleanFilterExpression(
              `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`,
              expressionIndex,
              start2
            );
          }
          let paramIndex;
          while ((paramIndex = booleanFilter.indexOf("()")) !== -1) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, paramIndex, 2);
            booleanFilter = `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`;
          }
          return booleanFilter;
        },
        getOperatorBounds(booleanFilter, matchingIndex, matchLength) {
          const matchingIndexEnd = matchingIndex + matchLength;
          let start2;
          let end2;
          if (matchingIndex > 4 && booleanFilter.slice(matchingIndex - 4, matchingIndex) === " or ") {
            start2 = matchingIndex - 4;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 4 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 4) === " or ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 4;
          } else if (matchingIndex > 5 && booleanFilter.slice(matchingIndex - 5, matchingIndex) === " and ") {
            start2 = matchingIndex - 5;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 5 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 5) === " and ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 5;
          } else {
            start2 = matchingIndex;
            end2 = matchingIndexEnd;
          }
          return { start: start2, end: end2 };
        }
      };
      const DeferredPromise = function() {
        this._promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
        this.then = this._promise.then.bind(this._promise);
        this.catch = this._promise.catch.bind(this._promise);
        this.finally = this._promise.finally.bind(this._promise);
        this[Symbol.toStringTag] = "Promise";
      };
      const Plan2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesPlan__c",
          Name: "",
          sfsp__SalesMetrics__r: [],
          sfsp__SalesAssignmentObjects__r: [],
          sfsp__SalesNodeMetrics__r: [],
          sfsp__ListViews__r: [],
          sfsp__SalesNodeBoundaries__r: [],
          sfsp__SalesPlanUsers__r: [],
          sfsp__SalesUserAccess__r: []
        })
      };
      const AssignmentObject = {
        getIcon(objName) {
          const icons = {
            Account: { category: "standard", name: "account", color: "#5867E8" },
            Lead: { category: "standard", name: "lead", color: "#FF5D2D" },
            Contact: { category: "standard", name: "contact", color: "#a094ed" },
            Opportunity: { category: "standard", name: "opportunity", color: "#fcb95b" },
            User: { category: "standard", name: "customers", color: "#06A59A" }
          };
          return icons[objName] || { category: "standard", name: "entity", color: "#f88962" };
        },
        getReferenceMetadata({ assignmentObject }) {
          return [
            ...assignmentObject.recordsDataset.dimensions.map((d) => ({ id: d.id, title: `Unique ${d.title}`, type: "unique" })),
            ...assignmentObject.recordsDataset.measures.reduce((arr, m) => [
              { id: m.id, title: `Sum of ${m.title}`, type: "sum" },
              { id: m.id, title: `Min ${m.title}`, type: "min" },
              { id: m.id, title: `Max ${m.title}`, type: "max" }
            ].concat(arr), [])
          ];
        },
        getFieldOptions({ assignmentObject, mode = "Record" }) {
          const aggregateIdPrefix = mode === "Record" ? "" : "sum__";
          const aggregateLabelPrefix = mode === "Record" ? "" : "Sum of ";
          const fields = assignmentObject.referenceFields.filter((f) => f.type === "Numeric" || mode === "Record").map(({ id, label, type, isNameField }) => ({
            id: `${aggregateIdPrefix}${assignmentObject.id}__${id}`,
            label: `${aggregateLabelPrefix}${label}`,
            type,
            isNameField
          }));
          if (mode === "Record") {
            SPM.$store.boundaryObjects.forEach((boundaryObject) => {
              var _a, _b;
              if ((_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name)) {
                fields.push({ id: `${assignmentObject.id}__${boundaryObject.name}`, label: boundaryObject.label, type: "Text" });
              }
            });
          }
          fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
          if (fields.find((f) => f.isNameField)) {
            fields.unshift(fields.splice(fields.findIndex((f) => f.isNameField), 1)[0]);
            if (mode === "Record") {
              fields.splice(
                1,
                0,
                { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
                { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
              );
            }
          } else if (mode === "Record") {
            fields.push(
              { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
              { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
            );
          }
          return fields;
        },
        getDefaultColumns({ assignmentObject, mode = "Record" }) {
          const fields = AssignmentObject.getFieldOptions({ assignmentObject, mode });
          if (fields.find((f) => f.isNameField)) {
            return fields.filter((f) => f.id !== `${assignmentObject.id}__Id`).map(({ id, type, isNameField }) => ({
              id,
              summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique",
              isNameField
            }));
          }
          return fields.map(({ id, type }) => ({
            id,
            summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique"
          }));
        },
        async getDatasetInfo({ alias }) {
          let response = {};
          let dataset = [];
          let metadata = {};
          if (!SPM.hasDataPipelinesAccess) {
            ({ datasets: response, metadata } = await SPM.Utils.Apex.invoke("GetDatasets", [alias]));
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
          } else {
            response = await SPM.Utils.Rest.invoke("GetDatasets", { alias });
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
            metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataset.currentVersionUrl });
          }
          return { dataset, metadata };
        },
        async loadDatasets({ assignmentObjectId, planId }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Records` });
          if (!recordsDataset || !recordsMetadata)
            return false;
          const { dataset: assignmentsDataset, metadata: assignmentsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Assignments` });
          if (!assignmentsDataset || !assignmentsDataset)
            return false;
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          Object.assign(assignmentsDataset, {
            measures: assignmentsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: assignmentsMetadata.measures,
            dimensions: assignmentsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          return { recordsDataset, assignmentsDataset };
        },
        async reassign({ objectId, reassignments }) {
          const recordAssignmentsMap = SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }).reduce((map2, node) => {
            if (node !== SPM.$store.rootNode) {
              node.assignments.forEach((a) => {
                if (a.sfsp__SalesAssignmentObject__c === objectId) {
                  map2[a.sfsp__RecordId__c] = map2[a.sfsp__RecordId__c] || [];
                  map2[a.sfsp__RecordId__c].push(a);
                }
              });
            }
            return map2;
          }, {});
          const assignmentsToDelete = [];
          const assignmentsToInsert = [];
          const impactedNodeIds = /* @__PURE__ */ new Set();
          reassignments.forEach(({ recordId, targetId }) => {
            const existingAssignments = recordAssignmentsMap[recordId];
            existingAssignments == null ? void 0 : existingAssignments.forEach((a) => {
              assignmentsToDelete.push(a);
              impactedNodeIds.add(a.sfsp__SalesNode__c);
            });
            let currentNode = SPM.$store.nodeMap[targetId];
            while (currentNode !== SPM.$store.rootNode) {
              impactedNodeIds.add(currentNode.id);
              assignmentsToInsert.push({
                sobjectType: "sfsp__SalesNodeAssignment__c",
                sfsp__SalesAssignmentObject__c: objectId,
                sfsp__RecordId__c: recordId,
                sfsp__AssignmentType__c: "Manual",
                sfsp__SalesNode__c: currentNode.id,
                sfsp__Status__c: "Active"
              });
              currentNode = SPM.$store.nodeMap[currentNode.parentId];
            }
          });
          await Promise.all([
            SPM.Utils.CRM.delete({ records: assignmentsToDelete }),
            SPM.Utils.CRM.upsert({ records: assignmentsToInsert })
          ]);
          impactedNodeIds.forEach((nodeId2) => {
            SPM.$store.nodeMap[nodeId2].assignments = SPM.$store.nodeMap[nodeId2].assignments.filter((a) => !assignmentsToDelete.includes(a));
            SPM.$store.nodeMap[nodeId2].assignments.push(...assignmentsToInsert.filter((a) => a.sfsp__SalesNode__c === nodeId2));
          });
        },
        async reassignBoundaries({ objectId, reassignments, isPreview, onProgress = () => {
        } }) {
          const boundaryObject = SPM.$store.boundaryObjects.find((o) => o.id === objectId);
          const rulesToDelete = [];
          const rulesToUpsert = [];
          SPM.$store.allNodes.forEach((node) => {
            if (node.id === "All Org")
              return;
            const nodeBoundaryMap = SPM.Utils.Node.getBoundaries({ node, boundaryObject, format: "map" });
            const considerSiblings = SPM.$store.rootNode.assignmentBehavior === "Exclusive";
            let isAffected = false;
            reassignments.forEach(({ boundary, targetId }) => {
              const targetNode = SPM.$store.nodeMap[targetId];
              const shouldHaveBoundary = node.id === targetNode.id || SPM.Utils.Node.isAncestor({ node: targetNode, ancestor: node, nodeMap: SPM.$store.nodeMap });
              if (shouldHaveBoundary && !nodeBoundaryMap[boundary]) {
                nodeBoundaryMap[boundary] = true;
                isAffected = true;
              } else if (considerSiblings && !shouldHaveBoundary && nodeBoundaryMap[boundary]) {
                delete nodeBoundaryMap[boundary];
                isAffected = true;
              }
            });
            if (isAffected) {
              if (isPreview) {
                const previewRules = [...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId)];
                rulesToDelete.push(...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = SPM.Utils.Rule.fromBoundaries({
                    boundaries: Object.keys(nodeBoundaryMap),
                    boundaryObject
                  });
                  previewRules.push(newBoundaryRule);
                }
                node.previewRules = previewRules;
              } else {
                rulesToDelete.push(...node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                node.rules = node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId);
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = {
                    ...SPM.Utils.Rule.fromBoundaries({
                      boundaries: Object.keys(nodeBoundaryMap),
                      boundaryObject
                    }),
                    sfsp__SalesNode__c: node.id
                  };
                  node.rules.push(newBoundaryRule);
                  rulesToUpsert.push(newBoundaryRule);
                }
              }
            }
          });
          if (isPreview)
            return;
          await SPM.Utils.CRM.upsert({
            records: rulesToUpsert,
            onProgress: (percent) => onProgress(`Saving Rules...${percent}%`)
          });
          const ruleItemsToUpsert = [];
          rulesToUpsert.forEach((rule) => {
            rule.sfsp__SalesNodeRuleItems__r.forEach((item) => {
              item.sfsp__SalesNodeRule__c = rule.Id;
              ruleItemsToUpsert.push(item);
            });
          });
          await SPM.Utils.CRM.upsert({
            records: ruleItemsToUpsert,
            onProgress: (percent) => onProgress(`Saving Rule Items...${percent}%`)
          });
          await SPM.Utils.CRM.delete({
            records: rulesToDelete,
            onProgress: (percent) => onProgress(`Cleaning Up...${percent}%`)
          });
        },
        async getSalesAsyncJobs({ objectId, statuses = [] }) {
          const objectFilter = objectId ? ` AND sfsp__SalesAssignmentObject__c = '${objectId}'` : "";
          const statusFilter = statuses.length > 0 ? ` AND sfsp__Status__c IN ('${statuses.join("','")}')` : "";
          return await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Name,
                    CreatedDate,
                    sfsp__Details__c,
                    sfsp__Status__c,
                    sfsp__Type__c,
                    sfsp__Splunk__c,
                    sfsp__SalesAssignmentObject__c,
                    sfsp__SalesAssignmentObject__r.Name,
                    sfsp__SalesAssignmentObject__r.sfsp__Label__c,
                    sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c
                FROM sfsp__SalesAsyncJob__c
                WHERE sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c = '${SPM.$store.plan.Id}'${objectFilter}${statusFilter}
                ORDER BY CreatedDate DESC
            `]) || [];
        },
        async updateReferenceFields({ assignmentObject }) {
          const referenceFields = JSON.parse((SPM.$store.plan.sfsp__SalesAssignmentObjects__r.find((obj) => obj.Id === assignmentObject.id) || {}).sfsp__ReferenceFields__c);
          referenceFields.forEach((field) => field.lastModifiedDate = Date.now());
          const [updatedAssignmentObject] = await SPM.Utils.Apex.invoke("UpdateSObjects", [
            [{
              Id: assignmentObject.id,
              Name: assignmentObject.name,
              sfsp__Label__c: assignmentObject.label,
              sfsp__ReferenceFields__c: JSON.stringify(referenceFields)
            }],
            true
          ]);
          SPM.$store.$patch((state2) => {
            const assignmentObjectIndex = state2.plan.sfsp__SalesAssignmentObjects__r.findIndex((a) => a.Id === assignmentObject.id);
            state2.plan.sfsp__SalesAssignmentObjects__r.splice(assignmentObjectIndex, 1, updatedAssignmentObject);
            state2.hasChanged = true;
          });
        }
      };
      const BoundaryObject = {
        Defaults: {
          type: "boundary",
          icon: "location",
          styles: {
            visible: true,
            opacity: 0.3
          }
        },
        getFieldOptions({ boundaryObject }) {
          const fields = [
            { id: "Name", label: boundaryObject.label, type: "Text" },
            { id: "AssignedTo", label: "Assigned To", type: "Text" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            fields.push(
              { id: `unique__${assignmentObject.id}__Id`, label: assignmentObject.label, type: "Numeric" },
              ...assignmentObject.referenceFields.filter((f) => f.type === "Numeric").map(({ id, label, type }) => ({
                id: `sum__${assignmentObject.id}__${id}`,
                label,
                type
              }))
            );
          });
          Object.entries(boundaryObject.metadata).forEach(([key, { label, type, visible }]) => {
            if (visible)
              fields.push({ id: `BoundaryMetadata:${key}`, label, type: type === "float" ? "Numeric" : "Text" });
          });
          return fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
        },
        getDefaultColumns({ boundaryObject }) {
          const defaultColumns = [
            { id: "Name", summaryFormat: "Unique" },
            { id: "AssignedTo", summaryFormat: "Unique" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            defaultColumns.push({ id: `unique__${assignmentObject.id}__Id`, summaryFormat: "Sum" });
          });
          return defaultColumns;
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: "{}"
        }),
        buildRows({ parentRow, childNodes, lazy, includeBoundaries = true }) {
          const childRows = [];
          childNodes.forEach((node) => {
            const row = {
              id: node.id,
              name: node.name,
              data: [
                { id: "Name", format: "Name", type: "custom", node },
                ...SPM.$store.assignmentObjects.filter((obj) => obj.recordsDataset.dimensions).map((assignment) => ({
                  id: assignment.id,
                  format: "Assignment",
                  type: "custom",
                  state: "loading",
                  value: 0,
                  columnName: assignment.name
                })),
                ...((includeBoundaries ? SPM.$store.boundaryObjects : []) || []).map((boundary) => ({
                  id: boundary.id,
                  format: "Boundary",
                  type: "custom",
                  state: "loading",
                  value: 0
                })),
                ...node.metrics.map((metric) => {
                  const salesMetric = SPM.$store.plan.sfsp__SalesMetrics__r.find((m) => m.Id === metric.sfsp__SalesMetric__c);
                  const monthKeys = [...Object.keys(metric)].filter((name) => name.startsWith("sfsp__Target_Month"));
                  const metricDetails = {
                    id: metric.Id,
                    format: "Allocation",
                    type: "custom",
                    dataType: salesMetric.sfsp__Type__c,
                    value: monthKeys.reduce((agg, field) => agg + metric[field], 0),
                    columnName: salesMetric.Name
                  };
                  metricDetails.overrideAmount = salesMetric.sfsp__TargetOverrideEnabled__c ? metric.sfsp__TargetOverrideType__c === "Percentage" ? metric.sfsp__TargetOverrideAmount__c / 100 * metricDetails.value : metric.sfsp__TargetOverrideAmount__c : 0;
                  return metricDetails;
                })
              ],
              parent: parentRow,
              children: [],
              childCount: 0,
              expanded: !lazy,
              loaded: !lazy
            };
            if (SPM.$store.hasSalesPlanningTemplateApp && SPM.$store.isEditor)
              row.data.splice(1, 0, { id: "SharedWith", format: "Shared with", type: "custom", node });
            childRows.push(row);
            parentRow.children.push(row);
          });
          parentRow.loaded = true;
          parentRow.expanded = true;
          return childRows;
        },
        async importHierarchy({ hierarchy, includeBoundaries = true }) {
          const rowMap = {};
          const traverse2 = (rows) => {
            rows.forEach((r) => {
              rowMap[r.id] = r;
              traverse2(r.children);
            });
          };
          traverse2(SPM.Components.Hierarchy.rows);
          let hierarchyNodes = [hierarchy];
          while (hierarchyNodes.length) {
            const parentIds = hierarchyNodes.map((n) => n.id);
            hierarchyNodes = hierarchyNodes.reduce((arr, hierarchyNode) => arr.concat(
              hierarchyNode.children.map((hierarchyChild) => Object.assign(hierarchyChild, {
                parentNode: SPM.$store.nodeMap[hierarchyNode.id] || { id: hierarchyNode.id, childCount: 0 }
              }))
            ), []);
            const nodesToInsert = hierarchyNodes.map((hierarchyNode, i2) => ({
              sobjectType: "sfsp__SalesNode__c",
              Name: hierarchyNode.name,
              sfsp__SalesPlan__c: SPM.$store.plan.Id,
              sfsp__Parent__c: hierarchyNode.parentNode.id.replace("All Org", ""),
              sfsp__Priority__c: hierarchyNode.parentNode.childCount + i2 + 1,
              sfsp__Color__c: SPM.Utils.Node.randomColor(),
              sfsp__AssignmentBehavior__c: "Exclusive"
            }));
            await SPM.Utils.CRM.upsert({ records: nodesToInsert });
            nodesToInsert.forEach((node, i2) => {
              hierarchyNodes[i2].id = node.Id;
              const parentId = node.sfsp__Parent__c || "All Org";
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              const newNode = {
                id: node.Id,
                name: node.Name,
                color: node.sfsp__Color__c,
                assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
                ownerId: "",
                ownerName: "",
                level: parentNode.level + 1,
                parentId,
                childCount: 0,
                children: [],
                metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => ({
                  ...SPM.Utils.NodeMetric.Defaults,
                  sfsp__SalesPlan__c: SPM.$store.plan.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  sfsp__SalesNode__c: node.Id
                })),
                users: [],
                accessRecords: [],
                rules: [],
                ruleLogics: {},
                previewRuleLogics: {},
                assignments: [],
                boundaries: [],
                referenceData: []
              };
              SPM.$store.nodeMap[newNode.id] = newNode;
              parentNode.children.push(newNode);
              rowMap[newNode.id] = this.buildRows({ parentRow: rowMap[parentNode.id], childNodes: [newNode], includeBoundaries })[0];
            });
            parentIds.forEach((parentId) => {
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              parentNode.childCount = parentNode.children.length;
              parentNode.children.forEach((childNode) => {
                childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
                childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
              });
            });
            SPM.$store.branch.descendantIds.push(...nodesToInsert.map((node) => node.Id));
          }
          this.calculateValues(SPM.Components.Hierarchy.rows);
        },
        getBoundaryValue({ cell, nodeId: nodeId2, boundaryObjectId }) {
          const count2 = SPM.Utils.Node.getBoundaries({ node: SPM.$store.nodeMap[nodeId2], boundaryObject: SPM.$store.boundaryObjects.find((o) => o.id === boundaryObjectId) }).length;
          cell.state = "loaded";
          cell.value = count2;
        },
        async getAssignmentValues({ nodeId: nodeId2, assignmentObjectId, referenceFields = [] }) {
          var _a;
          const assignmentObject = SPM.$store.assignmentObjects.find((o) => o.id === assignmentObjectId);
          if (!((_a = assignmentObject == null ? void 0 : assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions))
            return;
          const saql = SPM.Utils.Node.generateSaql({
            node: SPM.$store.nodeMap[nodeId2],
            assignmentObject,
            referenceFields,
            boundaryObjects: SPM.$store.boundaryObjects,
            nodeMap: SPM.$store.nodeMap,
            recordsDataset: assignmentObject.recordsDataset,
            assignmentsDataset: assignmentObject.assignmentsDataset,
            type: "cogroup"
          });
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          return ((results == null ? void 0 : results.records) || []).reduce((map2, rec) => {
            map2[rec.nodeId] = {};
            Object.entries(rec).forEach(([key, value]) => {
              if (key !== "nodeId")
                map2[rec.nodeId][key] = value;
            }, {});
            return map2;
          }, {});
        },
        calculateValues(rows) {
          const boundaryCalculations = [];
          const parentToObjectMap = {};
          const findValues = (parents) => {
            parents.forEach((row) => {
              var _a;
              const parentId = ((_a = row.parent) == null ? void 0 : _a.id) || "All Org";
              parentToObjectMap[parentId] = parentToObjectMap[parentId] || {};
              row.data.forEach((col) => {
                if (col.format === "Assignment" && col.state === "loading") {
                  parentToObjectMap[parentId][col.id] = parentToObjectMap[parentId][col.id] || {};
                  parentToObjectMap[parentId][col.id][row.id] = col;
                } else if (col.format === "Boundary" && col.state === "loading") {
                  boundaryCalculations.push({ cell: col, nodeId: row.id, boundaryObjectId: col.id });
                }
              });
              findValues(row.children);
            });
          };
          findValues(rows);
          SPM.Utils.Async.forEachParallel(boundaryCalculations, (boundaryToCalculate) => this.getBoundaryValue(boundaryToCalculate), 5);
          SPM.Utils.Async.forEach(Object.values(parentToObjectMap), async (assignmentObjectToCellMap) => {
            await SPM.Utils.Async.forEachParallel(Object.entries(assignmentObjectToCellMap), async ([assignmentObjectId, cellMap]) => {
              const nodeIds = Object.keys(cellMap);
              const lastSiblingId = nodeIds[nodeIds.length - 1];
              const assignmentValues = await this.getAssignmentValues({ nodeId: lastSiblingId, assignmentObjectId });
              nodeIds.forEach((nodeId2) => {
                var _a;
                const value = ((_a = assignmentValues[nodeId2]) == null ? void 0 : _a.count) || 0;
                cellMap[nodeId2].value = value;
                cellMap[nodeId2].state = "loaded";
              });
            }, 5);
          });
        },
        async getMaxLevel({ planId, nodeIds, currentLevel }) {
          if (nodeIds.includes(""))
            throw new Error("Blank node id is not supported");
          const fifthLevelChildNodes = await SPM.Utils.Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id IN ('${nodeIds.join("','")}')`]);
          if (fifthLevelChildNodes.length) {
            return Node2.getMaxLevel({ planId, nodeIds: fifthLevelChildNodes.map((n) => n.Id), currentLevel: currentLevel + 5 });
          }
          for (let i2 = 4; i2 > 0; i2--) {
            const ancestorPath = Array(i2).fill().map((item) => "sfsp__Parent__r").join(".");
            const nodes = await Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND ${ancestorPath}.Id IN ('${nodeIds.join("','")}') LIMIT 1`]);
            if (nodes.length) {
              return currentLevel + i2;
            }
          }
          return currentLevel;
        },
        async getNodeLevel({ nodeId: nodeId2 }) {
          var _a, _b, _c, _d, _e;
          let level = 1;
          while (nodeId2) {
            const node = (await Apex.invoke("Query", [`
                    SELECT Id,
                        sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                    FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
                `]))[0];
            let parentNode = node;
            while (parentNode = (_a = parentNode == null ? void 0 : parentNode.sfsp__Parent__r) == null ? void 0 : _a.Id)
              level++;
            nodeId2 = (_e = (_d = (_c = (_b = node == null ? void 0 : node.sfsp__Parent__r) == null ? void 0 : _b.sfsp__Parent__r) == null ? void 0 : _c.sfsp__Parent__r) == null ? void 0 : _d.sfsp__Parent__r) == null ? void 0 : _e.sfsp__Parent__r.Id;
          }
          return level;
        },
        async getDescendantIds({ planId, nodeIds }) {
          if (!nodeIds || nodeIds.length === 0)
            return [];
          const descendantIds = (await Apex.invoke("Query", [`
                SELECT Id, sfsp__SalesPlan__c, sfsp__Parent__r.Id FROM sfsp__SalesNode__c WHERE sfsp__Parent__r.Id IN ('${nodeIds.join("','")}') AND sfsp__SalesPlan__c = '${planId}'
            `])).map((node) => node.Id);
          return [
            ...descendantIds,
            ...await Node2.getDescendantIds({ planId, nodeIds: descendantIds })
          ];
        },
        async getAncestorIds({ nodeId: nodeId2 }) {
          if (!nodeId2 || nodeId2 === "All Org")
            return [];
          let node = (await Apex.invoke("Query", [`
                SELECT Id,
                    sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
            `]))[0];
          const ancestorIds = [];
          while (node = node.sfsp__Parent__r)
            ancestorIds.push(node.Id);
          return [
            ...ancestorIds,
            ...await Node2.getAncestorIds({ nodeId: ancestorIds[4] }),
            "All Org"
          ];
        },
        async loadScope({ planId, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false, rootNodeId, parentNodeIds = [] }) {
          if (rootNodeId && nodeMap[rootNodeId]) {
            parentNodeIds.push(rootNodeId);
            rootNodeId = null;
          }
          parentNodeIds = [...new Set(parentNodeIds)].filter((id) => {
            var _a;
            return !((_a = nodeMap[id || "All Org"]) == null ? void 0 : _a.children);
          });
          const parentNodeBatches = rootNodeId ? [[]] : [];
          let parentNodeIndex = 0;
          while (parentNodeIndex < parentNodeIds.length) {
            parentNodeBatches.push(parentNodeIds.slice(parentNodeIndex, parentNodeIndex + 1e3));
            parentNodeIndex += 1e3;
          }
          const nodes = [];
          await Async.forEachParallel(parentNodeBatches, async (batchIds) => {
            const parentClause = rootNodeId ? `(Id = '${rootNodeId}' OR sfsp__Parent__c = '${rootNodeId}')` : `sfsp__Parent__c IN ('${batchIds.join("','")}')`;
            const batchNodes = await Apex.invoke(
              "Query",
              [`
                        SELECT
                            Id,
                            Name,
                            sfsp__Parent__c,
                            sfsp__Color__c,
                            sfsp__Owner__c,
                            sfsp__Owner__r.Name,
                            sfsp__AssignmentBehavior__c,
                            sfsp__RuleLogics__c,
                            sfsp__HierarchyReferenceData__c,
                            (
                                SELECT
                                    Id,
                                    sfsp__TargetOverrideAmount__c,
                                    sfsp__TargetOverrideType__c,
                                    ${Array(12).fill().map((v, i2) => `sfsp__Target_Month${i2 + 1}__c`).join(", ")},
                                    sfsp__SalesMetric__c
                                FROM sfsp__SalesNodeMetrics__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c, sfsp__SalesAssignmentObject__c, sfsp__SalesNodeBoundary__c
                                FROM sfsp__SalesNodeRules__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c
                                FROM sfsp__SalesNodeBoundaries__r
                            ),
                            (
                                SELECT Id, sfsp__SalesNode__c, sfsp__User__c, sfsp__User__r.Name, sfsp__Role__c
                                FROM sfsp__SalesNodeUsers__r
                            ),
                            (
                                SELECT Id
                                FROM sfsp__SalesNodes__r
                            ),
                            (
                                SELECT Id, sfsp__User__r.Name, sfsp__AccessLevel__c, sfsp__SalesNode__r.Name FROM sfsp__SalesUserAccess__r 
                            )
                        FROM sfsp__SalesNode__c
                        WHERE sfsp__SalesPlan__c = '${planId}' AND ${parentClause}
                        ORDER BY sfsp__Priority__c ASC
                    `]
            );
            nodes.push(...batchNodes);
            if (loadRuleItems) {
              const batchRuleMap = batchNodes.reduce((map2, node) => {
                (node.sfsp__SalesNodeRules__r || []).forEach((rule) => {
                  rule.sfsp__SalesNodeRuleItems__r = [];
                  map2[rule.Id] = rule;
                });
                return map2;
              }, {});
              const batchRuleItems = Object.keys(batchRuleMap).length === 0 ? [] : await Apex.invoke(
                "Query",
                [`
                            SELECT Id, sfsp__SalesNodeRule__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                            FROM sfsp__SalesNodeRuleItem__c
                            WHERE sfsp__SalesNodeRule__c IN ('${Object.keys(batchRuleMap).join("','")}')
                        `]
              );
              batchRuleItems.forEach((item) => batchRuleMap[item.sfsp__SalesNodeRule__c].sfsp__SalesNodeRuleItems__r.push(item));
            }
            if (loadAssignments) {
              const batchNodeMap = batchNodes.reduce((map2, node) => {
                node.assignments = [];
                map2[node.Id] = node;
                return map2;
              }, {});
              const batchAssignments = Object.keys(batchNodeMap).length === 0 ? [] : await SPM.Utils.Rest.invoke(
                "Query",
                { query: `
                            SELECT sfsp__SalesNode__c, sfsp__SalesAssignmentObject__c, sfsp__AssignmentType__c, sfsp__RecordId__c, sfsp__Status__c
                            FROM sfsp__SalesNodeAssignment__c
                            WHERE sfsp__SalesNode__c IN ('${Object.keys(batchNodeMap).join("','")}') AND sfsp__Status__c != 'Deleted'
                        ` }
              );
              batchAssignments.forEach((assignment) => batchNodeMap[assignment.sfsp__SalesNode__c].assignments.push(assignment));
            }
          }, 5);
          let rootNodeLevel;
          if (rootNodeId) {
            rootNodeLevel = await Node2.getNodeLevel({ nodeId: rootNodeId });
            nodeMap[rootNodeId] = {
              level: rootNodeLevel,
              siblingIds: [],
              olderSiblingIds: [],
              users: [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: [],
              referenceData: []
            };
          }
          nodes.forEach((node) => {
            var _a, _b, _c;
            const nodeMetrics = node.sfsp__SalesNodeMetrics__r || [];
            const childNode = {
              ...nodeMap[node.Id],
              id: node.Id,
              name: node.Name,
              color: node.sfsp__Color__c,
              assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: node.sfsp__Owner__c || "",
              ownerName: ((_a = node == null ? void 0 : node.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: node.Id === rootNodeId ? rootNodeLevel : nodeMap[node.sfsp__Parent__c || "All Org"].level + 1,
              parentId: node.sfsp__Parent__c || "All Org",
              childCount: ((_b = node == null ? void 0 : node.sfsp__SalesNodes__r) == null ? void 0 : _b.length) || 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = nodeMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: node.sfsp__SalesNodeUsers__r || [],
              accessRecords: ((_c = node.sfsp__SalesUserAccess__r) == null ? void 0 : _c.map(({ sfsp__User__r, sfsp__User__c, sfsp__SalesNode__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: sfsp__SalesNode__c }))) || [],
              rules: node.sfsp__SalesNodeRules__r || [],
              ruleLogics: JSON.parse(node.sfsp__RuleLogics__c || "{}"),
              previewRuleLogics: {},
              assignments: node.assignments || [],
              boundaries: node.sfsp__SalesNodeBoundaries__r || [],
              referenceData: JSON.parse((node == null ? void 0 : node.sfsp__HierarchyReferenceData__c) || "[]")
            };
            nodeMap[node.Id] = childNode;
            const parentNode = nodeMap[node.sfsp__Parent__c || "All Org"];
            if (parentNode) {
              parentNode.children = parentNode.children || [];
              const childIndex = parentNode.children.findIndex((c) => c.id === childNode.id);
              if (childIndex === -1) {
                parentNode.children.push(childNode);
              } else {
                parentNode.children.splice(childIndex, 1, childNode);
              }
            }
          });
          const parentIdsToInit = rootNodeId ? [rootNodeId, ...parentNodeIds] : parentNodeIds;
          parentIdsToInit.forEach((parentId) => {
            const parentNode = nodeMap[parentId || "All Org"];
            parentNode.children = parentNode.children || [];
            parentNode.childCount = parentNode.children.length;
            parentNode.rules = parentNode.rules || [];
            parentNode.boundaries = parentNode.boundaries || [];
            parentNode.children.forEach((childNode) => {
              childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
              childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
            });
          });
        },
        async loadAncestors({ planId, nodeId: nodeId2, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false }) {
          var _a;
          const ancestorIds = await Node2.getAncestorIds({ nodeId: nodeId2 });
          if (!ancestorIds.length)
            return;
          if (!nodeMap["All Org"]) {
            const allOrgMetrics = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__TargetOverrideAmount__c, sfsp__TargetOverrideType__c, ${Array(12).fill().map((v, i2) => `sfsp__Target_Month${i2 + 1}__c`).join(", ")}, sfsp__SalesMetric__c FROM sfsp__SalesNodeMetric__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''`]);
            const planNodeBoundaries = await SPM.Utils.Rest.invoke("Query", { query: `SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c FROM sfsp__SalesNodeBoundary__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''` });
            nodeMap["All Org"] = {
              id: "All Org",
              name: "All Org",
              color: "#2C7ED0",
              assignmentBehavior: SPM.$store.plan.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: SPM.$store.plan.sfsp__Owner__c || "",
              ownerName: ((_a = SPM.$store.plan.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = allOrgMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: SPM.$store.plan.sfsp__SalesPlanUsers__r || [],
              accessRecords: SPM.$store.plan.sfsp__SalesUserAccess__r.filter((ua) => !ua.sfsp__SalesNode__c && !SPM.$store.availableAdminIds.has(ua.sfsp__User__c) && !SPM.$store.availableManagerIds.has(ua.sfsp__User__c)).map(({ sfsp__User__r, sfsp__User__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: "All Org" })) || [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: planNodeBoundaries,
              siblingIds: [],
              olderSiblingIds: []
            };
            await Node2.loadScope({ planId, metrics, nodeMap, loadRuleItems, loadAssignments, parentNodeIds: [""] });
          }
          let currentAncestor = nodeMap["All Org"].children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          while (currentAncestor.id !== nodeId2) {
            await Node2.loadScope({
              planId,
              metrics,
              nodeMap,
              loadRuleItems,
              loadAssignments,
              parentNodeIds: [currentAncestor.id]
            });
            currentAncestor = currentAncestor.children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          }
        },
        getProjectionFields({ node, referenceFields }) {
          const fields = /* @__PURE__ */ new Set(["Id"]);
          referenceFields.forEach((f) => fields.add(f.name));
          const checkParent = (node2) => {
            if (node2.parentId) {
              const parentNode = SPM.$store.nodeMap[node2.parentId];
              const allRules = [...parentNode.rules, ...parentNode.previewRules || []];
              allRules.forEach((rule) => {
                (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                  fields.add(ruleItem.sfsp__Field__c);
                });
              });
              [...parentNode.olderSiblingIds].forEach((nodeId2) => {
                const levelNode = SPM.$store.nodeMap[nodeId2];
                const allRules2 = [...levelNode.rules, ...levelNode.previewRules || []];
                allRules2.forEach((rule) => {
                  (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                    fields.add(ruleItem.sfsp__Field__c);
                  });
                });
              });
              checkParent(parentNode);
            }
          };
          checkParent(node);
          [...node.olderSiblingIds, node.id].forEach((nodeId2) => {
            const levelNode = SPM.$store.nodeMap[nodeId2];
            const allRules = [...levelNode.rules, ...levelNode.previewRules || []];
            allRules.forEach((rule) => {
              (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                fields.add(ruleItem.sfsp__Field__c);
              });
            });
          });
          return fields;
        },
        generateSaql({ node, assignmentObject, boundaryObjects, projectionFields, referenceFields = [], nodeMap, recordIds, type, returnType = "count", descendantNodes = [], descendantSaql = "", prefix = "", skipLoad = false, isBurndown = false }) {
          const dimensions = [...assignmentObject.recordsDataset.dimensions].map((d) => d.id);
          const measures = [...assignmentObject.recordsDataset.measures].map((d) => d.id);
          const uniqueIdField = "Id";
          prefix = prefix ? `${prefix}_` : "";
          if (!projectionFields) {
            if (returnType === "count") {
              projectionFields = this.getProjectionFields({ node, referenceFields });
            } else {
              projectionFields = /* @__PURE__ */ new Set([...dimensions, ...measures]);
            }
          }
          const referenceProjections = referenceFields.reduce((str, field) => {
            const aggregatePrefix = field.type === "Text" ? "unique" : "sum";
            str += ` ${aggregatePrefix}('${field.name}') as ${field.name},`;
            return str;
          }, "");
          function projection(dataStream = "") {
            const streamPrefix = dataStream ? `${dataStream}.` : "";
            return [
              ...dimensions.filter((d) => projectionFields.has(d)).map((d) => `${streamPrefix}${d} as ${d}`),
              ...measures.filter((m) => projectionFields.has(m)).map((m) => `sum(${streamPrefix}${m}) as ${m}`)
            ].join(", ");
          }
          function grouping() {
            return `(${dimensions.filter((d) => projectionFields.has(d)).map((f) => f).join(", ")})`;
          }
          if (!node.parentId) {
            const filterNodes = isBurndown && node === SPM.$store.rootNode ? [node, ...descendantNodes] : descendantNodes;
            return `
                    ${skipLoad ? `` : `
                            -- load records
                            q = load "${assignmentObject.recordsDataset.id}/${assignmentObject.recordsDataset.currentVersionId}";
                        `}

                    ------------------------------------------------------------------
                    -- All Possible
                    ------------------------------------------------------------------
                    ${recordIds ? `
                            all_possible = filter q by ${uniqueIdField} in ${JSON.stringify(recordIds)};
                            all_possible = foreach all_possible generate ${projection()};
                        ` : `
                            all_possible = filter q by ${filterNodes.length ? `(${filterNodes.map((n) => this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)).join(") && (")})` : `${uniqueIdField} is not null`};
                            all_possible = foreach all_possible generate ${projection()};
                        `}
                    ${descendantSaql || (returnType === "count" ? `
                            -- All Org
                            ${prefix}all_possible = group all_possible by all;
                            ${prefix}all_possible = foreach all_possible generate "All Org" as nodeId,${referenceProjections} count() as count;
                        ` : `
                            -- all records
                            ${prefix}all_possible = filter all_possible by ${uniqueIdField} != "";
                        `)}
                `.replace(/^ */gm, "");
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          let saql = "";
          [...node.olderSiblingIds.map((id) => nodeMap[id]), node].forEach((n, i2) => {
            const parentId = n.parentId.replace("All Org", "");
            saql += `
                    ------------------------------------------------------------------
                    -- ${n.name}${n.id !== node.id ? `(${node.name} sibling)` : ""}
                    ------------------------------------------------------------------
                `;
            saql += `
                    -- rules
                    ${n.id} = filter ${parentId || "all_possible"} by ${this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)};
                `;
            if (considerSiblings) {
              if (i2 === 0) {
                saql += `
                            -- exclusions
                            exclusions = union ${n.id}, ${n.id};
                        `;
              } else {
                saql += type === "join" ? `
                                -- remove exclusions from older siblings
                                ${n.id} = join ${n.id} by ${uniqueIdField} anti, exclusions by ${uniqueIdField};
                            ` : `
                                -- remove exclusions from older siblings
                                ${n.id} = cogroup ${n.id} by ${grouping()} left, exclusions by ${grouping()};
                                ${n.id} = foreach ${n.id} generate ${projection(n.id)}, exclusions.${uniqueIdField} as UnexceptionId;
                                ${n.id} = filter ${n.id} by UnexceptionId is null;
                            `;
                saql += `
                            -- exclusions
                            exclusions = union exclusions, ${n.id};
                        `;
              }
            }
          });
          if (!descendantSaql) {
            saql += `
                    ------------------------------------------------------------------
                    -- Results
                    ------------------------------------------------------------------
                `;
            if (returnType === "count") {
              const resultStreams = [];
              [nodeMap[node.parentId], ...node.olderSiblingIds.map((id) => nodeMap[id]), node].forEach((n) => {
                const streamId = n.id === "All Org" ? "all_possible" : n.id;
                saql += `
                            -- ${n.name}
                            ${prefix}${streamId} = group ${streamId} by all;
                            ${prefix}${streamId} = foreach ${prefix}${streamId} generate "${n.id}" as nodeId,${referenceProjections} count() as count;
                        `;
                resultStreams.push(`${prefix}${streamId}`);
              });
              saql += `
                        -- union results for target node, parent node, older siblings
                        results = union ${resultStreams.join(", ")};
                    `;
            } else {
              saql += `
                        -- all records
                        ${prefix}${node.id} = filter ${node.id} by ${uniqueIdField} != "";
                    `;
            }
          }
          return this.generateSaql({
            node: nodeMap[node.parentId || "All Org"],
            assignmentObject,
            boundaryObjects,
            projectionFields,
            nodeMap,
            recordIds,
            type,
            descendantNodes: descendantSaql ? [node, ...descendantNodes] : descendantNodes,
            descendantSaql: saql + descendantSaql
          });
        },
        generateRules(node, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown) {
          var _a, _b;
          const matchingRules = (node.previewRules || node.rules).filter((r) => {
            const matchesAssignmentObject = r.sfsp__SalesAssignmentObject__c === assignmentObject.id && r.state !== "deleted";
            return matchesAssignmentObject;
          });
          const matchingBoundaryRules = (node.previewRules || node.rules).filter((r) => {
            var _a2, _b2, _c;
            const boundaryField = (_a2 = boundaryObjects == null ? void 0 : boundaryObjects.find((o) => o.id === r.sfsp__SalesNodeBoundary__c)) == null ? void 0 : _a2.name;
            const matchesBoundary = (_c = (_b2 = assignmentObject.recordsDataset) == null ? void 0 : _b2.dimensions) == null ? void 0 : _c.some((f) => f.id === boundaryField);
            return matchesBoundary;
          });
          const matchingAssignments = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted");
          const burndownNodes = isBurndown ? node.children : [];
          if (matchingRules.length === 0 && matchingBoundaryRules.length === 0 && matchingAssignments.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} is null`;
          const ruleAndAssignmentSaqlParts = [];
          if (matchingRules.length) {
            const matchingRulesLogic = ((_a = node == null ? void 0 : node.previewRuleLogics) == null ? void 0 : _a[assignmentObject.id]) || ((_b = node == null ? void 0 : node.ruleLogics) == null ? void 0 : _b[assignmentObject.id]) || Array(matchingRules.length).fill().map((item, i2) => i2 + 1).join(" or ");
            const matchingRulesFilterExpression = SPM.Utils.Filter.mergeBooleanFilter(
              matchingRulesLogic,
              matchingRules.map((r) => Rule.toSaql(r, assignmentObject))
            );
            ruleAndAssignmentSaqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (matchingBoundaryRules.length) {
            ruleAndAssignmentSaqlParts.push(`(${matchingBoundaryRules.map((r) => Rule.toSaql(r, assignmentObject)).join(" || ")})`);
          }
          if (matchingAssignments.length) {
            ruleAndAssignmentSaqlParts.push(`${uniqueIdField} in ${JSON.stringify(matchingAssignments.map((a) => a.sfsp__RecordId__c))}`);
          }
          const saqlParts = [];
          if (ruleAndAssignmentSaqlParts.length) {
            saqlParts.push(`(${ruleAndAssignmentSaqlParts.join(" || ")})`);
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          if (considerSiblings) {
            const unexceptionIds = Node2.getUnexceptionIds(node, nodeMap, assignmentObject);
            if (unexceptionIds.length) {
              saqlParts.push(`${uniqueIdField} not in ${JSON.stringify(unexceptionIds)}`);
            }
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${Node2.generateRules(childNode, nodeMap, assignmentObject, boundaryObjects, uniqueIdField)})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        getUnexceptionIds(node, nodeMap, assignmentObject) {
          const nodeExceptionMap = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted").reduce((map2, a) => {
            map2[a.sfsp__RecordId__c] = a;
            return map2;
          }, {});
          const unexceptionMap = [];
          node.siblingIds.forEach((siblingId) => {
            const siblingNode = nodeMap[siblingId];
            const siblingIsOlder = node.olderSiblingIds.includes(siblingId);
            (siblingNode.previewAssignments || siblingNode.assignments).forEach((siblingAssignment) => {
              if (siblingAssignment.sfsp__SalesAssignmentObject__c !== assignmentObject.id || siblingAssignment.sfsp__Status__c === "Deleted")
                return;
              if (siblingIsOlder || !nodeExceptionMap[siblingAssignment.sfsp__RecordId__c])
                unexceptionMap[siblingAssignment.sfsp__RecordId__c] = siblingAssignment;
            });
          });
          return Object.keys(unexceptionMap);
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.children || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        getAncestors({ node, nodeMap }) {
          const ancestors = [];
          while (node = nodeMap[node.parentId]) {
            ancestors.unshift(node);
          }
          return ancestors;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node.parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        async getChildren({ node }) {
          const children = [];
          const childrenResponse = await SPM.Utils.Apex.invoke(
            "Query",
            [`
                    SELECT
                        Id,
                        Name,
                        sfsp__Parent__c,
                        (
                            SELECT
                                Id,
                                sfsp__TargetOverrideAmount__c,
                                sfsp__TargetOverrideType__c,
                                ${Array(12).fill().map((v, i2) => `sfsp__Target_Month${i2 + 1}__c`).join(", ")},
                                sfsp__SalesMetric__c
                            FROM sfsp__SalesNodeMetrics__r
                        ),
                        (
                            SELECT Id
                            FROM sfsp__SalesNodes__r
                        )
                    FROM sfsp__SalesNode__c
                    WHERE sfsp__SalesPlan__c = '${SPM.$store.plan.Id}' AND sfsp__Parent__c = '${node.id}'
                `]
          );
          childrenResponse.forEach((c) => {
            var _a;
            children.push({
              id: c.Id,
              name: c.Name,
              parentId: c.sfsp__Parent__c || "All Org",
              childCount: ((_a = c.sfsp__SalesNodes__r) == null ? void 0 : _a.length) || 0,
              metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => {
                const nodeMetric = (c.sfsp__SalesNodeMetrics__r || []).find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              })
            });
          });
          return children;
        },
        isExclusiveBranch({ node }) {
          return Node2.getDescendants({ nodes: [node] }).every((n) => n.assignmentBehavior === "Exclusive");
        },
        getBoundaryObjects({ node, nodeMap, includeDescendants = false }) {
          return [...Node2.getAncestors({ node, nodeMap }), ...includeDescendants ? Node2.getDescendants({ nodes: [node] }) : [node]].reduce((arr, n) => {
            arr.push(...(n.boundaries || []).map((b) => {
              const salesBoundary = SPM.$store.salesBoundaries.find((s) => s.Id === b.sfsp__SalesBoundary__c);
              const containerSet = SPM.$store.containerSets[b.sfsp__ContainerSet__c];
              const includesPoints = (salesBoundary == null ? void 0 : salesBoundary.sfsp__IncludePoints__c) || b.sfsp__IncludePoints__c;
              const fieldName = salesBoundary ? `${n.id === "All Org" || b.sfsp__SalesBoundary__c ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}${includesPoints ? "_points" : ""}` : `${n.id === "All Org" ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}`;
              return {
                id: b.Id,
                containerSetId: (salesBoundary == null ? void 0 : salesBoundary.sfsp__ContainerSet__c) || b.sfsp__ContainerSet__c,
                salesBoundary: b == null ? void 0 : b.sfsp__SalesBoundary__c,
                rootNodeId: n.id,
                name: fieldName,
                includesPoints,
                label: containerSet.label,
                metadata: containerSet.metadata,
                assignmentCount: 0,
                totalCount: containerSet.size + (b.sfsp__IncludePoints__c ? Object.keys(containerSet.childContainers || {}).length : 0),
                progress: null,
                icon: { category: "standard", name: "address", color: "#3BA755" }
              };
            }));
            return arr;
          }, []);
        },
        getBoundaries({ node, boundaryObject, format: format2 = "array" }) {
          let containers2 = SPM.$store.containerSets[boundaryObject.containerSetId].containers;
          if (!boundaryObject.includesPoints) {
            containers2 = Object.keys(containers2).filter((key) => !containers2[key].parent).reduce((res, key) => (res[key] = containers2[key], res), {});
          }
          if (boundaryObject.rootNodeId === node.id) {
            return format2 === "map" ? Object.values(containers2).reduce((map2, boundary) => {
              map2[boundary.name] = true;
              return map2;
            }, {}) : Object.values(containers2).map((boundary) => boundary.name);
          }
          const boundaryRule = (node.previewRules || node.rules).find((r) => r.sfsp__SalesNodeBoundary__c === boundaryObject.id);
          const boundaryValueMap = ((boundaryRule == null ? void 0 : boundaryRule.sfsp__SalesNodeRuleItems__r) || []).reduce((map2, ruleItem) => {
            ruleItem.sfsp__Value__c.split(",").forEach((v) => map2[v] = true);
            return map2;
          }, {});
          const boundaryPrefixValues = Object.keys(boundaryValueMap);
          const expandedBoundaries = SPM.Utils.Rule.unsimplifyValues(Object.values(containers2).map((c) => c.name), boundaryPrefixValues);
          const boundaries = expandedBoundaries.map((boundary) => containers2[boundary]);
          return format2 === "map" ? boundaries.reduce((map2, boundary) => {
            map2[boundary.name] = true;
            return map2;
          }, {}) : boundaries.map((boundary) => boundary.name);
        },
        async getBoundaryData({ nodes, boundaryObject }) {
          var _a, _b;
          const boundaryNodeMap = {};
          Node2.getDescendants({ nodes }).forEach((descendant) => {
            if (descendant.level > SPM.$store.scope)
              return;
            SPM.Utils.Node.getBoundaries({ node: descendant, boundaryObject }).forEach((boundary) => {
              boundaryNodeMap[boundary] = boundaryNodeMap[boundary] || [];
              const newBoundaryNodes = [];
              let isAncestor = false;
              boundaryNodeMap[boundary].forEach((n) => {
                if (SPM.Utils.Node.isAncestor({ node: n, ancestor: descendant, nodeMap: SPM.$store.nodeMap })) {
                  isAncestor = true;
                  return;
                } else if (!SPM.Utils.Node.isAncestor({ node: descendant, ancestor: n, nodeMap: SPM.$store.nodeMap })) {
                  newBoundaryNodes.push(n);
                }
              });
              if (!isAncestor)
                newBoundaryNodes.push(descendant);
              boundaryNodeMap[boundary] = newBoundaryNodes;
            });
          });
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === boundaryObject.name);
          });
          const containerMap = SPM.$store.containerMap[boundaryObject.containerSetId];
          const recordMap = {};
          Object.keys(boundaryNodeMap).forEach((boundary) => {
            recordMap[boundary] = {
              id: boundary,
              label: containerMap[boundary].label,
              nodeId: boundaryNodeMap[boundary][0].id,
              // nodeId is only used in exclusive assignment where there will be a single value
              AssignedTo: boundaryNodeMap[boundary].map((n) => n.name).join(", ")
            };
            objectsWithGeoField.forEach((o) => recordMap[boundary][o.id] = 0);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            nodes.forEach((node) => {
              saql += SPM.Utils.Node.generateSaql({
                node,
                assignmentObject,
                boundaryObjects: SPM.$store.boundaryObjects,
                nodeMap: SPM.$store.nodeMap,
                type: "cogroup",
                returnType: "records",
                prefix: "boundary",
                skipLoad: !!saql
              });
            });
            let rootStream = "all_possible";
            if (nodes.length > 1) {
              saql += `
                        ------------------------------------------------------------------
                        -- Combine Filter Nodes
                        ------------------------------------------------------------------
                        all_possible = union ${nodes.map((n) => `boundary_${n.id}`).join(", ")};
                    `;
            } else {
              rootStream = `boundary_${nodes[0].id.replace("All Org", "all_possible")}`;
            }
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, count() as '${assignmentObject.id}';
                    boundaries = order boundaries by '${assignmentObject.id}' desc;
                `;
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            ((results == null ? void 0 : results.records) || []).forEach((record) => {
              const existingRecord = recordMap[record[geoField.id]];
              if (existingRecord) {
                existingRecord[assignmentObject.id] = record[assignmentObject.id];
              }
            });
          }
          return Object.values(recordMap);
        },
        async getAssignments({ recordIds, assignmentObject, nodes = SPM.$store.scopeChildNodes }) {
          const assignments = recordIds.reduce((map2, id) => {
            map2[id] = [];
            return map2;
          }, {});
          await Async.forEachParallel(nodes, async (node) => {
            const saql = Node2.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              recordIds,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            results.records.forEach((record) => {
              var _a, _b, _c;
              const currentLevel = ((_c = (_b = SPM.$store.nodeMap) == null ? void 0 : _b[(_a = assignments[record.Id]) == null ? void 0 : _a[0]]) == null ? void 0 : _c.level) || 0;
              if (node.level > currentLevel) {
                assignments[record.Id] = [node.id];
              } else if (node.level === currentLevel) {
                assignments[record.Id].push(node.id);
              }
            });
          });
          return assignments;
        },
        async getAssignmentData({ nodes, includeDescendants = false, filters = [], filterLogic, assignmentObject, type, isBurndown }) {
          let saql = "";
          nodes.forEach((node) => {
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "filter",
              skipLoad: !!saql,
              isBurndown
            });
          });
          let rootStream = "all_possible";
          if (nodes.length > 1) {
            saql += `
                    ------------------------------------------------------------------
                    -- Combine Nodes
                    ------------------------------------------------------------------
                    all_possible = union ${nodes.map((n) => `filter_${n.id.replace("All Org", "all_possible")}`).join(", ")};
                `;
          } else {
            rootStream = `filter_${nodes[0].id.replace("All Org", "all_possible")}`;
          }
          if (filters.length) {
            const recordFiltersExpression = SPM.Utils.Filter.mergeBooleanFilter(
              filterLogic || Array(filters.length).fill("").map((item, i2) => i2 + 1).join(" and "),
              filters.map((f) => SPM.Utils.Filter.toSaql(f))
            );
            saql += `
                    ------------------------------------------------------------------
                    -- Record Filters
                    ------------------------------------------------------------------
                    q = filter ${rootStream} by ${recordFiltersExpression};
                `;
            rootStream = "q";
          }
          if (type === "aggregates") {
            const referenceMetadata = AssignmentObject.getReferenceMetadata({ assignmentObject });
            saql += `
                    ------------------------------------------------------------------
                    -- Measure Aggregation
                    ------------------------------------------------------------------
                    q = group ${rootStream} by all;
                    q = foreach q generate ${referenceMetadata.map(
              (m) => ["min", "max"].includes(m.type) ? `floor(${m.type}(${m.id})) as ${m.type}__${assignmentObject.id}__${m.id}` : `${m.type}(${m.id}) as ${m.type}__${assignmentObject.id}__${m.id}`
            ).join(", ")};
                `;
            const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            return referenceMetadata.reduce((map2, m) => {
              var _a, _b, _c, _d;
              map2[`${m.type}__${assignmentObject.id}__${m.id}`] = ["min", "max"].includes(m.type) ? (_b = (_a = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _a[0]) == null ? void 0 : _b[`${m.type}__${assignmentObject.id}__${m.id}`] : ((_d = (_c = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _c[0]) == null ? void 0 : _d[`${m.type}__${assignmentObject.id}__${m.id}`]) || 0;
              return map2;
            }, {});
          }
          if (type === "records") {
            saql += `
                    ------------------------------------------------------------------
                    -- Record Projections
                    ------------------------------------------------------------------
                    q = foreach ${rootStream} generate ${[
              ...assignmentObject.recordsDataset.dimensions.map((d) => d.id),
              ...assignmentObject.recordsDataset.measures.map((m) => m.id)
            ].map((f) => `${f} as ${assignmentObject.id}__${f}`).join(", ")};
                `;
            const { results: recordResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const records = Object.values(((recordResults == null ? void 0 : recordResults.records) || []).reduce((map2, record) => {
              const recordId = record[`${assignmentObject.id}__Id`];
              if (!map2[recordId])
                map2[recordId] = record;
              return map2;
            }, {}));
            const assignments = await SPM.Utils.Node.getAssignments({
              recordIds: records.map((r) => r[`${assignmentObject.id}__Id`]),
              assignmentObject,
              nodes: includeDescendants ? SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }) : SPM.$store.scopeNodes
            });
            const cachedNodeAssignments = /* @__PURE__ */ new Map();
            records.forEach((record) => {
              var _a;
              const recordId = record[`${assignmentObject.id}__Id`];
              assignments[recordId].forEach((nodeId2) => {
                if (!cachedNodeAssignments.has(nodeId2)) {
                  cachedNodeAssignments.set(nodeId2, new Map(SPM.$store.nodeMap[nodeId2].assignments.map((a) => [`${a.sfsp__RecordId__c}:${a.sfsp__SalesAssignmentObject__c}`, a])));
                }
              });
              record.NodeId = ((_a = assignments[recordId]) == null ? void 0 : _a[0]) || "";
              record.AssignedTo = assignments[recordId].join(", ");
              record.AssignmentType = assignments[recordId].map((nodeId2) => cachedNodeAssignments.get(nodeId2).has(`${recordId}:${assignmentObject.id}`) ? "Manual" : "Rule").join(", ") || "Rule";
            });
            return records;
          }
          if (type === "saql") {
            return { saql, rootStream };
          }
        },
        Colors: [
          // standard; a11y
          "#FFFA00",
          "#FF6E00",
          "#FF7B96",
          "#D31A28",
          "#D053FF",
          "#6C2777",
          "#46E71B",
          "#6FB384",
          "#68FFD7",
          "#01BFBF",
          "#ADD4F3",
          "#2C7ED0",
          // expanded
          "#e3abec",
          "#c2dbf7",
          "#9fd6ff",
          "#9de7da",
          "#9df0c0",
          "#fff099",
          "#fed49a",
          "#d073e0",
          "#86baf3",
          "#5ebbff",
          "#44d8be",
          "#3be282",
          "#ffe654",
          "#ffb758",
          "#bd35bd",
          "#5779c1",
          "#05007a",
          "#00aea9",
          "#3cba4c",
          "#f5bc25",
          "#f99221",
          "#580d8c",
          "#001970",
          "#0a2399",
          "#0b7477",
          "#0b6b50",
          "#b67e11",
          "#b85d0d"
        ],
        randomColor() {
          return SPM.Utils.Node.Colors[Math.floor(Math.random() * SPM.Utils.Node.Colors.length)];
        }
      };
      const NodeMetric = {
        Defaults: {
          sobjectType: "sfsp__SalesNodeMetric__c",
          sfsp__TargetOverrideAmount__c: 0,
          sfsp__TargetOverrideType__c: null,
          ...[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].reduce((fieldMap, monthIndex) => {
            fieldMap[`sfsp__Target_Month${monthIndex}__c`] = 0;
            fieldMap[`previewValue${monthIndex}`] = void 0;
            return fieldMap;
          }, {})
        },
        changeTarget({ nodeMetric, period, index, target, isPreview, startingMonth, customPercentages }) {
          function targetFieldName(i2) {
            return isPreview ? `previewValue${i2}` : `sfsp__Target_Month${i2}__c`;
          }
          if (customPercentages) {
            for (let i2 = 1; i2 < 13; i2++) {
              const monthValue = customPercentages[i2];
              nodeMetric[targetFieldName(i2)] = monthValue;
            }
          } else if (period === "Year") {
            const monthValue = Math.floor(target / 12);
            for (let i2 = 1; i2 < 12; i2++) {
              nodeMetric[targetFieldName(i2)] = monthValue;
            }
            nodeMetric[targetFieldName(12)] = monthValue + (target - monthValue * 12);
          } else if (period === "Quarter") {
            const monthValue = Math.floor(target / 3);
            let month = startingMonth + (index - 1) * 3 <= 12 ? startingMonth + (index - 1) * 3 : (startingMonth + (index - 1) * 3) % 12;
            for (let i2 = 0; i2 < 2; i2++) {
              nodeMetric[targetFieldName(month)] = monthValue;
              month = month + 1 <= 12 ? month + 1 : (month + 1) % 12;
            }
            nodeMetric[targetFieldName(month)] = monthValue + (target - monthValue * 3);
          } else {
            const month = index + startingMonth - 1 <= 12 ? index + startingMonth - 1 : (index + startingMonth - 1) % 12;
            nodeMetric[targetFieldName(month)] = target;
          }
        },
        getTarget({ nodeMetric, period = "Year", index = 0 }) {
          let startMonth;
          let endMonth;
          if (period === "Year") {
            startMonth = 1;
            endMonth = 12;
          } else if (period === "Quarter") {
            startMonth = (index - 1) * 3 + 1;
            endMonth = index * 3;
          } else {
            startMonth = index;
            endMonth = index;
          }
          let target = 0;
          for (let i2 = startMonth; i2 <= endMonth; i2++) {
            target += typeof nodeMetric[`previewValue${i2}`] === "undefined" ? nodeMetric[`sfsp__Target_Month${i2}__c`] : nodeMetric[`previewValue${i2}`];
          }
          return target;
        }
      };
      const Allocation = {
        generateAllocationDistributionTable() {
          const allocationTable = [];
          const quarterLength = SPM.FiscalPeriod.Quarter.length;
          const percentToAllocateEachQuarter = Math.round(100 / quarterLength * 10) / 10;
          for (let i2 = 0; i2 < quarterLength; i2++) {
            const months2 = SPM.FiscalPeriod.Quarter[i2];
            allocationTable[i2] = allocationTable[i2] || { months: [], percent: percentToAllocateEachQuarter, label: `Quarter ${i2 + 1}`, previewPercent: null };
            allocationTable[i2].percent = percentToAllocateEachQuarter;
            const percentToAllocateEachMonth = Math.round(percentToAllocateEachQuarter / months2.length * 10) / 10;
            for (let m = 0; m < months2.length - 1; m++) {
              const id = months2[m];
              const monthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[id] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, id - 1), { month: "long" });
              allocationTable[i2].months.push({
                label: monthLabel,
                percent: percentToAllocateEachMonth,
                id,
                previewPercent: null
              });
            }
            const lastMonthOfQuarter = months2[months2.length - 1];
            const lastMonthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[lastMonthOfQuarter] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, lastMonthOfQuarter - 1), { month: "long" });
            allocationTable[i2].months.push({
              label: lastMonthLabel,
              percent: Math.round((percentToAllocateEachMonth + (percentToAllocateEachQuarter - percentToAllocateEachMonth * months2.length)) * 10) / 10,
              id: lastMonthOfQuarter,
              previewPercent: null
            });
          }
          allocationTable[quarterLength - 1].percent = Math.round((percentToAllocateEachQuarter + (100 - percentToAllocateEachQuarter * quarterLength)) * 10) / 10;
          return allocationTable;
        },
        getPercentageChange(oldNumber, newNumber) {
          const decreaseValue = newNumber - oldNumber;
          const change = Math.floor(decreaseValue / oldNumber * 100);
          if (change === 0 || decreaseValue === 0) {
            return "0%";
          }
          if (change === Infinity) {
            return `+ ${newNumber}%`;
          }
          return change > 0 ? `+ ${change}%` : `- ${change * -1}%`;
        }
      };
      const ExternalData = {
        // https://developer.salesforce.com/docs/atlas.en-us.238.0.bi_dev_guide_ext_data.meta/bi_dev_guide_ext_data/bi_ext_data_overview.htm
        generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries }) {
          const fields = [];
          JSON.parse(assignmentObject.sfsp__ReferenceFields__c).forEach((f) => {
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${f.name}`,
              name: f.name,
              label: f.label,
              isUniqueId: f.unique,
              type: f.type,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.type === "Numeric") {
              field.precision = f.precision;
              field.scale = f.scale;
              field.defaultValue = 0;
            }
            if (["Latitude", "Longitude"].includes(f.type))
              field.type = "Text";
            fields.push(field);
          });
          const boundaryFields = [];
          geoBoundaries == null ? void 0 : geoBoundaries.forEach((boundary) => {
            const fieldName = `${boundary.sfsp__SalesNode__c || boundary.sfsp__SalesPlan__c}_${boundary.sfsp__ContainerSet__c}`;
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${fieldName}`,
              name: fieldName,
              label: boundary.Name,
              isUniqueId: false,
              type: "Text",
              isMultiValue: false,
              description: ""
            };
            const existingField = boundaryFields.find((f) => f.name === field.name);
            if (existingField)
              Object.assign(existingField, field);
            else
              boundaryFields.push(field);
          });
          fields.push(...boundaryFields);
          if (datasetType === "Assignments") {
            fields.push(
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentNode`,
                label: "Assignment Node",
                name: "AssignmentNode",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              },
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentType`,
                label: "Assignment Type",
                name: "AssignmentType",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              }
            );
          }
          return {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: assignmentObject.Id,
                label: `${planName} ${assignmentObject.sfsp__Label__c} ${datasetType}`,
                name: assignmentObject.Name,
                description: "",
                fields
              }
            ]
          };
        },
        async getDatasetRecords({ alias, assignmentObject }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias });
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          const datasetRowMap = {};
          const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
          await async function getBatch(offset2, batchSize) {
            const saql = `
                    // total records
                    records_batch = load "${recordsDataset.id}/${recordsDataset.currentVersionId}";
                    records_batch = foreach records_batch generate ${recordsDataset.dimensions.concat(recordsDataset.measures).map((field) => `'${field.id}' as '${field.id}'`).join(", ")};
                    records_batch = order records_batch by '${uniqueIdField}';
                    records_batch = offset records_batch ${offset2};
                    records_batch = limit records_batch ${batchSize};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            if (results.records.length === batchSize)
              await getBatch(offset2 + batchSize, batchSize);
          }(0, 1e4);
          return datasetRowMap;
        },
        async updateDataset({ planId, planName, datasetType, assignmentObject, geoBoundaries, rowsToUpdate }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const datasetRowMap = await this.getDatasetRecords({ alias: `${planId}_${assignmentObject.Id}_Records`, assignmentObject });
            const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
            rowsToUpdate.forEach((row) => {
              const existingRow = datasetRowMap[row[uniqueIdField]];
              if (existingRow) {
                Object.keys(row).forEach((fieldName) => {
                  existingRow[fieldName] = row[fieldName];
                });
                datasetRowMap[row[uniqueIdField]] = existingRow;
              }
            });
            const recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa2.unparse(batch);
              const chunkSize = 3e6;
              Papa2.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa2.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa2.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa2.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        },
        async createManualDataset({ planId, planName, datasetType, assignmentObject, records }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const recordBatches = [];
            while (records.length) {
              recordBatches.push(records.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => {
                return getValueFromRecord(field.name, record) || (field.type === "Text" ? "" : 0);
              })));
            }
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa2.unparse(batch);
              const chunkSize = 3e6;
              Papa2.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa2.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa2.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa2.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa2.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        }
      };
      const AutoAssignment = {
        async buildAssignmentObjectScus({ balanceField, geoAssignment, selectedObject, selectedRecords, targetNodeIds }) {
          const rootNodeId = SPM.$store.rootNode.id === "All Org" ? SPM.$store.plan.Id : SPM.$store.rootNode.id;
          const containerSetIds = /* @__PURE__ */ new Set();
          SPM.$store.boundaryObjects.forEach((o) => containerSetIds.add(o.containerSetId));
          const scus = {};
          selectedRecords.forEach((unit) => {
            var _a, _b;
            const boundaryFields = Object.keys(unit).filter((fieldName) => fieldName.startsWith(`${selectedObject.id}__${rootNodeId}`));
            const boundaryKey = boundaryFields.find((f) => !!unit[f]);
            let boundary = unit[boundaryKey] || "";
            const record = {
              Id: unit[`${selectedObject.id}__Id`],
              Locked: false,
              Boundaries: boundary || "",
              Weight: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0,
              Volume: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0
            };
            const latitudeField = (_a = selectedObject.latitude) == null ? void 0 : _a.name;
            const longitudeField = (_b = selectedObject.longitude) == null ? void 0 : _b.name;
            if (latitudeField && longitudeField) {
              record.Latitude = parseFloat(unit[`${selectedObject.id}__${latitudeField}`]);
              record.Longitude = parseFloat(unit[`${selectedObject.id}__${longitudeField}`]);
            }
            if (geoAssignment === "nonContiguous" && (!record.Latitude || !record.Longitude)) {
              const middleUSA = { latitude: 39.8283, longitude: 98.5795 };
              const radius = 944685;
              const randomPoint = randomLocation2.randomCirclePoint(middleUSA, radius);
              record.Latitude = randomPoint.latitude;
              record.Longitude = randomPoint.longitude;
            }
            if (record.Latitude && record.Longitude)
              scus[record.Id] = record;
          });
          const assignmentNodes = targetNodeIds.map((id) => SPM.$store.nodeMap[id]);
          for (const assignmentNode of assignmentNodes) {
            const saql = SPM.Utils.Node.generateSaql({
              node: assignmentNode,
              assignmentObject: selectedObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const boundaryRollup = results.records.reduce((agg, rec) => {
              const boundaryFields = Object.keys(rec).filter((fieldName) => fieldName.startsWith(rootNodeId));
              boundaryFields.forEach((fieldName) => {
                let boundary = rec[fieldName] || "";
                if (agg.includes(boundary))
                  ;
                else if (agg.length === 0)
                  agg = boundary;
                else
                  agg = `${agg},${boundary}`;
              });
              return agg;
            }, "");
            const weightRollup = results.records.reduce((agg, rec) => {
              if (scus[rec.Id])
                return agg;
              return agg + (balanceField === "Unit" ? 1 : rec[balanceField] || 0);
            }, 0);
            scus[`${assignmentNode.id}-Rollup`] = {
              Id: `${assignmentNode.id}-Rollup`,
              Assignment: assignmentNode.id,
              Boundaries: boundaryRollup,
              Locked: true,
              Latitude: 39.8283,
              Longitude: 98.5795,
              Weight: weightRollup,
              Volume: weightRollup
            };
          }
          return { scus: [...Object.values(scus)], containerSetIds };
        },
        async buildBoundaryObjectScus({ balanceField, selectedObject, selectedBoundaries, node }) {
          var _a, _b;
          const weightMap = {};
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === selectedObject.name);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "drilldown",
              skipLoad: !!saql
            });
            const rootStream = `drilldown_${node.id.replace("All Org", "all_possible")}`;
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === selectedObject.name);
            const aggregateProjection = balanceField === "Unit" ? `count() as ${balanceField}` : `sum('${balanceField}') as '${balanceField}'`;
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Filter
                    ------------------------------------------------------------------
                    ${rootStream} = filter ${rootStream} by ${geoField.id} ${node.id === SPM.$store.rootNode.id ? "in" : "not in"} ${JSON.stringify(selectedBoundaries)};

                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, ${aggregateProjection};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              const boundaryName = record[geoField.id];
              if (!weightMap[boundaryName])
                weightMap[boundaryName] = 0;
              weightMap[boundaryName] += record[balanceField];
            });
          }
          const scus = {};
          const boundaryMap = SPM.$store.containerMap[selectedObject.containerSetId];
          if (node.id !== SPM.$store.rootNode.id) {
            let boundaryRollup = "";
            let weightRollup = 0;
            let totalLat = 0;
            let totalLng = 0;
            Object.entries(weightMap).forEach(([boundary, weight]) => {
              if (boundaryRollup.length === 0)
                boundaryRollup = boundary;
              else
                boundaryRollup += `, ${boundary}`;
              totalLat += boundaryMap[boundary].metadata.lat;
              totalLng += boundaryMap[boundary].metadata.lng;
              weightRollup += weight;
            });
            const nodeId2 = node.id === "All Org" ? SPM.$store.plan.Id : node.id;
            scus[`${nodeId2}-Rollup`] = {
              Id: `${nodeId2}-Rollup`,
              Locked: true,
              Assignment: node.id,
              Boundaries: boundaryRollup,
              Weight: weightRollup,
              Volume: weightRollup,
              Latitude: totalLat / Object.keys(weightMap).length,
              Longitude: totalLng / Object.keys(weightMap).length
            };
          } else {
            selectedBoundaries.forEach((boundary) => {
              const weight = weightMap[boundary] || 0;
              scus[boundary] = {
                Id: boundary,
                Locked: false,
                Boundaries: boundary,
                Weight: weight,
                Volume: weight,
                Latitude: boundaryMap[boundary].metadata.lat,
                Longitude: boundaryMap[boundary].metadata.lng
              };
            });
          }
          return Object.values(scus);
        }
      };
      const Browser = {
        clearSelection() {
          var _a, _b, _c;
          (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.empty();
          (_b = window == null ? void 0 : window.getSelection()) == null ? void 0 : _b.removeAllRanges();
          (_c = document == null ? void 0 : document.selection) == null ? void 0 : _c.empty();
        },
        getCursorPosition(input, selectionPoint, { top: top2, left: left2 } = {}) {
          const { offsetLeft: inputX, offsetTop: inputY } = input;
          const div = document.createElement("div");
          const copyStyle = getComputedStyle(input);
          for (const prop of copyStyle)
            div.style[prop] = copyStyle[prop];
          const inputValue = input.tagName === "INPUT" ? input.value.replace(/ /g, ".") : input.value;
          div.textContent = inputValue.substr(0, selectionPoint);
          if (input.tagName === "TEXTAREA")
            div.style.height = "auto";
          if (input.tagName === "INPUT")
            div.style.width = "auto";
          const span = document.createElement("span");
          span.textContent = inputValue.substr(selectionPoint) || ".";
          div.appendChild(span);
          document.body.appendChild(div);
          div.style.position = "absolute";
          div.style.top = "0px";
          div.style.left = "-1000px";
          const { offsetLeft: spanX, offsetTop: spanY } = span;
          document.body.removeChild(div);
          return {
            x: inputX + spanX + (left2 || 0),
            y: inputY + spanY - input.scrollTop + (top2 || 0)
          };
        },
        // sets search params by replacing existing state (i.e. popstate event is not fired)
        setSearchParams(params = {}) {
          const url = new URL(window.location);
          for (const [key, value] of Object.entries(params)) {
            url.searchParams.set(key, value);
          }
          window.history.replaceState({}, "", url);
        }
      };
      const Str = {
        htmlEncode(str) {
          str = this.htmlDecode(str);
          return String(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        htmlDecode(stringValue) {
          let returnText = stringValue;
          if (typeof stringValue === "string") {
            if (typeof document === "object") {
              const txt = document.createElement("textarea");
              txt.innerHTML = stringValue;
              returnText = txt.value;
            } else {
              returnText = String(stringValue).replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }
          }
          return returnText;
        },
        sanitizeHTML(str) {
          const temp = document.createElement("div");
          temp.textContent = str;
          return temp.innerHTML;
        },
        splitLines(str) {
          return str.split(/\r?\n|\r|\n/g).filter((line) => !!line).map((line) => line.trim());
        },
        truncate(str, { length = 80, ellipsis = true } = {}) {
          return ellipsis && str.length > length && length >= 3 ? `${str.slice(0, length - 3)}...` : str.slice(0, length);
        }
      };
      const Pendo = {
        track(event, payload) {
          if (pendo.visitorId)
            pendo.track(event, payload);
          else
            console.log("Pendo is unable to track this event");
        }
      };
      const Splunk = {
        showLogs(logName = "spm*") {
          const baseSplunkUrl = `https://splunk-web.log-analytics.monitoring.aws-esvc1-useast2.aws.sfdc.is/en-US/app/search/search?q=search `;
          const searchParams = encodeURIComponent(` index=${SPM.instanceName} organizationId=${SPM.orgId} logRecordType=jsLog logName=${logName}`);
          window.open(`${`${baseSplunkUrl}${searchParams}&display.page.search.mode=verbose&dispatch.sample_ratio=1&earliest=-24h%40h&latest=now`}`);
        },
        sendLog({ txnId = SPM.$store.txnId || getGUID(), logName = "spmLog", logPayload = {} }) {
          if (logName === "spmEPT" && SPM.$store.eptCaptured)
            return;
          else if (logName === "spmEPT") {
            SPM.$store.eptCaptured = true;
            logPayload.ept = window.performance.now();
          }
          const logLines = [{
            logName,
            logLevel: "INFO",
            logAttrs: {
              txnId,
              ...logPayload
            }
          }];
          const iframe = document.createElement("iframe");
          iframe.style.display = "none";
          iframe.name = `jslogger_${Date.now()}`;
          document.body.appendChild(iframe);
          const logLinesInput = document.createElement("input");
          logLinesInput.style.display = "none";
          logLinesInput.name = "logLines";
          logLinesInput.value = JSON.stringify(logLines);
          const form = document.createElement("form");
          form.style.display = "none";
          form.method = "POST";
          form.action = `${SPM.orgDomainUrl}/_ui/common/request/servlet/JsLoggingServlet`;
          form.target = iframe.name;
          form.appendChild(logLinesInput);
          document.body.appendChild(form);
          form.submit();
          setTimeout(() => {
            form.remove();
            iframe.remove();
          }, 5e3);
        }
      };
      const Version244 = {
        /**
         * Waiting status metadata was introduced in version 244.4 to the SalesAsyncJob object on the Status field (picklist)
         * Picklist field values do not ship new or removed metadata values in managed package upgrades.
         * The new metadata values are only available on new installs. In this case 244.4 or higher
         * This check will run on every page load to see if the picklist value "Waiting" is available on the SalesAsyncJob object -> Status field
         */
        async checkAsyncJobWaitingStatus() {
          let toastMessage = "";
          try {
            const sObject = "sfsp__SalesAsyncJob__c";
            const statusField = "sfsp__Status__c";
            const sObjectDescribe = await SPM.Utils.Rest.invoke("SObject", { sObject });
            const field = sObjectDescribe.fields.find((f) => f.name === statusField);
            const waitingPicklistValue = field.picklistValues.find((f) => f.value === "Waiting");
            if (!waitingPicklistValue) {
              toastMessage = `Missing status "Waiting" on the ${statusField} field for the sobject ${sObject}`;
              const entityDefQuery = `SELECT DurableId, QualifiedApiName FROM EntityDefinition WHERE QualifiedApiName = '${sObject}'`;
              const entityRecords = await SPM.Utils.Rest.invoke("ToolingQuery", entityDefQuery);
              const entityRecord = entityRecords.records.length ? entityRecords.records[0] : null;
              if (entityRecord) {
                const sObjectToolingDescribe = await SPM.Utils.Rest.invoke("ToolingSObject", { sObject: "CustomField" });
                const toolingFieldsToQuery = sObjectToolingDescribe.fields.map((a) => a.name);
                const metadataCustomFieldQuery = `SELECT ${toolingFieldsToQuery.join(", ")} FROM CustomField WHERE DeveloperName = 'Status' AND EntityDefinitionId = '${entityRecord.DurableId}' AND NamespacePrefix = 'sfsp' LIMIT 1`;
                const customFieldRecords = await SPM.Utils.Rest.invoke("ToolingQuery", metadataCustomFieldQuery);
                if (!customFieldRecords.records.length) {
                  toastMessage = `Could not find ${statusField} field for the sobject ${sObject}`;
                  throw new Error(toastMessage);
                }
                const salesAsyncJobField = customFieldRecords.records.find((f) => f.FullName === `${sObject}.${statusField}`);
                if (!salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.find((f) => f.valueName === "Waiting")) {
                  salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.push({
                    color: null,
                    default: false,
                    description: null,
                    isActive: null,
                    label: "Waiting",
                    urls: null,
                    valueName: "Waiting"
                  });
                  salesAsyncJobField.Metadata.valueSet.valueSettings = [];
                  const metadata = { Metadata: salesAsyncJobField.Metadata, FullName: salesAsyncJobField.FullName };
                  const url = salesAsyncJobField.attributes.url;
                  try {
                    await SPM.Utils.Rest.invoke("ToolingSObjectPatch", { url, metadata });
                  } catch (ex) {
                    toastMessage = `Error updating ${statusField} field with picklist value "Waiting" for the sobject ${sObject}`;
                    throw new Error(ex);
                  }
                }
              } else {
                toastMessage = `Unable to find the sobject ${sObject}. Missing status "Waiting" on the ${statusField} field.`;
              }
              toastMessage = "";
            }
          } catch (e) {
            if (toastMessage !== "")
              SPM.$store.toast({ state: "error", message: `${toastMessage}.`, subMessage: "Please contact your admin to ensure Sales Planning is properly configured.", duration: null });
            console.log("checkAsyncJobWaitingStatus", e);
          }
        }
      };
      const Segment2 = SegClient({ Buffer: Buffer2, Papa: Papa2 });
      const Area = {
        getFieldValue(store2, area, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = area.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store2.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getAreaValue(area);
          } else if (fieldType === "Metadata") {
            fieldValue = area.metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = area[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store2, area, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Area.getFieldValue(store2, area, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store2, area, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Area.getFieldValue(store2, area, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store2, area, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Area.getFieldValue(store2, area, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store2, area, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Container = {
        getFieldValue(store2, containerUnit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = containerUnit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store2.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(containerUnit);
          } else if (fieldType === "Metadata") {
            fieldValue = containerUnit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "ContainerMetadata") {
            fieldValue = store2.state.containerSets.find((cs) => cs.id === containerUnit.ContainerSetId).containers[containerUnit.ContainerId].metadata[fieldId.replace(/^ContainerMetadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = containerUnit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store2, containerUnit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Container.getFieldValue(store2, containerUnit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store2, containerUnit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Container.getFieldValue(store2, containerUnit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store2, containerUnit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Container.getFieldValue(store2, containerUnit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store2, containerUnit, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Unit = {
        getFieldValue(store2, unit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = unit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store2.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(unit);
          } else if (fieldType === "Metadata") {
            fieldValue = unit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = unit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store2, unit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Unit.getFieldValue(store2, unit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store2, unit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Unit.getFieldValue(store2, unit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store2, unit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Unit.getFieldValue(store2, unit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store2, unit, overlay.altLabelFieldId);
          }
          return label;
        },
        get18CharacterId(store2, unit) {
          let id = unit.UnitId || "";
          if (id.length !== 15)
            return null;
          for (let i2 = 0; i2 < 3; i2++) {
            let flags = 0;
            for (let j = 0; j < 5; j++) {
              const c = id.charAt(i2 * 5 + j);
              if (c >= "A" && c <= "Z")
                flags += 1 << j;
            }
            id += "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345".charAt(flags);
          }
          return id;
        }
      };
      const PkChunking = {
        encode(int, charset) {
          let byCode = charset.byCode;
          if (int === 0) {
            return byCode[0];
          }
          var res = "", max2 = charset.length;
          while (int > 0) {
            res = byCode[int % max2] + res;
            int = Math.floor(int / max2);
          }
          return res;
        },
        decode(str, charset) {
          var byChar = charset.byChar, res = 0, length = str.length, max2 = charset.length, i2, char;
          for (i2 = 0; i2 < length; i2++) {
            char = str[i2];
            res += byChar[char] * Math.pow(max2, length - i2 - 1);
          }
          return res;
        },
        // NB: does not validate input
        indexCharset(str) {
          var byCode = {}, byChar = {}, length = str.length, i2, char;
          for (i2 = 0; i2 < length; i2++) {
            char = str[i2];
            byCode[i2] = char;
            byChar[char] = i2;
          }
          return { byCode, byChar, length };
        },
        /* strip the 6 digit id prefix, and last 3 digits (CRC check) if any
        * then base62 decode to convert to long
        */
        convertSalesforceIdToLong(salesforceId) {
          const salesforceIdStripped = salesforceId.substring(6, 15);
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          return this.decode(salesforceIdStripped, charset);
        },
        // base62 encode them, and add the id prefix back in
        convertLongToSalesforceId(idPrefix, longId) {
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          const sfNumId = Number(longId);
          const idStringB62 = this.encode(sfNumId, charset).padStart(9, 0);
          return idPrefix + idStringB62;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and break it into chunk ranges of specified size
        * Only works if all the IDs have the same pod identifier
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        chunkIdRange(startId, endId2, chunkSize) {
          const idPrefix = startId.substring(0, 6);
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const numberChunkList = this.chunkRange(startNum, endNum, 9, chunkSize);
          return numberChunkList.map((chunk) => {
            const first = this.convertLongToSalesforceId(idPrefix, chunk.first);
            const last = this.convertLongToSalesforceId(idPrefix, chunk.last);
            return { first, last };
          });
        },
        /*
        * This method is used to chunk up a large range of Long Integers into a list of smaller ranges.
        * start number, end number, and size of the chunks is passed in
        */
        chunkRange(firstNum, lastNum, totalLength, chunkSize) {
          const range = lastNum - firstNum;
          const numChunkList = [];
          if (range < chunkSize) {
            numChunkList.push({ first: firstNum, last: lastNum });
          } else {
            const numChunks = Math.trunc(range / chunkSize);
            let firstNumChunk = firstNum;
            let lastNumChunk = firstNum + chunkSize - 1;
            numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            for (let i2 = 1; i2 < numChunks; i2++) {
              firstNumChunk = lastNumChunk + 1;
              lastNumChunk = firstNumChunk + chunkSize - 1;
              numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            }
            const lastlastNumChunk = numChunkList[numChunkList.length - 1].last;
            if (lastlastNumChunk < lastNum) {
              numChunkList.push({ first: lastlastNumChunk + 1, last: lastNum });
            }
          }
          const numChunkListZeroPadded = numChunkList.map((numChunk) => ({
            first: (numChunk.first || "").toString().padStart(totalLength, 0),
            last: (numChunk.last || "").toString().padStart(totalLength, 0)
          }));
          return numChunkListZeroPadded;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and calculate the number of ids between the two
        * Use the unit count to calculate fragementation between the range we require and the actual ids present
        * Only works if all the IDs have the same pod identider
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        calculateFragmentation(startId, endId2, unitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          return totalRange / unitCount;
        },
        // split the range into the number of chunks specified by splitCount
        splitIdChunk(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return this.chunkIdRange(startId, endId2, chunkSize);
        },
        // Calculate the size of a chunk to split the input range into the number of splits specified
        // For example a range of 30002 with a split of 3 would result in a chunk size of 10001
        calculateChunkSizeToSplitRange(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return chunkSize;
        }
      };
      return {
        Debug: false,
        Apex,
        Rest,
        Pendo,
        Splunk,
        HTTP,
        CRM,
        CRMA,
        ExternalData,
        Async,
        Store: Store2,
        Obj,
        Arr: Arr2,
        Tree: Tree2,
        Rule,
        Filter,
        DeferredPromise,
        AutoAssignment,
        Plan: Plan2,
        AssignmentObject,
        BoundaryObject,
        Node: Node2,
        NodeMetric,
        Browser,
        Str,
        Map: MapUtil,
        Segment: Segment2,
        Allocation,
        Area,
        Container,
        Unit,
        PkChunking,
        Version244
      };
    }
    class MathStream {
      constructor(expressionString) {
        this.expressionString = expressionString;
        this.position = 0;
        this.nextChar = null;
      }
      // Returns the next character in the expression without advancing the position.
      peek() {
        if (this.nextChar === null) {
          this.nextChar = this.expressionString.charAt(this.position);
        }
        return this.nextChar;
      }
      // Returns the next character in the expression and advances the position.
      next() {
        var returnChar;
        if (this.nextChar !== null) {
          returnChar = this.nextChar;
          this.nextChar = null;
        } else {
          returnChar = this.expressionString.charAt(this.position);
        }
        this.position++;
        return returnChar;
      }
      // Moves to the next position in the expression.
      skip() {
        this.nextChar = null;
        this.position++;
      }
      // True if there are no more characters in the expression.
      get end() {
        return this.position >= this.expressionString.length;
      }
    }
    class MathLexer {
      static isWhitespace(c) {
        const regex = /^[ \t\n]$/;
        return regex.test(c);
      }
      static isDigit(c) {
        const regex = /^[0-9]$/;
        return regex.test(c);
      }
      static isFunctionStart(c) {
        const regex = /^[a-zA-Z_]$/;
        return regex.test(c);
      }
      static isFunction(c) {
        const regex = /^[a-zA-Z_0-9]$/;
        return regex.test(c);
      }
      static isNumericStart(c) {
        const regex = /^[0-9.]$/;
        return regex.test(c);
      }
      static isVariableStart(c) {
        return c === "[";
      }
      static isVariableEnd(c) {
        return c === "]";
      }
      static isStringStart(c) {
        return c === '"';
      }
      static isStringEnd(c) {
        return c === '"';
      }
      static isE(c) {
        const regex = /^[eE]$/;
        return regex.test(c);
      }
      static isSign(c) {
        const regex = /^[+-]$/;
        return regex.test(c);
      }
      constructor(expressionString) {
        this.stream = new MathStream(expressionString);
        this.nextToken = null;
        this.position = 0;
      }
      // Skips characters in the expression while the predicate function holds.
      skipWhile(predicate) {
        while (!this.stream.end && predicate(this.stream.peek())) {
          this.stream.next();
        }
      }
      // Skips characters in the expression while the predicate function holds.
      readWhile(predicate) {
        let str = "";
        while (!this.stream.end && predicate(this.stream.peek())) {
          str += this.stream.next();
        }
        return str;
      }
      // Attempts to read a number from the expression.
      readNumber() {
        let startPosition = this.stream.position;
        let numStr = "";
        numStr += this.readWhile(MathLexer.isDigit);
        if (!this.stream.end && this.stream.peek() === ".") {
          numStr += this.stream.next();
          numStr += this.readWhile(MathLexer.isDigit);
        }
        if (!this.stream.end && MathLexer.isE(this.stream.peek())) {
          numStr += this.stream.next();
          if (!this.stream.end && MathLexer.isSign(this.stream.peek())) {
            numStr += this.stream.next();
          }
          numStr += this.readWhile(MathLexer.isDigit);
        }
        let num = Number(numStr);
        if (isNaN(num)) {
          throw { error: "Invalid token", position: startPosition };
        }
        return num;
      }
      // Attempts to read a string from the expression.
      readString() {
        let startPosition = this.stream.position;
        this.stream.skip();
        let str = this.readWhile((c) => {
          return !MathLexer.isStringEnd(c);
        });
        if (this.stream.end) {
          throw {
            error: "Missing closing quote for string",
            position: startPosition
          };
        }
        this.stream.skip();
        return str;
      }
      readFunction() {
        return this.readWhile(MathLexer.isFunction);
      }
      readVariable() {
        let startPosition = this.stream.position;
        this.stream.skip();
        let variable = this.readWhile((c) => {
          return !MathLexer.isVariableEnd(c);
        });
        if (this.stream.end) {
          throw {
            error: "Missing closing bracket for variable",
            position: startPosition
          };
        }
        this.stream.skip();
        return variable;
      }
      // Reads and returns the next token from the expression. Returns null if the end of the expression is reached.
      readNext() {
        this.skipWhile(MathLexer.isWhitespace);
        if (this.stream.end) {
          return null;
        }
        let startPosition = this.stream.position;
        let c = this.stream.peek();
        switch (c) {
          case "(":
            this.stream.skip();
            return { type: "ParenStart" };
          case ")":
            this.stream.skip();
            return { type: "ParenEnd" };
          case ",":
            this.stream.skip();
            return { type: "Comma" };
          case "+":
            this.stream.skip();
            return { type: "Plus" };
          case "-":
            this.stream.skip();
            return { type: "Minus" };
          case "*":
            this.stream.skip();
            return { type: "Multiply" };
          case "/":
            this.stream.skip();
            return { type: "Divide" };
          case "^":
            this.stream.skip();
            return { type: "Exponentiation" };
          case "<":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "LessThanOrEqual" };
            }
            return { type: "LessThan" };
          case ">":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "GreaterThanOrEqual" };
            }
            return { type: "GreaterThan" };
          case "=":
            this.stream.skip();
            return { type: "EqualTo" };
          case "!":
            this.stream.skip();
            if (this.stream.peek() === "=") {
              this.stream.skip();
              return { type: "NotEqualTo" };
            }
        }
        if (MathLexer.isNumericStart(c)) {
          return {
            type: "Number",
            value: this.readNumber(),
            startPosition
          };
        }
        if (MathLexer.isStringStart(c)) {
          return {
            type: "String",
            value: this.readString(),
            startPosition
          };
        }
        if (MathLexer.isFunctionStart(c)) {
          return {
            type: "Function",
            value: this.readFunction(),
            startPosition
          };
        }
        if (MathLexer.isVariableStart(c)) {
          return {
            type: "Variable",
            value: this.readVariable(),
            startPosition
          };
        }
        throw { error: "Invalid token", position: this.stream.position };
      }
      // Returns the next token in the expression, but does not advance the position.
      // Returns null if the end of the expression is reached.
      peek() {
        if (this.nextToken === null && !this.stream.end) {
          this.nextToken = this.readNext();
        }
        return this.nextToken;
      }
      // Returns the next token in the expression and advances the position.
      // Returns null if the end of the expression is reached.
      next() {
        let returnToken;
        if (this.nextToken === null) {
          returnToken = this.stream.end ? null : this.readNext();
        } else {
          returnToken = this.nextToken;
          this.nextToken = null;
        }
        this.position = this.stream.position;
        return returnToken;
      }
      // Determines if the end of the expression has been reached.
      get end() {
        this.peek();
        return this.nextToken == null;
      }
    }
    class ConditionalNode {
      constructor(conditions, operator) {
        this.conditions = conditions;
        this.operator = operator;
      }
      evaluate() {
        switch (this.operator) {
          case "AND":
            return this.conditions.find((condition) => !condition.evaluate()) ? false : true;
          case "OR":
            return this.conditions.find((condition) => condition.evaluate()) ? true : false;
        }
      }
    }
    class RelationalNode {
      constructor(leftNode, rightNode, operator) {
        this.leftNode = leftNode;
        this.rightNode = rightNode;
        this.operator = operator;
      }
      evaluate() {
        switch (this.operator) {
          case "LessThan":
            return this.leftNode.evaluate() < this.rightNode.evaluate();
          case "LessThanOrEqual":
            return this.leftNode.evaluate() <= this.rightNode.evaluate();
          case "GreaterThan":
            return this.leftNode.evaluate() > this.rightNode.evaluate();
          case "GreaterThanOrEqual":
            return this.leftNode.evaluate() >= this.rightNode.evaluate();
          case "EqualTo":
            return this.leftNode.evaluate() === this.rightNode.evaluate();
          case "NotEqualTo":
            return this.leftNode.evaluate() !== this.rightNode.evaluate();
          default:
            return false;
        }
      }
    }
    class BooleanNode {
      constructor(boolVal, trueVal, falseVal) {
        this.boolVal = boolVal;
        this.trueVal = trueVal;
        this.falseVal = falseVal;
      }
      evaluate() {
        return this.boolVal.evaluate() ? this.trueVal.evaluate() : this.falseVal.evaluate();
      }
    }
    class VariableNode {
      constructor() {
        this.varValue = 0;
      }
      set value(varValue) {
        this.varValue = varValue;
      }
      evaluate() {
        return this.varValue;
      }
    }
    class ConstantNode {
      constructor(value) {
        this.value = value;
      }
      evaluate() {
        return this.value;
      }
    }
    class AdditionNode {
      constructor(addend1, addend2) {
        this.addend1 = addend1;
        this.addend2 = addend2;
      }
      evaluate() {
        return this.addend1.evaluate() + this.addend2.evaluate();
      }
    }
    class SubtractionNode {
      constructor(minuend, subtrahend) {
        this.minuend = minuend;
        this.subtrahend = subtrahend;
      }
      evaluate() {
        return this.minuend.evaluate() - this.subtrahend.evaluate();
      }
    }
    class MultiplicationNode {
      constructor(factor1, factor2) {
        this.factor1 = factor1;
        this.factor2 = factor2;
      }
      evaluate() {
        return this.factor1.evaluate() * this.factor2.evaluate();
      }
    }
    class DivisionNode {
      constructor(dividend, divisor) {
        this.dividend = dividend;
        this.divisor = divisor;
      }
      evaluate() {
        return this.dividend.evaluate() / this.divisor.evaluate();
      }
    }
    class NegationNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return this.term.evaluate() * -1;
      }
    }
    class ExponentiationNode {
      constructor(base, exponent) {
        this.base = base;
        this.exponent = exponent;
      }
      evaluate() {
        return Math.pow(this.base.evaluate(), this.exponent.evaluate());
      }
    }
    class SqrtNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.sqrt(this.term.evaluate());
      }
    }
    class LogNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.log(this.term.evaluate());
      }
    }
    class ExpNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.exp(this.term.evaluate());
      }
    }
    class AbsNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.abs(this.term.evaluate());
      }
    }
    class FloorNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.floor(this.term.evaluate());
      }
    }
    class CeilNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.ceil(this.term.evaluate());
      }
    }
    class RoundNode {
      constructor(term) {
        this.term = term;
      }
      evaluate() {
        return Math.round(this.term.evaluate());
      }
    }
    class MathParser {
      constructor(expressionString) {
        this.lexer = new MathLexer(expressionString);
        this.variables = /* @__PURE__ */ new Map();
      }
      // parse the expression and returns the node for evaluating
      parse() {
        if (this.lexer.end) {
          return new ConstantNode(0);
        }
        let node = this.parseAddSub();
        if (!this.lexer.end) {
          throw {
            error: "Expression does not end where expected",
            position: this.lexer.position
          };
        }
        return node;
      }
      parseRelation() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node = this.parseAddSub();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "LessThan":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "LessThan");
              break;
            case "LessThanOrEqual":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "LessThanOrEqual");
              break;
            case "GreaterThan":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "GreaterThan");
              break;
            case "GreaterThanOrEqual":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "GreaterThanOrEqual");
              break;
            case "EqualTo":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "EqualTo");
              break;
            case "NotEqualTo":
              this.lexer.next();
              node = new RelationalNode(node, this.parseAddSub(), "NotEqualTo");
              break;
          }
        } while (["LessThan", "GreaterThan", "GreaterThanOrEqual", "LessThanOrEqual", "EqualTo", "NotEqualTo"].includes(token2.type));
        return node;
      }
      // parse add and subtract operations
      parseAddSub() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node = this.parseMultDiv();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "Plus":
              this.lexer.next();
              node = new AdditionNode(node, this.parseMultDiv());
              break;
            case "Minus":
              this.lexer.next();
              node = new SubtractionNode(node, this.parseMultDiv());
              break;
          }
        } while (token2.type === "Plus" || token2.type === "Minus");
        return node;
      }
      // parse multiply and divide operations
      parseMultDiv() {
        let node = this.parseExp();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          switch (token2.type) {
            case "Multiply":
              this.lexer.next();
              node = new MultiplicationNode(node, this.parseExp());
              break;
            case "Divide":
              this.lexer.next();
              node = new DivisionNode(node, this.parseExp());
              break;
          }
        } while (token2.type === "Multiply" || token2.type === "Divide");
        return node;
      }
      // parse exponentiation operations
      parseExp() {
        let node = this.parseNegation();
        let token2;
        do {
          if (this.lexer.end) {
            break;
          }
          token2 = this.lexer.peek();
          if (token2.type === "Exponentiation") {
            this.lexer.next();
            node = new ExponentiationNode(node, this.parseExp());
          }
        } while (token2.type === "Exponentiation");
        return node;
      }
      // parse negation operations
      parseNegation() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let negate = false;
        let token2 = this.lexer.peek();
        switch (token2.type) {
          case "Plus":
            this.lexer.next();
            break;
          case "Minus":
            this.lexer.next();
            negate = true;
            break;
        }
        let node = this.parseParen();
        if (negate) {
          node = new NegationNode(node);
        }
        return node;
      }
      // parse expressions in parenthesis
      parseParen() {
        if (this.lexer.end) {
          throw { error: "Unexpected end of expression" };
        }
        let node;
        let token2 = this.lexer.peek();
        if (token2.type === "ParenStart") {
          this.lexer.next();
          node = this.parseAddSub();
          let closePosition = this.lexer.position;
          if (this.lexer.end || this.lexer.next().type !== "ParenEnd") {
            throw { error: "Missing closing parenthesis", position: closePosition };
          }
        } else {
          node = this.parseFuncVarNum();
        }
        return node;
      }
      // parse function calls, variables, and constants
      parseFuncVarNum() {
        let node;
        let token2 = this.lexer.next();
        if (token2.type === "Function") {
          if (!this.lexer.end && this.lexer.peek().type === "ParenStart") {
            this.lexer.next();
            let conditionArgs = [];
            let arg1Node, arg2Node, arg3Node;
            switch (token2.value.toLowerCase()) {
              case "pow":
                arg1Node = this.parseAddSub();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg2Node = this.parseAddSub();
                node = new ExponentiationNode(arg1Node, arg2Node);
                break;
              case "sqrt":
                arg1Node = this.parseAddSub();
                node = new SqrtNode(arg1Node);
                break;
              case "log":
                arg1Node = this.parseAddSub();
                node = new LogNode(arg1Node);
                break;
              case "exp":
                arg1Node = this.parseAddSub();
                node = new ExpNode(arg1Node);
                break;
              case "abs":
                arg1Node = this.parseAddSub();
                node = new AbsNode(arg1Node);
                break;
              case "floor":
                arg1Node = this.parseAddSub();
                node = new FloorNode(arg1Node);
                break;
              case "ceil":
                arg1Node = this.parseAddSub();
                node = new CeilNode(arg1Node);
                break;
              case "round":
                arg1Node = this.parseAddSub();
                node = new RoundNode(arg1Node);
                break;
              case "if":
                arg1Node = this.parseRelation();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg2Node = this.parseAddSub();
                if (this.lexer.end || this.lexer.next().type !== "Comma") {
                  throw {
                    error: "Expected comma",
                    position: this.lexer.position - 1
                  };
                }
                arg3Node = this.parseAddSub();
                node = new BooleanNode(arg1Node, arg2Node, arg3Node);
                break;
              case "and":
                conditionArgs.push(this.parseRelation());
                while (this.lexer.peek().type === "Comma") {
                  this.lexer.next();
                  conditionArgs.push(this.parseRelation());
                }
                node = new ConditionalNode(conditionArgs, "AND");
                break;
              case "or":
                conditionArgs.push(this.parseRelation());
                while (this.lexer.peek().type === "Comma") {
                  this.lexer.next();
                  conditionArgs.push(this.parseRelation());
                }
                node = new ConditionalNode(conditionArgs, "OR");
                break;
              default:
                throw { error: "Unknown function", position: token2.startPosition };
            }
            if (this.lexer.end || this.lexer.next().type !== "ParenEnd") {
              throw {
                error: "Missing closing parenthesis",
                position: this.lexer.position - 1
              };
            }
          } else {
            throw {
              error: "Missing starting parenthesis",
              position: token2.startPosition
            };
          }
        } else if (token2.type === "Number" || token2.type === "String") {
          node = new ConstantNode(token2.value);
        } else if (token2.type === "Variable") {
          node = this.variables.get(token2.value);
          if (node === void 0) {
            node = new VariableNode();
            this.variables.set(token2.value, node);
          }
        } else {
          throw { error: "Invalid token", position: token2.startPosition };
        }
        return node;
      }
    }
    class MathExpression {
      constructor(expressionString) {
        let parser = new MathParser(expressionString);
        this.root = parser.parse();
        this.variableMap = parser.variables;
      }
      // Returns the variable names used in the expression
      get variableNames() {
        let names = [];
        this.variableMap.forEach(function(variable, variableName) {
          names.push(variableName);
        });
        return names;
      }
      // Evaluates the expression using the given variable values and returns the result.
      evaluate(variableValues) {
        for (let [variable, node] of this.variableMap) {
          let value = variableValues.get(variable);
          if (value === void 0) {
            throw "Undefined variable: " + variable;
          }
          node.value = value;
        }
        return this.root.evaluate();
      }
    }
    const Plan = {
      defaults: () => ({
        sobjectType: "sfsp__SalesPlan__c",
        Name: "",
        sfsp__Type__c: "Quota",
        sfsp__ReferenceFields__c: "[]",
        _target: 0
      }),
      async import(rows) {
        const nodesByName = Object.values(SPM.Components.Root.nodeMap).reduce((map2, node) => {
          map2[node.Name] = node;
          return map2;
        }, {});
        const newNodesByName = rows.reduce((map2, row) => {
          if (!nodesByName[row.Territory])
            map2[row.Territory] = { ...SPM.Utils.Quota.Node.defaults(), Name: row.Territory, _parentName: row.Parent || "All" };
          return map2;
        }, {});
        if (Object.values(newNodesByName).some((newNode) => !nodesByName[newNode._parentName] && !newNodesByName[newNode._parentName]))
          throw "Invalid Parents";
        await SPM.Utils.CRM.upsert({ records: Object.values(newNodesByName) });
        const nodesToCalculate = /* @__PURE__ */ new Set();
        Object.values(newNodesByName).forEach((newNode) => {
          newNode.sfsp__SalesPlan__c = SPM.Components.Root.plan.Id;
          newNode.sfsp__Parent__c = (nodesByName[newNode._parentName] || newNodesByName[newNode._parentName]).Id.replace("all_org", "");
          newNode._parentId = newNode.sfsp__Parent__c || "all_org";
          SPM.Components.Root.nodeMap[newNode._parentId].sfsp__SalesNodes__r.push(newNode);
          SPM.Components.Root.nodeMap[newNode.Id] = newNode;
          nodesByName[newNode.Name] = SPM.Components.Root.nodeMap[newNode.Id];
          nodesToCalculate.add(nodesByName[newNode.Name]);
        });
        await SPM.Components.Root.loadUsers([...new Set(rows.map((r) => r.Owner))].filter((owner) => !!owner && owner !== "TBH"));
        const rollupsToCalculate = /* @__PURE__ */ new Set();
        await SPM.Utils.Async.forEach(rows, async (row) => {
          const node = nodesByName[row.Territory];
          const updatedColumns = SPM.Utils.Quota.Node.update(node, row);
          if (updatedColumns.length) {
            nodesToCalculate.add(node);
            updatedColumns.filter((c) => c.type === "Quota").forEach((c) => rollupsToCalculate.add(c));
          }
        });
        rollupsToCalculate.forEach(SPM.Utils.Quota.Column.calculateRollups);
        SPM.Components.Root.calculateNodes(rollupsToCalculate.size ? null : nodesToCalculate);
        await SPM.Utils.CRM.upsert({ records: nodesToCalculate });
      }
    };
    const Node$1 = {
      defaults: () => ({
        sobjectType: "sfsp__SalesNode__c",
        Name: "",
        sfsp__SalesNodes__r: [],
        _data: {}
      }),
      // getters
      getDescendants({ nodes }) {
        if (nodes.length === 0)
          return [];
        const childNodes = nodes.reduce((arr, n) => arr.concat(n.sfsp__SalesNodes__r || []), []);
        return [
          ...nodes,
          ...Node$1.getDescendants({ nodes: childNodes })
        ];
      },
      getLeafNodes({ nodes }) {
        const leafNodes = [];
        nodes.forEach((node) => leafNodes.push(...node.sfsp__SalesNodes__r.length ? Node$1.getLeafNodes({ nodes: node.sfsp__SalesNodes__r }) : [node]));
        return leafNodes;
      },
      // modifiers
      update(node, data = {}) {
        const updatedColumns = /* @__PURE__ */ new Set();
        Object.entries(data).forEach(([key, value]) => {
          const columnId = key.split(":")[0];
          const column = SPM.Components.Root.plan._columns.find((c) => c.id === columnId || c.id === key);
          if ((column == null ? void 0 : column.type) === "Numeric") {
            const newValue = parseFloat(value) || 0;
            if (node._data[key] !== newValue) {
              node._data[key] = newValue;
              updatedColumns.add(column);
            }
          }
          if ((column == null ? void 0 : column.type) === "Text") {
            if (node._data[key] !== value) {
              node._data[key] = value;
              updatedColumns.add(column);
            }
          }
          if ((column == null ? void 0 : column.type) === "Quota") {
            const quotaField = key.split(":")[1];
            if (["Target", "Quota"].includes(quotaField)) {
              const newValue = parseFloat(value) || 0;
              if (node._data[key] !== newValue) {
                node._data[key] = newValue;
                updatedColumns.add(column);
              }
            }
          }
          if (columnId === "Parent") {
            const currentParent = SPM.Components.Root.nodeMap[node._parentId];
            const newParent = Object.values(SPM.Components.Root.nodeMap).find((n) => n.Name === value) || SPM.Components.Root.nodeHierarchy;
            if (currentParent !== newParent) {
              Object.assign(node, {
                sfsp__Parent__c: newParent.Id.replace("all_org", ""),
                _parentId: newParent.Id
              });
              SPM.Utils.Arr.splice(currentParent.sfsp__SalesNodes__r, (n) => n.Id === node.Id);
              newParent.sfsp__SalesNodes__r.push(node);
              SPM.Components.Root.plan._columns.filter((c) => c.type === "Quota").forEach((c) => updatedColumns.add(c));
            }
          }
          if (columnId === "Owner") {
            const currentOwner = node.sfsp__Owner__r;
            const newOwner = SPM.Components.Root.usersByName[data.Owner];
            if ((currentOwner == null ? void 0 : currentOwner.Name) !== (newOwner == null ? void 0 : newOwner.Name)) {
              Object.assign(node, {
                sfsp__Owner__c: newOwner == null ? void 0 : newOwner.Id,
                sfsp__Owner__r: newOwner
              });
              updatedColumns.add("Owner");
            }
          }
        });
        node.sfsp__HierarchyReferenceData__c = JSON.stringify(
          Object.entries(node._data).reduce((map2, [key, value]) => {
            const columnId = key.split(":")[0];
            const column = SPM.Components.Root.plan._columns.find((c) => c.id === columnId || c.id === key);
            if ((column == null ? void 0 : column.type) === "Numeric") {
              map2[key] = value;
            }
            if ((column == null ? void 0 : column.type) === "Text") {
              map2[key] = value;
            }
            if ((column == null ? void 0 : column.type) === "Quota") {
              const quotaField = key.split(":")[1] || key;
              if (["Target", "Quota"].includes(quotaField)) {
                map2[key] = value;
              }
            }
            return map2;
          }, {})
        );
        return [...updatedColumns];
      },
      // calculators
      calculateColumns(node, { plan = SPM.Components.Root.plan } = {}) {
        const columnsToCalculate = plan._columns.filter((c) => c.type === "Formula" || c.type === "Quota" && c.expression);
        let column;
        let waitingColumnCount = 0;
        while (column = columnsToCalculate.shift()) {
          if (waitingColumnCount > columnsToCalculate.length)
            throw `Unable to calculate columns, please make sure there are no circular references.  First invalid column: {${SPM.Utils.Str.sanitizeHTML(column.label)}}`;
          if (new MathExpression(column.expression).variableNames.some((v) => [...columnsToCalculate, column].find((c) => c.id === v))) {
            columnsToCalculate.push(column);
            waitingColumnCount++;
            continue;
          }
          waitingColumnCount = 0;
          Node$1.calculateColumn({ node, column });
        }
      },
      calculateColumn({ node, column }) {
        const expression = new MathExpression(column.expression);
        const variableValues = /* @__PURE__ */ new Map();
        expression.variableNames.forEach((variableName) => {
          variableValues.set(variableName, node._data[variableName] || 0);
        });
        if (column.type === "Quota") {
          const target = +expression.evaluate(variableValues).toFixed();
          const quota = node._data[`${column.id}:Quota`] || 0;
          node._data[`${column.id}:Target`] = target;
          node._data[`${column.id}:Remaining`] = target - quota;
          node._data[`${column.id}:Progress`] = target ? 100 * quota / target : 100;
        } else {
          node._data[column.id] = +expression.evaluate(variableValues).toFixed();
        }
      }
    };
    const Column = {
      defaults: () => ({
        targetLabel: "Baseline",
        type: "Numeric",
        expression: ""
      }),
      types: () => ({
        Quota: { label: "Quota", description: "Hierarchical targets for allocation", icon: "hierarchy" },
        Numeric: { label: "Numeric", description: "Historic data, target, etc.", icon: "topic2" },
        Formula: { label: "Formula", description: "Column * Overassign = New Target", icon: "formula" },
        Text: { label: "Text", description: "Notes, comments, etc.", icon: "text" }
      }),
      calculateRollups(column, { nodeHierarchy = SPM.Components.Root.nodeHierarchy } = {}) {
        const rollup = (nodes) => {
          nodes.forEach((node) => {
            if (node.sfsp__SalesNodes__r.length > 0) {
              node._data[`${column.id}:Quota`] = rollup(node.sfsp__SalesNodes__r);
            }
            const quota = node._data[`${column.id}:Quota`] || 0;
            const target = node._data[`${column.id}:Target`] || 0;
            node._data[`${column.id}:Remaining`] = target - quota;
            node._data[`${column.id}:Progress`] = target ? 100 * quota / target : 100;
          });
          return nodes.reduce((total, node) => total + (node._data[`${column.id}:Quota`] || 0), 0);
        };
        rollup(nodeHierarchy.sfsp__SalesNodes__r);
      }
    };
    const helperUtils = {
      isColumnNameInvalid(name, columns) {
        const invalidSuffixRegex = /:(Quota|Target|Remaining|Progress)$/;
        const matchingCol = columns.find((c) => c.id === name.split(":")[0]);
        return !!matchingCol && invalidSuffixRegex.test(name);
      }
    };
    const QuotaUtils = {
      Plan,
      Node: Node$1,
      Column,
      helperUtils
    };
    const fetch = (url) => new Promise((resolve2, reject) => {
      console.log(url);
      const request = new XMLHttpRequest();
      request.onload = () => {
        if (request.status >= 200 && request.status < 400) {
          resolve2(request.responseText);
        } else {
          reject(request);
        }
      };
      request.onerror = () => console.error("Could not load the SVG.");
      request.open("GET", url, true);
      request.send();
    });
    const Icon = {
      name: "Icon",
      props: {
        assistiveText: String,
        button: Boolean,
        category: {
          type: String,
          default: "standard",
          validator(category) {
            if (!["action", "custom", "doctype", "standard", "utility"].includes(category)) {
              console.error("Invalid category. Please see documentation for valid categories.");
              return false;
            }
            return true;
          }
        },
        iconClass: {
          type: [Array, String]
        },
        inheritFillFromParent: Boolean,
        name: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          default: "",
          validator(size2) {
            if (size2 && !["xx-small", "x-small", "small", "large"].includes(size2)) {
              console.error("Invalid size. Please see documentation for valid sizes.");
              return false;
            }
            return true;
          }
        },
        src: String,
        svg: {
          type: [Object, String],
          validator(value) {
            const isString2 = typeof value === "string";
            const isESModule = typeof value === "object" && value.__esModule === true;
            return isString2 || isESModule;
          }
        },
        title: {
          type: String,
          default: ""
        },
        variant: {
          type: String,
          default: "default",
          validator(variant) {
            if (variant && !["inverse", "success", "warning", "error", "default", "none"].includes(variant)) {
              console.error("Invalid variant. Please see documentation for valid variants.");
              return false;
            }
            return true;
          }
        }
      },
      render() {
        const classes = [];
        if (!this.$props.button) {
          classes.push("slds-icon_container");
          if (this.hasFQIcon) {
            classes.push(`slds-icon-${this.$props.category}-${this.$props.name.replace(/_/g, "-")}`);
          }
        }
        const svgVNode = this.buildSVGVNode();
        const children = [svgVNode];
        if (this.$props.assistiveText) {
          children.push(
            h(
              "span",
              {
                class: "slds-assistive-text"
              },
              [this.$props.assistiveText]
            )
          );
        }
        if (this.$props.button) {
          return [children];
        }
        return h(
          "div",
          {
            class: classes,
            title: this.$props.title
          },
          [children]
        );
      },
      data() {
        return {
          processing: false,
          inlineData: null
        };
      },
      computed: {
        hasFQIcon() {
          return this.$props.category && this.$props.name;
        },
        computedFill() {
          return this.$props.button || this.hasFQIcon && this.$props.category === "utility" ? "inherit" : this.$props.fill;
        }
      },
      watch: {
        $props: {
          handler() {
            this.process();
          },
          deep: true,
          immediate: true
        }
      },
      inject: ["$__getIconSettings"],
      methods: {
        validateSources() {
          let numSources = 0;
          if (this.$props.src)
            numSources++;
          if (this.$props.svg)
            numSources++;
          if (this.hasFQIcon)
            numSources++;
          if (numSources === 0 || numSources > 1) {
            throw new Error("You must provide exactly one icon source.");
          }
        },
        async process() {
          if (this.processing)
            return;
          this.validateSources();
          try {
            this.processing = true;
            if (this.$props.src) {
              this.inlineData = await fetch(this.$props.src);
            } else if (this.$props.svg) {
              this.inlineData = this.$props.svg;
            }
          } finally {
            this.processing = false;
          }
        },
        buildSVGVNode() {
          const iconClasses = this.getIconClasses();
          const baseAttrs = {
            "aria-hidden": true,
            focusable: false,
            "data-key": this.$props.name
          };
          if (this.inlineData) {
            const fragment = document.createRange().createContextualFragment(this.inlineData);
            const svg = Array.from(fragment.childNodes).find((child) => child.nodeName === "svg");
            svg.classList.add(...iconClasses);
            if (this.$props.inheritFillFromParent) {
              svg.querySelectorAll("g, path").forEach((el) => {
                el.style.fill = "inherit";
              });
            }
            const attrs = Object.values(svg.attributes).reduce((result, attr) => {
              result[attr.name] = attr.value;
              return result;
            }, baseAttrs);
            return h(
              "svg",
              {
                ...attrs,
                class: iconClasses,
                innerHTML: svg.innerHTML
              }
            );
          }
          return h(
            "svg",
            {
              ...baseAttrs,
              class: iconClasses
            },
            [
              h(
                "use",
                {
                  href: this.getAssetURL()
                }
              )
            ]
          );
        },
        getAssetURL() {
          const {
            iconPath,
            actionSpritePath,
            customSpritePath,
            doctypeSpritePath,
            standardSpritePath,
            utilitySpritePath
          } = this.$__getIconSettings();
          if (iconPath) {
            return `${iconPath}/${this.$props.category}-sprite/svg/symbols.svg#${this.$props.name}`;
          }
          switch (this.$props.category) {
            case "action":
              return `${actionSpritePath}/symbols.svg#${this.$props.name}`;
            case "custom":
              return `${customSpritePath}/symbols.svg#${this.$props.name}`;
            case "doctype":
              return `${doctypeSpritePath}/symbols.svg#${this.$props.name}`;
            case "standard":
              return `${standardSpritePath}/symbols.svg#${this.$props.name}`;
            case "utility":
              return `${utilitySpritePath}/symbols.svg#${this.$props.name}`;
            default:
              throw new Error("Invalid path");
          }
        },
        getIconClasses() {
          const iconClasses = [];
          if (this.$props.category === "utility" && this.$props.variant !== "none") {
            iconClasses.push(`slds-icon-text-${this.$props.variant}`);
          }
          if (Array.isArray(this.iconClass)) {
            this.iconClass.forEach((cssClass) => iconClasses.push(cssClass));
          } else if (this.iconClass) {
            iconClasses.push(this.iconClass);
          }
          if (!this.$props.button && this.hasFQIcon) {
            iconClasses.push("slds-icon");
            if (this.$props.size) {
              iconClasses.push(`slds-icon_${this.$props.size}`);
            }
          }
          return iconClasses;
        }
      }
    };
    const ButtonIcon = {
      name: "Button",
      components: { Icon },
      props: {
        assistiveText: {
          type: String,
          required: true
        },
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        iconClass: {
          type: [Array, String],
          default: () => []
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Icon size.
         */
        iconSize: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid iconSize prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        more: Boolean,
        /**
         * Contained variants can be displayed in three smaller sizes—small, x-small, xx-small—by adding a sizing class on the <button>.
         */
        size: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid button icon prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, container,
         * brand, border, border-filled, base-inverse, border-inverse.
         */
        variant: {
          type: String,
          default: "bare",
          validator: (value) => {
            const variants = [
              "bare",
              "container",
              "brand",
              "border",
              "border-filled",
              "bare-inverse",
              "inverse",
              "border-inverse"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Displays browser-based tooltip text when the mouse moves over the element.
         */
        title: {
          type: String,
          required: true
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = Array.isArray(this.$props.iconClass) ? this.$props.iconClass : [this.$props.iconClass];
          iconClass.push("slds-button__icon");
          const props = {
            assistiveText: this.$props.assistiveText,
            category: this.$props.iconCategory,
            name: this.$props.iconName,
            iconClass,
            variant: "none",
            button: true
          };
          if (this.$props.iconSize) {
            iconClass.push(`slds-button__icon_${this.$props.iconSize}`);
            props.size = this.$props.iconSize;
          }
          iconVNode = h(Icon, props);
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children = [_default || iconVNode];
        if (this.$props.more) {
          const moreIconVNode = h(
            Icon,
            {
              assistiveText: iconVNode ? null : this.$props.assistiveText,
              category: "utility",
              name: "down",
              iconClass: ["slds-button__icon", "slds-button__icon_x-small"],
              variant: "none",
              button: true
            }
          );
          children.push(moreIconVNode);
        }
        const classes = ["slds-button", "slds-button_icon"];
        if (this.$props.more) {
          if (this.$props.variant === "border-filled") {
            classes.push("slds-button_icon-more");
          } else {
            classes.push("slds-button_icon-container-more");
          }
        }
        classes.push(`slds-button_icon-${this.$props.variant}`);
        if (this.$props.size)
          classes.push(`slds-button_icon-${this.$props.size}`);
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        return h(
          "button",
          {
            class: classes,
            title: this.$props.title,
            disabled: this.$props.disabled
          },
          children
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    const callbackMap = /* @__PURE__ */ new Map();
    function bind(el, handler, instance) {
      const callback = function(e) {
        if (instance.$.isUnmounted) {
          document.removeEventListener("click", callback);
          return;
        }
        if (!el.contains(e.target) && el !== e.target) {
          handler(e);
        }
      };
      callbackMap.set(el, callback);
      setTimeout(() => document.addEventListener("click", callback), 0);
    }
    function unbind(el) {
      const callback = callbackMap.get(el);
      document.removeEventListener("click", callback);
      callbackMap.delete(el);
    }
    const clickOutside = {
      created(el, { arg: { active, handler }, instance }) {
        if (typeof handler !== "function") {
          throw new Error("v-click-outside: missing required handler argument.");
        }
        if (active === true) {
          bind(el, handler, instance);
        }
      },
      updated(el, { arg: { active, handler } }, vNode) {
        if (active && !callbackMap.has(el)) {
          bind(el, handler, vNode);
        } else if (!active && callbackMap.has(el)) {
          unbind(el);
        }
      },
      unmounted(el) {
        unbind(el);
      }
    };
    const containers = /* @__PURE__ */ new Map();
    const createContainer = (el, context) => {
      const container = document.createElement("div");
      container.className = "slds-scope";
      container.appendChild(el);
      document.body.appendChild(container);
      context.$emit("detached", container);
      return container;
    };
    const alignToAnchor = (el, vnode, {
      anchorRef,
      resizeToAnchor,
      resizeToFitContent,
      alignment
    }) => {
      el.style.position = "fixed";
      const anchorRect = anchorRef.getBoundingClientRect();
      el.style.top = `${anchorRect.top + anchorRef.offsetHeight}px`;
      if (alignment === "left" || resizeToAnchor) {
        el.style.right = "auto";
        el.style.left = `${anchorRect.left}px`;
      } else if (alignment === "right") {
        el.style.left = "auto";
        el.style.right = `${document.documentElement.clientWidth - anchorRect.right}px`;
      }
      const anchorOffsetWidth = anchorRef.offsetWidth;
      if (resizeToAnchor) {
        el.style.width = `${anchorOffsetWidth}px`;
      } else if (resizeToFitContent) {
        el.style.minWidth = `${anchorOffsetWidth}px`;
        el.style.width = "auto";
      }
    };
    const getScrollbarWidth = () => {
      const scrollDiv = document.createElement("div");
      scrollDiv.style.width = "100px";
      scrollDiv.style.height = "100px";
      scrollDiv.style.overflow = "scroll";
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      scrollDiv.remove();
      return scrollbarWidth;
    };
    const adjustForViewPortOverflow = (el, options) => {
      const dropdownRect = el.getBoundingClientRect();
      const documentClientHeight = document.documentElement.clientHeight;
      const documentClientWidth = document.documentElement.clientWidth;
      const windowDocumentVerticalDiff = documentClientHeight - window.innerHeight;
      let viewportHeight;
      if (windowDocumentVerticalDiff <= 0) {
        viewportHeight = documentClientHeight;
      } else {
        viewportHeight = window.innerHeight - getScrollbarWidth();
      }
      if (dropdownRect.x < 0) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "left"
              }
            }
          );
        } else {
          el.style.left = `${el.offsetLeft + Math.abs(dropdownRect.x)}px`;
        }
      } else if (dropdownRect.left + dropdownRect.width > documentClientWidth) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "right"
              }
            }
          );
        } else {
          const overflowXDiff = dropdownRect.left + dropdownRect.width - documentClientWidth - window.pageXOffset;
          el.style.left = `${dropdownRect.left - overflowXDiff}px`;
        }
      }
      let dropdownHeight = el.offsetHeight;
      let adjustedVerticalPosition;
      if (options.anchorRef && options.anchorTopOnVerticalOverflow) {
        const anchor = options.anchorRef.getBoundingClientRect();
        let anchorY = anchor.bottom;
        const boxShadow = window.getComputedStyle(el)["box-shadow"];
        if (boxShadow && boxShadow !== "none") {
          dropdownHeight += parseInt(/(?:\dpx ){2}(\d)/.exec(boxShadow)[1], 10);
        }
        if (anchorY + dropdownHeight > viewportHeight) {
          anchorY = anchor.top - dropdownHeight;
        }
        adjustedVerticalPosition = anchorY;
      } else if (dropdownRect.top + dropdownHeight > viewportHeight) {
        adjustedVerticalPosition = dropdownRect.top - (dropdownRect.top + dropdownHeight - viewportHeight);
      }
      if (adjustedVerticalPosition) {
        el.style.top = `${adjustedVerticalPosition}px`;
      }
    };
    const removeContainer = (el) => {
      let container = containers.get(el);
      if (!container)
        return;
      container.remove();
      container = null;
      containers.delete(el);
    };
    let scrollHandlerFn;
    const scrollHandler = (el, _scrollHandler, e) => {
      if (e && e.type === "scroll" && el && el.contains(e.target))
        return;
      if (typeof _scrollHandler === "function") {
        _scrollHandler(el, e);
      } else {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const detach = {
      created(el, binding, vnode) {
        if (binding.value.disabled)
          return;
        binding.instance.$nextTick(() => {
          const options = binding.value;
          const container = createContainer(el, binding.instance);
          vnode.container = container;
          containers.set(el, container);
          if (typeof options.customDisplayMethod === "function") {
            options.customDisplayMethod();
          }
          if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
            alignToAnchor(el, vnode, options);
          }
          if (options.viewPortOverflow) {
            binding.instance.$nextTick(() => {
              if (typeof options.onRender === "function") {
                options.onRender();
                binding.instance.$nextTick(adjustForViewPortOverflow.bind(this, el, options));
              } else {
                adjustForViewPortOverflow(el, options);
              }
            });
          }
          scrollHandlerFn = scrollHandler.bind(null, el, options.scrollHandler);
          window.addEventListener("scroll", scrollHandlerFn, true);
        });
      },
      updated(el, { value: options, instance }, vnode) {
        if (options.disabled)
          return;
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(el, vnode, options);
        }
        if (options.viewPortOverflow) {
          instance.$nextTick(() => {
            if (typeof options.onUpdate === "function") {
              options.onUpdate();
            }
            adjustForViewPortOverflow(el, options);
          });
        }
      },
      unmounted(el) {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$G = {
      name: "ActionMenu",
      components: { ButtonIcon },
      directives: {
        "click-outside": clickOutside,
        "detach-element": detach
      },
      props: {
        /**
         * Determines which side of the anchor the dropdown should align to
         */
        alignment: {
          type: String,
          default: "left",
          validator(alignment) {
            if (!["left", "right"].includes(alignment)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return false;
            }
            return true;
          }
        },
        // TODO - Setup a watcher on bindTo. If changed, remove existing event listener and register a new one.
        /**
         * Bind to an HTML Element. Should be focusable.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to custom coordinates.
         * An object in the following format:
         * `{
                x: 50,
                y: 50
            }`
         */
        bindToCoords: {
          type: Object,
          default: null,
          validator: (value) => value.x && value.y
        },
        /**
         * Bind to current mouse position.
         */
        bindToMousePosition: {
          type: Boolean,
          default: false
        },
        buttonIconSize: {
          type: String,
          default: ""
        },
        /**
         * Disables entire action menu.
         */
        disabled: Boolean,
        /**
         * The sync-supported visibility state prop.
         */
        doShowSync: Boolean,
        /**
         * Hide on mouse leave.
         */
        hideOnMouseout: Boolean,
        /**
         * Name of the icon category.
         */
        iconCategory: {
          type: String,
          default: "utility"
        },
        /**
         * Name of the icon.
         */
        iconName: {
          type: String,
          default: "down"
        },
        /**
         * Determines the size of the icon.
         */
        iconSize: {
          type: String,
          default: ""
        },
        /**
         * Title property for the button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Action menu variant. Shows menu items with link styling.
         */
        isActionMenu: {
          type: Boolean,
          default: true
        },
        /**
         * If defined, this will get called before toggling the action menu and be passed the following:
         * 1. JS click event
         * 2. Current visibility state of the action menu
         *
         * If the function returns a boolean value of true then the action menu will be toggled, otherwise, nothing will occur
         */
        onToggleRequest: {
          type: Function,
          default: null
        },
        /**
         * Adjust menu width to be equal to the anchor's width
         */
        resizeToAnchor: Boolean,
        /**
         * Label for button title and icon assistive text.
         */
        showMoreLabel: {
          type: String,
          default: "Show More"
        }
      },
      data() {
        return {
          doShow: this.doShowSync,
          isDirty: false,
          adjustedAlignment: null,
          container: null,
          focusedMenuItemIndex: null,
          focusableMenuItems: []
        };
      },
      computed: {
        doShowAnchor() {
          return !(this.bindTo || this.bindToMousePosition || this.bindToCoords);
        },
        clickOutsideOptions() {
          return {
            active: this.doShow,
            handler: this.doHide
          };
        },
        computedShowMoreIconTitle() {
          return this.$props.iconTitle || this.$props.showMoreLabel;
        },
        dropdownClasses() {
          const classes = ["slds-dropdown"];
          if (this.$props.isActionMenu)
            classes.push("slds-dropdown_actions");
          return classes;
        }
      },
      watch: {
        "$props.alignment": {
          handler(value) {
            if (!["left", "right"].includes(value)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return;
            }
            this.adjustedAlignment = value;
          },
          immediate: true
        },
        doShow(value) {
          this.$emit("update:doShowSync", value);
        },
        doShowSync(value) {
          if (value === this.doShow)
            return;
          this.toggleMenu();
        }
      },
      created() {
        if (this.bindTo)
          this.bindTo.addEventListener("click", this.toggleMenu);
      },
      beforeUnmount() {
        if (this.bindTo)
          this.bindTo.removeEventListener("click", this.toggleMenu);
        this.destroy();
      },
      methods: {
        toggleMenu(e) {
          if (this.disabled || e && this.onToggleRequest && !this.onToggleRequest(e, this.doShow) || e && this.$refs.menu && (this.$refs.menu === e.target || this.$refs.menu.contains(e.target)))
            return;
          this.doShow = !this.doShow;
          if (this.doShow && !this.isKeyboardCallback) {
            window.addEventListener("scroll", this.doHide, true);
            window.addEventListener("resize", this.doHide);
            this.$nextTick(this.showMenu.bind(this, e));
            this.$emit("bindToClick", e);
          } else {
            this.destroy();
          }
        },
        showMenu() {
          this.$nextTick(() => {
            this.getFocusableMenuItems();
            if (this.focusableMenuItems.length) {
              this.focusedMenuItemIndex = 0;
              this.setMenuItemFocus();
            }
          });
        },
        onDetachRender() {
          this.$emit("detached", this.$refs.menu);
        },
        adjustAlignment(position) {
          this.adjustedAlignment = position;
        },
        destroy() {
          this.focusableMenuItems = [];
          this.doShow = false;
          window.removeEventListener("scroll", this.doHide, true);
          window.removeEventListener("resize", this.doHide);
          if (this.container) {
            this.container.remove();
            this.container = null;
          }
          if (this.doShowAnchor)
            this.$refs.anchor.firstElementChild.focus();
          this.$emit("hide");
        },
        doHide() {
          this.destroy();
        },
        mouseover(e) {
          this.$emit("mouseover", e);
        },
        mouseout(e) {
          if (this.hideOnMouseout && e.type === "mouseout" && !this.$refs.menu.contains(e.toElement || e.relatedTarget)) {
            this.destroy();
            return;
          }
          this.$emit("mouseout", e);
        },
        getFocusableMenuItems() {
          this.focusableMenuItems = [];
          this.$refs.menu.querySelectorAll(".slds-dropdown__item").forEach((item) => {
            this.focusableMenuItems.push(item.querySelector("a"));
          });
        },
        down() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex < this.focusableMenuItems.length - 1) {
              this.focusedMenuItemIndex++;
            } else {
              this.focusedMenuItemIndex = 0;
            }
            this.setMenuItemFocus();
          }
        },
        up() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex > 0) {
              this.focusedMenuItemIndex--;
            } else {
              this.focusedMenuItemIndex = this.focusableMenuItems.length - 1;
            }
            this.setMenuItemFocus();
          }
        },
        setMenuItemFocus() {
          this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = 0;
          this.focusableMenuItems[this.focusedMenuItemIndex].focus();
        }
      }
    };
    const _hoisted_1$z = {
      key: 0,
      ref: "anchor"
    };
    const _hoisted_2$y = ["aria-label"];
    function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: "slds-dropdown-trigger slds-dropdown-trigger_click slds-is-open slds-show",
        onClick: _cache[6] || (_cache[6] = (...args) => $options.toggleMenu && $options.toggleMenu(...args)),
        onKeydown: [
          _cache[7] || (_cache[7] = withKeys((...args) => $options.toggleMenu && $options.toggleMenu(...args), ["enter"])),
          _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
          _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"]))
        ]
      }, [
        $options.doShowAnchor ? (openBlock(), createElementBlock("div", _hoisted_1$z, [
          renderSlot(_ctx.$slots, "button", {}, () => [
            createVNode(_component_ButtonIcon, {
              "aria-haspopup": "",
              variant: "border-filled",
              disabled: _ctx.$props.disabled,
              iconSize: _ctx.$props.iconSize,
              iconCategory: _ctx.$props.iconCategory,
              iconName: _ctx.$props.iconName,
              title: $options.computedShowMoreIconTitle,
              assistiveText: $props.showMoreLabel,
              "aria-expanded": $data.doShow,
              size: _ctx.$props.buttonIconSize
            }, null, 8, ["disabled", "iconSize", "iconCategory", "iconName", "title", "assistiveText", "aria-expanded", "size"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        $data.doShow ? withDirectives((openBlock(), createElementBlock("div", {
          key: 1,
          ref: "menu",
          class: normalizeClass([$options.dropdownClasses, "translateX"]),
          onMouseover: _cache[0] || (_cache[0] = (...args) => $options.mouseover && $options.mouseover(...args)),
          onMouseout: _cache[1] || (_cache[1] = (...args) => $options.mouseout && $options.mouseout(...args)),
          onKeydown: [
            _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["stop"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["stop"]), ["up"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"])),
            _cache[5] || (_cache[5] = withKeys((...args) => $options.destroy && $options.destroy(...args), ["tab"]))
          ]
        }, [
          createBaseVNode("ul", {
            class: "slds-dropdown__list",
            role: "menu",
            "aria-label": $props.showMoreLabel
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode("--- menu items go here ---")
            ], true)
          ], 8, _hoisted_2$y)
        ], 34)), [
          [_directive_click_outside, void 0, $options.clickOutsideOptions],
          [_directive_detach_element, {
            anchorRef: _ctx.$refs.anchor,
            viewPortOverflow: true,
            anchorTopOnVerticalOverflow: true,
            onRender: $options.onDetachRender,
            onOverflowAdjustment: $options.adjustAlignment,
            resizeToAnchor: _ctx.$props.resizeToAnchor,
            scrollHandler: $options.doHide,
            alignment: _ctx.$props.alignment
          }]
        ]) : createCommentVNode("", true)
      ], 32);
    }
    const ActionMenu = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$E], ["__scopeId", "data-v-413e8c13"]]);
    const decodeHtml = {
      methods: {
        decodeHtml(html) {
          const txt = document.createElement("textarea");
          txt.innerHTML = html;
          return txt.value;
        }
      }
    };
    const _sfc_main$F = {
      name: "ActionMenuItem",
      components: {
        Icon
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Label for the menu item.
         */
        label: {
          type: String,
          required: true
        },
        /**
         * Disable action menu item.
         */
        disabled: Boolean,
        /**
         * Determines if this item is a read-only header.
         */
        header: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Role for menu item. Selectable items need the role "menuitemcheckbox" or "menuitemradio"
         * Options: `menuitem` | `menuitemcheckbox` | `menuitemradio`
         */
        role: {
          type: String,
          default: "menuitem",
          validator: (value) => {
            const validRoles = [
              "menuitem",
              "menuitemcheckbox",
              "menuitemradio"
            ];
            const isValid2 = !value || validRoles.includes(value);
            if (!isValid2)
              console.error(`Valid role values are ${validRoles.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * If true we add aria-checked="true" to the anchor tag
         */
        selected: Boolean
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      methods: {
        onEnter(e) {
          this.$attrs.onClick(e);
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        },
        onClick() {
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        }
      }
    };
    const _hoisted_1$y = {
      key: 0,
      role: "presentation",
      class: "slds-dropdown__header slds-text-heading--label"
    };
    const _hoisted_2$x = { role: "presentation" };
    const _hoisted_3$w = ["aria-disabled"];
    const _hoisted_4$s = ["role", "aria-checked"];
    const _hoisted_5$p = ["title"];
    function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return _ctx.$props.header ? (openBlock(), createElementBlock("li", _hoisted_1$y, [
        createBaseVNode("div", _hoisted_2$x, toDisplayString(_ctx.$props.label), 1)
      ])) : (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        class: ["slds-dropdown__item", { "slds-is-selected": _ctx.$props.selected }],
        "aria-disabled": $props.disabled,
        role: "presentation"
      }, toHandlers(_ctx.$attrs, true), {
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.onClick && $options.onClick(...args), ["stop", "prevent"])),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.onEnter && $options.onEnter(...args), ["stop", "prevent"]), ["enter"]))
      }), [
        createBaseVNode("a", {
          role: $props.role,
          tabindex: "-1",
          "aria-checked": _ctx.$props.selected,
          class: normalizeClass({ "disabled": $props.disabled })
        }, [
          createBaseVNode("span", {
            title: $props.label,
            class: normalizeClass([{ "slds-text-color_inverse-weak": $props.disabled, "disabled": $props.disabled }, "slds-truncate"])
          }, [
            $options.hasFQIcon ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              category: _ctx.$props.iconCategory,
              name: _ctx.$props.iconName,
              size: "x-small",
              class: "slds-m-right_x-small"
            }, null, 8, ["category", "name"])) : createCommentVNode("", true),
            !_ctx.$parent.$props.isActionMenu ? (openBlock(), createBlock(_component_Icon, {
              key: 1,
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-m-right_x-small",
              iconClass: "slds-icon_selected"
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($props.label)), 1)
            ], true)
          ], 10, _hoisted_5$p)
        ], 10, _hoisted_4$s)
      ], 16, _hoisted_3$w));
    }
    const ActionMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$D], ["__scopeId", "data-v-ffe335c1"]]);
    const _sfc_main$E = {
      name: "Badge",
      props: {
        /**
         * Content to be placed inside the badge component.
         */
        content: {
          type: [String, Number],
          default: ""
        },
        /**
         * Icon alignment for the badge component.
         */
        iconAlignment: {
          type: String,
          default: "left"
        },
        /**
         * Color variant for the badge component
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "inverse",
              "lightest",
              "success",
              "warning",
              "error"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        iconOnly() {
          return this.$slots.icon && !this.content;
        },
        themeClasses() {
          const contrastClasses = ["inverse", "lightest"];
          const themeClasses = ["success", "warning", "error"];
          let themeClass = "";
          if (contrastClasses.includes(this.theme))
            themeClass = `slds-badge_${this.theme}`;
          if (themeClasses.includes(this.theme))
            themeClass = `slds-theme_${this.theme}`;
          return themeClass;
        },
        badgeIconClasses() {
          const classes = ["slds-badge__icon"];
          if (this.theme === "inverse")
            classes.push("slds-badge__icon_inverse");
          if (this.iconAlignment && !this.iconOnly)
            classes.push(`slds-badge__icon_${this.iconAlignment}`);
          return classes;
        }
      }
    };
    function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(["slds-badge", $options.themeClasses])
      }, [
        _ctx.$slots["icon"] && $props.iconAlignment === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2),
          createTextVNode(" " + toDisplayString($props.content), 1)
        ], 64)) : _ctx.$slots["icon"] && $props.iconAlignment === "right" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString($props.content) + " ", 1),
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString($props.content), 1)
        ], 64))
      ], 2);
    }
    const Badge = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$C]]);
    const Button = {
      name: "Button",
      components: { Icon },
      props: {
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon class(es)
         */
        iconClass: {
          type: [Array, String]
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Describes the position of the icon with respect to body. Options include left and right.
         * This value defaults to left.
         */
        iconPosition: {
          type: String,
          default: "left"
        },
        iconVariant: {
          type: String,
          default: "none"
        },
        /**
         * The text to be displayed inside the button.
         */
        label: {
          type: String,
          default: "Button"
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, neutral,
         * brand, outline-brand, destructive, text-destructive, inverse, and success. This value defaults to neutral.
         */
        variant: {
          type: String,
          default: "neutral",
          validator: (value) => {
            const variants = [
              "base",
              "neutral",
              "brand",
              "inverse",
              "destructive",
              "success",
              "outline-brand",
              "text-destructive"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = ["slds-button__icon"];
          if (this.$props.iconPosition) {
            iconClass.push(`slds-button__icon_${this.$props.iconPosition}`);
          }
          if (this.$props.iconClass) {
            if (Array.isArray(this.$props.iconClass)) {
              iconClass.push(...this.$props.iconClass);
            } else {
              iconClass.push(this.$props.iconClass);
            }
          }
          iconVNode = h(
            Icon,
            {
              button: true,
              category: this.$props.iconCategory,
              iconClass,
              name: this.$props.iconName,
              variant: this.$props.iconVariant
            }
          );
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children = [_default || this.$props.label];
        if (iconVNode) {
          if (this.$props.iconPosition === "right") {
            children.push(iconVNode);
          } else {
            children.unshift(iconVNode);
          }
        }
        const classes = ["slds-button"];
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        if (this.$props.variant !== "base") {
          classes.push(`slds-button_${this.variant}`);
        }
        return h(
          "button",
          {
            // on: this.$listeners,
            class: classes,
            disabled: this.$props.disabled
          },
          children
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    const _sfc_main$D = {
      name: "Card",
      props: {
        /**
         * Sets the title for the card.
         */
        title: {
          type: String,
          default: ""
        },
        /**
         * Add padding to the body of the card.
         */
        padBody: Boolean
      },
      computed: {
        showHeader() {
          return this.title || this.$slots.icon || this.$slots["header-content"] || this.$slots["title"];
        }
      }
    };
    const _hoisted_1$x = { class: "slds-card" };
    const _hoisted_2$w = {
      key: 0,
      class: "slds-card__header slds-grid"
    };
    const _hoisted_3$v = { class: "slds-media slds-media_center slds-has-flexi-truncate" };
    const _hoisted_4$r = {
      key: 0,
      class: "slds-media__figure"
    };
    const _hoisted_5$o = { class: "slds-media__body" };
    const _hoisted_6$l = { class: "slds-card__header-title" };
    const _hoisted_7$j = ["title"];
    const _hoisted_8$h = { key: 0 };
    const _hoisted_9$h = {
      key: 1,
      class: "slds-card__footer"
    };
    function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("article", _hoisted_1$x, [
        $options.showHeader ? (openBlock(), createElementBlock("div", _hoisted_2$w, [
          createBaseVNode("div", _hoisted_3$v, [
            _ctx.$slots["icon"] ? (openBlock(), createElementBlock("div", _hoisted_4$r, [
              renderSlot(_ctx.$slots, "icon")
            ])) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_5$o, [
              renderSlot(_ctx.$slots, "title", {}, () => [
                createBaseVNode("h2", _hoisted_6$l, [
                  createBaseVNode("span", {
                    title: $props.title,
                    class: "slds-truncate"
                  }, [
                    createBaseVNode("span", null, toDisplayString($props.title), 1)
                  ], 8, _hoisted_7$j)
                ])
              ])
            ])
          ]),
          _ctx.$slots["header-content"] ? (openBlock(), createElementBlock("div", _hoisted_8$h, [
            renderSlot(_ctx.$slots, "header-content")
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([{ "slds-card__body_inner": $props.padBody }, "slds-card__body"])
        }, [
          renderSlot(_ctx.$slots, "body", {}, () => [
            createTextVNode("Card Body")
          ])
        ], 2),
        _ctx.$slots["footer"] ? (openBlock(), createElementBlock("footer", _hoisted_9$h, [
          renderSlot(_ctx.$slots, "footer")
        ])) : createCommentVNode("", true)
      ]);
    }
    const Card = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$B]]);
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state2 = _ref.state;
      Object.keys(state2.elements).forEach(function(name) {
        var style = state2.styles[name] || {};
        var attributes = state2.attributes[name] || {};
        var element = state2.elements[name];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name2) {
          var value = attributes[name2];
          if (value === false) {
            element.removeAttribute(name2);
          } else {
            element.setAttribute(name2, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state2 = _ref2.state;
      var initialStyles = {
        popper: {
          position: state2.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state2.elements.popper.style, initialStyles.popper);
      state2.styles = initialStyles;
      if (state2.elements.arrow) {
        Object.assign(state2.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state2.elements).forEach(function(name) {
          var element = state2.elements[name];
          var attributes = state2.attributes[name] || {};
          var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$1 = Math.max;
    var min$1 = Math.min;
    var round$1 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y,
        right: x + width,
        bottom: y + height,
        left: x,
        x,
        y
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$2(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$2(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$2(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$2(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$1(min2, min$1(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v = within(min2, value, max2);
      return v > max2 ? max2 : v;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state2) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
        placement: state2.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state2 = _ref.state, name = _ref.name, options = _ref.options;
      var arrowElement = state2.elements.arrow;
      var popperOffsets2 = state2.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state2.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len2 = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state2);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state2.rects.reference[len2] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len2];
      var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len2] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len2] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state2 = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state2.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state2.elements.popper, arrowElement)) {
        return;
      }
      state2.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x = _ref.x, y = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(x * dpr) / dpr || 0,
        y: round$1(y * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x,
        y
      }) : {
        x,
        y
      };
      x = _ref3.x;
      y = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y -= offsetY - popperRect.height;
          y *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x -= offsetX - popperRect.width;
          x *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x,
        y
      }, getWindow(popper2)) : {
        x,
        y
      };
      x = _ref4.x;
      y = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state2 = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state2.placement),
        variation: getVariation(state2.placement),
        popper: state2.elements.popper,
        popperRect: state2.rects.popper,
        gpuAcceleration,
        isFixed: state2.options.strategy === "fixed"
      };
      if (state2.modifiersData.popperOffsets != null) {
        state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state2.modifiersData.popperOffsets,
          position: state2.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state2.modifiersData.arrow != null) {
        state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state2.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
        "data-popper-placement": state2.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state2.elements.popper);
      var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x = 0;
      var y = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x = visualViewport.offsetLeft;
          y = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x + getWindowScrollBarX(element),
        y
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y = -winScroll.scrollTop;
      if (getComputedStyle$2(body || html).direction === "rtl") {
        x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x,
        y
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$1(rect.top, accRect.top);
        accRect.right = min$1(rect.right, accRect.right);
        accRect.bottom = min$1(rect.bottom, accRect.bottom);
        accRect.left = max$1(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len2 = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len2] / 2 - element[len2] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len2] / 2 - element[len2] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state2, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state2.rects.popper;
      var element = state2.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state2.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state2.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state2, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state2, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state2 = _ref.state, options = _ref.options, name = _ref.name;
      if (state2.modifiersData[name]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state2.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i2 = 0; i2 < placements2.length; i2++) {
        var placement = placements2[i2];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len2 = isVertical ? "width" : "height";
        var overflow = detectOverflow(state2, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len2] > popperRect[len2]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state2.placement !== firstFittingPlacement) {
        state2.modifiersData[name]._skip = true;
        state2.placement = firstFittingPlacement;
        state2.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state2 = _ref.state, name = _ref.name;
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var preventedOffsets = state2.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state2, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state2, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state2.modifiersData[name] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y = _data$state$placement.y;
      if (state2.modifiersData.popperOffsets != null) {
        state2.modifiersData.popperOffsets.x += x;
        state2.modifiersData.popperOffsets.y += y;
      }
      state2.modifiersData[name] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state2 = _ref.state, name = _ref.name;
      state2.modifiersData[name] = computeOffsets({
        reference: state2.rects.reference,
        element: state2.rects.popper,
        strategy: "absolute",
        placement: state2.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state2 = _ref.state, options = _ref.options, name = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state2, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state2.placement);
      var variation = getVariation(state2.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state2.modifiersData.popperOffsets;
      var referenceRect = state2.rects.reference;
      var popperRect = state2.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
        placement: state2.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len2 = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len2] / 2 : 0;
        var minLen = variation === start ? referenceRect[len2] : popperRect[len2];
        var maxLen = variation === start ? -popperRect[len2] : -referenceRect[len2];
        var arrowElement = state2.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len2], arrowRect[len2]);
        var minOffset = isBasePlacement ? referenceRect[len2] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len2] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state2.modifiersData[name] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$1(rect.width) / element.offsetWidth || 1;
      var scaleY = round$1(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce$1(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS$1 = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS$1 : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state2 = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS$1, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state: state2,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
            cleanupModifierEffects();
            state2.options = Object.assign({}, defaultOptions, state2.options, options2);
            state2.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
            state2.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state2.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state2.reset = false;
            state2.placement = state2.options.placement;
            state2.orderedModifiers.forEach(function(modifier) {
              return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state2.orderedModifiers.length; index++) {
              if (state2.reset === true) {
                state2.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state2.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state2 = fn({
                  state: state2,
                  options: _options,
                  name,
                  instance
                }) || state2;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state2);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state3) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state3);
          }
        });
        function runModifierEffects() {
          state2.orderedModifiers.forEach(function(_ref) {
            var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state: state2,
                name,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    const alignmentPositions$1 = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const isAlignmentValid$1 = (alignment) => Object.keys(alignmentPositions$1).find((value) => value === alignment);
    const _sfc_main$C = {
      name: "Tooltip",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Alignment of the Tooltip relative to the element that triggers it.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid$1(alignment);
          }
        },
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: String,
          default: "Help"
        },
        /**
         * Title prop for button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for popover body.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Trigger element or function. If provided, the source slot will not be rendered.
         */
        source: {
          type: [HTMLElement, Function],
          default: null
        },
        /**
         * Content inside Tooltip.
         */
        text: {
          type: String,
          default: ""
        }
      },
      data() {
        return {
          localSource: null,
          isOpen: false,
          tooltipId: getGUID(),
          popperInstance: null
        };
      },
      computed: {
        computedText() {
          return this.$props.text.replaceAll(/(<br>|<br \/>)/gm, "\n").replaceAll("<br />", "\n").replaceAll("&lt;br /&gt;", "\n").replaceAll(/(\\r\\n|\\n|\\r)/gm, "\n");
        },
        computedIconTitle() {
          return this.$props.iconTitle || this.$props.assistiveText;
        }
      },
      watch: {
        "$props.source": {
          handler() {
            if (!this.$props.source)
              return;
            if (this.$slots.source) {
              throw new Error("Cannot set source prop and provide a default source");
            }
            this.processSource(this.$props.source);
          },
          immediate: true
        },
        alignment() {
          if (isAlignmentValid$1(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions$1[this.$props.alignment]
            });
          }
        }
      },
      mounted() {
        if (this.$props.source)
          return;
        let source;
        if (this.$slots.source) {
          source = this.$refs.source;
        } else {
          source = this.$refs.defaultSource.$el;
        }
        this.processSource(source);
      },
      beforeUnmount() {
        this.removeListeners();
      },
      methods: {
        async processSource(source) {
          this.removeListeners();
          this.localSource = typeof source === "function" ? await source() : source;
          this.localSource.setAttribute("aria-describedby", this.tooltipId);
          this.addListeners();
          if (this.popperInstance) {
            this.popperInstance.state.elements.reference = this.localSource;
          } else {
            this.$nextTick(this.setPopperInstance);
          }
        },
        setPopperInstance() {
          this.popperInstance = createPopper(this.localSource, this.$refs.tooltip, {
            strategy: this.$props.position,
            placement: alignmentPositions$1[this.$props.alignment],
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: ({ placement }) => {
                    if (placement.includes("end")) {
                      return [16, 14];
                    }
                    if (placement.includes("start")) {
                      return [-16, 14];
                    }
                    return [0, 14];
                  }
                }
              },
              {
                name: "preventOverflow",
                options: {
                  padding: this.$props.overflowPadding
                }
              }
            ]
          });
          this.$nextTick(() => {
            if (document.activeElement === this.localSource)
              this.enter();
          });
        },
        addListeners() {
          const showEvents = ["mouseenter", "focus"];
          const hideEvents = ["mouseleave", "blur"];
          showEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.enter);
          });
          hideEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.leave);
          });
        },
        removeListeners() {
          if (!this.localSource)
            return;
          this.localSource.removeEventListener("focus", this.enter);
          this.localSource.removeEventListener("mouseenter", this.enter);
          this.localSource.removeEventListener("blur", this.leave);
          this.localSource.removeEventListener("mouseleave", this.leave);
        },
        enter() {
          this.isOpen = true;
          this.popperInstance.update();
        },
        leave() {
          if (document.activeElement === this.localSource)
            return;
          this.isOpen = false;
        }
      }
    };
    const _withScopeId$d = (n) => (pushScopeId("data-v-0233e977"), n = n(), popScopeId(), n);
    const _hoisted_1$w = {
      key: 0,
      ref: "source"
    };
    const _hoisted_2$v = ["id"];
    const _hoisted_3$u = { class: "slds-popover__body" };
    const _hoisted_4$q = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        !_ctx.$props.source ? (openBlock(), createElementBlock("span", _hoisted_1$w, [
          renderSlot(_ctx.$slots, "source", {}, () => [
            createVNode(_component_ButtonIcon, {
              ref: "defaultSource",
              "aria-describedby": $data.tooltipId,
              "aria-disabled": "true",
              iconCategory: "utility",
              iconName: "info",
              iconSize: "xx-small",
              assistiveText: _ctx.$props.assistiveText,
              title: $options.computedIconTitle
            }, null, 8, ["aria-describedby", "assistiveText", "title"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", {
          id: $data.tooltipId,
          ref: "tooltip",
          class: "slds-popover slds-popover_tooltip",
          role: "tooltip"
        }, [
          createBaseVNode("div", _hoisted_3$u, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedText)), 1)
            ], true)
          ]),
          _hoisted_4$q
        ], 8, _hoisted_2$v), [
          [vShow, $data.isOpen]
        ])
      ]);
    }
    const Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$A], ["__scopeId", "data-v-0233e977"]]);
    const defaultLabels$5 = () => ({
      name: "Default Label",
      stateOn: "Enabled",
      stateOff: "Disabled",
      required: "required"
    });
    const _sfc_main$B = {
      name: "Checkbox",
      components: {
        Icon,
        Tooltip
      },
      mixins: [decodeHtml],
      props: {
        /**
         * The aria-labelledby attribute establishes relationships between objects and their label(s), and its value should be one or more element IDs, which refer to elements that have the text needed for labeling. List multiple element IDs in a space delimited fashion.
         */
        ariaLabeledBy: {
          type: String,
          default: ""
        },
        /**
         * Disables the Checkbox and prevents clicking it.
         */
        disabled: Boolean,
        /**
         * An array of errors used for checkbox validation.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Content for Tooltip component that is displayed next to the label. Only for use with form element variant.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Adds assistive text class to visually hide checkbox label.
         */
        hideLabel: Boolean,
        /**
         * Adds a tertiary state to no-slide checkboxes.
         */
        indeterminate: Boolean,
        /**
         * Shows label as a block element.
         */
        isFormElement: Boolean,
        /**
         * Labels object for the checkbox
         */
        labels: {
          type: Object,
          default: () => {
          },
          validator: (value) => {
            if (!value || !value.name) {
              console.error('You must provide a "name" label, because it is the minimum requirement for accessibility. If you do not want to render the label than set hideLabel to true and the "name" label will be used as assistive text.');
              return false;
            }
            return true;
          }
        },
        /**
         * v-model binding.
         */
        modelValue: Boolean,
        /**
         * Displays the value of the input, but does not allow changes.
         */
        readonly: Boolean,
        /**
         * Highlights the Checkbox as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * Shows state labels for toggle variant.
         */
        showStateLabels: Boolean,
        /**
         * Checkbox Toggle variant.
         */
        slide: Boolean,
        // TODO - Change to 'toggle' in next major release to align with SLDS terminology
        toggleBuffer: {
          type: Number,
          default: 0
        }
      },
      data() {
        return {
          checkboxId: getGUID(),
          errorId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().checkbox || {} : {};
          return {
            ...defaultLabels$5(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length && !this.$props.slide;
        },
        checkboxClass() {
          return !this.slide ? "slds-form-element__control" : "slds-checkbox_toggle slds-grid";
        }
      },
      watch: {
        modelValue(checked) {
          if (this.$refs.checkbox) {
            this.$refs.checkbox.checked = checked;
          }
          if (checked) {
            this.$emit("update:indeterminate", false);
          }
        },
        indeterminate: {
          handler(state2) {
            if (!this.$props.slide) {
              this.$nextTick(() => {
                this.$refs.checkbox.indeterminate = state2;
                if (state2) {
                  this.$emit("update:modelValue", false);
                }
              });
            }
          },
          immediate: true
        }
      },
      mounted() {
        if (this.$refs.checkbox) {
          this.$refs.checkbox.checked = this.$props.modelValue;
        }
      },
      methods: {
        onClick(e) {
          if (!e.clientX && !e.clientY)
            return;
          if (e.currentTarget.checked && this.toggleBuffer) {
            this.$refs.checkbox.disabled = true;
            setTimeout(() => {
              this.$refs.checkbox.disabled = false;
            }, this.toggleBuffer);
          }
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.checked);
        }
      }
    };
    const _withScopeId$c = (n) => (pushScopeId("data-v-6891711e"), n = n(), popScopeId(), n);
    const _hoisted_1$v = ["title"];
    const _hoisted_2$u = ["checked", "disabled", "aria-describedby"];
    const _hoisted_3$t = ["id"];
    const _hoisted_4$p = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_5$n = {
      key: 0,
      class: "slds-checkbox_on"
    };
    const _hoisted_6$k = {
      key: 1,
      class: "slds-checkbox_off"
    };
    const _hoisted_7$i = ["for"];
    const _hoisted_8$g = ["title"];
    const _hoisted_9$g = { class: "slds-form-element__control" };
    const _hoisted_10$f = {
      key: 0,
      class: "slds-checkbox slds-checkbox_standalone"
    };
    const _hoisted_11$c = ["id", "aria-describedby", "checked", "disabled"];
    const _hoisted_12$b = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_13$b = {
      key: 2,
      class: "slds-form-element__control"
    };
    const _hoisted_14$8 = {
      key: 0,
      class: "slds-checkbox"
    };
    const _hoisted_15$7 = ["title"];
    const _hoisted_16$7 = ["id", "checked", "disabled", "aria-describedby", "aria-labelledby"];
    const _hoisted_17$6 = ["id", "for"];
    const _hoisted_18$6 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_19$5 = { class: "slds-form-element__label slds-m-left_x-small" };
    const _hoisted_20$4 = ["id"];
    function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $props.slide ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass($options.checkboxClass)
        }, [
          !$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_1$v)) : createCommentVNode("", true),
            createBaseVNode("span", {
              class: normalizeClass(["slds-form-element__label slds-m-bottom_none", { "slds-assistive-text": _ctx.$props.hideLabel }])
            }, [
              createBaseVNode("span", null, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
            ], 2),
            createBaseVNode("input", mergeProps({
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": $data.labelId,
              type: "checkbox",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_2$u),
            createBaseVNode("span", {
              id: $data.labelId,
              class: "slds-checkbox_faux_container",
              "aria-live": "assertive"
            }, [
              _hoisted_4$p,
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_5$n, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOn)), 1)) : createCommentVNode("", true),
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_6$k, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOff)), 1)) : createCommentVNode("", true)
            ], 8, _hoisted_3$t)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ])
          ], 64))
        ], 2)) : $props.isFormElement ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("label", {
            class: "slds-form-element__label",
            for: $data.checkboxId
          }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_8$g)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 8, _hoisted_7$i),
          _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
            key: 0,
            class: "slds-form-element__icon",
            alignment: "top right",
            text: _ctx.$props.helpText
          }, null, 8, ["text"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_9$g, [
            !$props.readonly ? (openBlock(), createElementBlock("span", _hoisted_10$f, [
              createBaseVNode("input", mergeProps({
                id: $data.checkboxId,
                ref: "checkbox",
                "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                checked: _ctx.$props.modelValue || false,
                disabled: $props.disabled,
                type: "checkbox",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                onInput: _cache[3] || (_cache[3] = (...args) => $options.onInput && $options.onInput(...args))
              }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_11$c),
              _hoisted_12$b
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "check",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, _ctx.$props.modelValue]
              ]),
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "steps",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, !_ctx.$props.modelValue]
              ])
            ], 64))
          ])
        ], 64)) : (openBlock(), createElementBlock("div", _hoisted_13$b, [
          !$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_14$8, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_15$7)) : createCommentVNode("", true),
            createBaseVNode("input", mergeProps({
              id: $data.checkboxId,
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
              "aria-labelledby": `${$data.labelId} ${_ctx.$props.ariaLabeledBy}`,
              type: "checkbox",
              onClick: _cache[4] || (_cache[4] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[5] || (_cache[5] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_16$7),
            createBaseVNode("label", {
              id: $data.labelId,
              for: $data.checkboxId,
              class: "slds-checkbox__label"
            }, [
              _hoisted_18$6,
              createBaseVNode("span", {
                class: normalizeClass(["slds-form-element__label", { "slds-assistive-text": _ctx.$props.hideLabel }])
              }, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 3)
            ], 8, _hoisted_17$6)
          ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ]),
            createBaseVNode("span", _hoisted_19$5, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 64))
        ])),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 3,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_20$4)) : createCommentVNode("", true)
      ], 2);
    }
    const Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$z], ["__scopeId", "data-v-6891711e"]]);
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$1;
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h2;
      let s;
      if (max2 === min2) {
        h2 = 0;
      } else if (r === max2) {
        h2 = (g - b) / delta;
      } else if (g === max2) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max2) {
        h2 = 4 + (r - g) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max2 + min2);
      } else {
        s = delta / (2 - max2 - min2);
      }
      return [h2, s * 100, l * 100];
    };
    convert$1.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff2 = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff2 / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h2 = bdif - gdif;
        } else if (g === v) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h2 = convert$1.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h2, w * 100, b * 100];
    };
    convert$1.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert$1.rgb.lab = function(rgb) {
      const xyz = convert$1.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.hsl.rgb = function(hsl) {
      const h2 = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i2 = 0; i2 < 3; i2++) {
        t3 = h2 + 1 / 3 * -(i2 - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i2] = val * 255;
      }
      return rgb;
    };
    convert$1.hsl.hsv = function(hsl) {
      const h2 = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h2, sv * 100, v * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p2 = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p2];
        case 1:
          return [q, v, p2];
        case 2:
          return [p2, v, t];
        case 3:
          return [p2, q, v];
        case 4:
          return [t, p2, v];
        case 5:
          return [v, p2, q];
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h2, sl * 100, l * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i2 = Math.floor(6 * h2);
      const v = 1 - bl;
      f = 6 * h2 - i2;
      if ((i2 & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i2) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert$1.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert$1.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h2];
    };
    convert$1.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert$1.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert$1.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len2 = models2.length, i2 = 0; i2 < len2; i2++) {
        graph[models2[i2]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len2 = adjacents.length, i2 = 0; i2 < len2; i2++) {
          const adjacent = adjacents[i2];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from2, to2) {
      return function(args) {
        return to2(from2(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len2 = models2.length, i2 = 0; i2 < len2; i2++) {
        const toModel = models2[i2];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len2 = result.length, i2 = 0; i2 < len2; i2++) {
            result[i2] = Math.round(result[i2]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    const ConditionalWrapper$1 = {
      name: "ConditionalWrapper",
      functional: true,
      inheritAttrs: false,
      props: {
        element: {
          type: String,
          required: true
        },
        active: Boolean
      },
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        if (this.$props.active) {
          return h(
            this.$props.element,
            {
              ...this.$attrs
            },
            _default
          );
        }
        return _default;
      }
    };
    function debounce(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce.debounce = debounce;
    var debounce_1 = debounce;
    const _debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
    var vClickOutside_umd = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal, function() {
        var e = "__v-click-outside", n = "undefined" != typeof window, t = "undefined" != typeof navigator, r = n && ("ontouchstart" in window || t && navigator.msMaxTouchPoints > 0) ? ["touchstart"] : ["click"], i2 = function(e2) {
          var n2 = e2.event, t2 = e2.handler;
          (0, e2.middleware)(n2) && t2(n2);
        }, a = function(n2, t2) {
          var a2 = function(e2) {
            var n3 = "function" == typeof e2;
            if (!n3 && "object" != typeof e2)
              throw new Error("v-click-outside: Binding value must be a function or an object");
            return { handler: n3 ? e2 : e2.handler, middleware: e2.middleware || function(e3) {
              return e3;
            }, events: e2.events || r, isActive: !(false === e2.isActive), detectIframe: !(false === e2.detectIframe), capture: Boolean(e2.capture) };
          }(t2.value), o2 = a2.handler, d2 = a2.middleware, c = a2.detectIframe, u = a2.capture;
          if (a2.isActive) {
            if (n2[e] = a2.events.map(function(e2) {
              return { event: e2, srcTarget: document.documentElement, handler: function(e3) {
                return function(e4) {
                  var n3 = e4.el, t3 = e4.event, r2 = e4.handler, a3 = e4.middleware, o3 = t3.path || t3.composedPath && t3.composedPath();
                  (o3 ? o3.indexOf(n3) < 0 : !n3.contains(t3.target)) && i2({ event: t3, handler: r2, middleware: a3 });
                }({ el: n2, event: e3, handler: o2, middleware: d2 });
              }, capture: u };
            }), c) {
              var l = { event: "blur", srcTarget: window, handler: function(e2) {
                return function(e3) {
                  var n3 = e3.el, t3 = e3.event, r2 = e3.handler, a3 = e3.middleware;
                  setTimeout(function() {
                    var e4 = document.activeElement;
                    e4 && "IFRAME" === e4.tagName && !n3.contains(e4) && i2({ event: t3, handler: r2, middleware: a3 });
                  }, 0);
                }({ el: n2, event: e2, handler: o2, middleware: d2 });
              }, capture: u };
              n2[e] = [].concat(n2[e], [l]);
            }
            n2[e].forEach(function(t3) {
              var r2 = t3.event, i3 = t3.srcTarget, a3 = t3.handler;
              return setTimeout(function() {
                n2[e] && i3.addEventListener(r2, a3, u);
              }, 0);
            });
          }
        }, o = function(n2) {
          (n2[e] || []).forEach(function(e2) {
            return e2.srcTarget.removeEventListener(e2.event, e2.handler, e2.capture);
          }), delete n2[e];
        }, d = n ? { beforeMount: a, updated: function(e2, n2) {
          var t2 = n2.value, r2 = n2.oldValue;
          JSON.stringify(t2) !== JSON.stringify(r2) && (o(e2), a(e2, { value: t2 }));
        }, unmounted: o } : {};
        return { install: function(e2) {
          e2.directive("click-outside", d);
        }, directive: d };
      });
    })(vClickOutside_umd);
    var vClickOutside_umdExports = vClickOutside_umd.exports;
    const vClickOutside = /* @__PURE__ */ getDefaultExportFromCjs(vClickOutside_umdExports);
    function groupBuilder() {
      const groups = {
        0: {
          options: [],
          filtered: []
        }
      };
      let numAsyncGroups = 0;
      let hasStaticOptions = false;
      let groupIndex = 1;
      const optionsLength = this.options.length;
      for (let i2 = 0; i2 < optionsLength; i2++) {
        const option = this.options[i2];
        const isGroup = option.options;
        if (isGroup) {
          const isTitledGroup = option.title;
          if (Array.isArray(option.options)) {
            const { title, options } = option;
            if (isTitledGroup) {
              groups[groupIndex++] = {
                title,
                options,
                // static data
                filtered: [],
                static: true
              };
            } else {
              groups[0].options = groups[0].options.concat(options);
            }
            hasStaticOptions = true;
          } else if (typeof option.options === "function") {
            const groupId = isTitledGroup ? groupIndex++ : 0;
            const optionsFunction = (term) => this.invokeOptionsFunction(option.options, groupId, term);
            const debounce2 = _debounce(optionsFunction, this.asyncDelay, option.lazy);
            const asyncOptions = {
              searchIndex: 0,
              cached: false,
              options: [],
              doCancelAsync: false,
              loading: false,
              async: true,
              lazy: option.lazy,
              optionsFunction,
              debounce: debounce2
            };
            if (isTitledGroup) {
              groups[groupId] = {
                title: option.title,
                filtered: [],
                ...asyncOptions
              };
            } else {
              groups[0] = {
                ...groups[0],
                ...asyncOptions
              };
            }
            numAsyncGroups++;
          }
        } else {
          groups[0].static = true;
          hasStaticOptions = true;
          if (typeof option === "object") {
            groups[0].options.push({ $__guid: getGUID(), ...option });
          } else if (["string", "number", "symbol"].includes(typeof option)) {
            const title = typeof option === "symbol" ? option.description : option.toString();
            groups[0].options.push({
              $__guid: getGUID(),
              [this.idKey]: option,
              [this.titleKey]: title
            });
          }
        }
      }
      return { groups, numAsyncGroups, hasStaticOptions };
    }
    const _sfc_main$A = {
      name: "Spinner",
      props: {
        /**
         * This centers the spinner indicator within the viewport. This is used for when the spinner's container overflows the viewport and the indicator may be hidden.
         */
        adjustForOverflow: Boolean,
        /**
         * Adds delay of 300ms to the spinner.
         */
        delayed: Boolean,
        /**
         * Sets the spinner container position attribute to `fixed`.
         */
        fixed: Boolean,
        /**
         * Starts animation immediately.
         */
        immediate: Boolean,
        /**
         * Add styling to support an inline spinner inside of the document flow.
         */
        inline: Boolean,
        /**
         * Assistive text label for the spinner.
         */
        loadingLabel: {
          type: String,
          default: "Loading"
        },
        /**
         * Determines the size of the spinner.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = ["xx-small", "x-small", "small", "medium", "large"];
            const isValid2 = validSizes.includes(value);
            if (!isValid2)
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Determines the color of the spinner: `base` is gray, `brand` is blue, and `inverse` is white.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = ["base", "brand", "inverse"];
            const isValid2 = validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Render the spinner without a container.
         */
        withoutContainer: Boolean
      },
      data() {
        return {
          observer: null
        };
      },
      computed: {
        spinnerClasses() {
          const classes = [];
          if (this.$props.immediate)
            classes.push("spm-spinner_immediate");
          if (this.$props.theme)
            classes.push(`slds-spinner_${this.$props.theme}`);
          if (this.$props.delayed)
            classes.push("slds-spinner_delayed");
          if (this.$props.size)
            classes.push(`slds-spinner_${this.$props.size}`);
          if (this.$props.inline)
            classes.push("slds-spinner_inline");
          return classes;
        },
        containerClasses() {
          const classes = [];
          if (!this.$props.withoutContainer || this.$slots.description)
            classes.push("slds-spinner_container");
          if (this.$props.fixed)
            classes.push("slds-is-fixed");
          return classes;
        }
      },
      created() {
        if (this.$props.adjustForOverflow) {
          window.addEventListener("scroll", this.updateContainerSize);
        }
      },
      mounted() {
        if (this.$props.adjustForOverflow) {
          this.updateContainerSize();
          this.observer = new MutationObserver(this.updateContainerSize);
          this.observer.observe(this.$refs.container, { attributes: true });
        }
      },
      beforeUnmount() {
        if (this.$props.adjustForOverflow) {
          window.removeEventListener("scroll", this.updateContainerSize);
          this.observer.disconnect();
          this.observer = null;
        }
      },
      methods: {
        updateContainerSize() {
          const spinnerContainer = this.$refs.container;
          const { parentNode } = spinnerContainer.parentNode;
          const parentRect = parentNode.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          if (parentRect.height < windowHeight)
            return;
          if (parentRect.top < 0) {
            spinnerContainer.style.top = `${Math.abs(parentRect.top)}px`;
          } else {
            spinnerContainer.style.top = 0;
          }
          if (parentRect.bottom > windowHeight) {
            spinnerContainer.style.bottom = `${parentRect.bottom - windowHeight}px`;
          } else {
            spinnerContainer.style.bottom = 0;
          }
        }
      }
    };
    const _withScopeId$b = (n) => (pushScopeId("data-v-21b087de"), n = n(), popScopeId(), n);
    const _hoisted_1$u = { class: "slds-assistive-text" };
    const _hoisted_2$t = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-a" }, null, -1));
    const _hoisted_3$s = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-b" }, null, -1));
    const _hoisted_4$o = {
      key: 0,
      class: "description"
    };
    const _hoisted_5$m = {
      "aria-live": "assertive",
      class: "slds-grid slds-grid_vertical slds-p-top_xx-large slds-text-align_center"
    };
    function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass($options.containerClasses)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([$options.spinnerClasses, "slds-spinner"]),
          "aria-hidden": "false",
          role: "status"
        }, [
          createBaseVNode("span", _hoisted_1$u, toDisplayString(_ctx.$props.loadingLabel), 1),
          _hoisted_2$t,
          _hoisted_3$s
        ], 2),
        _ctx.$slots["description"] ? (openBlock(), createElementBlock("div", _hoisted_4$o, [
          createBaseVNode("div", _hoisted_5$m, [
            renderSlot(_ctx.$slots, "description", {}, void 0, true)
          ])
        ])) : createCommentVNode("", true)
      ], 2);
    }
    const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$y], ["__scopeId", "data-v-21b087de"]]);
    const {
      parseInt: parseInt$1,
      getComputedStyle: getComputedStyle$1
    } = window;
    const _sfc_main$z = {
      name: "PicklistDropdown",
      components: {
        Icon,
        Spinner
      },
      mixins: [decodeHtml],
      data() {
        return {
          focusedOption: null,
          paddingBuffer: 0,
          currentOptionsLength: this.getDefaultOptionsLength()
        };
      },
      computed: {
        focusedOptionId() {
          let result = null;
          if (this.focusedOption) {
            result = this.focusedOption.dataset.id;
            if (this.focusedOption.dataset.type === "number") {
              result = parseInt$1(result);
            }
            if (this.focusedOption.dataset.type === "symbol") {
              result = Symbol.for(result);
            }
          }
          return result;
        },
        computedOptionGroups() {
          const result = {};
          let remaining = this.currentOptionsLength;
          Object.entries(this.$parent.groupData.groups).forEach(([key, group]) => {
            if (group.async || group.filtered.length) {
              if (remaining === 0)
                return;
              let renderLength;
              if (group.filtered.length >= remaining) {
                renderLength = remaining;
                remaining = 0;
              } else {
                renderLength = group.filtered.length;
                remaining -= group.filtered.length;
              }
              result[key] = {
                renderLength,
                ...group
              };
            }
          });
          return result;
        },
        doRenderGlobalNoSearchResults() {
          return this.$parent.groupData.hasStaticOptions && !Object.values(this.$parent.groupData.groups).some((group) => group.async || group.filtered.length);
        }
      },
      watch: {
        focusedOption() {
          this.$parent.focusedOptionId = this.focusedOptionId;
        },
        "$parent.groupData.groups": {
          handler() {
            if (this.$parent.computedDoRenderDropdown) {
              this.currentOptionsLength = this.getDefaultOptionsLength();
              this.$nextTick(this.setDropdownHeight);
            }
          },
          deep: true,
          immediate: true
        },
        "$parent.comboboxInputOption": {
          handler(value) {
            this.$nextTick(() => {
              this.focusedOption = value ? this.$refs.comboboxInputOption : this.getFirstAvailableOptionEl();
              this.$el.scrollTop = 0;
            });
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.paddingBuffer = parseInt$1(getComputedStyle$1(this.$el).paddingTop || 0);
        });
      },
      methods: {
        getDefaultOptionsLength() {
          if (this.$parent.$props.pageSize <= 0) {
            return Infinity;
          }
          return Math.max(this.$parent.$props.pageSize, this.$parent.$props.heightInNumOptions + 1);
        },
        getListRole(groupId) {
          return !groupId ? "presentation" : "group";
        },
        setDropdownHeight() {
          var _a, _b, _c;
          const dropdown = this.$el;
          let dropdownHeight = 0;
          let numResultNodes = 0;
          let numTitleNodes = 0;
          const options = Array.from(this.$el.querySelectorAll("li.slds-listbox__item"));
          for (let i2 = 0; i2 < options.length; i2++) {
            const option = options[i2];
            dropdownHeight += option.clientHeight;
            if (Object.prototype.hasOwnProperty.call(option.dataset, "header")) {
              numTitleNodes++;
            } else {
              numResultNodes++;
            }
            if (numResultNodes === this.$parent.$props.heightInNumOptions)
              break;
          }
          if (options.length <= numResultNodes + numTitleNodes) {
            dropdown.style.height = "auto";
          } else {
            const { borderTopWidth, paddingTop } = getComputedStyle$1(dropdown);
            const dropdownHeightAdjustment = (parseInt$1(borderTopWidth, 10) + parseInt$1(paddingTop, 10)) * 2;
            let dropdownHeaderHeightAdjustment = (_a = this.$refs.dropdownHeader) == null ? void 0 : _a.clientHeight;
            if (dropdownHeaderHeightAdjustment) {
              const { marginTop, marginBottom } = getComputedStyle$1((_c = (_b = this.$refs.dropdownHeader) == null ? void 0 : _b.children) == null ? void 0 : _c[0]);
              dropdownHeaderHeightAdjustment += parseInt$1(marginTop, 10);
              dropdownHeaderHeightAdjustment += parseInt$1(marginBottom, 10);
            }
            dropdown.style.height = `${dropdownHeight + dropdownHeightAdjustment + dropdownHeaderHeightAdjustment}px`;
          }
          this.focusOption();
        },
        focusOption() {
          if (Array.isArray(this.$parent.modelValue)) {
            if (this.$parent.modelValue.length) {
              const [firstId] = this.$parent.modelValue;
              this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(firstId)}"][data-type="${typeof firstId}"]`) || this.getFirstAvailableOptionEl();
              this.scrollToFocusedOption();
            } else {
              this.focusedOption = this.getFirstAvailableOptionEl();
            }
          } else if (this.$parent.modelValue !== null && this.$parent.modelValue !== "" && this.$parent.comboboxInputOption === null) {
            this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(this.$parent.modelValue)}"][data-type="${typeof this.$parent.modelValue}"]`) || this.getFirstAvailableOptionEl();
            this.scrollToFocusedOption();
          } else {
            this.focusedOption = this.getFirstAvailableOptionEl();
          }
        },
        getFirstAvailableOptionEl() {
          return this.$el.querySelector("li[data-option]");
        },
        scrollToFocusedOption() {
          const focusedOptionAbsoluteOffsetTop = this.focusedOption.offsetTop + this.paddingBuffer;
          const dropdownHeight = this.$el.clientHeight;
          if (focusedOptionAbsoluteOffsetTop >= this.$el.scrollTop + dropdownHeight - this.paddingBuffer) {
            this.$el.scrollTop = focusedOptionAbsoluteOffsetTop + this.focusedOption.clientHeight - dropdownHeight;
          }
        },
        enter(e) {
          if (this.focusedOption === this.$refs.comboboxInputOption) {
            this.$parent.select(this.$parent.comboboxInputOption, e);
          } else {
            const option = this.$parent.getOptionById(this.focusedOptionId);
            this.$parent.select(option, e);
          }
        },
        down() {
          if (!this.focusedOption)
            return;
          const {
            nextElementSibling,
            parentElement: {
              nextElementSibling: parentsNextElementSibling
            }
          } = this.focusedOption;
          if (nextElementSibling) {
            this.focusedOption = nextElementSibling;
          } else if (parentsNextElementSibling) {
            const getNextDataOption = function getNextDataOption2(_parentsNextElementSibling) {
              if (_parentsNextElementSibling === null)
                return null;
              return _parentsNextElementSibling.querySelector("li[data-option]") || getNextDataOption2(parentsNextElementSibling.nextElementSibling);
            };
            const li = getNextDataOption(parentsNextElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption) {
            this.scrollToFocusedOption();
          }
          this.onScroll();
        },
        up() {
          if (!this.focusedOption)
            return;
          const {
            previousElementSibling,
            parentElement: {
              previousElementSibling: parentsPreviousElementSibling
            }
          } = this.focusedOption;
          const hasPreviousDataOptionSibling = previousElementSibling && Object.hasOwnProperty.call(previousElementSibling.dataset, "option");
          if (hasPreviousDataOptionSibling) {
            this.focusedOption = previousElementSibling;
          } else if (parentsPreviousElementSibling) {
            const getPreviousDataOption = function getPreviousDataOption2(_parentsPreviousElementSibling) {
              if (_parentsPreviousElementSibling === null)
                return null;
              return _parentsPreviousElementSibling.querySelector("li[data-option]:last-child") || getPreviousDataOption2(parentsPreviousElementSibling.previousElementSibling);
            };
            const li = getPreviousDataOption(parentsPreviousElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption.offsetTop <= this.$el.scrollTop) {
            this.$el.scrollTop = this.focusedOption.offsetTop - this.paddingBuffer;
          }
        },
        onScroll({ target = this.$el } = {}) {
          const { scrollTop, scrollHeight, clientHeight } = target || this.$el;
          if (this.lastScrollTop > scrollTop)
            return;
          if (scrollTop + clientHeight >= scrollHeight - 5) {
            this.currentOptionsLength += this.$parent.$props.pageSize;
            target.scrollTop = scrollTop;
            this.lastScrollTop = scrollTop;
          }
        }
      }
    };
    const _hoisted_1$t = ["id"];
    const _hoisted_2$s = { ref: "dropdownHeader" };
    const _hoisted_3$r = {
      key: 0,
      class: "slds-listbox slds-listbox_vertical",
      role: "presentation"
    };
    const _hoisted_4$n = ["data-id"];
    const _hoisted_5$l = ["aria-selected"];
    const _hoisted_6$j = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_7$h = { class: "slds-media__body" };
    const _hoisted_8$f = { class: "slds-listbox__option-text slds-listbox__option-text_entity" };
    const _hoisted_9$f = { key: 1 };
    const _hoisted_10$e = {
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_11$b = ["title"];
    const _hoisted_12$a = ["role"];
    const _hoisted_13$a = {
      key: 0,
      role: "presentation",
      class: "slds-listbox__item",
      "data-header": ""
    };
    const _hoisted_14$7 = {
      class: "slds-media slds-listbox__option slds-listbox__option_plain slds-media_small",
      role: "presentation"
    };
    const _hoisted_15$6 = {
      class: "slds-listbox__option-header",
      role: "presentation"
    };
    const _hoisted_16$6 = {
      key: 1,
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_17$5 = ["title"];
    const _hoisted_18$5 = ["data-id", "data-type", "onMousedown"];
    const _hoisted_19$4 = ["aria-selected"];
    const _hoisted_20$3 = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_21$2 = { class: "slds-media__body" };
    const _hoisted_22$2 = ["title"];
    const _hoisted_23$2 = { key: 2 };
    const _hoisted_24$2 = { class: "slds-align_absolute-center slds-p-top_medium" };
    function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      return openBlock(), createElementBlock("div", mergeProps({
        id: _ctx.$parent.dropdownId,
        class: "slds-dropdown slds-dropdown_fluid",
        role: "listbox"
      }, toHandlers(_ctx.$parent.$props.pageSize > 0 ? { scroll: $options.onScroll } : {}, true)), [
        createBaseVNode("div", _hoisted_2$s, [
          renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
        ], 512),
        _ctx.$parent.comboboxInputOption ? (openBlock(), createElementBlock("ul", _hoisted_3$r, [
          createBaseVNode("li", {
            ref: "comboboxInputOption",
            role: "presentation",
            class: "slds-listbox__item",
            "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(_ctx.$parent.comboboxInputOption)),
            "data-option": "",
            onMousedown: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$parent.select(_ctx.$parent.comboboxInputOption, $event), ["prevent"]))
          }, [
            createBaseVNode("div", {
              "aria-selected": $data.focusedOption === _ctx.$refs.comboboxInputOption,
              class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_entity slds-listbox__option_term", { "slds-has-focus": $data.focusedOption === _ctx.$refs.comboboxInputOption }]),
              role: "option"
            }, [
              createBaseVNode("span", _hoisted_6$j, [
                createVNode(_component_Icon, {
                  assistiveText: _ctx.$parent.computedLabels.comboboxAdd,
                  title: _ctx.$parent.computedLabels.comboboxAdd,
                  category: "utility",
                  name: "add",
                  size: "x-small"
                }, null, 8, ["assistiveText", "title"])
              ]),
              createBaseVNode("span", _hoisted_7$h, [
                createBaseVNode("span", _hoisted_8$f, toDisplayString(_ctx.$parent.comboboxInputOption[_ctx.$parent.$props.titleKey]), 1)
              ])
            ], 10, _hoisted_5$l)
          ], 40, _hoisted_4$n)
        ])) : createCommentVNode("", true),
        $options.doRenderGlobalNoSearchResults ? (openBlock(), createElementBlock("ul", _hoisted_9$f, [
          createBaseVNode("li", _hoisted_10$e, [
            createBaseVNode("span", {
              class: "slds-m-left_x-large",
              title: _ctx.$parent.computedLabels.noSearchResults
            }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_11$b)
          ])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.computedOptionGroups, (group, name, index) => {
          return openBlock(), createElementBlock("ul", {
            key: index,
            class: "slds-listbox slds-listbox_vertical",
            role: $options.getListRole(group)
          }, [
            group.title != null && (group.filtered.length || group.async) ? (openBlock(), createElementBlock("li", _hoisted_13$a, [
              createBaseVNode("div", _hoisted_14$7, [
                createBaseVNode("h3", _hoisted_15$6, toDisplayString(_ctx.decodeHtml(group.title)), 1)
              ])
            ])) : createCommentVNode("", true),
            group.async && !group.filtered.length && !group.loading ? (openBlock(), createElementBlock("li", _hoisted_16$6, [
              createBaseVNode("span", {
                class: "slds-m-left_x-large",
                title: _ctx.$parent.computedLabels.noSearchResults
              }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_17$5)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(group.renderLength, (n) => {
              return openBlock(), createElementBlock("li", {
                key: group.filtered[n - 1].$__guid,
                "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(group.filtered[n - 1])),
                "data-type": _ctx.$parent.getIdType(group.filtered[n - 1]),
                "data-option": "",
                role: "presentation",
                class: "slds-listbox__item",
                onMousedown: withModifiers(($event) => _ctx.$parent.select(group.filtered[n - 1], $event), ["prevent"])
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_plain slds-media_small", { "slds-has-focus": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId, "slds-is-selected": _ctx.$parent.isOptionSelected(group.filtered[n - 1]) }]),
                  "aria-selected": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId,
                  role: "option"
                }, [
                  renderSlot(_ctx.$slots, "option", {
                    option: group.filtered[n - 1],
                    index: n
                  }, () => [
                    createBaseVNode("span", _hoisted_20$3, [
                      _ctx.$parent.isOptionSelected(group.filtered[n - 1]) ? (openBlock(), createBlock(_component_Icon, {
                        key: 0,
                        class: "slds-current-color",
                        category: "utility",
                        name: "check",
                        size: "x-small"
                      })) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("span", _hoisted_21$2, [
                      createBaseVNode("span", {
                        class: "slds-truncate",
                        title: _ctx.$parent.getTitle(group.filtered[n - 1])
                      }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.getTitle(group.filtered[n - 1]))), 9, _hoisted_22$2)
                    ])
                  ], true)
                ], 10, _hoisted_19$4)
              ], 40, _hoisted_18$5);
            }), 128)),
            group.loading ? (openBlock(), createElementBlock("li", _hoisted_23$2, [
              createBaseVNode("div", _hoisted_24$2, [
                createVNode(_component_Spinner, {
                  class: "slds-input__icon",
                  size: "x-small",
                  withoutContainer: "",
                  isInline: ""
                })
              ])
            ])) : createCommentVNode("", true)
          ], 8, _hoisted_12$a);
        }), 128))
      ], 16, _hoisted_1$t);
    }
    const Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$x], ["__scopeId", "data-v-4e43a862"]]);
    const _sfc_main$y = {
      components: { Checkbox },
      mixins: [decodeHtml],
      data() {
        return {
          dialogId: getGUID(),
          focusableElements: []
        };
      },
      watch: {
        "$parent.groupData": {
          handler(groupData) {
            Object.values(groupData.groups).forEach((group) => {
              group.filtered = group.filtered.map((option) => ({
                ...option,
                isSelected: this.$parent.isOptionSelected(option),
                original: option
              }));
            });
          },
          immediate: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.focusableElements = this.$el.querySelectorAll("input:not([disabled])");
          this.focusableElements[0].focus();
        });
      },
      methods: {
        save(e) {
          const valueArray = [];
          Object.values(this.$parent.groupData.groups).forEach((group) => {
            group.filtered.forEach((option) => {
              if (option.isSelected) {
                const id = this.$parent.getId(option);
                valueArray.push(id);
              }
            });
          });
          this.$parent.$emit("update:modelValue", valueArray);
          this.reset(e);
        },
        select(option, e) {
          this.$parent.$emit("selected-option", option.original, e);
        },
        reset(e) {
          this.$parent.reset(e);
          this.$parent.focus();
        },
        focusFirstElement(e) {
          e.stopPropagation();
          e.preventDefault();
          this.focusableElements[0].focus();
        },
        shiftTab(e) {
          if (document.activeElement === this.focusableElements[0]) {
            e.stopPropagation();
            e.preventDefault();
            this.$refs.savebutton.focus();
          }
        }
      }
    };
    const _hoisted_1$s = ["aria-describedby", "aria-label"];
    const _hoisted_2$r = ["id"];
    const _hoisted_3$q = {
      key: 0,
      class: "slds-form-element__legend slds-form-element__label"
    };
    const _hoisted_4$m = { class: "slds-form-element__control" };
    const _hoisted_5$k = { class: "slds-popover__footer slds-popover__footer_form" };
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Checkbox = resolveComponent("Checkbox");
      return openBlock(), createElementBlock("section", {
        "aria-describedby": $data.dialogId,
        "aria-label": _ctx.$parent.$props.labels.name,
        class: "slds-popover slds-popover_full-width custom-z-index",
        role: "dialog",
        onKeydown: [
          _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.reset && $options.reset(...args), ["stop"]), ["esc"])),
          _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["exact", "shift"]), ["tab"]))
        ]
      }, [
        createBaseVNode("div", {
          id: $data.dialogId,
          ref: "multiselectdialog",
          class: "slds-popover__body slds-popover__body_small"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$parent.groupData.groups, (group, name, index) => {
            return openBlock(), createElementBlock("fieldset", {
              key: index,
              class: "slds-form-element"
            }, [
              group.title != null ? (openBlock(), createElementBlock("legend", _hoisted_3$q, toDisplayString(_ctx.decodeHtml(group.title)), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$m, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(group.filtered, (option) => {
                  return openBlock(), createBlock(_component_Checkbox, {
                    key: option.$__guid,
                    modelValue: option.isSelected,
                    "onUpdate:modelValue": ($event) => option.isSelected = $event,
                    labels: { name: _ctx.$parent.getTitle(option) },
                    onClick: ($event) => $options.select(option, $event)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "labels", "onClick"]);
                }), 128))
              ])
            ]);
          }), 128))
        ], 8, _hoisted_2$r),
        createBaseVNode("footer", _hoisted_5$k, [
          createBaseVNode("button", {
            class: "slds-button slds-button_neutral",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.reset && $options.reset(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.cancel)), 1),
          createBaseVNode("button", {
            ref: "savebutton",
            class: "slds-button slds-button_brand",
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.focusFirstElement && $options.focusFirstElement(...args), ["stop", "exact"]), ["tab"])),
            onClick: _cache[2] || (_cache[2] = (...args) => $options.save && $options.save(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.save)), 545)
        ])
      ], 40, _hoisted_1$s);
    }
    const MultiselectDialog = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$w], ["__scopeId", "data-v-0a28cef2"]]);
    const _sfc_main$x = {
      name: "PillList",
      components: { Icon },
      mixins: [decodeHtml],
      props: {
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: Object,
          default: () => ({
            remove: "Press delete or backspace to remove.",
            listboxLabel: "Selected Options:",
            error: "Warning"
          })
        },
        /**
         * Adds border to pill list container.
         */
        containerBorder: Boolean,
        /**
         * Labels object for the pill list
         */
        labels: {
          type: Object,
          default: () => ({
            removeTitle: "Remove",
            error: "Error"
          })
        },
        /**
         * Options array for the pill list. `label` and `title` props are required.
         */
        options: {
          type: Array,
          default: () => [],
          validator(value) {
            return value.every((item) => {
              const requiredProps = ["label", "title"];
              const missing = getMissingProps(item, requiredProps);
              if (missing.length) {
                console.error(`Options object is missing required properties: ${missing.toString()}`);
                return false;
              }
              return true;
            });
          }
        },
        /**
         * Border for individual pill items.
         */
        pillBorder: {
          type: Boolean,
          default: true
        },
        /**
         * Sets pills to readonly and disables deletion.
         */
        readonly: Boolean
      },
      data() {
        return {
          mutableOptionsArray: [],
          lastFocusedOptionIndex: 0
        };
      },
      watch: {
        options: {
          handler(value) {
            this.mutableOptionsArray = value.map((item) => ({
              $__guid: getGUID(),
              ...item
            }));
          },
          deep: true,
          immediate: true
        }
      },
      methods: {
        focusLastFocusedOption() {
          const option = this.$refs[`option-${this.lastFocusedOptionIndex}`][0];
          if (option)
            option.focus();
        },
        remove(optionIndex, e) {
          if (this.readonly)
            return;
          const removedOption = this.mutableOptionsArray.splice(optionIndex, 1)[0];
          delete removedOption.$__guid;
          this.$emit("update:options", this.mutableOptionsArray);
          this.$emit("remove", removedOption, e);
          if (!this.mutableOptionsArray.length) {
            this.$nextTick(this.$refs.listbox.focus.bind(this.$refs.listbox));
            return;
          }
          if (this.lastFocusedOptionIndex > this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex--;
          }
          this.$nextTick(this.focusLastFocusedOption.bind(this));
        },
        left() {
          if (this.lastFocusedOptionIndex > 0) {
            this.lastFocusedOptionIndex--;
          } else {
            this.lastFocusedOptionIndex = this.mutableOptionsArray.length - 1;
          }
          this.focusLastFocusedOption();
        },
        right() {
          if (this.lastFocusedOptionIndex < this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex++;
          } else {
            this.lastFocusedOptionIndex = 0;
          }
          this.focusLastFocusedOption();
        }
      }
    };
    const _hoisted_1$r = ["aria-label"];
    const _hoisted_2$q = ["tabindex", "onFocus"];
    const _hoisted_3$p = ["title"];
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({ "slds-pill_container": _ctx.$props.containerBorder, "slds-listbox_selection-group": !_ctx.$props.containerBorder })
      }, [
        createBaseVNode("ul", {
          ref: "listbox",
          class: "slds-listbox slds-listbox_horizontal",
          role: "listbox",
          "aria-label": $props.assistiveText.listboxLabel,
          "aria-orientation": "horizontal",
          onKeydown: [
            _cache[0] || (_cache[0] = withKeys((...args) => $options.left && $options.left(...args), ["left"])),
            _cache[1] || (_cache[1] = withKeys((...args) => $options.right && $options.right(...args), ["right"])),
            _cache[2] || (_cache[2] = withKeys(($event) => $options.remove($data.lastFocusedOptionIndex, $event), ["delete"]))
          ]
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.mutableOptionsArray, (option, index) => {
            return openBlock(), createElementBlock("li", {
              key: option.$__guid,
              class: "slds-listbox-item",
              role: "presentation"
            }, [
              createBaseVNode("span", {
                ref_for: true,
                ref: `option-${index}`,
                class: normalizeClass(["slds-pill", { "slds-pill_bare": !$props.pillBorder, "slds-has-error": option.hasError }]),
                role: "option",
                tabindex: $data.lastFocusedOptionIndex === index ? 0 : -1,
                "aria-selected": "true",
                onFocus: ($event) => $data.lastFocusedOptionIndex = index
              }, [
                option.hasError ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  class: "slds-pill__icon_container",
                  category: "utility",
                  name: "error",
                  variant: "error",
                  assistiveText: $props.assistiveText.error,
                  title: $props.labels.error
                }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
                createBaseVNode("span", {
                  class: "slds-pill__label",
                  title: option.title
                }, toDisplayString(_ctx.decodeHtml(option.label)), 9, _hoisted_3$p),
                !$props.readonly ? (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  class: "slds-pill__remove cursor-pointer",
                  category: "utility",
                  name: "close",
                  size: "x-small",
                  assistiveText: $props.assistiveText.remove,
                  onMousedown: withModifiers(($event) => $options.remove(index, $event), ["prevent"])
                }, null, 8, ["assistiveText", "onMousedown"])) : createCommentVNode("", true)
              ], 42, _hoisted_2$q)
            ]);
          }), 128))
        ], 40, _hoisted_1$r)
      ], 2);
    }
    const PillList = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$v], ["__scopeId", "data-v-e31e462f"]]);
    const valuePropUpdater = function valuePropUpdater2(value) {
      if (value) {
        if (Array.isArray(this.$props.modelValue)) {
          this.mutableValueArray = [].concat(...this.$props.modelValue);
        } else {
          this.mutableValueArray = this.$props.modelValue ? [this.$props.modelValue] : [];
          this.$emit("update:modelValue", this.mutableValueArray);
        }
      } else {
        this.$emit("update:modelValue", this.mutableValueArray.length === 1 ? this.mutableValueArray[0] : "");
      }
    };
    const defaultLabels$4 = () => ({
      name: null,
      search: "Search...",
      noSearchResults: "No search results.",
      clearTitle: "Clear the text input",
      clearAssistiveText: "Clear the text input",
      removeTitle: "Remove",
      removeAssistiveText: "Remove",
      comboboxAdd: "Add",
      comboboxSearchAssistiveText: "Search for term",
      save: "Save",
      required: "Required",
      loading: "Loading",
      cancel: "Cancel",
      placeholder: "Select an Option"
    });
    const _sfc_main$w = {
      name: "Picklist",
      components: {
        ButtonIcon,
        Dropdown,
        Icon,
        MultiselectDialog,
        PillList,
        Spinner,
        Tooltip
      },
      directives: {
        "click-outside": vClickOutside.directive,
        "detach-element": detach
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Provides debounce function with delay value.
         */
        asyncDelay: {
          type: Number,
          default: 500
        },
        /**
         * When selected, allows combobox functionality.
         */
        combobox: Boolean,
        /**
         * Allows for Picklist dropdown to be removed from DOM flow
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * List of picklist errors.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Allows for filterable options.
         */
        filterable: Boolean,
        /**
         * Sets height of dropdown in number of options.
         */
        heightInNumOptions: {
          type: [Number, Infinity],
          default: 5
        },
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Value of the id key.
         */
        idKey: {
          type: String,
          default: "id"
        },
        /**
         * If using a label that is not part of this component, use this prop
         * since there is a label being used in the app that is located outside
         * of this component.
         */
        labelForId: {
          type: String,
          default: ""
        },
        /**
         * Picklist labels object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Minimum search length before search func is initiated.
         */
        minSearchLength: {
          type: Number,
          default: 2
        },
        /**
         * Currently selected picklist value(s).
         */
        modelValue: {
          type: [Number, String, Array, Symbol],
          default: ""
        },
        /**
         * Allows for multiselectable options.
         */
        multiselect: Boolean,
        /**
         * Multiselect Dialog options dropdown.
         */
        multiselectDialog: Boolean,
        /**
         * Callback function invoked by the component when a user selects an option.
         */
        onRequestSelectOption: {
          type: Function,
          default: null
        },
        /**
         * Array of item objects in the dropdown menu or asynchronous search function.
         */
        options: {
          type: Array,
          required: true,
          validator(options) {
            let hasUntitledGroup = false;
            for (let i2 = 0; i2 < options.length; i2++) {
              const option = options[i2];
              if (Object.hasOwnProperty.call(option, "options") && !Object.hasOwnProperty.call(option, "title")) {
                if (hasUntitledGroup) {
                  console.error("Cannot have more than one group without a title.");
                  return false;
                }
                hasUntitledGroup = true;
              }
            }
            return true;
          }
        },
        /**
         * When applicable, this value is used to lazily render options. To disable, set to a value of 0.
         */
        pageSize: {
          type: Number,
          default: 50
        },
        /**
         * Readonly version of the picklist.
         */
        readonly: Boolean,
        /**
         * Allows dropdown to remain open on selection of option
         */
        remainOpenOnSelect: Boolean,
        /**
         * Applies label styling for a required form element.
         */
        required: Boolean,
        /**
         * By default the dropdown list will resize itself to the width of the input element (anchor). If resizeToFitContent
         * is toggled on the dropdown width resizes to fit the content with the minimum width set to the width of the anchor.
         */
        resizeToFitContent: Boolean,
        /**
         * Value of the title key.
         */
        titleKey: {
          type: String,
          default: "title"
        }
      },
      emits: [
        "clear",
        "detached",
        "reset",
        "selected-option",
        "update:modelValue"
      ],
      data() {
        return {
          isActive: false,
          doRenderDropdown: false,
          dropdownId: getGUID(),
          errorId: getGUID(),
          focusedOptionId: null,
          input: "",
          cachedInput: "",
          labelId: getGUID(),
          inputId: getGUID(),
          mutableValueArray: [],
          comboboxInputOption: null,
          multiselectOptions: [],
          groupData: {
            groups: {},
            numAsyncGroups: 0,
            hasStaticOptions: false
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().picklist || {} : {};
          return {
            ...defaultLabels$4(),
            ...globals,
            ...this.$props.labels
          };
        },
        clickOutsideOptions() {
          return {
            isActive: this.doRenderDropdown,
            handler: this.clickedOutside
          };
        },
        showSearchIcon() {
          return this.$props.filterable && (this.$props.multiselect || !this.hasValue);
        },
        hasAutocompletedValue() {
          return this.hasValue && this.singleSelect && this.$props.filterable;
        },
        showDownIcon() {
          return !this.$props.filterable;
        },
        isReadOnly() {
          return this.hasAutocompletedValue || !this.$props.filterable && !this.$props.combobox;
        },
        readonlyValue() {
          if (this.singleSelect) {
            const option = this.getOptionById(this.$props.modelValue);
            return !option ? null : this.getTitle(option);
          }
          return null;
        },
        singleSelect() {
          return !this.$props.multiselect;
        },
        hasValue() {
          return this.$props.multiselect ? (this.$props.modelValue || []).length > 0 : !!this.$props.modelValue;
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        computedPlaceholder() {
          if (this.isLoading) {
            return this.computedLabels.loading;
          }
          return this.isReadOnly || this.$props.combobox && !this.$props.filterable ? this.computedLabels.placeholder : this.computedLabels.search;
        },
        doRenderPillList() {
          return this.$props.readonly && this.multiselectOptions.length || this.$props.multiselect && !this.$props.multiselectDialog && (this.multiselectOptions.length > 1 || (this.$props.filterable || this.$props.combobox) && this.multiselectOptions.length);
        },
        isLoading() {
          return Object.values(this.groupData.groups).some((group) => group.loading);
        },
        computedDoRenderDropdown() {
          return !this.$props.multiselectDialog && this.doRenderDropdown || this.groupData.numAsyncGroups > 1 && this.isLoading;
        }
      },
      watch: {
        modelValue: {
          handler(value) {
            if (value === null || Array.isArray(value)) {
              this.mutableValueArray = [].concat(...value || []);
            }
            this.setMultiselectOptions();
            this.setInput();
          },
          immediate: true
        },
        multiselect: valuePropUpdater,
        multiselectDialog: valuePropUpdater,
        $props: {
          handler() {
            if (this.$props.multiselectDialog) {
              if (this.$props.filterable || this.$props.combobox || this.$props.multiselect) {
                throw new Error("Cannot combine multiselectDialog with other features.");
              }
            }
            if (this.$props.labels && (!this.$props.labels.name || !this.$props.labels.name.length) && (!this.$props.labelForId || !this.$props.labelForId.length)) {
              console.error("Must provide label for name or pass value to labelForId prop");
            }
            if (this.$props.remainOpenOnSelect && !this.$props.multiselect) {
              console.error("Must enable multiselect to use remainOpenOnSelect prop");
            }
          },
          deep: true,
          immediate: true
        },
        focusedOptionId(value) {
          if (value && !this.$props.filterable && !this.$props.combobox && this.singleSelect) {
            this.input = this.getTitleById(value);
          }
        },
        options: {
          handler() {
            this.groupData = groupBuilder.call(this);
            this.reconcileOptions();
          },
          deep: true
        },
        asyncDelay(value) {
          Object.values(this.groupData.groups).forEach((group) => {
            if (group.async) {
              group.debounce = _debounce(group.optionsFunction, value);
            }
          });
        }
      },
      created() {
        this.validateValueBindingType();
        this.groupData = groupBuilder.call(this);
      },
      methods: {
        focus() {
          this.$refs.input.focus();
        },
        reconcileOptions() {
          if (this.$props.combobox || !this.hasValue)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            const originalLength = this.mutableValueArray.length;
            this.mutableValueArray = this.mutableValueArray.filter((value) => this.getOptionById(value));
            if (originalLength !== this.mutableValueArray.length) {
              this.$emit("update:modelValue", this.mutableValueArray);
            }
          } else if (this.getOptionById(this.$props.modelValue)) {
            this.setInput();
          } else {
            this.$emit("update:modelValue", "");
          }
        },
        clear() {
          this.input = "";
          this.$emit("update:modelValue", this.input);
          this.$emit("clear");
          this.$nextTick(this.activationHandler);
          this.$nextTick(() => {
            this.$refs.input.focus();
          });
        },
        setMultiselectOptions() {
          this.multiselectOptions = this.mutableValueArray.map((id) => {
            const option = this.getOptionById(id);
            const title = option ? this.getTitle(option) : id;
            return {
              [this.$props.idKey]: id,
              label: title,
              title
            };
          });
        },
        setInput() {
          if ((this.$props.multiselect || this.$props.multiselectDialog) && !this.$props.filterable) {
            if (this.$props.combobox) {
              this.input = null;
              return;
            }
            if (this.mutableValueArray.length > 1) {
              this.input = `${this.mutableValueArray.length} options selected`;
            } else {
              this.input = this.getTitleById(this.mutableValueArray[0]);
            }
          } else if (this.$props.modelValue) {
            this.input = this.getTitleById(this.$props.modelValue);
          } else {
            this.input = null;
          }
          this.cachedInput = this.input;
        },
        validateValueBindingType() {
          if (this.$props.modelValue === null)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            if (!Array.isArray(this.$props.modelValue)) {
              throw new Error("Value binding type must be in array in multi-select mode.");
            }
          } else if (!["string", "number", "symbol"].includes(typeof this.$props.modelValue)) {
            throw new Error("Value binding type must be a Number, String, or Symbol in single-select mode.");
          }
        },
        onBlur(e) {
          if (e.relatedTarget && this.doRenderDropdown && !this.$props.multiselectDialog) {
            this.reset(e);
            this.$emit("reset");
          }
        },
        onClick() {
          if (!this.doRenderDropdown) {
            this.activationHandler();
          }
        },
        onDetachRender() {
          if (!this.$props.multiselectDialog) {
            this.$refs.dropdown.setDropdownHeight();
          }
        },
        enter(e) {
          if (e.isComposing || e.keyCode === 229) {
            return;
          }
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.enter(e);
          } else {
            this.activationHandler();
          }
        },
        up() {
          if (!this.$props.multiselectDialog && this.doRenderDropdown) {
            this.$refs.dropdown.up();
          }
        },
        down() {
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.down();
          } else {
            this.activationHandler();
          }
        },
        activationHandler() {
          if (this.hasAutocompletedValue || this.isLoading)
            return;
          if (this.groupData.hasStaticOptions) {
            this.doRenderDropdown = true;
          } else if (this.$props.combobox && this.input) {
            this.doRenderDropdown = true;
            this.updateComboboxInputOption();
          } else {
            this.doRenderDropdown = false;
          }
          this.search();
        },
        clickedOutside(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.reset(e);
          this.$emit("reset");
        },
        escape(e) {
          this.reset(e);
          this.$emit("reset");
        },
        reset(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.input = this.cachedInput;
          Object.values(this.groupData.groups).forEach((group) => {
            group.filtered = [];
            group.searchIndex++;
            group.loading = false;
          });
          this.comboboxInputOption = null;
          this.focusedOptionId = null;
          this.doRenderDropdown = false;
        },
        getIdType(option) {
          return typeof this.getId(option);
        },
        getId(option) {
          if (!option || ["string", "number", "symbol"].includes(typeof option))
            return option;
          return option[this.$props.idKey];
        },
        getIdAsString(id) {
          return typeof id === "symbol" ? id.description : id;
        },
        getTitle(option) {
          if (["string", "number"].includes(typeof option))
            return option.toString();
          if (typeof option === "symbol")
            return option.description;
          return option[this.$props.titleKey];
        },
        getTitleById(id) {
          return this.getTitle(this.getOptionById(id) || id || "");
        },
        getOptionById(id) {
          if (!id)
            return null;
          for (let i2 = 0; i2 < this.$props.options.length; i2++) {
            const item = this.$props.options[i2];
            if (Array.isArray(item.options)) {
              const result = item.options.find((subOption) => this.getId(subOption) === id);
              if (result)
                return result;
            }
            if (typeof item === "object" && this.getId(item) === id)
              return item;
            if (["string", "number", "symbol"].includes(typeof item) && item === id)
              return item;
          }
          const groups = Object.values(this.groupData.groups);
          for (let i2 = 0; i2 < groups.length; i2++) {
            const option = groups[i2].filtered.find((_option) => this.getId(_option) === id);
            if (option)
              return option;
          }
          return null;
        },
        search() {
          if (this.hasAutocompletedValue)
            return;
          const sanitizedValue = (this.input || "").replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
          const regex = new RegExp(sanitizedValue, "i");
          const returnAllOptions = !sanitizedValue || (!this.$props.filterable || !this.$props.filterable && this.$props.combobox);
          Object.entries(this.groupData.groups).forEach(([, group]) => {
            group.filtered = [];
            if (group.static) {
              if (returnAllOptions || this.groupData.numAsyncGroups) {
                group.filtered = group.options;
              } else {
                group.options.forEach((option) => {
                  if (regex.test(this.getTitle(option))) {
                    group.filtered.push(option);
                  }
                });
              }
            } else if (group.async) {
              if (!this.$props.filterable) {
                group.optionsFunction(sanitizedValue);
              } else if (group.lazy || sanitizedValue.length >= this.$props.minSearchLength) {
                group.debounce(sanitizedValue);
              }
            }
          });
        },
        invokeOptionsFunction(fn, groupId, term) {
          const group = this.groupData.groups[groupId];
          group.loading = true;
          const searchIndex = ++group.searchIndex;
          fn.call(fn, term).then((options = []) => {
            if (searchIndex < group.searchIndex)
              return;
            const filtered = [];
            options.forEach((option) => {
              if (typeof option === "object") {
                filtered.push({ $__guid: getGUID(), ...option });
              } else if (["string", "number"].includes(typeof option)) {
                filtered.push({
                  $__guid: getGUID(),
                  [this.idKey]: option,
                  [this.titleKey]: option.toString()
                });
              }
            });
            group.filtered = group.filtered.concat(filtered);
            if (group.lazy || !this.$props.filterable) {
              group.options = group.filtered;
              group.static = true;
              group.async = false;
              this.groupData.hasStaticOptions = true;
              this.groupData.numAsyncGroups--;
            }
            this.doRenderDropdown = true;
            if (!this.multiselectDialog) {
              this.$nextTick(() => {
                group.loading = false;
              });
            }
          }).catch((error) => {
            throw new Error(error);
          });
        },
        isOptionSelected(option) {
          const id = this.getId(option);
          return this.$props.modelValue === id || (this.$props.multiselect || this.$props.multiselectDialog) && this.mutableValueArray.includes(id);
        },
        onInput() {
          this.activationHandler();
          this.updateComboboxInputOption();
        },
        updateComboboxInputOption() {
          if (!this.combobox)
            return;
          if (this.input) {
            this.comboboxInputOption = {
              [this.$props.idKey]: this.input,
              [this.$props.titleKey]: this.input
            };
          } else {
            this.comboboxInputOption = null;
          }
        },
        select(option, e) {
          if (this.onRequestSelectOption && typeof this.onRequestSelectOption === "function" && !this.onRequestSelectOption(option, e)) {
            return;
          }
          const id = this.getId(option);
          if (this.singleSelect) {
            this.$emit("update:modelValue", id);
          } else if (this.isOptionSelected(option)) {
            this.$emit("update:modelValue", this.mutableValueArray.filter((item) => this.getId(item) !== id));
          } else {
            this.mutableValueArray.push(id);
            this.$emit("update:modelValue", this.mutableValueArray);
          }
          const optionToEmit = { ...option };
          delete optionToEmit.$__guid;
          this.$emit("selected-option", optionToEmit, e);
          if (!this.$props.multiselectDialog && !this.$props.remainOpenOnSelect) {
            this.$nextTick(() => {
              this.reset();
              this.$nextTick(() => {
                this.$refs.input.focus();
              });
            });
          }
        },
        removePillListOptionHandler(option, e) {
          this.select(option, e);
        }
      }
    };
    const _hoisted_1$q = ["id", "for"];
    const _hoisted_2$p = ["title"];
    const _hoisted_3$o = { class: "slds-form-element__control" };
    const _hoisted_4$l = ["aria-expanded"];
    const _hoisted_5$j = {
      class: "slds-combobox__form-element slds-input-has-icon slds-input-has-icon_right",
      role: "none"
    };
    const _hoisted_6$i = ["id", "disabled", "aria-labelledby", "aria-controls"];
    const _hoisted_7$g = { class: "slds-truncate" };
    const _hoisted_8$e = ["id", "aria-controls", "aria-activedescendant", "aria-invalid", "aria-describedby", "placeholder", "readonly", "disabled"];
    const _hoisted_9$e = {
      key: 1,
      class: "readonly-select-label"
    };
    const _hoisted_10$d = ["id"];
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Dropdown = resolveComponent("Dropdown");
      const _component_MultiselectDialog = resolveComponent("MultiselectDialog");
      const _component_PillList = resolveComponent("PillList");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slds-form-element", { "slds-has-error": $options.hasErrors }])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          class: "slds-form-element__label",
          for: $data.inputId
        }, [
          $props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "* ", 8, _hoisted_2$p)) : createCommentVNode("", true),
          createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$q)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$o, [
          createBaseVNode("div", {
            class: normalizeClass(["slds-combobox_container", { "slds-has-selection": $options.hasAutocompletedValue }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click", { "slds-is-open": $options.computedDoRenderDropdown }]),
              "aria-expanded": `${$options.computedDoRenderDropdown}`,
              "aria-haspopup": "listbox",
              role: "combobox"
            }, [
              createBaseVNode("div", _hoisted_5$j, [
                !_ctx.$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  $options.hasAutocompletedValue ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    id: $data.inputId,
                    ref: "input",
                    disabled: _ctx.$props.disabled,
                    type: "button",
                    class: "slds-input_faux slds-combobox__input slds-combobox__input-value",
                    "aria-labelledby": [$data.labelId, $data.inputId].join(" "),
                    "aria-controls": $data.dropdownId,
                    "aria-expanded": "false",
                    "aria-haspopup": "listbox"
                  }, [
                    createBaseVNode("span", _hoisted_7$g, toDisplayString($data.input), 1)
                  ], 8, _hoisted_6$i)) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
                    key: 1,
                    id: $options.computedLabels.name ? $data.inputId : $props.labelForId,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.input = $event),
                    type: "text",
                    class: ["slds-input slds-combobox__input", { "slds-combobox__input-value": $options.hasAutocompletedValue }],
                    "aria-autocomplete": "list",
                    autoComplete: "off",
                    role: "textbox",
                    "aria-controls": $options.computedDoRenderDropdown ? $data.dropdownId : null,
                    "aria-activedescendant": $options.getIdAsString($data.focusedOptionId),
                    "aria-invalid": !!_ctx.$props.errors.length,
                    "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                    placeholder: $options.computedPlaceholder,
                    readonly: $options.isReadOnly,
                    disabled: _ctx.$props.disabled
                  }, _ctx.$attrs, {
                    onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args)),
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                    onBlur: _cache[3] || (_cache[3] = (...args) => $options.onBlur && $options.onBlur(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
                      _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => $options.enter && $options.enter(...args), ["prevent"]), ["enter"])),
                      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => $options.escape && $options.escape(...args), ["stop"]), ["esc"]))
                    ]
                  }), null, 16, _hoisted_8$e)), [
                    [vModelText, $data.input]
                  ]),
                  !_ctx.$props.disabled && $options.hasAutocompletedValue ? (openBlock(), createBlock(_component_ButtonIcon, {
                    key: 2,
                    class: "slds-input__icon",
                    iconCategory: "utility",
                    iconName: "clear",
                    assistiveText: $options.computedLabels.clearAssistiveText,
                    title: $options.computedLabels.clearTitle,
                    onClick: $options.clear
                  }, null, 8, ["assistiveText", "title", "onClick"])) : $options.isLoading ? (openBlock(), createBlock(_component_Spinner, {
                    key: 3,
                    class: "slds-input__icon",
                    size: "x-small",
                    theme: "brand",
                    loadingLabel: $options.computedLabels.loading,
                    withoutContainer: ""
                  }, null, 8, ["loadingLabel"])) : renderSlot(_ctx.$slots, "icon", { key: 4 }, () => [
                    $options.showSearchIcon ? (openBlock(), createBlock(_component_Icon, {
                      key: 0,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "search",
                      size: "x-small"
                    })) : $options.showDownIcon && !$options.isLoading ? (openBlock(), createBlock(_component_Icon, {
                      key: 1,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "down",
                      size: "x-small"
                    })) : createCommentVNode("", true)
                  ], true)
                ], 64)) : (openBlock(), createElementBlock("div", _hoisted_9$e, toDisplayString($options.readonlyValue), 1))
              ]),
              $options.computedDoRenderDropdown ? withDirectives((openBlock(), createBlock(_component_Dropdown, {
                key: 0,
                ref: "dropdown"
              }, {
                option: withCtx(({ option, index }) => [
                  renderSlot(_ctx.$slots, "option", {
                    option,
                    index
                  }, void 0, true)
                ]),
                dropdownHeader: withCtx(() => [
                  renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
                ]),
                _: 3
              })), [
                [_directive_click_outside, $options.clickOutsideOptions],
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true),
              _ctx.$props.multiselectDialog && $data.doRenderDropdown ? withDirectives((openBlock(), createBlock(_component_MultiselectDialog, {
                key: 1,
                ref: "dropdown"
              }, null, 512)), [
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true)
            ], 10, _hoisted_4$l)
          ], 2),
          $options.doRenderPillList ? (openBlock(), createBlock(_component_PillList, {
            key: 0,
            readonly: _ctx.$props.readonly,
            options: $data.multiselectOptions,
            onRemove: $options.removePillListOptionHandler
          }, null, 8, ["readonly", "options", "onRemove"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "footer", {}, void 0, true),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_10$d)) : createCommentVNode("", true)
      ], 2);
    }
    const Picklist = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$u], ["__scopeId", "data-v-3db3f0d2"]]);
    const defaultLabels$3 = () => ({
      name: null,
      placeholder: null,
      required: "Required"
    });
    const _sfc_main$v = {
      name: "TextInput",
      components: { Tooltip },
      mixins: [decodeHtml],
      props: {
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * Disables manual resize for textarea type inputs.
         */
        disableResize: Boolean,
        /**
         * Error array for text input.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Displays text or node to the left of the input. This follows the fixed text input UX pattern.
         */
        fixedTextLeft: {
          type: String,
          default: ""
        },
        /**
         * Displays text or node to the right of the input. This follows the fixed text input UX pattern.
         */
        fixedTextRight: {
          type: String,
          default: ""
        },
        /**
         * Immediately sets focus to input.
         */
        hasFocus: Boolean,
        /**
         * Content for Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Labels prop for input.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The input is a controlled component, and will always display this value.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * Displays the value of the input as read-only. This is used in the inline edit UX pattern.
         */
        readonly: Boolean,
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * The element includes support for all HTML5 types.
         */
        type: {
          type: String,
          default: "text"
        },
        /**
         * A multi-line plain-text editing control.
         */
        useTextArea: Boolean
      },
      data() {
        return {
          errorId: getGUID(),
          inputId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().textInput || {} : {};
          return {
            ...defaultLabels$3(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        hasFixedAddon() {
          return this.$props.fixedTextLeft || this.$props.fixedTextRight;
        },
        fixedAddonIds() {
          if (!this.hasFixedAddon)
            return null;
          let addonIds = this.labelId;
          if (this.$props.fixedTextLeft)
            addonIds += " fixed-text-addon-pre";
          if (this.$props.fixedTextRight)
            addonIds += " fixed-text-addon-post";
          return addonIds;
        }
      },
      watch: {
        "$props.hasFocus": {
          handler(value) {
            if (value)
              this.focus();
          }
        }
      },
      mounted() {
        if (this.$props.hasFocus)
          this.focus();
      },
      methods: {
        focus() {
          this.$refs.input.focus();
          this.$refs.input.select();
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.value);
        }
      }
    };
    const _hoisted_1$p = ["id", "for"];
    const _hoisted_2$o = ["title"];
    const _hoisted_3$n = {
      key: 0,
      id: "fixed-text-addon-pre",
      class: "slds-form-element__addon"
    };
    const _hoisted_4$k = ["id", "disabled", "value", "placeholder", "readonly", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_5$i = ["id", "type", "disabled", "readonly", "placeholder", "value", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_6$h = {
      key: 3,
      id: "fixed-text-addon-post",
      class: "slds-form-element__addon"
    };
    const _hoisted_7$f = ["id"];
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          for: $data.inputId,
          class: "slds-form-element__label"
        }, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "*", 8, _hoisted_2$o)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$p)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          class: "slds-form-element__icon",
          alignment: "top right",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["slds-form-element__control", { "slds-input-has-fixed-addon": $options.hasFixedAddon }])
        }, [
          _ctx.$props.fixedTextLeft ? (openBlock(), createElementBlock("span", _hoisted_3$n, toDisplayString(_ctx.$props.fixedTextLeft), 1)) : createCommentVNode("", true),
          _ctx.$props.useTextArea ? (openBlock(), createElementBlock("textarea", mergeProps({
            key: 1,
            id: $data.inputId,
            ref: "input",
            disabled: _ctx.$props.disabled,
            value: _ctx.$props.modelValue,
            placeholder: $options.computedLabels.placeholder,
            readonly: _ctx.$props.readonly,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: [{ "disable-resize": _ctx.$props.disableResize }, "slds-textarea"]
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_4$k)) : (openBlock(), createElementBlock("input", mergeProps({
            key: 2,
            id: $data.inputId,
            ref: "input",
            type: _ctx.$props.type,
            disabled: _ctx.$props.disabled,
            readonly: _ctx.$props.readonly,
            placeholder: $options.computedLabels.placeholder,
            value: _ctx.$props.modelValue,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: "slds-input"
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[2] || (_cache[2] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_5$i)),
          _ctx.$props.fixedTextRight ? (openBlock(), createElementBlock("span", _hoisted_6$h, toDisplayString(_ctx.$props.fixedTextRight), 1)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "extend", {}, void 0, true)
        ], 2),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_7$f)) : createCommentVNode("", true)
      ], 2);
    }
    const TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$t], ["__scopeId", "data-v-7b6f943d"]]);
    var columnResizer = { exports: {} };
    (function(module2, exports2) {
      !function webpackUniversalModuleDefinition(e, t) {
        module2.exports = t();
      }(commonjsGlobal, () => (() => {
        var e = { 887: (e2) => {
          e2.exports = function hash2(e3) {
            for (var t2 = 5381, r2 = e3.length; r2; )
              t2 = 33 * t2 ^ e3.charCodeAt(--r2);
            return t2 >>> 0;
          };
        } }, t = {};
        function __webpack_require__(r2) {
          var i2 = t[r2];
          if (void 0 !== i2)
            return i2.exports;
          var o = t[r2] = { exports: {} };
          return e[r2](o, o.exports, __webpack_require__), o.exports;
        }
        __webpack_require__.n = (e2) => {
          var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
          return __webpack_require__.d(t2, { a: t2 }), t2;
        }, __webpack_require__.d = (e2, t2) => {
          for (var r2 in t2)
            __webpack_require__.o(t2, r2) && !__webpack_require__.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
        }, __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), __webpack_require__.r = (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var r = {};
        return (() => {
          __webpack_require__.r(r), __webpack_require__.d(r, { default: () => n });
          var e2 = __webpack_require__(887), t2 = __webpack_require__.n(e2);
          function _typeof(e3) {
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, _typeof(e3);
          }
          function _defineProperties(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++) {
              var i3 = t3[r2];
              i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e3, _toPropertyKey(i3.key), i3);
            }
          }
          function _createClass(e3, t3, r2) {
            return t3 && _defineProperties(e3.prototype, t3), r2 && _defineProperties(e3, r2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }
          function _classCallCheck(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperty(e3, t3, r2) {
            return (t3 = _toPropertyKey(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t3] = r2, e3;
          }
          function _toPropertyKey(e3) {
            var t3 = function _toPrimitive(e4, t4) {
              if ("object" !== _typeof(e4) || null === e4)
                return e4;
              var r2 = e4[Symbol.toPrimitive];
              if (void 0 !== r2) {
                var i3 = r2.call(e4, t4 || "default");
                if ("object" !== _typeof(i3))
                  return i3;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t4 ? String : Number)(e4);
            }(e3, "string");
            return "symbol" === _typeof(t3) ? t3 : String(t3);
          }
          var i2, o = (i2 = 0, function() {
            return i2++;
          }), n = _createClass(function ColumnResizer2(e3) {
            var r2 = this, i3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            _classCallCheck(this, ColumnResizer2), _defineProperty(this, "ID", "id"), _defineProperty(this, "PX", "px"), _defineProperty(this, "RESIZABLE", "grip-resizable"), _defineProperty(this, "FLEX", "grip-flex"), _defineProperty(this, "legacyIE", navigator.userAgent.indexOf("Trident/4.0") > 0), _defineProperty(this, "reset", function(e4) {
              return r2.init(e4);
            }), _defineProperty(this, "onResize", function() {
              var e4 = r2.tb;
              if (e4.classList.remove(r2.RESIZABLE), e4.opt.fixed) {
                e4.tableWidth = Number(window.getComputedStyle(e4).width.replace(/px/, "")).valueOf();
                for (var t3 = 0, i4 = 0; i4 < e4.columnCnt; i4++)
                  t3 += e4.columns[i4].w;
                for (var o2 = 0; o2 < e4.columnCnt; o2++)
                  e4.columns[o2].style.width = Math.round(1e3 * e4.columns[o2].w / t3) / 10 + "%", e4.columns[o2].locked = true, e4.opt.currentWidths[o2] = Number(window.getComputedStyle(e4.columns[o2]).width.replace(/px/, "")).valueOf();
              } else
                r2.applyBounds(), "flex" === e4.opt.resizeMode && e4.opt.serialize && r2.serializeStore();
              e4.classList.add(r2.RESIZABLE), r2.syncGrips();
            }), _defineProperty(this, "onGripMouseDown", function(e4) {
              var t3 = e4.target.parentNode.data, i4 = r2.tb, o2 = i4.grips[t3.i], n2 = e4.touches;
              if (o2.ox = n2 ? n2[0].pageX : e4.pageX, o2.l = o2.offsetLeft, o2.x = o2.l, r2.createStyle(document.querySelector("head"), "*{cursor:" + i4.opt.dragCursor + "!important}"), document.addEventListener("touchmove", r2.onGripDrag), document.addEventListener("mousemove", r2.onGripDrag), document.addEventListener("touchend", r2.onGripDragOver), document.addEventListener("mouseup", r2.onGripDragOver), o2.classList.add(i4.opt.draggingClass), r2.grip = o2, i4.columns[t3.i].locked)
                for (var l, a = 0; a < i4.columnCnt; a++)
                  (l = i4.columns[a]).locked = false, l.w = Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf();
              e4.preventDefault();
            }), _defineProperty(this, "onGripDrag", function(e4) {
              var t3 = r2.grip;
              if (t3) {
                var i4 = t3.t, o2 = e4.touches, n2 = (o2 ? o2[0].pageX : e4.pageX) - t3.ox + t3.l, l = i4.opt.minWidth, a = t3.i, s = 1.5 * i4.cellSpace + l + i4.borderSpace, d = a === i4.columnCnt - 1, p2 = a ? i4.grips[a - 1].offsetLeft + i4.cellSpace + l : s, u = i4.opt.fixed ? a === i4.columnCnt - 1 ? i4.tableWidth - s : i4.grips[a + 1].offsetLeft - i4.cellSpace - l : 1 / 0;
                if (n2 = Math.max(p2, Math.min(u, n2)), t3.x = n2, t3.style.left = n2 + r2.PX, d && (t3.w = i4.columns[a].w + n2 - t3.l), i4.opt.liveDrag) {
                  d ? (i4.columns[a].style.width = t3.w + r2.PX, !i4.opt.fixed && i4.opt.overflow ? i4.style.minWidth = i4.tableWidth + n2 - t3.l + r2.PX : i4.tableWidth = Number(window.getComputedStyle(i4).width.replace(/px/, "")).valueOf()) : r2.syncCols(i4, a, false, i4.opt), r2.syncGrips();
                  var c = i4.opt.onDrag;
                  c && c(e4);
                }
                e4.preventDefault();
              }
            }), _defineProperty(this, "onGripDragOver", function(e4) {
              var t3 = r2.grip;
              document.removeEventListener("touchend", r2.onGripDragOver), document.removeEventListener("mouseup", r2.onGripDragOver), document.removeEventListener("touchmove", r2.onGripDrag), document.removeEventListener("mousemove", r2.onGripDrag);
              var i4 = document.querySelector("head").lastChild;
              if (i4.parentNode.removeChild(i4), t3) {
                if (t3.classList.remove(t3.t.opt.draggingClass), t3.x - t3.l != 0) {
                  var o2 = t3.t, n2 = o2.opt.onResize, l = t3.i;
                  if (l === o2.columnCnt - 1) {
                    var a = o2.columns[l];
                    a.style.width = t3.w + r2.PX, a.w = t3.w;
                  } else
                    r2.syncCols(o2, l, true, o2.opt);
                  o2.opt.fixed || r2.applyBounds(), r2.syncGrips(), n2 && n2(e4), o2.opt.serialize && r2.serializeStore();
                }
                r2.grip = null;
              }
            }), _defineProperty(this, "init", function(e4) {
              if (e4.disable)
                return r2.destroy();
              var t3 = r2.tb, i4 = t3.getAttribute(r2.ID) || r2.RESIZABLE + o();
              if (!t3.matches("table") || t3.extended && !e4.partialRefresh)
                return null;
              var n2 = document.querySelector("head");
              if (r2.createStyle(n2, " .grip-resizable{table-layout:fixed;} .grip-resizable > tbody > tr > td, .grip-resizable > tbody > tr > th{overflow:hidden} .grip-padding > tbody > tr > td, .grip-padding > tbody > tr > th{padding-left:0!important; padding-right:0!important;} .grip-container{ height:0px; position:relative;} .grip-handle{margin-left:-5px; position:absolute; z-index:5; } .grip-handle .grip-resizable{position:absolute;background-color:red;filter:alpha(opacity=1);opacity:0;width:10px;height:100%;cursor: col-resize;top:0px} .grip-lastgrip{position:absolute; width:1px; } .grip-drag{ border-left:1px dotted black;	} .grip-flex{width:auto!important;} .grip-handle.grip-disabledgrip .grip-resizable{cursor:default; display:none;}"), e4.hoverCursor && "col-resize" !== e4.hoverCursor) {
                var l = ".grip-handle .grip-resizable:hover{cursor:" + e4.hoverCursor + "!important}";
                r2.createStyle(n2, l);
              }
              t3.setAttribute(r2.ID, i4);
              var a = t3.opt;
              t3.opt = r2.extendOptions(e4);
              var s = r2.getTableHeaders(t3);
              if (r2.extendTable(s), e4.remoteTable && e4.remoteTable.matches("table")) {
                var d = r2.getTableHeaders(t3.opt.remoteTable);
                s.length === d.length ? r2.extendRemoteTable(t3.opt.remoteTable, d, t3) : console.warn("column count for remote table did not match");
              }
              return a;
            }), _defineProperty(this, "applyBounds", function() {
              var e4 = r2.tb, t3 = e4.columns.map(function(e5) {
                return window.getComputedStyle(e5).width;
              });
              e4.style.width = window.getComputedStyle(e4).width, e4.tableWidth = Number(e4.style.width.replace(/px/, "")).valueOf(), e4.classList.remove(r2.FLEX), e4.columns.forEach(function(r3, i4) {
                r3.style.width = t3[i4];
                var o2 = Number(t3[i4].replace(/px/, "")).valueOf();
                r3.w = o2, e4.opt.currentWidths[i4] = o2;
              }), e4.classList.add(r2.FLEX);
            }), _defineProperty(this, "serializeStore", function() {
              var e4 = r2.store, t3 = r2.tb;
              e4[t3.getAttribute(r2.ID)] = "";
              for (var i4 = 0, o2 = 0; o2 < t3.columns.length; o2++) {
                var n2 = window.getComputedStyle(t3.columns[o2]).width.replace(/px/, "");
                e4[t3.getAttribute(r2.ID)] += n2 + ";", i4 += Number(n2).valueOf();
              }
              e4[t3.getAttribute(r2.ID)] += i4.toString(), t3.opt.fixed || (e4[t3.getAttribute(r2.ID)] += ";" + window.getComputedStyle(t3).width.replace(/px/, ""));
            }), _defineProperty(this, "syncGrips", function() {
              var e4 = r2.tb;
              e4.gripContainer.style.width = e4.tableWidth + r2.PX;
              for (var t3 = 0; t3 < e4.columnCnt; t3++) {
                var i4 = e4.columns[t3], o2 = i4.getBoundingClientRect(), n2 = e4.getBoundingClientRect();
                e4.grips[t3].style.left = o2.left - n2.left + i4.offsetWidth + e4.cellSpace / 2 + r2.PX, e4.grips[t3].style.height = (e4.opt.headerOnly ? e4.columns[0].offsetHeight : e4.offsetHeight) + r2.PX;
              }
            }), _defineProperty(this, "destroy", function() {
              var e4 = r2.tb, t3 = e4.getAttribute(r2.ID);
              return t3 ? (r2.store[t3] = "", e4.classList.remove(r2.RESIZABLE), e4.classList.remove(r2.FLEX), e4.remote && (e4.remote.classList.remove(r2.RESIZABLE), e4.remote.classList.remove(r2.FLEX)), e4.gripContainer && e4.gripContainer.parentNode && e4.gripContainer.parentNode.removeChild(e4.gripContainer), delete e4.extended, e4.opt) : null;
            }), _defineProperty(this, "createStyle", function(e4, r3) {
              var i4 = t2()(r3).toString(), o2 = e4.querySelectorAll("style"), n2 = Array.from(o2).filter(function(e5) {
                return e5.gripid === i4;
              });
              if (!n2.length) {
                var l = document.createElement("style");
                l.type = "text/css", l.gripid = i4, l.styleSheet ? l.styleSheet.cssText = r3 : l.appendChild(document.createTextNode(r3)), e4.appendChild(l);
              }
            }), _defineProperty(this, "extendOptions", function(e4) {
              var t3 = Object.assign({}, ColumnResizer2.DEFAULTS, e4);
              switch (t3.fixed = true, t3.overflow = false, t3.resizeMode) {
                case "flex":
                  t3.fixed = false;
                  break;
                case "overflow":
                  t3.fixed = false, t3.overflow = true;
              }
              return t3;
            }), _defineProperty(this, "getTableHeaders", function(e4) {
              var t3 = "#" + e4.id, i4 = Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>th"));
              return (i4 = i4.concat(Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>td")))).length || (i4 = (i4 = (i4 = (i4 = Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>th"))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>th")))).concat(Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>td")))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>td")))), r2.filterInvisible(i4, false);
            }), _defineProperty(this, "filterInvisible", function(e4, t3) {
              return e4.filter(function(e5) {
                var r3 = t3 ? -1 : e5.offsetWidth, i4 = t3 ? -1 : e5.offsetHeight;
                return !(0 === r3 && 0 === i4 || e5.style && e5.style.display && "none" === window.getComputedStyle(e5).display || false);
              });
            }), _defineProperty(this, "extendTable", function(e4) {
              var t3 = r2.tb;
              t3.opt.removePadding && t3.classList.add("grip-padding"), t3.classList.add(r2.RESIZABLE), t3.insertAdjacentHTML("beforebegin", '<div class="grip-container"/>'), t3.grips = [], t3.columns = [], t3.tableWidth = Number(window.getComputedStyle(t3).width.replace(/px/, "")).valueOf(), t3.gripContainer = t3.previousElementSibling, t3.opt.marginLeft && (t3.gripContainer.style.marginLeft = t3.opt.marginLeft), t3.opt.marginRight && (t3.gripContainer.style.marginRight = t3.opt.marginRight), t3.cellSpace = parseInt(r2.legacyIE ? t3.cellSpacing || t3.currentStyle.borderSpacing : window.getComputedStyle(t3).borderSpacing.split(" ")[0].replace(/px/, "")) || 2, t3.borderSpace = parseInt(r2.legacyIE ? t3.border || t3.currentStyle.borderLeftWidth : window.getComputedStyle(t3).borderLeftWidth.replace(/px/, "")) || 1, t3.extended = true, r2.createGrips(e4);
            }), _defineProperty(this, "extendRemoteTable", function(e4, t3, i4) {
              i4.opt.removePadding && e4.classList.add("grip-padding"), e4.classList.add(r2.RESIZABLE), e4.getAttribute(r2.ID) || e4.setAttribute(r2.ID, i4.getAttribute(r2.ID) + "remote"), e4.columns = [], t3.forEach(function(o3, n2) {
                var l = t3[n2];
                l.w = i4.columns[n2].w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), e4.columns.push(l);
              }), e4.tableWidth = i4.tableWidth, e4.cellSpace = i4.cellSpace, e4.borderSpace = i4.borderSpace;
              var o2 = Array.from(e4.querySelectorAll("col"));
              e4.columnGrp = r2.filterInvisible(o2, true), e4.columnGrp.forEach(function(e5, t4) {
                e5.removeAttribute("width"), e5.style.width = i4.columnGrp[t4].style.width;
              }), i4.remote = e4;
            }), _defineProperty(this, "createGrips", function(e4) {
              var t3 = r2.tb;
              t3.columnGrp = r2.filterInvisible(Array.from(t3.querySelectorAll("col")), true), t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.columnCnt = e4.length;
              var i4 = false;
              r2.store[t3.getAttribute(r2.ID)] && (r2.deserializeStore(e4), i4 = true), e4.forEach(function(o3, n2) {
                var l = e4[n2], a = -1 !== t3.opt.disabledColumns.indexOf(n2);
                r2.createDiv(t3.gripContainer, "grip-handle");
                var s = t3.gripContainer.lastChild;
                !a && t3.opt.gripInnerHtml && (s.innerHTML = t3.opt.gripInnerHtml), r2.createDiv(s, r2.RESIZABLE), n2 === t3.columnCnt - 1 && (s.classList.add("grip-lastgrip"), t3.opt.fixed && (s.innerHTML = "")), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true), a ? s.classList.add("grip-disabledgrip") : (s.classList.remove("grip-disabledgrip"), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true)), s.t = t3, s.i = n2, t3.opt.widths[n2] ? l.w = t3.opt.widths[n2] : l.w = i4 ? Number(l.style.width.replace(/px/, "")).valueOf() : Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf(), t3.opt.currentWidths[n2] = l.w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), s.data = { i: n2, t: t3.getAttribute(r2.ID), last: n2 === t3.columnCnt - 1 }, t3.grips.push(s), t3.columns.push(l);
              });
              var o2 = Array.from(t3.querySelectorAll("td"));
              o2.concat(Array.from(t3.querySelectorAll("th"))), (o2 = (o2 = o2.filter(function(t4) {
                for (var r3 = 0; r3 < e4.length; r3++)
                  if (e4[r3] === t4)
                    return false;
                return true;
              })).filter(function(e5) {
                return !(e5.querySelectorAll("table th").length || e5.querySelectorAll("table td").length);
              })).forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.fixed || (t3.removeAttribute("width"), t3.classList.add(r2.FLEX)), r2.syncGrips();
            }), _defineProperty(this, "deserializeStore", function(e4) {
              var t3 = r2.tb;
              if (t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.flush)
                r2.store[t3.getAttribute(r2.ID)] = "";
              else {
                var i4 = r2.store[t3.getAttribute(r2.ID)].split(";"), o2 = i4[t3.columnCnt + 1];
                !t3.opt.fixed && o2 && (t3.style.width = o2 + r2.PX, t3.opt.overflow && (t3.style.minWidth = o2 + r2.PX, t3.tableWidth = Number(o2).valueOf()));
                for (var n2 = 0; n2 < t3.columnCnt; n2++)
                  e4[n2].style.width = i4[n2] + r2.PX, t3.columnGrp[n2] && (t3.columnGrp[n2].style.width = 100 * Number(i4[n2]).valueOf() / Number(i4[t3.columnCnt]).valueOf() + "%");
              }
            }), _defineProperty(this, "createDiv", function(e4, t3, r3) {
              var i4 = document.createElement("div");
              i4.classList.add(t3), r3 && (i4.innerHTML = r3), e4.appendChild(i4);
            }), _defineProperty(this, "syncCols", function(e4, t3, i4, o2) {
              var n2 = e4.remote, l = r2.grip.x - r2.grip.l, a = e4.columns[t3], s = e4.columns[t3 + 1];
              if (a && s) {
                var d = a.w + l, p2 = s.w - l, u = d + r2.PX;
                if (a.style.width = u, e4.columnGrp[t3] && e4.columnGrp[t3].style.width && (e4.columnGrp[t3].style.width = u), n2 && (n2.columns[t3].style.width = u, n2.columnGrp[t3] && n2.columnGrp[t3].style.width && (n2.columnGrp[t3].style.width = u)), o2.fixed) {
                  var c = p2 + r2.PX;
                  s.style.width = c, e4.columnGrp[t3 + 1] && e4.columnGrp[t3 + 1].style.width && (e4.columnGrp[t3 + 1].style.width = c), n2 && (n2.columns[t3 + 1].style.width = c, n2.columnGrp[t3 + 1] && n2.columnGrp[t3 + 1].style.width && (n2.columnGrp[t3 + 1].style.width = c));
                } else
                  o2.overflow && (e4.style.minWidth = e4.tableWidth + l + r2.PX);
                i4 && (a.w = d, s.w = o2.fixed ? p2 : s.w, n2 && (n2.columns[t3].w = d, n2.columns[t3 + 1].w = o2.fixed ? p2 : s.w));
              }
            });
            try {
              this.store = sessionStorage;
            } catch (e4) {
              this.store = {};
            }
            this.grip = null, this.tb = e3, window.addEventListener("resize", this.onResize), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector), this.init(i3);
          });
          n.DEFAULTS = { resizeMode: "fit", draggingClass: "grip-drag", gripInnerHtml: "", liveDrag: false, minWidth: 15, headerOnly: false, hoverCursor: "col-resize", dragCursor: "col-resize", flush: false, marginLeft: null, marginRight: null, remoteTable: null, disable: false, partialRefresh: false, disabledColumns: [], removePadding: true, widths: [], currentWidths: [], serialize: true, onDrag: null, onResize: null };
        })(), r;
      })());
    })(columnResizer);
    var columnResizerExports = columnResizer.exports;
    const ColumnResizer = /* @__PURE__ */ getDefaultExportFromCjs(columnResizerExports);
    const HALIN_CLASS = {
      center: "slds-grid_align-center",
      space: "slds-grid_align-space",
      spread: "slds-grid_align-spread",
      end: "slds-grid_align-end"
    };
    const VALIN_CLASS = {
      start: "slds-grid_vertical-align-start",
      center: "slds-grid_vertical-align-center",
      end: "slds-grid_vertical-align-end",
      stretch: "slds-grid_vertical-stretch"
    };
    const BOUNDARY_CLASS = {
      small: "slds-grid_pull-padded",
      medium: "slds-grid_pull-padded-medium",
      large: "slds-grid_pull-padded-large"
    };
    const VERTICAL_ALIGN = Object.keys(VALIN_CLASS);
    const BOUNDARY = Object.keys(BOUNDARY_CLASS);
    const HORIZONTAL_ALIGN = Object.keys(HALIN_CLASS);
    const ROWS_CLASS = "slds-wrap";
    const GRID_CLASS = "slds-grid";
    const VERTICAL_CLASS = "slds-grid_vertical";
    const GUTTERS_CLASS = "slds-gutters";
    const _sfc_main$u = {
      name: "Layout",
      props: {
        gutters: Boolean,
        horizontalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || HORIZONTAL_ALIGN.includes(value);
          }
        },
        multipleRows: Boolean,
        pullToBoundary: {
          type: String,
          default: null,
          validator(value) {
            return !value || BOUNDARY.includes(value);
          }
        },
        vertical: Boolean,
        verticalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || VERTICAL_ALIGN.includes(value);
          }
        }
      },
      computed: {
        computedClasses() {
          const result = [
            GRID_CLASS,
            HALIN_CLASS[this.$props.horizontalAlign],
            VALIN_CLASS[this.$props.verticalAlign],
            BOUNDARY_CLASS[this.$props.boundary]
          ];
          if (this.$props.multipleRows) {
            result.push(ROWS_CLASS);
          }
          if (this.$props.vertical) {
            result.push(VERTICAL_CLASS);
          }
          if (this.$props.gutters) {
            result.push(GUTTERS_CLASS);
          }
          return result;
        }
      }
    };
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    }
    const Layout = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$s], ["__scopeId", "data-v-8aa1ef04"]]);
    const PADDING = [
      "horizontal-small",
      "horizontal-medium",
      "horizontal-large",
      "around-small",
      "around-medium",
      "around-large"
    ];
    const PADDING_CLASS = {
      "slds-p-right_small": "horizontal-small",
      "slds-p-left_small": "horizontal-small",
      "slds-p-right_medium": "horizontal-medium",
      "slds-p-left_medium": "horizontal-medium",
      "slds-p-right_large": "horizontal-large",
      "slds-p-left_large": "horizontal-large",
      "slds-p-around_small": "around-small",
      "slds-p-around_medium": "around-medium",
      "slds-p-around_large": "around-large"
    };
    const FLEXIBILITY = [
      "auto",
      "shrink",
      "no-shrink",
      "grow",
      "no-grow",
      "no-flex"
    ];
    const FLEX_CLASS = {
      "slds-col": "auto",
      "slds-grow": "grow",
      "slds-shrink": "shrink",
      "slds-grow-none": "no-grow",
      "slds-shrink-none": "no-shrink",
      "slds-no-flex": "no-flex"
    };
    const SIZE_MIN = 1;
    const SIZE_MAX = 12;
    const SIZE_CLASS = {
      default: "slds-size_",
      small: "slds-small-size_",
      medium: "slds-medium-size_",
      large: "slds-large-size_"
    };
    const DIRECTION = ["left", "top", "right", "bottom"];
    const ERRORS = {
      FLEX_CONFLICT: "You cannot have `flexibility` value to be set to `auto` and `no-flex` together for LayoutItem component",
      SIZE_RANGE: "Invalid `size` attribute for LayoutItem component. The `size` attribute should be an integer between 1 and 12",
      SMALL_SIZE_RANGE: "Invalid `smallDeviceSize` attribute for LayoutItem component. The `smallDeviceSize` attribute should be an integer between 1 and 12",
      MEDIUM_SIZE_RANGE: "Invalid `mediumDeviceSize` attribute for LayoutItem component. The `mediumDeviceSize` attribute should be an integer between 1 and 12",
      LARGE_SIZE_RANGE: "Invalid `largeDeviceSize` attribute for LayoutItem component. The `largeDeviceSize` attribute should be an integer between 1 and 12",
      SIZE_REQUIRED: "You cannot have device specific size attributes for LayoutItem component without specifying the `size` attribute"
    };
    const _sfc_main$t = {
      name: "LayoutItem",
      props: {
        /**
         * Make the item fluid so that it absorbs any extra space in its
         * container or shrinks when there is less space. Allowed values are:
         *   auto (columns grow or shrink equally as space allows),
         *   shrink (columns shrink equally as space decreases),
         *   no-shrink (columns don't shrink as space reduces),
         *   grow (columns grow equally as space increases),
         *   no-grow (columns don't grow as space increases),
         *   no-flex (columns don't grow or shrink as space changes).
         * Use a comma-separated or space-separated value for multiple options, such as 'auto, no-shrink'.
         */
        flexibility: {
          type: String,
          default: "auto",
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/).map((item) => item.trim());
            if (classes.some((item) => item === "auto") && classes.some((item) => item === "no-flex")) {
              throw new Error(ERRORS.FLEX_CONFLICT);
            }
            return classes.every((item) => FLEXIBILITY.some((allowed) => item === allowed));
          }
        },
        /**
         * Specifies a direction to bump the alignment of adjacent layout items. Allowed values are left, top, right, bottom.
         */
        alignmentBump: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one alignment class set.");
            }
            return classes.every((item) => DIRECTION.some((allowed) => item === allowed));
          }
        },
        padding: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one padding class set.");
            }
            return classes.every((item) => PADDING.some((allowed) => item === allowed));
          }
        },
        size: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SIZE_RANGE);
            }
            return true;
          }
        },
        smallDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SMALL_SIZE_RANGE);
            }
            return true;
          }
        },
        mediumDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.MEDIUM_SIZE_RANGE);
            }
            return true;
          }
        },
        largeDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.LARGE_SIZE_RANGE);
            }
            return true;
          }
        }
      },
      data() {
        return {
          pFlexibility: null,
          pPadding: null,
          pAlignmentBump: null
        };
      },
      computed: {
        computedClasses() {
          const classes = /* @__PURE__ */ new Set();
          this.computeSizeClasses(
            {
              default: this.$props.size,
              small: this.$props.smallDeviceSize,
              medium: this.$props.mediumDeviceSize,
              large: this.$props.largeDeviceSize
            },
            classes
          );
          this.computePaddingClass(this.$props.padding, classes);
          this.computeFlexibilityClass(this.$props.flexibility, classes);
          this.computeBumpClass(this.$props.alignmentBump, classes);
          return Array.from(classes);
        }
      },
      watch: {
        size() {
          this.validateSizes();
        },
        smallDeviceSize() {
          this.validateSizes();
        },
        mediumDeviceSize() {
          this.validateSizes();
        },
        largeDeviceSize() {
          this.validateSizes();
        }
      },
      created() {
        this.validateSizes();
      },
      methods: {
        validateSizes() {
          if (this.$props.size === null && (this.$props.smallDeviceSize != null || this.$props.mediumDeviceSize != null || this.$props.largeDeviceSize != null)) {
            throw new Error(ERRORS.SIZE_REQUIRED);
          }
        },
        computeSizeClasses(sizes, classes) {
          Object.keys(SIZE_CLASS).forEach((key) => {
            const size2 = sizes[key];
            if (size2 != null && size2 !== 0) {
              classes.add(`${SIZE_CLASS[key]}${size2}-of-12`);
            }
          });
        },
        computeFlexibilityClass(flexibility, classes) {
          if (flexibility === null)
            return;
          flexibility = flexibility.trim().split(/[,|\s]+/).map((item) => item.trim());
          Object.keys(FLEX_CLASS).forEach((key) => {
            if (flexibility.some((flex) => flex === FLEX_CLASS[key])) {
              classes.add(key);
            }
          });
        },
        computePaddingClass(padding, classes) {
          if (padding === null)
            return;
          Object.keys(PADDING_CLASS).forEach((key) => {
            if (PADDING_CLASS[key].toLowerCase() === padding.trim()) {
              classes.add(key);
            }
          });
        },
        computeBumpClass(direction, classes) {
          if (direction) {
            classes.add(`slds-col_bump-${direction}`);
          }
        }
      }
    };
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    }
    const LayoutItem = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$r]]);
    const _sfc_main$s = {
      name: "DataTableRow",
      components: {
        ActionMenu,
        ActionMenuItem,
        Badge,
        ButtonIcon,
        Checkbox,
        ConditionalWrapper: ConditionalWrapper$1,
        Icon
      },
      inject: [
        "rootProps",
        "selectAllId",
        "rootEmit"
      ],
      props: [
        "childIndex",
        "depth",
        "parentRef",
        "row"
      ],
      data() {
        return {
          indexOfColumnBeingEdited: null
        };
      },
      methods: {
        handleAnchorClick(data, e) {
          if (typeof data.onClick === "function") {
            e.preventDefault();
            data.onClick(data, e);
          }
        },
        handleRowToggleClick() {
          this.$props.row.expanded = !this.$props.row.expanded;
        },
        handleCellEdit(event, index) {
          this.indexOfColumnBeingEdited = index;
          const cell = event.path.find((el) => ["td", "th"].includes(el.localName) && el.className.includes("slds-cell-edit"));
          this.$nextTick(() => cell.querySelector("input").focus());
        },
        handleRowAction(action) {
          this.rootEmit(
            "row-action",
            {
              action,
              ...this.$props
            }
          );
        },
        updateCellValue(e) {
          const cellValue = e.path[0].value;
          this.$props.row.data[this.indexOfColumnBeingEdited].value = cellValue;
          this.rootEmit("update-cell", { value: cellValue, row: this.$props.row, columnIndex: this.indexOfColumnBeingEdited });
          this.$nextTick(() => {
            if (!this.$props.row.data[this.indexOfColumnBeingEdited].error)
              this.indexOfColumnBeingEdited = null;
          });
        },
        resetEditMode() {
          this.indexOfColumnBeingEdited = null;
        }
      }
    };
    const _hoisted_1$o = ["aria-selected", "aria-level"];
    const _hoisted_2$n = {
      key: 0,
      class: "slds-text-align_right slds-cell_action-mode",
      role: "gridcell"
    };
    const _hoisted_3$m = ["title"];
    const _hoisted_4$j = {
      key: 0,
      "aria-describedby": "dialog-body-id-1",
      class: "slds-popover slds-popover slds-popover_edit",
      role: "dialog",
      style: { "position": "absolute", "top": "0px", "left": "0.0625rem" }
    };
    const _hoisted_5$h = {
      id: "dialog-body-id-1",
      class: "slds-popover__body"
    };
    const _hoisted_6$g = { class: "slds-media" };
    const _hoisted_7$e = { class: "slds-media__body" };
    const _hoisted_8$d = ["for"];
    const _hoisted_9$d = { class: "slds-assistive-text" };
    const _hoisted_10$c = { class: "slds-form-element__control slds-grow" };
    const _hoisted_11$a = ["id", "value"];
    const _hoisted_12$9 = {
      key: 0,
      class: "slds-form-element__help"
    };
    const _hoisted_13$9 = {
      key: 1,
      class: "slds-cell_action-mode",
      role: "gridcell"
    };
    function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Badge = resolveComponent("Badge");
      const _component_Icon = resolveComponent("Icon");
      const _component_ConditionalWrapper = resolveComponent("ConditionalWrapper");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      return openBlock(), createElementBlock("tr", {
        ref: "row",
        key: _ctx.$props.row.id,
        "aria-selected": $options.rootProps.multiselectable ? _ctx.$props.row.selected || "false" : null,
        "aria-level": _ctx.$props.depth ? _ctx.$props.depth : null,
        class: normalizeClass([{ "slds-is-selected": _ctx.$props.row.selected }, "slds-hint-parent"])
      }, [
        $options.rootProps.multiselectable ? (openBlock(), createElementBlock("td", _hoisted_2$n, [
          createVNode(_component_Checkbox, {
            modelValue: _ctx.$props.row.selected,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$props.row.selected = $event),
            ariaLabeledBy: $options.selectAllId,
            labels: { name: `Select item ${_ctx.$props.childIndex + 1}` },
            hideLabel: "",
            onInput: _cache[1] || (_cache[1] = ($event) => $options.rootEmit("select-row", { id: _ctx.$props.row.id, row: _ctx.$props.row, selected: _ctx.$props.row.selected }))
          }, null, 8, ["modelValue", "ariaLabeledBy", "labels"])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.data, (data, i2) => {
          var _a2, _b;
          return openBlock(), createBlock(resolveDynamicComponent(i2 === 0 ? "th" : "td"), {
            key: `'Root' + ${i2}`,
            "data-label": $options.rootProps.columns[i2].name,
            class: normalizeClass([
              `slds-text-align_${((_a2 = $options.rootProps.columns[i2]) == null ? void 0 : _a2.alignment) || "left"}`,
              {
                "slds-tree__item": i2 === 0 && $options.rootProps.tree,
                "slds-cell-edit": (_b = $options.rootProps) == null ? void 0 : _b.editableColumnIndices.includes(i2),
                "slds-is-edited": data == null ? void 0 : data.dirty,
                "slds-has-error": data == null ? void 0 : data.error
              }
            ]),
            role: i2 > 0 && $options.rootProps.tree ? "gridcell" : null,
            scope: i2 === 0 ? "row" : null
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createVNode(_component_ConditionalWrapper, {
                  class: normalizeClass(["slds-grid slds-grid_align-spread", { "slds-grow": i2 === 0 }]),
                  element: "span",
                  style: { "width": "100%" },
                  active: (_a3 = $options.rootProps) == null ? void 0 : _a3.editableColumnIndices.includes(i2)
                }, {
                  default: withCtx(() => {
                    var _a4, _b2;
                    return [
                      createVNode(_component_ConditionalWrapper, {
                        element: "span",
                        class: "slds-grid slds-truncate",
                        active: i2 === 0 && ((_a4 = $options.rootProps) == null ? void 0 : _a4.editableColumnIndices.includes(i2))
                      }, {
                        default: withCtx(() => {
                          var _a5;
                          return [
                            $options.rootProps.tree && i2 === 0 ? (openBlock(), createBlock(_component_ButtonIcon, {
                              key: 0,
                              variant: "bare",
                              iconCategory: "utility",
                              iconName: _ctx.$props.row.expanded ? "chevrondown" : "chevronright",
                              size: "x-small",
                              class: normalizeClass(["slds-m-right_x-small", { "slds-is-disabled": !((_a5 = _ctx.$props.row.children) == null ? void 0 : _a5.length) }]),
                              tabindex: "-1",
                              title: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              assistiveText: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              onClick: $options.handleRowToggleClick
                            }, null, 8, ["iconName", "class", "title", "assistiveText", "onClick"])) : createCommentVNode("", true),
                            (data == null ? void 0 : data.type) === "custom" ? renderSlot(_ctx.$slots, "cell", mergeProps({
                              key: 1,
                              column: $options.rootProps.columns[i2],
                              columnIndex: i2,
                              data
                            }, _ctx.$props)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                              (data == null ? void 0 : data.type) === "badge" ? (openBlock(), createBlock(_component_Badge, {
                                key: 0,
                                theme: data.theme,
                                content: data.value
                              }, null, 8, ["theme", "content"])) : typeof data === "boolean" ? (openBlock(), createBlock(_component_Icon, {
                                key: 1,
                                category: "utility",
                                name: "check",
                                size: "xx-small"
                              })) : (openBlock(), createElementBlock("div", {
                                key: 2,
                                title: (data == null ? void 0 : data.type) === "anchor" ? data.value : data,
                                class: "slds-truncate"
                              }, [
                                createVNode(_component_ConditionalWrapper, mergeProps({
                                  tabindex: "-1",
                                  element: "a"
                                }, (data == null ? void 0 : data.attrs) || {}, {
                                  active: (data == null ? void 0 : data.type) === "anchor",
                                  onClick: ($event) => $options.handleAnchorClick(data, $event)
                                }), {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString((data == null ? void 0 : data.type) === "anchor" ? data.value : data), 1)
                                  ]),
                                  _: 2
                                }, 1040, ["active", "onClick"])
                              ], 8, _hoisted_3$m))
                            ], 64))
                          ];
                        }),
                        _: 2
                      }, 1032, ["active"]),
                      ((_b2 = $options.rootProps) == null ? void 0 : _b2.editableColumnIndices.includes(i2)) ? (openBlock(), createBlock(_component_ButtonIcon, {
                        key: 0,
                        variant: "bare",
                        iconCategory: "utility",
                        iconClass: "slds-button__icon_hint slds-button__icon_edit",
                        iconName: data.locked ? "lock" : "edit",
                        size: "x-small",
                        class: "slds-cell-edit__button slds-m-left_x-small",
                        title: `Edit ${$options.rootProps.columns[i2].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        assistiveText: `Edit ${$options.rootProps.columns[i2].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        disabled: data.locked,
                        onClick: ($event) => $options.handleCellEdit($event, i2)
                      }, null, 8, ["iconName", "title", "assistiveText", "disabled", "onClick"])) : createCommentVNode("", true)
                    ];
                  }),
                  _: 2
                }, 1032, ["class", "active"]),
                i2 === $data.indexOfColumnBeingEdited ? (openBlock(), createElementBlock("section", _hoisted_4$j, [
                  createBaseVNode("div", _hoisted_5$h, [
                    createBaseVNode("div", _hoisted_6$g, [
                      createBaseVNode("div", _hoisted_7$e, [
                        createBaseVNode("div", {
                          class: normalizeClass(["slds-form-element slds-grid slds-wrap", { "slds-has-error": data.error }])
                        }, [
                          createBaseVNode("label", {
                            class: "slds-form-element__label slds-form-element__label_edit slds-no-flex",
                            for: `${$options.rootProps.columns[i2].name}-${i2}`
                          }, [
                            createBaseVNode("span", _hoisted_9$d, toDisplayString($options.rootProps.columns[i2].name), 1)
                          ], 8, _hoisted_8$d),
                          createBaseVNode("div", _hoisted_10$c, [
                            createBaseVNode("input", {
                              id: `${$options.rootProps.columns[i2].name}-${i2}`,
                              class: "slds-input",
                              type: "text",
                              value: data.value,
                              onBlur: _cache[2] || (_cache[2] = (...args) => $options.resetEditMode && $options.resetEditMode(...args)),
                              onKeydown: [
                                _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.resetEditMode && $options.resetEditMode(...args), ["stop"]), ["esc"])),
                                _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => $options.updateCellValue($event), ["stop"]), ["enter"]))
                              ]
                            }, null, 40, _hoisted_11$a)
                          ]),
                          data.error ? (openBlock(), createElementBlock("div", _hoisted_12$9, toDisplayString(data.error), 1)) : createCommentVNode("", true)
                        ], 2)
                      ])
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ];
            }),
            _: 2
          }, 1032, ["data-label", "class", "role", "scope"]);
        }), 128)),
        ((_a = _ctx.$props.row.actions) == null ? void 0 : _a.length) ? (openBlock(), createElementBlock("td", _hoisted_13$9, [
          createVNode(_component_ActionMenu, null, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.actions, (action, i2) => {
                return openBlock(), createBlock(_component_ActionMenuItem, {
                  key: i2,
                  label: action.label,
                  onClick: ($event) => $options.handleRowAction(action)
                }, null, 8, ["label", "onClick"]);
              }), 128))
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$o);
    }
    const Row = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$q]]);
    const Node = {
      name: "DataTableTreeNode",
      components: {
        Row
      },
      props: [
        "depth",
        "parentRef",
        "row",
        "childIndex"
      ],
      render() {
        const children = [
          h(
            Row,
            {
              ...this.$props
            },
            {
              cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
            }
          )
        ];
        if (this.$props.row.children && this.$props.row.expanded) {
          this.$props.row.children.forEach((row, childIndex) => children.push(
            h(
              Node,
              {
                childIndex,
                depth: this.$props.depth + 1,
                parentRef: this.$props.row,
                row
              },
              {
                cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
              }
            )
          ));
        }
        return [children];
      }
    };
    const Tree = {
      name: "DataTableTree",
      components: {
        Node
      },
      props: ["rows"],
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        return this.$props.rows.map((row, childIndex) => h(
          Node,
          {
            childIndex,
            depth: 0,
            parentRef: null,
            row
          },
          {
            cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
          }
        )).concat(_default);
      }
    };
    const _sfc_main$r = {
      name: "DataTable",
      components: {
        ActionMenu,
        ActionMenuItem,
        Checkbox,
        // ConditionalWrapper,
        Icon,
        Layout,
        LayoutItem,
        Row,
        Tree
      },
      provide() {
        return {
          rootProps: this.$props,
          selectAllId: this.selectAllId,
          rootEmit: (...args) => {
            this.$emit(args[0], ...args.slice(1));
          }
        };
      },
      props: {
        actions: Boolean,
        ariaLabel: {
          type: String,
          default: ""
        },
        bordered: Boolean,
        bufferCells: Boolean,
        columns: {
          type: Array,
          required: true
        },
        columnsBordered: Boolean,
        editableColumnIndices: {
          type: Array,
          default: () => []
        },
        hideHeader: Boolean,
        multiselectable: Boolean,
        resizable: Boolean,
        // TODO: Explore making a copy of this array to avoid directly manipulating rows
        rows: {
          type: Array,
          required: true
        },
        selectAll: Boolean,
        summaryFooter: Boolean,
        summaryHeader: Boolean,
        tree: Boolean,
        virtual: Boolean
      },
      emits: [
        "column-action",
        "row-action",
        "select-all",
        "select-column",
        "select-row",
        "update-cell"
      ],
      data() {
        return {
          selectedAll: false,
          selectAllId: getGUID(),
          columnResizer: {},
          rowHeight: 0,
          containerHeight: 0,
          visibleRowsStartIndex: 0,
          // CSS vars
          selectedColumnBackgroundColor: "blue"
        };
      },
      computed: {
        computedRole() {
          if (this.$props.tree)
            return "treegrid";
          if (this.$props.multiselectable)
            return "grid";
          return null;
        },
        visibleRows() {
          return this.$props.virtual ? this.rows.slice(this.visibleRowsStartIndex, this.visibleRowsStartIndex + 200) : this.rows;
        },
        tableContainerPaddingTop() {
          return this.visibleRowsStartIndex * this.rowHeight;
        },
        tableContainerPaddingBottom() {
          return (this.rows.length - this.visibleRows.length) * this.rowHeight - this.tableContainerPaddingTop;
        },
        hasSelectableColumns() {
          return this.$props.columns.some((column) => column.selectable);
        },
        verticalHeaderCellPadding() {
          return this.$props.summaryHeader && this.hasSelectableColumns ? "0.75rem" : "0.5rem";
        },
        selectedPseudoElementTop() {
          return !this.hasSelectableColumns || !this.$props.summaryHeader ? "-4px" : 0;
        },
        selectedBorderRadius() {
          return this.$props.summaryHeader ? 0 : "2px";
        }
      },
      watch: {
        "$props.rows": {
          handler(rows) {
            if (rows.length) {
              this.initColumnResizer();
              if (this.$props.virtual) {
                this.$nextTick(() => {
                  this.rowHeight = this.$refs["row-0"][0].$refs.row.offsetHeight;
                  this.containerHeight = this.$refs.tableContainer.offsetHeight;
                });
              }
            }
          },
          immediate: true
        }
      },
      methods: {
        async initColumnResizer() {
          if (!this.$props.resizable)
            return;
          await this.$nextTick();
          this.columnResizer = new ColumnResizer(this.$refs.table, {
            disable: !this.$props.resizable,
            innerGripHtml: "<div class='rangeGrip'></div>",
            removePadding: false,
            minWidth: 48
          });
        },
        onSelectAllChange() {
          this.rows.forEach((row) => {
            row.selected = this.selectedAll;
          });
          this.$emit("select-all", this.selectedAll);
        },
        onScroll() {
          if (!this.$props.virtual || this.scrollTimeout)
            return;
          this.scrollTimeout = setTimeout(() => {
            this.visibleRowsStartIndex = Math.max(0, Math.floor(this.$refs.tableContainer.scrollTop / this.rowHeight) - 100);
            this.scrollTimeout = null;
          }, 500);
        },
        getListeners(column, columnIndex) {
          const base = { ...column.listeners || {} };
          if (column.selectable) {
            base.click = [base.click, this.onHeaderClick.bind(this, column, columnIndex)];
          }
          return base;
        },
        onHeaderClick(column, columnIndex, e) {
          function getParentTH(el) {
            if (el.nodeName === "TH")
              return el;
            while (el.parentNode) {
              el = el.parentNode;
              if (el.nodeName === "TH") {
                return el;
              }
            }
            return null;
          }
          if (e.target.nodeName !== "BUTTON") {
            this.$emit("select-column", { column, columnIndex });
            column.selected = true;
            this.$refs.tableContainer.style.paddingTop = "5px";
            if (column.icon) {
              const iconContainer = getParentTH(e.target).querySelector("div.slds-icon_container");
              if (iconContainer) {
                this.selectedColumnBackgroundColor = window.getComputedStyle(iconContainer).backgroundColor;
              }
            }
          }
        }
      }
    };
    const __injectCSSVars__ = () => {
      useCssVars((_ctx) => ({
        "4d4e3100": _ctx.selectedPseudoElementTop,
        "85016f72": _ctx.selectedBorderRadius,
        "484c9e56": _ctx.selectedColumnBackgroundColor,
        "f99d0584": _ctx.verticalHeaderCellPadding
      }));
    };
    const __setup__ = _sfc_main$r.setup;
    _sfc_main$r.setup = __setup__ ? (props, ctx) => {
      __injectCSSVars__();
      return __setup__(props, ctx);
    } : __injectCSSVars__;
    //! moment.js
    //! version : 2.29.4
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject$1(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i2, arrLen = arr.length;
      for (i2 = 0; i2 < arrLen; ++i2) {
        res.push(fn(arr[i2], i2));
      }
      return res;
    }
    function extend(a, b) {
      for (var i2 in b) {
        if (hasOwnProp(b, i2)) {
          a[i2] = b[i2];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len2 = t.length >>> 0, i2;
        for (i2 = 0; i2 < len2; i2++) {
          if (i2 in t && fun.call(this, t[i2], i2, t)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      if (m._isValid == null) {
        var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i2) {
          return i2 != null;
        }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
        if (Object.isFrozen == null || !Object.isFrozen(m)) {
          m._isValid = isNowValid;
        } else {
          return isNowValid;
        }
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i2, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i2 = 0; i2 < momentPropertiesLen; i2++) {
          prop = momentProperties[i2];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i2, key, argLen = arguments.length;
          for (i2 = 0; i2 < argLen; i2++) {
            arg = "";
            if (typeof arguments[i2] === "object") {
              arg += "\n[" + i2 + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i2];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set(config) {
      var prop, i2;
      for (i2 in config) {
        if (hasOwnProp(config, i2)) {
          prop = config[i2];
          if (isFunction(prop)) {
            this[i2] = prop;
          } else {
            this["_" + i2] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject$1(parentConfig[prop]) && isObject$1(childConfig[prop])) {
            res[prop] = {};
            extend(res[prop], parentConfig[prop]);
            extend(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject$1(parentConfig[prop])) {
          res[prop] = extend({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i2, res = [];
        for (i2 in obj) {
          if (hasOwnProp(obj, i2)) {
            res.push(i2);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array = format2.match(formattingTokens), i2, length;
      for (i2 = 0, length = array.length; i2 < length; i2++) {
        if (formatTokenFunctions[array[i2]]) {
          array[i2] = formatTokenFunctions[array[i2]];
        } else {
          array[i2] = removeFormattingTokens(array[i2]);
        }
      }
      return function(mom) {
        var output = "", i3;
        for (i3 = 0; i3 < length; i3++) {
          output += isFunction(array[i3]) ? array[i3].call(mom, format2) : array[i3];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i2 = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i2 >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i2 -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {};
    function addUnitAlias(unit, shorthand) {
      var lowerCase = unit.toLowerCase();
      aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {};
    function addUnitPriority(unit, priority) {
      priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({ unit: u, priority: priorities[u] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get(this, unit);
        }
      };
    }
    function get(mom, unit) {
      return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
      if (mom.isValid() && !isNaN(value)) {
        if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
          value = toInt(value);
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
            value,
            mom.month(),
            daysInMonth(value, mom.month())
          );
        } else {
          mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
      }
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i2, prioritizedLen = prioritized.length;
        for (i2 = 0; i2 < prioritizedLen; i2++) {
          this[prioritized[i2].unit](units[prioritized[i2].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i2, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array) {
          array[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        tokens[token2[i2]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    function mod(n, x) {
      return (n % x + x) % x;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i2;
        for (i2 = 0; i2 < this.length; ++i2) {
          if (this[i2] === o) {
            return i2;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addUnitAlias("month", "M");
    addUnitPriority("month", 8);
    addRegexToken("M", match1to2);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array) {
      array[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i2, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i2 = 0; i2 < 12; ++i2) {
          mom = createUTC([2e3, i2]);
          this._shortMonthsParse[i2] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i2] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i2, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        if (strict && !this._longMonthsParse[i2]) {
          this._longMonthsParse[i2] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i2] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i2]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i2] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i2].test(monthName)) {
          return i2;
        } else if (!strict && this._monthsParse[i2].test(monthName)) {
          return i2;
        }
      }
    }
    function setMonth(mom, value) {
      var dayOfMonth;
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
      mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i2, mom;
      for (i2 = 0; i2 < 12; i2++) {
        mom = createUTC([2e3, i2]);
        shortPieces.push(this.monthsShort(mom, ""));
        longPieces.push(this.months(mom, ""));
        mixedPieces.push(this.months(mom, ""));
        mixedPieces.push(this.monthsShort(mom, ""));
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      for (i2 = 0; i2 < 12; i2++) {
        shortPieces[i2] = regexEscape(shortPieces[i2]);
        longPieces[i2] = regexEscape(longPieces[i2]);
      }
      for (i2 = 0; i2 < 24; i2++) {
        mixedPieces[i2] = regexEscape(mixedPieces[i2]);
      }
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken("Y", 0, 0, function() {
      var y = this.year();
      return y <= 9999 ? zeroFill(y, 4) : "+" + y;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addUnitAlias("year", "y");
    addUnitPriority("year", 1);
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array) {
      array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array) {
      array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array) {
      array[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function createDate(y, m, d, h2, M, s, ms) {
      var date;
      if (y < 100 && y >= 0) {
        date = new Date(y + 400, m, d, h2, M, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
      } else {
        date = new Date(y, m, d, h2, M, s, ms);
      }
      return date;
    }
    function createUTCDate(y) {
      var date, args;
      if (y < 100 && y >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addUnitAlias("week", "w");
    addUnitAlias("isoWeek", "W");
    addUnitPriority("week", 5);
    addUnitPriority("isoWeek", 5);
    addRegexToken("w", match1to2);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addUnitAlias("day", "d");
    addUnitAlias("weekday", "e");
    addUnitAlias("isoWeekday", "E");
    addUnitPriority("day", 11);
    addUnitPriority("weekday", 11);
    addUnitPriority("isoWeekday", 11);
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i2, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i2 = 0; i2 < 7; ++i2) {
          mom = createUTC([2e3, 1]).day(i2);
          this._minWeekdaysParse[i2] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i2] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i2] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i2, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        if (strict && !this._fullWeekdaysParse[i2]) {
          this._fullWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i2] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i2]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i2] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i2].test(weekdayName)) {
          return i2;
        } else if (!strict && this._weekdaysParse[i2].test(weekdayName)) {
          return i2;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i2, mom, minp, shortp, longp;
      for (i2 = 0; i2 < 7; i2++) {
        mom = createUTC([2e3, 1]).day(i2);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    addUnitAlias("hour", "h");
    addUnitPriority("hour", 13);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2);
    addRegexToken("h", match1to2);
    addRegexToken("k", match1to2);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array, config) {
      var kInput = toInt(input);
      array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array, config) {
      array[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array, config) {
      var pos = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos));
      array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array[HOUR] = toInt(input.substr(0, pos1));
      array[MINUTE] = toInt(input.substr(pos1, 2));
      array[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i2, minl = Math.min(arr1.length, arr2.length);
      for (i2 = 0; i2 < minl; i2 += 1) {
        if (arr1[i2] !== arr2[i2]) {
          return i2;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i2 = 0, j, next, locale2, split;
      while (i2 < names.length) {
        split = normalizeLocale(names[i2]).split("-");
        j = split.length;
        next = normalizeLocale(names[i2 + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i2++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return name.match("^[^/\\\\]*$") != null;
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x) {
            defineLocale(x.name, x.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i2, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i2 = 0, l = isoDatesLen; i2 < l; i2++) {
          if (isoDates[i2][1].exec(match[1])) {
            dateFormat = isoDates[i2][0];
            allowTime = isoDates[i2][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i2 = 0, l = isoTimesLen; i2 < l; i2++) {
            if (isoTimes[i2][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i2][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
        return h2 * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i2, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i2 = 0; i2 < 3 && config._a[i2] == null; ++i2) {
        config._a[i2] = input[i2] = currentDate[i2];
      }
      for (; i2 < 7; i2++) {
        config._a[i2] = input[i2] = config._a[i2] == null ? i2 === 2 ? 1 : 0 : config._a[i2];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults(
          w.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
        week = defaults(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i2, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i2 = 0; i2 < tokenLen; i2++) {
        token2 = tokens2[i2];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i2, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i2 = 0; i2 < configfLen; i2++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i2];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i2 = normalizeObjectUnits(config._i), dayOrDate = i2.day === void 0 ? i2.date : i2.day;
      config._a = map(
        [i2.year, i2.month, dayOrDate, i2.hour, i2.minute, i2.second, i2.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject$1(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject$1(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i2;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i2 = 1; i2 < moments.length; ++i2) {
        if (!moments[i2].isValid() || moments[i2][fn](res)) {
          res = moments[i2];
        }
      }
      return res;
    }
    function min() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i2, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i2 = 0; i2 < orderLen; ++i2) {
        if (m[ordering[i2]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i2]]) !== toInt(m[ordering[i2]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len2 = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i2;
      for (i2 = 0; i2 < len2; i2++) {
        if (dontConvert && array1[i2] !== array2[i2] || !dontConvert && toInt(array1[i2]) !== toInt(array2[i2])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher, string) {
      var matches = (string || "").match(matcher), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i2, property, propertyLen = properties.length;
      for (i2 = 0; i2 < propertyLen; i2 += 1) {
        property = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject$1(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i2, property;
      for (i2 = 0; i2 < properties.length; i2 += 1) {
        property = properties[i2];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(
          m,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(
        m,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale$1(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return new Date(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y, m, d).valueOf();
      }
    }
    function utcStartOfDate(y, m, d) {
      if (y < 100 && y >= 0) {
        return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate$1() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i2, l, date, eras = this._eras || getLocale("en")._eras;
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        switch (typeof eras[i2].since) {
          case "string":
            date = hooks(eras[i2].since).startOf("day");
            eras[i2].since = date.valueOf();
            break;
        }
        switch (typeof eras[i2].until) {
          case "undefined":
            eras[i2].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i2].until).startOf("day").valueOf();
            eras[i2].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i2, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        name = eras[i2].name.toUpperCase();
        abbr = eras[i2].abbr.toUpperCase();
        narrow = eras[i2].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i2];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i2];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i2];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i2];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i2, l, val, eras = this.localeData().eras();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].name;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i2, l, val, eras = this.localeData().eras();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].narrow;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i2, l, val, eras = this.localeData().eras();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until) {
          return eras[i2].abbr;
        }
        if (eras[i2].until <= val && val <= eras[i2].since) {
          return eras[i2].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i2, l, dir, val, eras = this.localeData().eras();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        dir = eras[i2].since <= eras[i2].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i2].since <= val && val <= eras[i2].until || eras[i2].until <= val && val <= eras[i2].since) {
          return (this.year() - hooks(eras[i2].since).year()) * dir + eras[i2].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i2, l, eras = this.eras();
      for (i2 = 0, l = eras.length; i2 < l; ++i2) {
        namePieces.push(regexEscape(eras[i2].name));
        abbrPieces.push(regexEscape(eras[i2].abbr));
        narrowPieces.push(regexEscape(eras[i2].narrow));
        mixedPieces.push(regexEscape(eras[i2].name));
        mixedPieces.push(regexEscape(eras[i2].abbr));
        mixedPieces.push(regexEscape(eras[i2].narrow));
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addUnitAlias("weekYear", "gg");
    addUnitAlias("isoWeekYear", "GG");
    addUnitPriority("weekYear", 1);
    addUnitPriority("isoWeekYear", 1);
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday(),
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addUnitAlias("quarter", "Q");
    addUnitPriority("quarter", 7);
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array) {
      array[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addUnitAlias("date", "D");
    addUnitPriority("date", 9);
    addRegexToken("D", match1to2);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array) {
      array[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addUnitAlias("dayOfYear", "DDD");
    addUnitPriority("dayOfYear", 4);
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addUnitAlias("minute", "m");
    addUnitPriority("minute", 14);
    addRegexToken("m", match1to2);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addUnitAlias("second", "s");
    addUnitPriority("second", 15);
    addRegexToken("s", match1to2);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addUnitAlias("millisecond", "ms");
    addUnitPriority("millisecond", 16);
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array) {
      array[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale$1;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate$1;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1(format2, index, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index, field) {
      if (isNumber(format2)) {
        index = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index != null) {
        return get$1(format2, index, field, "month");
      }
      var i2, out = [];
      for (i2 = 0; i2 < 12; i2++) {
        out[i2] = get$1(format2, i2, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i2, out = [];
      if (index != null) {
        return get$1(format2, (index + shift) % 7, field, "day");
      }
      for (i2 = 0; i2 < 7; i2++) {
        out[i2] = get$1(format2, (i2 + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index) {
      return listMonthsImpl(format2, index, "months");
    }
    function listMonthsShort(format2, index) {
      return listMonthsImpl(format2, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function valueOf$1() {
      if (!this.isValid()) {
        return NaN;
      }
      return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x) {
      return (x > 0) - (x < 0) || +x;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale$1;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.29.4";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    const Modes = Object.freeze({
      ALL: Symbol.for("slds-vue-expression-all"),
      ANY: Symbol.for("slds-vue-expression-any"),
      CUSTOM: Symbol.for("slds-vue-expression-custom")
    });
    const getDefaultLabels = () => ({
      addCondition: "Add Condition",
      customLogic: "Custom Logic",
      takeAction: "Take Action When",
      title: "Conditions",
      modeAll: "All Conditions Are Met",
      modeAny: "Any Condition Is Met",
      modeCustom: "Custom Logic Is Met",
      and: "AND",
      or: "OR",
      customLogicPlaceholder: "e.g. (1 AND 2) OR 3"
    });
    ({
      name: "Expression",
      components: {
        Button,
        TextInput,
        Picklist
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Proxied listeners to the custom logic TextInput component.
         */
        customLogicListeners: {
          type: Object,
          default: () => {
          }
        },
        /**
         * If true, disables built-in accessibility logic when component state changes.
         */
        disableA11y: Boolean,
        /**
         * If true, the logic selection picklist is diabled.
         */
        disableLogic: Boolean,
        /**
         * @param {Object} labels Text labels for internationalization.
         * @param {String} labels.addCondition Label for the Add Condition button. Defaults to "Add Condition".
         * @param {String} labels.customLogic Label for the custom logic input. Default to "Custom Logic".
         * @param {String} labels.takeAction Label for the expression mode dropdown. Defaults to "Take Action When".
         * @param {String} labels.title Label for the expression title. Defaults to "Conditions".
         * @param {String} labels.modeAll Label for the ALL mode. Defaults to "All Conditions Are Met".
         * @param {String} labels.modeAny Label for the ANY mode. Defaults to "Any Condition Is Met".
         * @param {String} labels.modeCustom Label for the CUSTOM mode. Defaults to "Custom Logic Is Met".
         * @param {String} labels.and Label for the gutter label when mode is ALL. Defaults to "AND".
         * @param {String} labels.or Label for the gutter label when mode is ANY. Defaults to "OR".
         */
        labels: {
          type: Object,
          default: () => getDefaultLabels()
        },
        /**
         * @param {Symbol} mode The selected mode. Defaults to Modes.ALL.
         */
        mode: {
          type: Symbol,
          default: Modes.ALL,
          validator(value) {
            const valid = Object.values(Modes).includes(value);
            if (!valid) {
              console.warn("Mode prop must be equal to one of the enumerated values from the exported Expression.Modes module.");
            }
            return valid;
          }
        },
        /**
        * @param {Array} modes The list of available modes. Defaults to ALL, ANY, and CUSTOM. Array members must be
        *                      one or more of the available properties from the exported Modes module.
        */
        modes: {
          type: Array,
          default: () => [
            Modes.ALL,
            Modes.ANY,
            Modes.CUSTOM
          ],
          validator() {
            return true;
          }
        },
        /**
         * If true, gutters are not rendered.
         */
        noGutter: Boolean,
        /**
         * If true, all logic-related artifacts will not be rendered.
         */
        noLogic: Boolean,
        /**
         * If true, no title is rendered.
         */
        noTitle: Boolean,
        /**
        * @param {String} customLogic The custom logic value. If set, it will appear in the custom logic input box
        *                             if the current mode is Modes.CUSTOM.
        */
        customLogic: {
          type: String,
          default: ""
        },
        customLogicErrors: {
          type: Array,
          default: () => []
        }
      },
      data() {
        return {
          registeredConditions: {},
          localMode: this.$props.mode,
          addConditionFlag: false,
          mergedLabels: {
            ...getDefaultLabels(),
            ...this.$props.labels
          }
        };
      },
      computed: {
        modeOptions() {
          return this.$props.modes.map((mode) => ({
            id: mode,
            title: this.modeLabels[mode]
          }));
        },
        modeLabels() {
          return {
            [Modes.ALL]: this.mergedLabels.modeAll,
            [Modes.ANY]: this.mergedLabels.modeAny,
            [Modes.CUSTOM]: this.mergedLabels.modeCustom
          };
        },
        showCustomLogicInput() {
          return this.$props.mode === Modes.CUSTOM;
        },
        numConditions() {
          return Object.keys(this.registeredConditions).length;
        }
      },
      watch: {
        numConditions(newValue, oldValue) {
          this.updateConditions();
          if (this.addConditionFlag && newValue > oldValue) {
            const conditionId = Object.keys(this.registeredConditions)[newValue - 1];
            this.$nextTick(this.registeredConditions[conditionId].focusResource);
          }
        },
        "$props.mode": {
          handler(value) {
            this.localMode = value;
          }
        },
        "$props.noGutter": {
          handler() {
            this.updateConditions();
          }
        },
        localMode() {
          this.updateConditions();
        }
      },
      mounted() {
        this.$el.addEventListener("register-condition", this.onRegisterCondition);
      },
      methods: {
        registerCondition(id, callbacks) {
          this.registeredConditions[id] = callbacks;
        },
        unregisterCondition(id) {
          this.updateFocus(id);
          delete this.registeredConditions[id];
        },
        updateFocus(id) {
          const conditionIds = Object.keys(this.registeredConditions);
          const indexToBeUnregistered = conditionIds.indexOf(id);
          let registeredCondition;
          if (indexToBeUnregistered === conditionIds.length - 1) {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered - 1]];
          } else {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered + 1]];
          }
          if (registeredCondition && registeredCondition.focusResource) {
            registeredCondition.focusResource();
          }
        },
        addCondition() {
          this.addConditionFlag = true;
          this.$emit("add-condition");
        },
        updateConditions() {
          Object.entries(this.registeredConditions).forEach(([, callbacks], index) => {
            callbacks.setGutterLabel(null);
            switch (this.localMode) {
              case Modes.ALL:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.and);
                }
                break;
              case Modes.ANY:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.or);
                }
                break;
              case Modes.CUSTOM:
                callbacks.setGutterLabel(index + 1);
                break;
            }
            callbacks.setGutterVisibility(!this.$props.noGutter);
            callbacks.setIndex(index);
            callbacks.setNumSiblings(this.numConditions - 1);
          });
        }
      }
    });
    const defaultLabels$2 = () => ({
      prompt: "Okay",
      closeTitle: "Close",
      closeAssistiveText: "Close"
    });
    const _sfc_main$q = {
      name: "Modal",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Hides modal body.
         */
        bodyless: Boolean,
        /**
         * Detaches modal from flow of DOM.
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Hides modal header.
         */
        headless: Boolean,
        /**
         * Hides close button.
         */
        hideCloseButton: Boolean,
        /**
         * Hides modal footer.
         */
        footless: Boolean,
        /**
         * Modal label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Styles the modal as a prompt.
         */
        prompt: Boolean,
        /**
         * Specifies the modal's width.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = [
              "small",
              "base",
              "medium",
              "large",
              "x-large"
            ];
            if (!value || !validSizes.includes(value)) {
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
              return false;
            }
            return true;
          }
        },
        /**
         * Text heading at the top of a modal.
         */
        title: {
          type: String,
          required: true
        }
      },
      data() {
        return {
          container: null,
          focusableElements: [],
          modalId: getGUID(),
          triggerElement: null
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().modal || {} : {};
          return {
            ...defaultLabels$2(),
            ...globals,
            ...this.$props.labels
          };
        },
        headerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_alert-texture slds-theme_error");
          if (this.headless)
            classes.push("slds-modal__header_empty");
          return classes;
        },
        footerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_default");
          if (this.bodyless)
            classes.push("footer-bodyless");
          return classes;
        },
        modalClass() {
          const classes = [];
          if (this.size !== "base") {
            classes.push(`slds-modal_${this.size}`);
          }
          if (this.prompt) {
            classes.push("slds-modal_prompt");
          }
          return classes;
        }
      },
      mounted() {
        this.triggerElement = document.activeElement || document.body;
        if (this.detach) {
          this._detach();
          Array.from(this.container.parentNode.children).filter((node) => node !== this.container && !(node instanceof HTMLScriptElement)).forEach((node) => {
            node.setAttribute("aria-hidden", true);
          });
        }
        this.getFocusableElements();
        this.setFocusOnFirstFocusableItem();
        this.$emit("mounted");
      },
      beforeUnmount() {
        if (this.container) {
          this.container.remove();
          this.container = null;
        }
        this.triggerElement.focus();
      },
      updated() {
        this.getFocusableElements();
      },
      methods: {
        _detach() {
          this.container = document.createElement("div");
          this.container.className = `slds-scope ${this.$el.className}`;
          this.container.appendChild(this.$el);
          document.body.appendChild(this.container);
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.section.querySelectorAll("a, button, input, textarea, select, details")].filter((el) => !el.hasAttribute("disabled") && el.tabIndex !== -1);
        },
        setFocusOnFirstFocusableItem() {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton.$el) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _hoisted_1$n = {
      appear: "",
      name: "fade"
    };
    const _hoisted_2$m = ["role", "tabindex", "aria-labelledby", "aria-describedby"];
    const _hoisted_3$l = { class: "slds-modal__container" };
    const _hoisted_4$i = ["id"];
    const _hoisted_5$g = ["id"];
    const _hoisted_6$f = { key: 1 };
    const _hoisted_7$d = {
      ref: "backdrop",
      key: "backdrop",
      class: "slds-backdrop-custom"
    };
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", _hoisted_1$n, [
        createBaseVNode("section", {
          ref: "section",
          key: "section",
          role: $props.prompt ? "alertdialog" : "dialog",
          tabindex: $props.prompt ? "0" : null,
          class: normalizeClass(["slds-modal-custom", $options.modalClass]),
          "aria-labelledby": $props.headless ? null : `modal-heading-${$data.modalId}`,
          "aria-describedby": `modal-content-${$data.modalId}`,
          onKeydown: [
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact"]), ["tab"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift"]), ["tab"])),
            _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.$emit("close"), ["stop"]), ["esc"]))
          ]
        }, [
          createBaseVNode("div", _hoisted_3$l, [
            createBaseVNode("header", {
              class: normalizeClass([$options.headerClasses, "slds-modal__header"])
            }, [
              !$props.hideCloseButton ? (openBlock(), createBlock(_component_ButtonIcon, {
                key: 0,
                ref: "closeButton",
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                class: "slds-modal__close slds-button_icon-inverse",
                assistiveText: $options.computedLabels.closeAssistiveText,
                title: $options.computedLabels.closeTitle,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
              !$props.headless ? (openBlock(), createElementBlock("h2", {
                key: 1,
                id: `modal-heading-${$data.modalId}`,
                class: "slds-text-heading_medium slds-hyphenate"
              }, toDisplayString(_ctx.decodeHtml($props.title)), 9, _hoisted_4$i)) : createCommentVNode("", true),
              !$props.headless ? renderSlot(_ctx.$slots, "tagline", { key: 2 }, void 0, true) : createCommentVNode("", true)
            ], 2),
            !$props.bodyless ? (openBlock(), createElementBlock("div", {
              key: 0,
              id: `modal-content-${$data.modalId}`,
              ref: "content",
              class: "slds-modal__content slds-p-around_medium slds-is-relative",
              onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("submit"), ["enter"]))
            }, [
              renderSlot(_ctx.$slots, "content", {}, () => [
                createTextVNode("default content")
              ], true)
            ], 40, _hoisted_5$g)) : createCommentVNode("", true),
            !$props.footless ? (openBlock(), createElementBlock("footer", {
              key: 1,
              class: normalizeClass(["slds-modal__footer", $options.footerClasses])
            }, [
              renderSlot(_ctx.$slots, "footer", {}, () => [
                $props.prompt ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
                }, toDisplayString($options.computedLabels.prompt), 1)) : (openBlock(), createElementBlock("span", _hoisted_6$f, " default footer "))
              ], true)
            ], 2)) : createCommentVNode("", true)
          ])
        ], 42, _hoisted_2$m),
        createBaseVNode("div", _hoisted_7$d, null, 512)
      ]);
    }
    const Modal = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$p], ["__scopeId", "data-v-7777abc4"]]);
    const alignmentPositions = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const defaultLabels$1 = () => ({
      closeTitle: "Close Dialog",
      closeAssistiveText: "Close Dialog"
    });
    const isAlignmentValid = (alignment) => Object.keys(alignmentPositions).find((value) => value === alignment);
    const _sfc_main$p = {
      name: "Popover",
      description: "Renders a SLDS-themed popover dialog",
      components: {
        ButtonIcon,
        Icon
      },
      directives: {
        "click-outside": clickOutside
      },
      props: {
        /**
         * Alignment of popover in relation to trigger element.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid(alignment);
          }
        },
        /**
         * `aria-label` for popover section element. If no Heading element is present, use this prop and set the value to be a meaningful title of the dialog
         */
        ariaLabel: {
          type: String,
          default: null
        },
        /**
         * Bind the dialog to a specific element.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to coordinates. Overrides bindTo.
         */
        bindToRect: {
          type: Object,
          default: () => {
          },
          validator: (value) => value.x && value.y
        },
        /**
         * Allow mouse click on elements outside popover to close popover.
         */
        closeOnClickOutside: Boolean,
        /**
         * Popover label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The rem set for the nubbin.
         */
        nubbinREM: {
          type: Number,
          default: 1.8
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for the popover.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Array of elements to allow scrolling without closing popover.
         */
        scrollElementsToIgnore: {
          type: Array,
          default: () => []
        },
        /**
         * Determines the type of the popover.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "error",
              "warning"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Sets width of popover.
         */
        width: {
          type: String,
          default: "small",
          validator: (value) => {
            const validThemes = [
              "small",
              "medium",
              "large",
              "x-large",
              "full-width"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid width prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      data() {
        return {
          container: null,
          el: null,
          focusableElements: [],
          triggerElement: null,
          popoverId: getGUID(),
          observer: null,
          popperInstance: () => {
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().popover || {} : {};
          return {
            ...defaultLabels$1(),
            ...globals,
            ...this.$props.labels
          };
        },
        widthClass() {
          return `slds-popover_${this.width}`;
        },
        popoverClass() {
          return this.theme !== "base" ? `slds-popover_${this.theme}` : "";
        },
        showHeader() {
          return this.$slots.header || this.$slots.custom;
        },
        showFooter() {
          return this.$slots.footer;
        },
        clickOutsideOptions() {
          return {
            active: this.closeOnClickOutside,
            handler: this.doHide
          };
        }
      },
      watch: {
        alignment() {
          if (isAlignmentValid(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions[this.$props.alignment]
            });
          }
        },
        width() {
          this.popperInstance.setOptions({
            placement: alignmentPositions[this.$props.alignment]
          });
        },
        "$props.bindTo": {
          handler() {
            if (!this.$props.bindTo)
              return;
            this.popperInstance.state.elements.reference = this.$props.bindTo;
            this.popperInstance.update();
          }
        }
      },
      mounted() {
        this.triggerElement = this.bindTo || document.activeElement || document.body;
        this.getFocusableElements();
        this.popperInstance = createPopper(this.triggerElement, this.$refs.popover, {
          strategy: this.position,
          placement: alignmentPositions[this.alignment],
          modifiers: [
            {
              name: "offset",
              options: {
                offset: ({ placement }) => {
                  if (placement.includes("end")) {
                    return [16, 16];
                  }
                  if (placement.includes("start")) {
                    return [-16, 16];
                  }
                  return [0, 16];
                }
              }
            },
            {
              name: "preventOverflow",
              options: {
                padding: this.$props.overflowPadding
              }
            }
          ]
        });
        this.observer = new MutationObserver(() => this.popperInstance.update());
        this.observer.observe(this.triggerElement, { attributes: true, childList: true, subtree: true });
        if (this.focusableElements.length) {
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        }
      },
      updated() {
        this.getFocusableElements();
      },
      beforeUnmount() {
        this.destroy();
      },
      methods: {
        doHide(e) {
          if (e) {
            if (e.type !== "scroll") {
              if (this.bindTo && this.bindTo.contains(e.target))
                return;
            } else {
              const isTargetInPopover = this.$refs.popover.contains(e.target);
              const targetIsInIgnoreList = this.scrollElementsToIgnore.includes(e.target) || this.scrollElementsToIgnore.some((el) => el && el.contains(e.target));
              if (isTargetInPopover || targetIsInIgnoreList)
                return;
            }
          }
          this.$emit("close", e);
        },
        destroy() {
          if (this.el)
            this.el.remove();
          if (this.container)
            this.container.remove();
          this.el = null;
          this.container = null;
          window.removeEventListener("scroll", this.doHide, true);
          this.triggerElement.focus();
          this.observer.disconnect();
          this.observer = null;
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.popover.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _withScopeId$a = (n) => (pushScopeId("data-v-ee69ade2"), n = n(), popScopeId(), n);
    const _hoisted_1$m = ["aria-describedby", "aria-labelledby", "aria-label"];
    const _hoisted_2$l = ["id"];
    const _hoisted_3$k = { class: "slds-media" };
    const _hoisted_4$h = { class: "slds-media__body" };
    const _hoisted_5$f = ["id"];
    const _hoisted_6$e = { class: "slds-text-heading_small" };
    const _hoisted_7$c = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_8$c = ["id"];
    const _hoisted_9$c = { class: "slds-media slds-media_center slds-has-flexi-truncate" };
    const _hoisted_10$b = { class: "slds-media__figure" };
    const _hoisted_11$9 = { class: "slds-media__body" };
    const _hoisted_12$8 = { class: "slds-truncate slds-text-heading_medium" };
    const _hoisted_13$8 = ["id"];
    const _hoisted_14$6 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_15$5 = {
      key: 2,
      class: "slds-popover__footer"
    };
    const _hoisted_16$5 = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Icon = resolveComponent("Icon");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("section", {
        ref: "popover",
        role: "dialog",
        "aria-describedby": `dialog-body-${$data.popoverId}`,
        "aria-labelledby": $options.showHeader ? `dialog-heading-${$data.popoverId}` : null,
        "aria-label": $props.ariaLabel,
        tabindex: "-1",
        class: normalizeClass([[$options.popoverClass, $options.widthClass], "slds-popover"]),
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact", "stop"]), ["tab"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift", "stop"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.doHide && $options.doHide(...args), ["stop"]), ["esc"]))
        ]
      }, [
        createVNode(_component_ButtonIcon, {
          ref: "closeButton",
          variant: $props.theme === "error" ? "inverse" : "bare",
          title: $options.computedLabels.closeTitle,
          class: "slds-float_right slds-popover__close",
          iconCategory: "utility",
          size: "small",
          iconName: "close",
          assistiveText: $options.computedLabels.closeAssistiveText,
          onClick: withModifiers($options.doHide, ["stop"])
        }, null, 8, ["variant", "title", "assistiveText", "onClick"]),
        $props.theme === "base" ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: `dialog-body-${$data.popoverId}`,
          class: "slds-popover__body"
        }, [
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("div", _hoisted_4$h, [
              $options.showHeader ? (openBlock(), createElementBlock("header", {
                key: 0,
                id: `dialog-heading-${$data.popoverId}`,
                class: "slds-popover__header"
              }, [
                renderSlot(_ctx.$slots, "custom", {}, () => [
                  createBaseVNode("h2", _hoisted_6$e, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ], true)
              ], 8, _hoisted_5$f)) : createCommentVNode("", true)
            ])
          ]),
          renderSlot(_ctx.$slots, "content", {}, () => [
            _hoisted_7$c
          ], true)
        ], 8, _hoisted_2$l)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $options.showHeader ? (openBlock(), createElementBlock("header", {
            key: 0,
            id: `dialog-heading-${$data.popoverId}`,
            class: "slds-popover__header"
          }, [
            createBaseVNode("div", _hoisted_9$c, [
              renderSlot(_ctx.$slots, "custom", {}, () => [
                createBaseVNode("div", _hoisted_10$b, [
                  $props.theme !== "base" ? (openBlock(), createBlock(_component_Icon, {
                    key: 0,
                    category: "utility",
                    name: _ctx.$props.theme,
                    variant: "inverse",
                    iconClass: ["slds-icon", "slds-icon_x-small"]
                  }, null, 8, ["name"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_11$9, [
                  createBaseVNode("h2", _hoisted_12$8, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ])
              ], true)
            ])
          ], 8, _hoisted_8$c)) : createCommentVNode("", true),
          createBaseVNode("div", {
            id: `dialog-body-${$data.popoverId}`,
            class: "slds-popover__body"
          }, [
            renderSlot(_ctx.$slots, "content", {}, () => [
              _hoisted_14$6
            ], true)
          ], 8, _hoisted_13$8)
        ], 64)),
        $options.showFooter ? (openBlock(), createElementBlock("footer", _hoisted_15$5, [
          renderSlot(_ctx.$slots, "footer", {}, void 0, true)
        ])) : createCommentVNode("", true),
        _hoisted_16$5
      ], 42, _hoisted_1$m)), [
        [_directive_click_outside, void 0, $options.clickOutsideOptions]
      ]);
    }
    const Popover = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$o], ["__scopeId", "data-v-ee69ade2"]]);
    const defaultLabels = () => ({
      name: null,
      required: "Required"
    });
    const _sfc_main$o = {
      components: { Tooltip },
      props: {
        /**
         * Disable all radio inputs.
         */
        disabled: Boolean,
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Indicates that the radio group is in an invalid state.
         */
        invalid: Boolean,
        /**
         * Label object for the radio group.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Selected value for the radio group.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * options needs to be an array of objects with label and value (optionally disabled).
         */
        options: {
          type: Array,
          required: true
        },
        /**
         * Read only state for the radio group.
         */
        readonly: Boolean,
        /**
         * Adds an indicator that this field is required.
         */
        required: Boolean
      },
      data() {
        return {
          guid: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().radio || {} : {};
          return {
            ...defaultLabels(),
            ...globals,
            ...this.$props.labels
          };
        },
        input: {
          get() {
            return this.$props.modelValue;
          },
          set(val) {
            this.$emit("update:modelValue", val);
          }
        }
      }
    };
    const BaseRadio = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-20f14d8f"]]);
    const _sfc_main$n = {
      name: "RadioGroup",
      extends: BaseRadio,
      mixins: [decodeHtml]
    };
    const _hoisted_1$l = {
      key: 0,
      class: "slds-form-element__label"
    };
    const _hoisted_2$k = ["title"];
    const _hoisted_3$j = {
      key: 2,
      class: "slds-form-element__control",
      style: { "position": "relative" }
    };
    const _hoisted_4$g = ["id", "name", "value", "disabled", "aria-describedby"];
    const _hoisted_5$e = ["for"];
    const _hoisted_6$d = /* @__PURE__ */ createBaseVNode("span", { class: "slds-radio_faux" }, null, -1);
    const _hoisted_7$b = { class: "slds-form-element__label" };
    const _hoisted_8$b = {
      key: 3,
      class: "slds-form-element__control readonly-radio-label"
    };
    const _hoisted_9$b = ["id"];
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("fieldset", {
        class: normalizeClass([{ "slds-has-error": _ctx.$props.invalid }, "slds-form-element"])
      }, [
        _ctx.computedLabels.name ? (openBlock(), createElementBlock("label", _hoisted_1$l, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: _ctx.computedLabels.required
          }, "*", 8, _hoisted_2$k)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml(_ctx.computedLabels.name)), 1)
        ])) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        !_ctx.$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_3$j, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
            return openBlock(), createElementBlock("span", {
              key: index,
              class: "slds-radio"
            }, [
              withDirectives(createBaseVNode("input", {
                id: _ctx.guid + index,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.input = $event),
                name: _ctx.guid,
                value: option.value,
                disabled: _ctx.$props.disabled || option.disabled,
                "aria-describedby": _ctx.$props.invalid ? `error-${_ctx.guid}` : null,
                type: "radio"
              }, null, 8, _hoisted_4$g), [
                [vModelRadio, _ctx.input]
              ]),
              createBaseVNode("label", {
                for: _ctx.guid + index,
                class: "slds-radio__label"
              }, [
                _hoisted_6$d,
                createBaseVNode("span", _hoisted_7$b, toDisplayString(_ctx.decodeHtml(option.label)), 1)
              ], 8, _hoisted_5$e)
            ]);
          }), 128))
        ])) : (openBlock(), createElementBlock("div", _hoisted_8$b, toDisplayString(_ctx.decodeHtml(_ctx.$props.modelValue) || " "), 1)),
        _ctx.$props.invalid ? (openBlock(), createElementBlock("div", {
          key: 4,
          id: `error-${_ctx.guid}`,
          class: "slds-form-element__help"
        }, [
          renderSlot(_ctx.$slots, "errors")
        ], 8, _hoisted_9$b)) : createCommentVNode("", true)
      ], 2);
    }
    const RadioGroup = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
    const _sfc_main$m = {
      name: "ScopedNotification",
      components: { Icon },
      props: {
        /**
         * Theme for the scoped notification.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "info",
              "success",
              "error",
              "warning"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        themeClass() {
          let themeClass;
          if (this.$props.theme === "" || this.$props.theme === "base") {
            themeClass = "slds-scoped-notification_light";
          } else {
            themeClass = `slds-theme_${this.$props.theme}`;
          }
          return themeClass;
        }
      }
    };
    const _hoisted_1$k = { class: "slds-media__figure" };
    const _hoisted_2$j = { class: "slds-media__body" };
    function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slds-scoped-notification slds-media slds-media_center", $options.themeClass]),
        role: "status"
      }, [
        createBaseVNode("div", _hoisted_1$k, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_Icon, {
              category: "utility",
              assistiveText: "info",
              size: "small",
              name: _ctx.$props.theme === "base" ? "info" : _ctx.$props.theme,
              variant: _ctx.$props.theme === "base" ? "default" : "inverse"
            }, null, 8, ["name", "variant"])
          ])
        ]),
        createBaseVNode("div", _hoisted_2$j, [
          renderSlot(_ctx.$slots, "content")
        ])
      ], 2);
    }
    const ScopedNotification = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
    const stateMap = /* @__PURE__ */ new Map();
    stateMap.set("info", {
      divClass: "slds-theme_info"
    });
    stateMap.set("success", {
      divClass: "slds-theme_success"
    });
    stateMap.set("warning", {
      divClass: "slds-theme_warning"
    });
    stateMap.set("error", {
      divClass: "slds-theme_error"
    });
    const _sfc_main$l = {
      name: "ToastContainer",
      components: {
        ButtonIcon,
        Icon
      },
      mixins: [decodeHtml],
      props: {
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          stateMap
        };
      }
    };
    const _hoisted_1$j = { class: "slds-assistive-text" };
    const _hoisted_2$i = { class: "slds-notify__content" };
    const _hoisted_3$i = { class: "slds-text-heading_small" };
    const _hoisted_4$f = { key: 0 };
    function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createBlock(TransitionGroup, {
        name: "slide",
        tag: "div"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.toasts, (toast) => {
            return openBlock(), createElementBlock("div", {
              key: toast.$__id,
              class: normalizeClass([$data.stateMap.get(toast.state).divClass, "slds-notify slds-notify_toast"]),
              role: "status"
            }, [
              createBaseVNode("span", _hoisted_1$j, toDisplayString(toast.state), 1),
              createVNode(_component_Icon, {
                category: "utility",
                name: toast.state,
                size: "small",
                variant: "none",
                class: "slds-icon_container slds-m-right_small slds-no-flex slds-align-top"
              }, null, 8, ["name"]),
              createBaseVNode("div", _hoisted_2$i, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createBaseVNode("h2", _hoisted_3$i, toDisplayString(_ctx.decodeHtml(toast.message)), 1),
                  toast.subMessage ? (openBlock(), createElementBlock("p", _hoisted_4$f, toDisplayString(_ctx.decodeHtml(toast.subMessage)), 1)) : createCommentVNode("", true)
                ], true)
              ]),
              createVNode(_component_ButtonIcon, {
                title: toast.closeLabel,
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                variant: "inverse",
                class: "slds-notify__close",
                assistiveText: toast.closeLabel,
                onClick: ($event) => _ctx.$parent.close(toast.$__id)
              }, null, 8, ["title", "assistiveText", "onClick"])
            ], 2);
          }), 128))
        ]),
        _: 3
      });
    }
    const ToastContainer = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l], ["__scopeId", "data-v-f8233d6c"]]);
    const _sfc_main$k = {
      name: "Toast",
      components: { ToastContainer },
      props: {
        /**
         * Array of toasts. Each toast object should have `position`, `state`, `message` and optionally `submessage` properties.
         */
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          timeoutMap: /* @__PURE__ */ new Map(),
          callbackMap: /* @__PURE__ */ new Map()
        };
      },
      computed: {
        topCenterToasts() {
          return this.toasts.filter((toast) => toast.position === "top-center");
        },
        topRightToasts() {
          return this.toasts.filter((toast) => toast.position === "top-right");
        },
        bottomRightToasts() {
          return this.toasts.filter((toast) => toast.position === "bottom-right");
        }
      },
      watch: {
        toasts: {
          handler(value) {
            value.forEach((toast) => {
              if (!Object.prototype.hasOwnProperty.call(toast, "$__id")) {
                if (!toast.state) {
                  toast.state = "info";
                }
                if (!toast.closeLabel) {
                  toast.closeLabel = "Close";
                }
                if (!toast.position) {
                  toast.position = "top-center";
                }
                const guid = getGUID();
                toast.$__id = guid;
                if (typeof toast.onClose === "function") {
                  this.callbackMap.set(guid, toast.onClose);
                }
                if (toast.duration > 0) {
                  this.timeoutMap.set(guid, setTimeout(this.close.bind(this, guid), toast.duration));
                }
              }
            });
          },
          immediate: true,
          deep: true
        }
      },
      beforeUnmount() {
        this.timeoutMap.forEach((timeoutId) => clearTimeout(timeoutId));
      },
      methods: {
        close(id) {
          this.$emit("close", id);
          const indexToRemove = this.toasts.findIndex((toast) => toast.$__id === id);
          const newToasts = this.toasts.splice(indexToRemove, 1);
          this.$emit("input", newToasts);
          this.$emit("update:toasts", newToasts);
          if (this.timeoutMap.has(id)) {
            clearTimeout(this.timeoutMap.get(id));
            this.timeoutMap.delete(id);
          }
          if (this.callbackMap.has(id)) {
            this.callbackMap.get(id)();
          }
        }
      }
    };
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ToastContainer = resolveComponent("ToastContainer");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_ToastContainer, {
          toasts: $options.topCenterToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_vertical-reverse"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.bottomRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_bottom-right slds-grid_vertical-align-end"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.topRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_top-right slds-grid_vertical-reversee"
        }, null, 8, ["toasts"])
      ]);
    }
    const Toasts = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-339e5872"]]);
    const _sfc_main$j = {
      name: "NoAccess",
      props: {
        type: {
          type: String,
          default: "plan"
        }
      },
      computed: {
        text() {
          return this.type === "segment" ? "To access this segment, contact its owner." : "To access this sales plan, contact its owner or your Salesforce admin.";
        }
      }
    };
    const _hoisted_1$i = {
      class: "slds-grid slds-grid_vertical-align-center slds-grid_align-center",
      style: { "height": "100%", "background": "#fff" }
    };
    const _hoisted_2$h = { class: "slds-illustration slds-illustration_small" };
    const _hoisted_3$h = /* @__PURE__ */ createStaticVNode('<svg class="slds-illustration__svg" viewBox="0 0 454 212" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-70.000000, -95.000000)"><g><g transform="translate(124.500000, 222.000000)"><g fill="#FFFFFF"><path vector-effect="non-scaling-stroke" d="M18.9209988,1.95433401 L33.259296,51.443436 C33.5666778,52.5043744 32.9557995,53.613617 31.8948612,53.9209988 C31.7139843,53.9734036 31.5266126,54 31.3382972,54 L2.6617028,54 C1.5571333,54 0.661702805,53.1045695 0.661702805,52 C0.661702805,51.8116846 0.688299176,51.6243129 0.74070397,51.443436 L15.0790012,1.95433401 C15.386383,0.893395645 16.4956256,0.282517358 17.556564,0.589899164 C18.2152102,0.780726338 18.7301717,1.29568777 18.9209988,1.95433401 Z"></path></g><g class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><polygon vector-effect="non-scaling-stroke" stroke-linejoin="round" points="17 0.323943662 34 54 -1.81721305e-12 54"></polygon><path vector-effect="non-scaling-stroke" d="M17,4.6953125 C17,43.0456294 17,62.6471919 17,63.5 C17,62.6471919 17,43.0456294 17,4.6953125 Z"></path><path vector-effect="non-scaling-stroke" d="M17,29.3239437 C22.3333333,35.7851611 25,39.1184944 25,39.3239437 C25,39.1184944 22.3333333,35.7851611 17,29.3239437 Z" stroke-linejoin="round" transform="translate(21.000000, 34.323944) scale(-1, 1) translate(-21.000000, -34.323944) "></path></g></g><g transform="translate(145.000000, 194.000000)"><g transform="translate(1.000000, 0.000000)" fill="#FFFFFF"><path vector-effect="non-scaling-stroke" d="M25.6478873,0 L50.879042,84.4273253 C51.1953215,85.4856452 50.5937789,86.5999782 49.535459,86.9162577 C49.3496374,86.9717906 49.1567264,87 48.9627843,87 L2.33299037,87 C1.22842087,87 0.332990367,86.1045695 0.332990367,85 C0.332990367,84.8060578 0.361199757,84.6131469 0.416732643,84.4273253 L25.6478873,0 Z"></path></g><g class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><polygon vector-effect="non-scaling-stroke" stroke-linejoin="round" points="26.5 0 52.5 87 0.5 87"></polygon><path vector-effect="non-scaling-stroke" d="M26.5,2.58642578 C26.5,61.0261034 26.5,90.9972948 26.5,92.5 C26.5,90.9972948 26.5,61.0261034 26.5,2.58642578 Z"></path><path vector-effect="non-scaling-stroke" d="M15.6478873,42 C22.314554,49.078692 25.6478873,52.7453587 25.6478873,53 C25.6478873,52.7453587 22.314554,49.078692 15.6478873,42 Z" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M27.6478873,68 C36.9812207,57.078692 41.6478873,51.7453587 41.6478873,52 C41.6478873,51.7453587 36.9812207,57.078692 27.6478873,68 Z" stroke-linejoin="round"></path></g></g><g transform="translate(404.500000, 245.000000) scale(-1, 1) translate(-404.500000, -245.000000) translate(348.000000, 226.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-linejoin="round" stroke-width="3"><g><polyline vector-effect="non-scaling-stroke" points="0 38 47.5 0 80.5 26"></polyline><polyline vector-effect="non-scaling-stroke" points="71 17 80.5 9 113 36"></polyline></g></g><g transform="translate(72.000000, 262.500000)"><path vector-effect="non-scaling-stroke" d="M153.962142,26.4644491 C151.225735,20.0143094 144.944776,15.5029106 137.633892,15.5029106 C135.619663,15.5029106 133.683612,15.8453541 131.878328,16.4764392 C128.451481,11.1704266 122.567406,7.66985447 115.883789,7.66985447 C109.491267,7.66985447 103.830159,10.8721423 100.350851,15.7935668 C98.9589956,14.968161 97.3423157,14.4956341 95.6177606,14.4956341 C94.1083143,14.4956341 92.6815102,14.8576334 91.4157672,15.5014039 C87.9975328,6.58722215 79.5098304,0.275259875 69.5804557,0.275259875 C60.4632836,0.275259875 52.5615782,5.59684366 48.6837305,13.3681823 C46.3912034,12.266973 43.8314865,11.6515593 41.1312741,11.6515593 C32.4373504,11.6515593 25.1998844,18.0312998 23.6476214,26.4644491 L153.962142,26.4644491 Z" class="slds-illustration__fill-secondary"></path><path vector-effect="non-scaling-stroke" d="M13,25 L143,25" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M0,25 L450,25" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path></g><g transform="translate(344.000000, 247.000000)"><g transform="translate(0.293436, 0.054545)"><path vector-effect="non-scaling-stroke" d="M165.428708,41.9454545 L0.0995432562,41.9454545 C0.0336614956,41.2089487 0,40.4630069 0,39.7090909 C0,26.2132599 10.7866531,15.2727273 24.0926641,15.2727273 C27.7492016,15.2727273 31.215485,16.0989227 34.3199502,17.5772977 C39.5712028,7.14424616 50.271428,0 62.6175975,0 C76.0636257,0 87.5573893,8.47383452 92.1862485,20.441159 C93.9002755,19.5768947 95.8324059,19.0909091 97.8764479,19.0909091 C100.211783,19.0909091 102.401037,19.7252784 104.285841,20.8333889 C108.997403,14.2263569 116.663488,9.92727273 125.320028,9.92727273 C138.043441,9.92727273 148.627152,19.2146805 150.834755,31.4671412 C151.487388,31.3631046 152.156394,31.3090909 152.837838,31.3090909 C159.117096,31.3090909 164.340238,35.8953699 165.428708,41.9454545 Z" class="slds-illustration__fill-secondary"></path><path vector-effect="non-scaling-stroke" d="M32.7065637,40.4454545 L173.706564,40.4454545" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path></g></g><g transform="translate(105.000000, 203.000000)"><g transform="translate(106.000000, 0.000000)" fill="#FFFFFF"><polygon vector-effect="non-scaling-stroke" points="121.5 48.5 158.5 48.5 158.5 34.5 47.5 34.5 47.5 48.5 93.5 48.5 93.5 69.5 121.5 69.5 121.5 48.5"></polygon><path vector-effect="non-scaling-stroke" d="M33.9882812,0.21875 C36.5611979,0.21875 70.6126302,0.21875 136.142578,0.21875 L152.384766,11.1132813 C155.083088,16.811292 155.656656,19.677503 154.105469,19.7119141 C152.554281,19.7463252 116.293865,17.6717809 45.3242187,13.4882812 C35.1940104,4.64192708 31.4153646,0.21875 33.9882812,0.21875 Z"></path><path vector-effect="non-scaling-stroke" d="M32.6708984,2.02246094 L21.5554199,0.374195518 L17.6036034,0.374195518 L5.77148437,7.90429688 C3.09089817,12.6737672 3.09089817,15.2284547 5.77148437,15.5683594 C8.45207058,15.9082641 16.1278518,14.3268839 28.7988281,10.8242188 L42.9921875,7.90429688 L41.0699892,5.68448183 L32.6708984,2.02246094 Z"></path><rect x="0" y="34" width="48" height="14"></rect></g><g transform="translate(106.000000, 5.000000)" class="slds-illustration__fill-secondary"><polygon vector-effect="non-scaling-stroke" points="93.3109375 43.4566406 93.3109375 64.6722656 120.925 64.6722656 121.823047 44.1324219 158.5 43.4566406 158.5 97.5 48.5 97.5 48.5 43.6933594"></polygon><path vector-effect="non-scaling-stroke" d="M132.670898,7.66300119e-19 C125.172201,-2.55433373e-19 94.1907552,-2.55433373e-19 39.7265625,7.66300119e-19 L31.8183594,12.5058594 L29.7050781,28.2714844 L157.78125,28.2714844 L157.78125,15.4775391 C148.539714,5.15917969 140.169596,1.78803361e-18 132.670898,7.66300119e-19 Z"></path><path vector-effect="non-scaling-stroke" d="M37.8266602,0 C34.4632704,0 29.4181858,0 22.6914062,0 C16.1624349,0 9.53808594,3.83528646 2.81835938,11.5058594 L0.705078125,30.2714844 L48.4101562,30.2714844 L48.4101562,14.4775391 L48.1789909,12.3275853 C43.283405,4.10919509 39.832628,0 37.8266602,0 Z"></path><rect x="0.5" y="43.5" width="48" height="54"></rect></g><g><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="154.5" y="34.5" width="110" height="68"></rect><polygon vector-effect="non-scaling-stroke" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" points="264.5 48.5 264.5 34.5 154.5 34.5 154.5 48.5 199.5 48.5 199.5 69.5 227.5 69.5 227.5 48.5"></polygon><path vector-effect="non-scaling-stroke" d="M130.5,0.5 L234.5,0.5 C251.068542,0.5 264.5,13.9314575 264.5,30.5 L264.5,34.5 L106.5,34.5 L106.5,24.5 C106.5,11.245166 117.245166,0.5 130.5,0.5 Z" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M130.5,0.5 L130.5,0.5 C143.754834,0.5 154.5,11.245166 154.5,24.5 L154.5,34.5 L106.5,34.5 L106.5,24.5 C106.5,11.245166 117.245166,0.5 130.5,0.5 Z" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="106.5" y="48.5" width="48" height="54"></rect><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="106.5" y="34.5" width="48" height="14"></rect><path vector-effect="non-scaling-stroke" d="M219,52 C219,54.765 216.765,57 214,57 C211.235,57 209,54.765 209,52 C209,49.235 211.235,47 214,47 C216.765,47 219,49.235 219,52 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M214,55 L214,60" class="slds-illustration__stroke-primary" stroke-width="4" stroke-linecap="round"></path><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="164" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="164" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="255" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="255" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="145" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="145" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="116" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="116" cy="93" r="3"></circle><path vector-effect="non-scaling-stroke" d="M289.928751,82.2971422 L298,102.518658 L280,102.518658 L288.071249,82.2971422 C288.275982,81.784207 288.857768,81.5343604 289.370703,81.7390942 C289.625359,81.8407378 289.827108,82.0424867 289.928751,82.2971422 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M300.428751,89.8132712 L305.5,102.518658 L293.5,102.518658 L298.571249,89.8132712 C298.775982,89.300336 299.357768,89.0504894 299.870703,89.2552232 C300.125359,89.3568668 300.327108,89.5586158 300.428751,89.8132712 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M93.4287513,82.2971422 L101.5,102.518658 L83.5,102.518658 L91.5712487,82.2971422 C91.7759825,81.784207 92.3577681,81.5343604 92.8707033,81.7390942 C93.1253588,81.8407378 93.3271077,82.0424867 93.4287513,82.2971422 Z" class="slds-illustration__fill-primary" transform="translate(92.500000, 92.517446) scale(-1, 1) translate(-92.500000, -92.517446) "></path><path vector-effect="non-scaling-stroke" d="M76.9287513,89.8132712 L82,102.518658 L70,102.518658 L75.0712487,89.8132712 C75.2759825,89.300336 75.8577681,89.0504894 76.3707033,89.2552232 C76.6253588,89.3568668 76.8271077,89.5586158 76.9287513,89.8132712 Z" class="slds-illustration__fill-primary" transform="translate(76.000000, 96.275510) scale(-1, 1) translate(-76.000000, -96.275510) "></path><path vector-effect="non-scaling-stroke" d="M360,102.5 L372,102.5" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M0,102.5 L350,102.5" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></g></g><g transform="translate(150.000000, 96.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g><g transform="translate(271.000000, 135.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><g><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g></g><g transform="translate(402.000000, 164.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><g transform="translate(31.713442, 25.088326) rotate(-15.000000) translate(-31.713442, -25.088326) translate(4.713442, 6.588326)"><path vector-effect="non-scaling-stroke" d="M31.0360707,3.43528591 C31.0360707,3.43528591 40.5802283,0.671893051 42.6488424,10.6908663" transform="translate(36.842457, 6.888440) rotate(41.000000) translate(-36.842457, -6.888440) "></path><path vector-effect="non-scaling-stroke" d="M40.4282002,10.1797377 C40.4282002,10.1797377 49.9723578,7.4163448 52.0409719,17.435318" transform="translate(46.234586, 13.632892) scale(-1, 1) rotate(-41.000000) translate(-46.234586, -13.632892) "></path><path vector-effect="non-scaling-stroke" d="M0.730284783,29.5865514 C0.730284783,29.5865514 10.2744424,26.8231586 12.3430565,36.8421318"></path><path vector-effect="non-scaling-stroke" d="M12.7302848,29.5865514 C12.7302848,29.5865514 22.2744424,26.8231586 24.3430565,36.8421318" transform="translate(18.536671, 33.039705) scale(-1, 1) translate(-18.536671, -33.039705) "></path></g></g></g></g></g></svg>', 1);
    const _hoisted_4$e = { class: "slds-text-longform" };
    const _hoisted_5$d = /* @__PURE__ */ createBaseVNode("h3", { class: "slds-text-heading_medium" }, "No access yet", -1);
    const _hoisted_6$c = { class: "slds-text-body_regular" };
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", _hoisted_2$h, [
          _hoisted_3$h,
          createBaseVNode("div", _hoisted_4$e, [
            _hoisted_5$d,
            createBaseVNode("p", _hoisted_6$c, toDisplayString($options.text), 1)
          ])
        ])
      ]);
    }
    const NoAccess = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
    const _sfc_main$i = {
      name: "PageHeader",
      components: {
        Icon
      },
      props: ["segment"],
      data() {
        return {};
      },
      async mounted() {
        SPM.Components.PageHeader = this;
      },
      methods: {
        launchSegmentBuilder() {
          window.open(`/apex/SegmentBuilder?planId=${this.$store.segment.sfsp__SalesPlan__r.Id}`);
        }
      }
    };
    const _hoisted_1$h = {
      class: "slds-page-header slds-m-bottom_small",
      style: { "padding": "0" }
    };
    const _hoisted_2$g = { class: "slds-grid slds-grid_vertical-align-center slds-grid_align-spread slds-p-around_medium" };
    const _hoisted_3$g = { class: "slds-media" };
    const _hoisted_4$d = { class: "slds-media__figure" };
    const _hoisted_5$c = { class: "slds-media__body" };
    const _hoisted_6$b = { class: "slds-page-header__name" };
    const _hoisted_7$a = { class: "slds-page-header__name-title" };
    const _hoisted_8$a = /* @__PURE__ */ createBaseVNode("span", null, "Segment", -1);
    const _hoisted_9$a = ["title"];
    const _hoisted_10$a = {
      class: "slds-button-group",
      role: "group"
    };
    const _hoisted_11$8 = {
      class: "slds-grid slds-p-around_medium",
      style: { "background": "#FFF" }
    };
    const _hoisted_12$7 = {
      key: 0,
      class: "slds-page-header__detail-block"
    };
    const _hoisted_13$7 = /* @__PURE__ */ createBaseVNode("div", {
      class: "slds-text-title slds-truncate",
      title: "Manager"
    }, "Owner", -1);
    const _hoisted_14$5 = ["title"];
    const _hoisted_15$4 = ["href"];
    const _hoisted_16$4 = {
      key: 1,
      class: "slds-page-header__detail-block"
    };
    const _hoisted_17$4 = /* @__PURE__ */ createBaseVNode("div", {
      class: "slds-text-title slds-truncate",
      title: "Sales Plan"
    }, "Sales Plan Name", -1);
    const _hoisted_18$4 = ["title"];
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      var _a, _b, _c, _d;
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("div", _hoisted_2$g, [
          createBaseVNode("div", _hoisted_3$g, [
            createBaseVNode("div", _hoisted_4$d, [
              createVNode(_component_Icon, {
                category: "standard",
                name: "segments"
              })
            ]),
            createBaseVNode("div", _hoisted_5$c, [
              createBaseVNode("div", _hoisted_6$b, [
                createBaseVNode("div", _hoisted_7$a, [
                  createBaseVNode("h1", null, [
                    _hoisted_8$a,
                    createBaseVNode("span", {
                      class: "slds-page-header__title slds-truncate",
                      title: $props.segment.Name
                    }, toDisplayString($props.segment.Name), 9, _hoisted_9$a)
                  ])
                ])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_10$a, [
            _ctx.$store.isAdmin || _ctx.$store.isManager ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "slds-button slds-button_neutral",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.launchSegmentBuilder && $options.launchSegmentBuilder(...args))
            }, "Open In Builder")) : createCommentVNode("", true)
          ])
        ]),
        createBaseVNode("div", _hoisted_11$8, [
          ((_b = (_a = $props.segment) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Name) ? (openBlock(), createElementBlock("div", _hoisted_12$7, [
            _hoisted_13$7,
            createBaseVNode("div", {
              class: "slds-truncate",
              title: $props.segment.sfsp__Owner__r.Name
            }, [
              createBaseVNode("a", {
                href: `/${$props.segment.sfsp__Owner__c}`,
                target: "_blank"
              }, toDisplayString($props.segment.sfsp__Owner__r.Name), 9, _hoisted_15$4)
            ], 8, _hoisted_14$5)
          ])) : createCommentVNode("", true),
          ((_d = (_c = $props.segment) == null ? void 0 : _c.sfsp__SalesPlan__r) == null ? void 0 : _d.Name) ? (openBlock(), createElementBlock("div", _hoisted_16$4, [
            _hoisted_17$4,
            createBaseVNode("div", {
              class: "slds-truncate",
              title: $props.segment.sfsp__SalesPlan__r.Name
            }, toDisplayString($props.segment.sfsp__SalesPlan__r.Name), 9, _hoisted_18$4)
          ])) : createCommentVNode("", true)
        ])
      ]);
    }
    const PageHeader = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
    /**
     * Vue Currency Input 3.1.0
     * (c) 2018-2024 Matthias Stiller
     * @license MIT
     */
    var CurrencyDisplay;
    (function(CurrencyDisplay2) {
      CurrencyDisplay2["symbol"] = "symbol";
      CurrencyDisplay2["narrowSymbol"] = "narrowSymbol";
      CurrencyDisplay2["code"] = "code";
      CurrencyDisplay2["name"] = "name";
      CurrencyDisplay2["hidden"] = "hidden";
    })(CurrencyDisplay || (CurrencyDisplay = {}));
    var ValueScaling;
    (function(ValueScaling2) {
      ValueScaling2["precision"] = "precision";
      ValueScaling2["thousands"] = "thousands";
      ValueScaling2["millions"] = "millions";
      ValueScaling2["billions"] = "billions";
    })(ValueScaling || (ValueScaling = {}));
    const escapeRegExp = (str) => {
      return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    };
    const removeLeadingZeros = (str) => {
      return str.replace(/^0+(0$|[^0])/, "$1");
    };
    const count = (str, search) => {
      return (str.match(new RegExp(escapeRegExp(search), "g")) || []).length;
    };
    const substringBefore = (str, search) => {
      return str.substring(0, str.indexOf(search));
    };
    const DECIMAL_SEPARATORS = [
      ",",
      ".",
      "٫",
      "。"
    ];
    const INTEGER_PATTERN = "(0|[1-9]\\d*)";
    class CurrencyFormat {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        const { currency, currencyDisplay, locale: locale2, precision, accountingSign, useGrouping } = options;
        this.locale = locale2;
        this.options = {
          currency,
          useGrouping,
          style: "currency",
          currencySign: accountingSign ? "accounting" : void 0,
          currencyDisplay: currencyDisplay !== CurrencyDisplay.hidden ? currencyDisplay : void 0
        };
        const numberFormat = new Intl.NumberFormat(locale2, this.options);
        const formatParts = numberFormat.formatToParts(123456);
        this.currency = (_a = formatParts.find(({ type }) => type === "currency")) === null || _a === void 0 ? void 0 : _a.value;
        this.digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((i2) => i2.toLocaleString(locale2));
        this.decimalSymbol = (_b = formatParts.find(({ type }) => type === "decimal")) === null || _b === void 0 ? void 0 : _b.value;
        this.groupingSymbol = (_c = formatParts.find(({ type }) => type === "group")) === null || _c === void 0 ? void 0 : _c.value;
        this.minusSign = (_d = numberFormat.formatToParts(-1).find(({ type }) => type === "minusSign")) === null || _d === void 0 ? void 0 : _d.value;
        if (this.decimalSymbol === void 0) {
          this.minimumFractionDigits = this.maximumFractionDigits = 0;
        } else if (typeof precision === "number") {
          this.minimumFractionDigits = this.maximumFractionDigits = precision;
        } else {
          this.minimumFractionDigits = (_e = precision === null || precision === void 0 ? void 0 : precision.min) !== null && _e !== void 0 ? _e : numberFormat.resolvedOptions().minimumFractionDigits;
          this.maximumFractionDigits = (_f = precision === null || precision === void 0 ? void 0 : precision.max) !== null && _f !== void 0 ? _f : numberFormat.resolvedOptions().maximumFractionDigits;
        }
        const getPrefix = (str) => {
          return substringBefore(str, this.digits[1]);
        };
        const getSuffix = (str) => {
          return str.substring(str.lastIndexOf(this.decimalSymbol ? this.digits[0] : this.digits[1]) + 1);
        };
        this.prefix = getPrefix(numberFormat.format(1));
        this.suffix = getSuffix(numberFormat.format(1));
        this.negativePrefix = getPrefix(numberFormat.format(-1));
        this.negativeSuffix = getSuffix(numberFormat.format(-1));
      }
      parse(str) {
        if (str) {
          const negative = this.isNegative(str);
          str = this.normalizeDigits(str);
          str = this.stripCurrency(str, negative);
          str = this.stripSignLiterals(str);
          const fraction = this.decimalSymbol ? `(?:${escapeRegExp(this.decimalSymbol)}(\\d*))?` : "";
          const match = this.stripGroupingSeparator(str).match(new RegExp(`^${INTEGER_PATTERN}${fraction}$`));
          if (match && this.isValidIntegerFormat(this.decimalSymbol ? str.split(this.decimalSymbol)[0] : str, Number(match[1]))) {
            return Number(`${negative ? "-" : ""}${this.onlyDigits(match[1])}.${this.onlyDigits(match[2] || "")}`);
          }
        }
        return null;
      }
      isValidIntegerFormat(formattedNumber, integerNumber) {
        const options = { ...this.options, minimumFractionDigits: 0 };
        return [
          this.stripCurrency(this.normalizeDigits(integerNumber.toLocaleString(this.locale, { ...options, useGrouping: true })), false),
          this.stripCurrency(this.normalizeDigits(integerNumber.toLocaleString(this.locale, { ...options, useGrouping: false })), false)
        ].includes(formattedNumber);
      }
      format(value, options = {
        minimumFractionDigits: this.minimumFractionDigits,
        maximumFractionDigits: this.maximumFractionDigits
      }) {
        return value != null ? value.toLocaleString(this.locale, { ...this.options, ...options }) : "";
      }
      toFraction(str) {
        return `${this.digits[0]}${this.decimalSymbol}${this.onlyLocaleDigits(str.substring(1)).substring(0, this.maximumFractionDigits)}`;
      }
      isFractionIncomplete(str) {
        return !!this.normalizeDigits(this.stripGroupingSeparator(str)).match(new RegExp(`^${INTEGER_PATTERN}${escapeRegExp(this.decimalSymbol)}$`));
      }
      isNegative(str) {
        return str.startsWith(this.negativePrefix) || this.minusSign === void 0 && (str.startsWith("(") || str.startsWith("-")) || this.minusSign !== void 0 && str.replace("-", this.minusSign).startsWith(this.minusSign);
      }
      insertCurrency(str, negative) {
        return `${negative ? this.negativePrefix : this.prefix}${str}${negative ? this.negativeSuffix : this.suffix}`;
      }
      stripGroupingSeparator(str) {
        return this.groupingSymbol !== void 0 ? str.replace(new RegExp(escapeRegExp(this.groupingSymbol), "g"), "") : str;
      }
      stripSignLiterals(str) {
        if (this.minusSign !== void 0) {
          return str.replace("-", this.minusSign).replace(this.minusSign, "");
        } else {
          return str.replace(/[-()]/g, "");
        }
      }
      stripCurrency(str, negative) {
        return str.replace(negative ? this.negativePrefix : this.prefix, "").replace(negative ? this.negativeSuffix : this.suffix, "");
      }
      normalizeDecimalSeparator(str, from2) {
        DECIMAL_SEPARATORS.forEach((s) => {
          str = str.substring(0, from2) + str.substring(from2).replace(s, this.decimalSymbol);
        });
        return str;
      }
      normalizeDigits(str) {
        if (this.digits[0] !== "0") {
          this.digits.forEach((digit, index) => {
            str = str.replace(new RegExp(digit, "g"), String(index));
          });
        }
        return str;
      }
      onlyDigits(str) {
        return this.normalizeDigits(str).replace(/\D+/g, "");
      }
      onlyLocaleDigits(str) {
        return str.replace(new RegExp(`[^${this.digits.join("")}]*`, "g"), "");
      }
    }
    class AbstractInputMask {
      constructor(currencyFormat) {
        this.currencyFormat = currencyFormat;
      }
    }
    class DefaultInputMask extends AbstractInputMask {
      conformToMask(str, previousConformedValue = "") {
        const negative = this.currencyFormat.isNegative(str);
        const isEmptyNegativeValue = (str2) => str2 === "" && negative && !(this.currencyFormat.minusSign === void 0 ? previousConformedValue === this.currencyFormat.negativePrefix + this.currencyFormat.negativeSuffix : previousConformedValue === this.currencyFormat.negativePrefix);
        const checkIncompleteValue = (str2) => {
          if (isEmptyNegativeValue(str2)) {
            return "";
          } else if (this.currencyFormat.maximumFractionDigits > 0) {
            if (this.currencyFormat.isFractionIncomplete(str2)) {
              return str2;
            } else if (str2.startsWith(this.currencyFormat.decimalSymbol)) {
              return this.currencyFormat.toFraction(str2);
            }
          }
          return null;
        };
        let value = str;
        value = this.currencyFormat.stripCurrency(value, negative);
        value = this.currencyFormat.stripSignLiterals(value);
        const incompleteValue = checkIncompleteValue(value);
        if (incompleteValue != null) {
          return this.currencyFormat.insertCurrency(incompleteValue, negative);
        }
        const [integer, ...fraction] = value.split(this.currencyFormat.decimalSymbol);
        const integerDigits = removeLeadingZeros(this.currencyFormat.onlyDigits(integer));
        const fractionDigits = this.currencyFormat.onlyDigits(fraction.join("")).substring(0, this.currencyFormat.maximumFractionDigits);
        const invalidFraction = fraction.length > 0 && fractionDigits.length === 0;
        const invalidNegativeValue = integerDigits === "" && negative && (this.currencyFormat.minusSign === void 0 ? previousConformedValue === str.slice(0, -2) + this.currencyFormat.negativeSuffix : previousConformedValue === str.slice(0, -1));
        if (invalidFraction || invalidNegativeValue || isEmptyNegativeValue(integerDigits)) {
          return previousConformedValue;
        } else if (integerDigits.match(/\d+/)) {
          return {
            numberValue: Number(`${negative ? "-" : ""}${integerDigits}.${fractionDigits}`),
            fractionDigits
          };
        } else {
          return "";
        }
      }
    }
    class AutoDecimalDigitsInputMask extends AbstractInputMask {
      conformToMask(str, previousConformedValue = "") {
        if (str === "" || this.currencyFormat.parse(previousConformedValue) === 0 && this.currencyFormat.stripCurrency(previousConformedValue, true).slice(0, -1) === this.currencyFormat.stripCurrency(str, true)) {
          return "";
        }
        const negative = this.currencyFormat.isNegative(str);
        const numberValue = this.currencyFormat.stripSignLiterals(str) === "" ? -0 : Number(`${negative ? "-" : ""}${removeLeadingZeros(this.currencyFormat.onlyDigits(str))}`) / Math.pow(10, this.currencyFormat.maximumFractionDigits);
        return {
          numberValue,
          fractionDigits: numberValue.toFixed(this.currencyFormat.maximumFractionDigits).slice(-this.currencyFormat.maximumFractionDigits)
        };
      }
    }
    const DEFAULT_OPTIONS = {
      locale: void 0,
      currency: void 0,
      currencyDisplay: void 0,
      hideGroupingSeparatorOnFocus: true,
      hideCurrencySymbolOnFocus: true,
      hideNegligibleDecimalDigitsOnFocus: true,
      precision: void 0,
      autoDecimalDigits: false,
      valueRange: void 0,
      useGrouping: void 0,
      valueScaling: void 0
    };
    class CurrencyInput {
      constructor(args) {
        this.el = args.el;
        this.onInput = args.onInput;
        this.onChange = args.onChange;
        this.addEventListener();
        this.init(args.options);
      }
      setOptions(options) {
        this.init(options);
        this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue)));
        this.onChange(this.getValue());
      }
      getValue() {
        const numberValue = this.valueScaling && this.numberValue != null ? this.toInteger(this.numberValue, this.valueScaling) : this.numberValue;
        return { number: numberValue, formatted: this.formattedValue };
      }
      setValue(value) {
        const newValue = this.valueScaling !== void 0 && value != null ? this.toFloat(value, this.valueScaling) : value;
        if (newValue !== this.numberValue) {
          this.format(this.currencyFormat.format(this.validateValueRange(newValue)));
          this.onChange(this.getValue());
        }
      }
      init(options) {
        this.options = {
          ...DEFAULT_OPTIONS,
          ...options
        };
        if (this.options.autoDecimalDigits) {
          this.options.hideNegligibleDecimalDigitsOnFocus = false;
        }
        if (!this.el.getAttribute("inputmode")) {
          this.el.setAttribute("inputmode", this.options.autoDecimalDigits ? "numeric" : "decimal");
        }
        this.currencyFormat = new CurrencyFormat(this.options);
        this.numberMask = this.options.autoDecimalDigits ? new AutoDecimalDigitsInputMask(this.currencyFormat) : new DefaultInputMask(this.currencyFormat);
        const valueScalingOptions = {
          [ValueScaling.precision]: this.currencyFormat.maximumFractionDigits,
          [ValueScaling.thousands]: 3,
          [ValueScaling.millions]: 6,
          [ValueScaling.billions]: 9
        };
        this.valueScaling = this.options.valueScaling ? valueScalingOptions[this.options.valueScaling] : void 0;
        this.valueScalingFractionDigits = this.valueScaling !== void 0 && this.options.valueScaling !== ValueScaling.precision ? this.valueScaling + this.currencyFormat.maximumFractionDigits : this.currencyFormat.maximumFractionDigits;
        this.minValue = this.getMinValue();
        this.maxValue = this.getMaxValue();
      }
      getMinValue() {
        var _a, _b;
        let min2 = this.toFloat(-Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.min) !== void 0) {
          min2 = Math.max((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.min, this.toFloat(-Number.MAX_SAFE_INTEGER));
        }
        return min2;
      }
      getMaxValue() {
        var _a, _b;
        let max2 = this.toFloat(Number.MAX_SAFE_INTEGER);
        if (((_a = this.options.valueRange) === null || _a === void 0 ? void 0 : _a.max) !== void 0) {
          max2 = Math.min((_b = this.options.valueRange) === null || _b === void 0 ? void 0 : _b.max, this.toFloat(Number.MAX_SAFE_INTEGER));
        }
        return max2;
      }
      toFloat(value, maxFractionDigits) {
        return value / Math.pow(10, maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits);
      }
      toInteger(value, maxFractionDigits) {
        return Number(value.toFixed(maxFractionDigits !== null && maxFractionDigits !== void 0 ? maxFractionDigits : this.valueScalingFractionDigits).split(".").join(""));
      }
      validateValueRange(value) {
        return value != null ? Math.min(Math.max(value, this.minValue), this.maxValue) : value;
      }
      format(value, hideNegligibleDecimalDigits = false) {
        if (value != null) {
          if (this.decimalSymbolInsertedAt !== void 0) {
            value = this.currencyFormat.normalizeDecimalSeparator(value, this.decimalSymbolInsertedAt);
            this.decimalSymbolInsertedAt = void 0;
          }
          const conformedValue = this.numberMask.conformToMask(value, this.formattedValue);
          let formattedValue;
          if (typeof conformedValue === "object") {
            const { numberValue, fractionDigits } = conformedValue;
            let { maximumFractionDigits, minimumFractionDigits } = this.currencyFormat;
            if (this.focus) {
              minimumFractionDigits = hideNegligibleDecimalDigits ? fractionDigits.replace(/0+$/, "").length : Math.min(maximumFractionDigits, fractionDigits.length);
            } else if (Number.isInteger(numberValue) && !this.options.autoDecimalDigits && (this.options.precision === void 0 || minimumFractionDigits === 0)) {
              minimumFractionDigits = maximumFractionDigits = 0;
            }
            formattedValue = this.toInteger(Math.abs(numberValue)) > Number.MAX_SAFE_INTEGER ? this.formattedValue : this.currencyFormat.format(numberValue, {
              useGrouping: this.options.useGrouping !== false && !(this.focus && this.options.hideGroupingSeparatorOnFocus),
              minimumFractionDigits,
              maximumFractionDigits
            });
          } else {
            formattedValue = conformedValue;
          }
          if (this.maxValue <= 0 && !this.currencyFormat.isNegative(formattedValue) && this.currencyFormat.parse(formattedValue) !== 0) {
            formattedValue = formattedValue.replace(this.currencyFormat.prefix, this.currencyFormat.negativePrefix);
          }
          if (this.minValue >= 0) {
            formattedValue = formattedValue.replace(this.currencyFormat.negativePrefix, this.currencyFormat.prefix);
          }
          if (this.options.currencyDisplay === CurrencyDisplay.hidden || this.focus && this.options.hideCurrencySymbolOnFocus) {
            formattedValue = formattedValue.replace(this.currencyFormat.negativePrefix, this.currencyFormat.minusSign !== void 0 ? this.currencyFormat.minusSign : "(").replace(this.currencyFormat.negativeSuffix, this.currencyFormat.minusSign !== void 0 ? "" : ")").replace(this.currencyFormat.prefix, "").replace(this.currencyFormat.suffix, "");
          }
          this.el.value = formattedValue;
          this.numberValue = this.currencyFormat.parse(formattedValue);
        } else {
          this.el.value = "";
          this.numberValue = null;
        }
        this.formattedValue = this.el.value;
        this.onInput(this.getValue());
      }
      addEventListener() {
        this.el.addEventListener("input", (e) => {
          const { value, selectionStart } = this.el;
          const inputEvent = e;
          if (selectionStart && inputEvent.data && DECIMAL_SEPARATORS.includes(inputEvent.data)) {
            this.decimalSymbolInsertedAt = selectionStart - 1;
          }
          this.format(value);
          if (this.focus && selectionStart != null) {
            const getCaretPositionAfterFormat = () => {
              const { prefix, suffix, decimalSymbol, maximumFractionDigits, groupingSymbol } = this.currencyFormat;
              let caretPositionFromLeft = value.length - selectionStart;
              const newValueLength = this.formattedValue.length;
              if (this.currencyFormat.minusSign === void 0 && (value.startsWith("(") || value.startsWith("-")) && !value.endsWith(")")) {
                return newValueLength - this.currencyFormat.negativeSuffix.length > 1 ? this.formattedValue.substring(selectionStart).length : 1;
              }
              if (this.formattedValue.substring(selectionStart, 1) === groupingSymbol && count(this.formattedValue, groupingSymbol) === count(value, groupingSymbol) + 1) {
                return newValueLength - caretPositionFromLeft - 1;
              }
              if (newValueLength < caretPositionFromLeft) {
                return selectionStart;
              }
              if (decimalSymbol !== void 0 && value.indexOf(decimalSymbol) !== -1) {
                const decimalSymbolPosition = value.indexOf(decimalSymbol) + 1;
                if (Math.abs(newValueLength - value.length) > 1 && selectionStart <= decimalSymbolPosition) {
                  return this.formattedValue.indexOf(decimalSymbol) + 1;
                } else {
                  if (!this.options.autoDecimalDigits && selectionStart > decimalSymbolPosition) {
                    if (this.currencyFormat.onlyDigits(value.substring(decimalSymbolPosition)).length - 1 === maximumFractionDigits) {
                      caretPositionFromLeft -= 1;
                    }
                  }
                }
              }
              return this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === CurrencyDisplay.hidden ? newValueLength - caretPositionFromLeft : Math.max(newValueLength - Math.max(caretPositionFromLeft, suffix.length), prefix.length);
            };
            this.setCaretPosition(getCaretPositionAfterFormat());
          }
        });
        this.el.addEventListener("focus", () => {
          this.focus = true;
          this.numberValueOnFocus = this.numberValue;
          setTimeout(() => {
            const { value, selectionStart, selectionEnd } = this.el;
            this.format(value, this.options.hideNegligibleDecimalDigitsOnFocus);
            if (selectionStart != null && selectionEnd != null && Math.abs(selectionStart - selectionEnd) > 0) {
              this.setCaretPosition(0, this.el.value.length);
            } else if (selectionStart != null) {
              const caretPositionOnFocus = this.getCaretPositionOnFocus(value, selectionStart);
              this.setCaretPosition(caretPositionOnFocus);
            }
          });
        });
        this.el.addEventListener("blur", () => {
          this.focus = false;
          this.format(this.currencyFormat.format(this.validateValueRange(this.numberValue)));
          if (this.numberValueOnFocus !== this.numberValue) {
            this.onChange(this.getValue());
          }
        });
      }
      getCaretPositionOnFocus(value, selectionStart) {
        if (this.numberValue == null) {
          return selectionStart;
        }
        const { prefix, negativePrefix, suffix, negativeSuffix, groupingSymbol, currency } = this.currencyFormat;
        const isNegative = this.numberValue < 0;
        const currentPrefix = isNegative ? negativePrefix : prefix;
        const prefixLength = currentPrefix.length;
        if (this.options.hideCurrencySymbolOnFocus || this.options.currencyDisplay === CurrencyDisplay.hidden) {
          if (isNegative) {
            if (selectionStart <= 1) {
              return 1;
            } else if (value.endsWith(")") && selectionStart > value.indexOf(")")) {
              return this.formattedValue.length - 1;
            }
          }
        } else {
          const suffixLength = isNegative ? negativeSuffix.length : suffix.length;
          if (selectionStart >= value.length - suffixLength) {
            return this.formattedValue.length - suffixLength;
          } else if (selectionStart < prefixLength) {
            return prefixLength;
          }
        }
        let result = selectionStart;
        if (this.options.hideCurrencySymbolOnFocus && this.options.currencyDisplay !== CurrencyDisplay.hidden && selectionStart >= prefixLength && currency !== void 0 && currentPrefix.includes(currency)) {
          result -= prefixLength;
          if (isNegative) {
            result += 1;
          }
        }
        if (this.options.hideGroupingSeparatorOnFocus && groupingSymbol !== void 0) {
          result -= count(value.substring(0, selectionStart), groupingSymbol);
        }
        return result;
      }
      setCaretPosition(start2, end2 = start2) {
        this.el.setSelectionRange(start2, end2);
      }
    }
    const findInput = (el) => (el === null || el === void 0 ? void 0 : el.matches("input")) ? el : el === null || el === void 0 ? void 0 : el.querySelector("input");
    function useCurrencyInput(options, autoEmit) {
      var _a, _b, _c, _d;
      let currencyInput;
      const inputRef = ref(null);
      const formattedValue = ref(null);
      const numberValue = ref(null);
      const vm = getCurrentInstance();
      const emit2 = (vm === null || vm === void 0 ? void 0 : vm.emit) || ((_b = (_a = vm === null || vm === void 0 ? void 0 : vm.proxy) === null || _a === void 0 ? void 0 : _a.$emit) === null || _b === void 0 ? void 0 : _b.bind(vm === null || vm === void 0 ? void 0 : vm.proxy));
      const props = (vm === null || vm === void 0 ? void 0 : vm.props) || ((_c = vm === null || vm === void 0 ? void 0 : vm.proxy) === null || _c === void 0 ? void 0 : _c.$props);
      const isVue3 = version.startsWith("3");
      const lazyModel = isVue3 && ((_d = vm === null || vm === void 0 ? void 0 : vm.attrs.modelModifiers) === null || _d === void 0 ? void 0 : _d.lazy);
      const modelValue = computed(() => props === null || props === void 0 ? void 0 : props[isVue3 ? "modelValue" : "value"]);
      const inputEvent = isVue3 ? "update:modelValue" : "input";
      const changeEvent = lazyModel ? "update:modelValue" : "change";
      watch(inputRef, (value) => {
        var _a2;
        if (value) {
          const el = findInput((_a2 = value === null || value === void 0 ? void 0 : value.$el) !== null && _a2 !== void 0 ? _a2 : value);
          if (el) {
            currencyInput = new CurrencyInput({
              el,
              options,
              onInput: (value2) => {
                if (!lazyModel && autoEmit !== false && modelValue.value !== value2.number) {
                  emit2 === null || emit2 === void 0 ? void 0 : emit2(inputEvent, value2.number);
                }
                numberValue.value = value2.number;
                formattedValue.value = value2.formatted;
              },
              onChange: (value2) => {
                if (autoEmit !== false) {
                  emit2 === null || emit2 === void 0 ? void 0 : emit2(changeEvent, value2.number);
                }
              }
            });
            currencyInput.setValue(modelValue.value);
          } else {
            console.error('No input element found. Please make sure that the "inputRef" template ref is properly assigned.');
          }
        } else {
          currencyInput = null;
        }
      });
      return {
        inputRef,
        numberValue,
        formattedValue,
        setValue: (value) => currencyInput === null || currencyInput === void 0 ? void 0 : currencyInput.setValue(value),
        setOptions: (options2) => currencyInput === null || currencyInput === void 0 ? void 0 : currencyInput.setOptions(options2)
      };
    }
    const _sfc_main$h = {
      name: "CurrencyInput",
      props: {
        hideLabel: Boolean,
        inputId: {
          type: String,
          required: true
        },
        label: {
          type: String,
          default: "Input Label"
        },
        modelValue: {
          type: Number,
          default: NaN
        },
        options: {
          type: Object,
          default: () => {
          }
        }
      },
      emits: ["update-value", "update:modelValue"],
      setup(props) {
        const { inputRef, setValue } = useCurrencyInput({
          currency: "USD",
          locale: "en",
          currencyDisplay: "hidden",
          hideCurrencySymbolOnFocus: false,
          hideGroupingSeparatorOnFocus: false,
          ...props.options
        });
        watch(() => props.modelValue, setValue);
        return { inputRef };
      }
    };
    const _hoisted_1$g = { class: "slds-form-element" };
    const _hoisted_2$f = ["for"];
    const _hoisted_3$f = { class: "slds-form-element__control" };
    const _hoisted_4$c = ["id"];
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$g, [
        createBaseVNode("label", {
          class: normalizeClass([{ "slds-assistive-text": $props.hideLabel }, "slds-form-element__label"]),
          for: $props.inputId
        }, toDisplayString($props.label), 11, _hoisted_2$f),
        createBaseVNode("div", _hoisted_3$f, [
          createBaseVNode("input", {
            id: $props.inputId,
            ref: "inputRef",
            class: "slds-input"
          }, null, 8, _hoisted_4$c)
        ])
      ]);
    }
    const MaskedInput = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
    const _sfc_main$g = {
      name: "Overview",
      components: {
        MaskedInput,
        // slds vue
        Spinner,
        Button,
        Tooltip,
        ButtonIcon,
        Icon,
        ActionMenu,
        ActionMenuItem,
        Modal
      },
      props: ["segment"],
      data() {
        return {
          isLoading: true,
          recordCount: 0,
          fieldData: {},
          stampedCount: 0,
          stampDate: "",
          // target
          targetModalConfig: null
        };
      },
      computed: {
        alignmentCount() {
          return this.$store.territoryPlans.reduce((total, dataSet) => {
            var _a;
            return total + (((_a = dataSet == null ? void 0 : dataSet.maps__Alignments__r) == null ? void 0 : _a.length) || 0);
          }, 0);
        },
        dataSetRowCount() {
          if (this.segment.sfsp__StampDataSourceId__c) {
            return this.stampedCount;
          }
          return this.recordCount;
        },
        canCarveTerritories() {
          return this.$store.isAdmin || this.$store.userAccessRecords.some((r) => {
            var _a, _b;
            return r.sfsp__User__c === SPM.currentUser.Id && (r.sfsp__SalesPlan__c || ((_b = (_a = r.sfsp__ApplicationAccess__c) == null ? void 0 : _a.split(";")) == null ? void 0 : _b.includes("Territory Planning")));
          });
        },
        canSetTargets() {
          return SPM.betaFlags.SP_Quota_Targets && (this.$store.isAdmin || this.$store.userAccessRecords.some((r) => r.sfsp__User__c === SPM.currentUser.Id && r.sfsp__SalesPlan__c));
        }
      },
      async mounted() {
        SPM.Components.Overview = this;
        await this.loadRecords();
      },
      methods: {
        async getDataSetCount() {
          const dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: this.segment.sfsp__StampDataSourceId__c });
          this.stampDate = new Date(dataset.lastModifiedDate);
          const saql = `
            ${SPM.Utils.Segment.Node.getDataSetCountSaql({
            datasetId: dataset.id,
            versionId: dataset.currentVersionId
          })}
            `;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          this.stampedCount = results.records[0].count;
        },
        async loadRecords() {
          if (!this.$store.dataSource) {
            this.isLoading = false;
            return;
          }
          const nodeMap = await SPM.Utils.Segment.Node.buildNodeMap({ nodeId: this.segment.Id });
          const dataSource = this.$store.dataSource;
          const numericFields = dataSource._referenceFields.filter((f) => !f.isId && !f.isName && f.dataType === "Numeric");
          const textFields = dataSource._referenceFields.filter((f) => !f.isId && !f.isName && f.dataType === "Text");
          const saql = `
                ${SPM.Utils.Segment.Node.generateNodeFilterSaql({
            node: nodeMap[this.segment.Id],
            nodeMap,
            dataSource
          })}

                -- Numeric Aggregates
                __Aggregates = group results by all;
                __Records = foreach __Aggregates generate "__Records" as field, "Sum" as bucket, count() as value;
                ${numericFields.map((f) => `
                    sum__${f.id} = foreach __Aggregates generate "${f.id}" as field, "Sum" as bucket, sum(${f.id}) as value;
                    min__${f.id} = foreach __Aggregates generate "${f.id}" as field, "Min" as bucket, min(${f.id}) as value;
                    max__${f.id} = foreach __Aggregates generate "${f.id}" as field, "Max" as bucket, max(${f.id}) as value;
                `).join("")}

                -- Text Fields
                ${textFields.map((f) => `
                    ${f.id} = group results by ${f.id};
                    ${f.id} = foreach ${f.id} generate "${f.id}" as field, ${f.id} as bucket, count() as value;
                    ${f.id} = limit ${f.id} 5;
                `).join("")}

                -- results
                results = union ${[
            "__Records",
            ...numericFields.map((f) => [`sum__${f.id}`, `min__${f.id}`, `max__${f.id}`]),
            ...textFields.map((f) => f.id)
          ].join(", ")};
            `;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          results.records.forEach(({ field, bucket, value }) => {
            if (field === "__Records") {
              this.recordCount = value;
            } else {
              this.fieldData[field] = this.fieldData[field] || { dataType: dataSource._referenceFields.find((f) => f.id === field).dataType };
              this.fieldData[field][bucket] = value;
            }
          });
          if (this.segment.sfsp__StampDataSourceId__c) {
            await this.getDataSetCount();
          }
          this.isLoading = false;
        },
        carveTerritories() {
          SPM.Components.TerritoryPlans.launchTerritoryPlanningDataset();
        },
        launchSegmentBuilder() {
          window.open(`/apex/SegmentBuilder?planId=${this.$store.segment.sfsp__SalesPlan__c}`);
        },
        openStampModal() {
          SPM.Components.Root.openModal("stamp", {
            callback: async () => {
              await this.$store.refreshTerritoryStamp();
            }
          });
        },
        openViewStampModal() {
          SPM.Components.Root.openModal("viewStamped");
          const pendoPayload = {
            segmentId: this.segment.Id,
            planId: this.segment.sfsp__SalesPlan__r.Id
          };
          SPM.$store.trackPendoEvent({ actionType: "SP | Segmentation - View Stamped Territories", pendoPayload });
        },
        async updateStampModal() {
          const records = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id,
                    Name
                FROM maps__TPAlignment__c
                WHERE Id = '${this.$store.territoryStampRoot.Id}'
                    AND maps__Status__c != 'Deleted'
                ORDER BY Name ASC
            `]);
          if (!records.length) {
            SPM.$store.toast({ state: "error", message: `Alignment ${this.$store.territoryStampRoot.Name} no longer exists. Please stamp another alignment.` });
          } else {
            SPM.Components.Root.openModal("stampTerritory", {
              alignment: records[0],
              update: true,
              callback: async () => {
                await this.$store.refreshTerritoryStamp();
              }
            });
          }
        },
        deleteStampModal() {
          SPM.Components.Root.openModal("deleteTerritoryStamp", {
            alignmentName: this.$store.territoryStampRoot.Name,
            callback: async () => {
              await this.$store.refreshTerritoryStamp();
            }
          });
        },
        // target
        saveTarget() {
          this.$store.segment.sfsp__Target__c = this.targetModalConfig.target || 0;
          SPM.Utils.CRM.upsert({ records: [this.$store.segment] });
          this.targetModalConfig = null;
        }
      }
    };
    const _hoisted_1$f = { class: "spm-overview slds-card" };
    const _hoisted_2$e = /* @__PURE__ */ createBaseVNode("div", { class: "spm-overview-title" }, "Overview", -1);
    const _hoisted_3$e = { class: "slds-grid slds-wrap" };
    const _hoisted_4$b = {
      id: "records-card",
      class: "slds-card slds-grid slds-wrap"
    };
    const _hoisted_5$b = { class: "slds-grid slds-col slds-size_1-of-1" };
    const _hoisted_6$a = { class: "slds-col" };
    const _hoisted_7$9 = /* @__PURE__ */ createBaseVNode("div", { class: "spm-overview-card-title" }, "Records", -1);
    const _hoisted_8$9 = { class: "spm-overview-card-count" };
    const _hoisted_9$9 = {
      key: 0,
      class: "stamped-desc slds-m-top_x-small"
    };
    const _hoisted_10$9 = /* @__PURE__ */ createBaseVNode("span", { id: "open-builder-button" }, "Edit in Builder", -1);
    const _hoisted_11$7 = {
      key: 0,
      id: "stamp-dataset-button"
    };
    const _hoisted_12$6 = {
      key: 1,
      id: "stamp-dataset-button"
    };
    const _hoisted_13$6 = {
      key: 0,
      class: "slds-grid slds-col slds-size_1-of-1 slds-col_bump-top"
    };
    const _hoisted_14$4 = /* @__PURE__ */ createBaseVNode("div", null, "Assigned using segmentation rules", -1);
    const _hoisted_15$3 = {
      key: 1,
      class: "slds-grid slds-col slds-size_1-of-1 slds-col_bump-top"
    };
    const _hoisted_16$3 = /* @__PURE__ */ createBaseVNode("div", null, "The record count in segmentation rules changed", -1);
    const _hoisted_17$3 = {
      id: "alignments-card",
      class: "slds-card slds-grid slds-grid_vertical slds-wrap"
    };
    const _hoisted_18$3 = /* @__PURE__ */ createBaseVNode("div", { class: "spm-overview-card-title" }, "Territories", -1);
    const _hoisted_19$3 = {
      key: 0,
      class: "spm-inner-card slds-grow slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_align-center",
      style: { "width": "100%" }
    };
    const _hoisted_20$2 = /* @__PURE__ */ createBaseVNode("div", { class: "card-text slds-col slds-p-bottom--medium" }, "Get started by creating your first Territory Plan", -1);
    const _hoisted_21$1 = { class: "slds-col" };
    const _hoisted_22$1 = { class: "spm-overview-card-count" };
    const _hoisted_23$1 = /* @__PURE__ */ createBaseVNode("div", { class: "numeric-desc slds-m-top_x-small slds-col_bump-bottom" }, "Alignments", -1);
    const _hoisted_24$1 = { class: "slds-grid slds-col_bump-top" };
    const _hoisted_25$1 = { class: "spm-overview-card-count" };
    const _hoisted_26$1 = {
      key: 0,
      class: "slds-grid slds-m-top_x-small"
    };
    const _hoisted_27$1 = { class: "alignment-name" };
    const _hoisted_28$1 = { class: "stamped-desc" };
    const _hoisted_29$1 = /* @__PURE__ */ createBaseVNode("li", {
      class: "slds-dropdown__header slds-truncate",
      title: "Stamp",
      role: "separator"
    }, [
      /* @__PURE__ */ createBaseVNode("span", null, "Stamp")
    ], -1);
    const _hoisted_30$1 = /* @__PURE__ */ createBaseVNode("span", { id: "view-stamped-button" }, "View", -1);
    const _hoisted_31$1 = /* @__PURE__ */ createBaseVNode("span", { id: "update-territory-stamp-button" }, "Update", -1);
    const _hoisted_32$1 = /* @__PURE__ */ createBaseVNode("span", { id: "delete-territory-stamp-button" }, "Delete", -1);
    const _hoisted_33$1 = {
      key: 0,
      id: "target-card",
      class: "slds-card slds-grid slds-grid_vertical"
    };
    const _hoisted_34$1 = /* @__PURE__ */ createBaseVNode("div", { class: "spm-overview-card-title" }, "Target", -1);
    const _hoisted_35 = { class: "spm-overview-card-count" };
    const _hoisted_36 = {
      key: 0,
      class: "slds-m-top_large"
    };
    const _hoisted_37 = /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-color_inverse-weak" }, "Quota Rollup", -1);
    const _hoisted_38 = { class: "slds-text-title_bold" };
    const _hoisted_39 = {
      key: 1,
      class: "slds-col_bump-top slds-grid slds-grid_vertical-align-center"
    };
    const _hoisted_40 = { class: "slds-m-left_x-small" };
    const _hoisted_41 = { class: "slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_align-center slds-grow" };
    const _hoisted_42 = /* @__PURE__ */ createBaseVNode("div", { class: "slds-p-bottom_small slds-text-color_inverse-weak" }, "No Target Yet", -1);
    const _hoisted_43 = { class: "slds-col_bump-top slds-grid slds-grid_vertical-align-center" };
    const _hoisted_44 = /* @__PURE__ */ createBaseVNode("span", { class: "slds-m-left_x-small" }, "Consider setting a target before planning quota", -1);
    const _hoisted_45 = { class: "slds-grid" };
    const _hoisted_46 = { class: "slds-col_bump-left" };
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_Button = resolveComponent("Button");
      const _component_Icon = resolveComponent("Icon");
      const _component_MaskedInput = resolveComponent("MaskedInput");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createElementBlock("div", _hoisted_1$f, [
        $data.isLoading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        _hoisted_2$e,
        createBaseVNode("div", _hoisted_3$e, [
          createBaseVNode("div", _hoisted_4$b, [
            createBaseVNode("div", _hoisted_5$b, [
              createBaseVNode("div", _hoisted_6$a, [
                _hoisted_7$9,
                createBaseVNode("div", _hoisted_8$9, toDisplayString(_ctx.$F("Compact", $options.dataSetRowCount)), 1),
                $data.stampDate ? (openBlock(), createElementBlock("div", _hoisted_9$9, "Stamped on " + toDisplayString(_ctx.$F("DateTime", $data.stampDate)), 1)) : createCommentVNode("", true)
              ]),
              createVNode(_component_ActionMenu, null, {
                button: withCtx(() => [
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "threedots_vertical",
                    variant: "border-filled",
                    size: "x-small",
                    assistiveText: `View Actions`,
                    title: `View Actions`
                  })
                ]),
                default: withCtx(() => [
                  createVNode(_component_ActionMenuItem, {
                    label: "",
                    onClick: _cache[0] || (_cache[0] = ($event) => $options.launchSegmentBuilder())
                  }, {
                    default: withCtx(() => [
                      _hoisted_10$9
                    ]),
                    _: 1
                  }),
                  $data.recordCount > 0 ? (openBlock(), createBlock(_component_ActionMenuItem, {
                    key: 0,
                    label: "",
                    onClick: _cache[1] || (_cache[1] = ($event) => $options.openStampModal())
                  }, {
                    default: withCtx(() => [
                      $data.stampedCount < 1 ? (openBlock(), createElementBlock("span", _hoisted_11$7, "Stamp")) : (openBlock(), createElementBlock("span", _hoisted_12$6, "Update Stamp"))
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            $data.recordCount > 0 && $data.stampedCount < 1 ? (openBlock(), createElementBlock("div", _hoisted_13$6, [
              createVNode(_component_Tooltip, {
                text: "You can create a static copy of these records for planning with the “Stamp” option in this card’s action menu.",
                alignment: "top"
              }, {
                source: withCtx(() => [
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "info",
                    variant: "bare",
                    title: "Help",
                    assistiveText: "Help",
                    size: "small"
                  })
                ]),
                _: 1
              }),
              _hoisted_14$4
            ])) : createCommentVNode("", true),
            $data.stampedCount > 0 && $data.recordCount !== $data.stampedCount ? (openBlock(), createElementBlock("div", _hoisted_15$3, [
              createVNode(_component_Tooltip, {
                text: "The number of records in your segmentation rules is different from that in the segment stamp. You can update the stamped record set with the “Stamp” option in this card’s action menu.",
                alignment: "top"
              }, {
                source: withCtx(() => [
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "info",
                    variant: "bare",
                    title: "Help",
                    assistiveText: "Help",
                    size: "small"
                  })
                ]),
                _: 1
              }),
              _hoisted_16$3
            ])) : createCommentVNode("", true)
          ]),
          createBaseVNode("div", _hoisted_17$3, [
            _hoisted_18$3,
            !_ctx.$store.territoryPlans.length && !_ctx.$store.territoryStampSize ? (openBlock(), createElementBlock("div", _hoisted_19$3, [
              _hoisted_20$2,
              createBaseVNode("div", _hoisted_21$1, [
                $options.canCarveTerritories ? (openBlock(), createBlock(_component_Button, {
                  key: 0,
                  id: "create-dataset-button",
                  disabled: _ctx.$store.isLaunchingTerritoryPlanning,
                  onClick: $options.carveTerritories
                }, {
                  default: withCtx(() => [
                    createTextVNode("New Territory Plan")
                  ]),
                  _: 1
                }, 8, ["disabled", "onClick"])) : createCommentVNode("", true)
              ])
            ])) : !_ctx.$store.territoryStampSize ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_22$1, toDisplayString($options.alignmentCount), 1),
              _hoisted_23$1,
              createBaseVNode("div", _hoisted_24$1, [
                createVNode(_component_Tooltip, {
                  class: "slds-m-right_xx-small",
                  text: "Stamp territory alignment data to this segment to make it available for other planning activities like Quota Planning."
                }),
                createTextVNode("Consider stamping territories ")
              ])
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createBaseVNode("div", _hoisted_25$1, toDisplayString(_ctx.$store.territoryStampSize), 1),
              _ctx.$store.territoryStampRoot.CreatedDate ? (openBlock(), createElementBlock("div", _hoisted_26$1, [
                createBaseVNode("div", _hoisted_27$1, toDisplayString(_ctx.$store.territoryStampRoot.Name), 1),
                createBaseVNode("div", _hoisted_28$1, " stamped on " + toDisplayString(_ctx.$F("DateTime", _ctx.$store.territoryStampRoot.CreatedDate, { month: "short", day: "numeric", year: "numeric" })), 1)
              ])) : createCommentVNode("", true),
              createVNode(_component_ActionMenu, { style: { "position": "absolute", "top": ".75em", "right": ".75em" } }, {
                button: withCtx(() => [
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "threedots_vertical",
                    variant: "border-filled",
                    size: "x-small",
                    assistiveText: `View Actions`,
                    title: `View Actions`
                  })
                ]),
                default: withCtx(() => [
                  _hoisted_29$1,
                  createVNode(_component_ActionMenuItem, {
                    label: "",
                    onClick: $options.openViewStampModal
                  }, {
                    default: withCtx(() => [
                      _hoisted_30$1
                    ]),
                    _: 1
                  }, 8, ["onClick"]),
                  $options.canCarveTerritories && _ctx.$store.territoryStampRoot.Id ? (openBlock(), createBlock(_component_ActionMenuItem, {
                    key: 0,
                    label: "Update Territory Stamp",
                    onClick: _cache[2] || (_cache[2] = ($event) => $options.updateStampModal())
                  }, {
                    default: withCtx(() => [
                      _hoisted_31$1
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  $options.canCarveTerritories ? (openBlock(), createBlock(_component_ActionMenuItem, {
                    key: 1,
                    label: "Delete Territory Stamp",
                    onClick: _cache[3] || (_cache[3] = ($event) => $options.deleteStampModal())
                  }, {
                    default: withCtx(() => [
                      _hoisted_32$1
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ], 64))
          ]),
          $options.canSetTargets ? (openBlock(), createElementBlock("div", _hoisted_33$1, [
            _hoisted_34$1,
            _ctx.$store.segment.sfsp__Target__c ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createBaseVNode("div", _hoisted_35, toDisplayString(_ctx.$F("Compact", _ctx.$store.segment.sfsp__Target__c)), 1),
              _ctx.$store.segment.sfsp__QuotaRollup__c ? (openBlock(), createElementBlock("div", _hoisted_36, [
                _hoisted_37,
                createBaseVNode("div", _hoisted_38, toDisplayString(_ctx.$F("Compact", _ctx.$store.segment.sfsp__QuotaRollup__c)), 1)
              ])) : createCommentVNode("", true),
              _ctx.$store.segment._quotaStamp ? (openBlock(), createElementBlock("div", _hoisted_39, [
                createVNode(_component_Icon, {
                  category: "utility",
                  name: "info",
                  size: "xx-small"
                }),
                createBaseVNode("span", _hoisted_40, [
                  createBaseVNode("b", null, toDisplayString(_ctx.$store.segment._quotaStamp.planName), 1),
                  createTextVNode(" stamped on " + toDisplayString(_ctx.$F("DateTime", _ctx.$store.segment._quotaStamp.date, { month: "short", day: "numeric", year: "numeric" })), 1)
                ])
              ])) : createCommentVNode("", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", _hoisted_41, [
                _hoisted_42,
                _ctx.$store.isAdmin ? (openBlock(), createBlock(_component_Button, {
                  key: 0,
                  id: "create-target-button",
                  variant: "brand",
                  onClick: _cache[4] || (_cache[4] = ($event) => $data.targetModalConfig = { target: _ctx.$store.segment.sfsp__Target__c || 0 })
                }, {
                  default: withCtx(() => [
                    createTextVNode("Create Target")
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ]),
              createBaseVNode("div", _hoisted_43, [
                createVNode(_component_Icon, {
                  category: "utility",
                  name: "info",
                  size: "xx-small"
                }),
                _hoisted_44
              ])
            ], 64)),
            createVNode(_component_ActionMenu, { style: { "position": "absolute", "top": ".75em", "right": ".75em" } }, {
              button: withCtx(() => [
                createVNode(_component_ButtonIcon, {
                  iconCategory: "utility",
                  iconName: "threedots_vertical",
                  variant: "border-filled",
                  size: "x-small",
                  assistiveText: `View Actions`,
                  title: `View Actions`
                })
              ]),
              default: withCtx(() => [
                createVNode(_component_ActionMenuItem, {
                  label: "Set Target",
                  onClick: _cache[5] || (_cache[5] = ($event) => $data.targetModalConfig = { target: _ctx.$store.segment.sfsp__Target__c || 0 })
                })
              ]),
              _: 1
            })
          ])) : createCommentVNode("", true)
        ]),
        $data.targetModalConfig ? (openBlock(), createBlock(_component_Modal, {
          key: 1,
          ref: "modal",
          size: "base",
          title: "Set Target",
          onClose: _cache[8] || (_cache[8] = ($event) => $data.targetModalConfig = null)
        }, {
          content: withCtx(() => [
            createVNode(_component_MaskedInput, {
              modelValue: $data.targetModalConfig.target,
              "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.targetModalConfig.target = $event),
              label: "Target",
              inputId: "target-input"
            }, null, 8, ["modelValue"])
          ]),
          footer: withCtx(() => [
            createBaseVNode("div", _hoisted_45, [
              createBaseVNode("div", _hoisted_46, [
                createVNode(_component_Button, {
                  class: "slds-button",
                  onClick: _cache[7] || (_cache[7] = ($event) => $data.targetModalConfig = null)
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }),
                createVNode(_component_Button, {
                  class: "slds-button",
                  variant: "brand",
                  onClick: $options.saveTarget
                }, {
                  default: withCtx(() => [
                    createTextVNode("Save")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ]),
          _: 1
        }, 512)) : createCommentVNode("", true)
      ]);
    }
    const Overview = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
    const _sfc_main$f = {
      name: "TerritoryPlans",
      components: {
        Spinner,
        Icon,
        ButtonIcon,
        Picklist,
        ActionMenu,
        ActionMenuItem
      },
      props: ["segment"],
      data() {
        return {
          isLoadingTerritoryPlans: true,
          isTPEnabled: false,
          dataSetId: ""
        };
      },
      computed: {
        alignments() {
          var _a;
          return ((_a = this.$store.territoryPlans.find((ds) => ds.Id === this.dataSetId)) == null ? void 0 : _a.maps__Alignments__r) || [];
        },
        canEdit() {
          return this.$store.isAdmin || this.$store.userAccessRecords.some((r) => {
            var _a, _b;
            return r.sfsp__User__c === SPM.currentUser.Id && (r.sfsp__SalesPlan__c || ((_b = (_a = r.sfsp__ApplicationAccess__c) == null ? void 0 : _a.split(";")) == null ? void 0 : _b.includes("Territory Planning")));
          });
        }
      },
      async mounted() {
        var _a, _b;
        SPM.Components.TerritoryPlans = this;
        try {
          this.$store.territoryPlans = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id,
                    Name,
                    (SELECT Id, Name, CreatedDate, CreatedById, CreatedBy.Name FROM maps__Alignments__r WHERE maps__Status__c != 'Deleted' ORDER BY CreatedDate DESC)
                FROM maps__TPDataSet__c
                WHERE Id IN ('${SPM.Components.Details.externalAssets.filter((a) => a.sfsp__AssetType__c === "Territory Plan").map((a) => a.sfsp__AssetId__c).join("','")}')
                    AND maps__Status__c != 'Deleted'
                ORDER BY Name ASC
            `]);
          this.dataSetId = ((_b = (_a = this.$store.territoryPlans) == null ? void 0 : _a[0]) == null ? void 0 : _b.Id) || "";
          this.isTPEnabled = true;
        } catch (err) {
        }
        this.isLoadingTerritoryPlans = false;
      },
      methods: {
        async launchTerritoryPlanningDataset() {
          this.$store.isLaunchingTerritoryPlanning = true;
          if (!this.isTPEnabled) {
            this.$store.toast({ state: "warning", message: "To carve territories, ask your Salesforce admin for access to Territory Planning." });
            this.$store.isLaunchingTerritoryPlanning = false;
            return;
          }
          window.open(`/one/one.app#/alohaRedirect/apex/maps__TerritoryPlanning?modal=dataset&segmentId=${this.segment.Id}`);
          this.$store.isLaunchingTerritoryPlanning = false;
        },
        openDataSet() {
          window.open(`/${this.dataSetId}`);
        },
        stampTerritory(territoryAlignment) {
          SPM.Components.Root.openModal("stampTerritory", {
            alignment: territoryAlignment,
            callback: async () => {
              await this.$store.refreshTerritoryStamp();
            }
          });
        }
      }
    };
    const _withScopeId$9 = (n) => (pushScopeId("data-v-318cd094"), n = n(), popScopeId(), n);
    const _hoisted_1$e = { class: "slds-card slds-card_boundary" };
    const _hoisted_2$d = { class: "slds-card__header slds-grid slds-grid_vertical-align-center" };
    const _hoisted_3$d = { class: "slds-card__header-title" };
    const _hoisted_4$a = ["disabled"];
    const _hoisted_5$a = { key: 1 };
    const _hoisted_6$9 = {
      class: "slds-grid slds-grid_vertical-align-center slds-p-vertical_x-small slds-p-horizontal_small",
      style: { "background": "#e5e5e5" }
    };
    const _hoisted_7$8 = { class: "slds-table filter-table" };
    const _hoisted_8$8 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("thead", null, [
      /* @__PURE__ */ createBaseVNode("tr", null, [
        /* @__PURE__ */ createBaseVNode("th", null, "Alignment Name"),
        /* @__PURE__ */ createBaseVNode("th", null, "Created By"),
        /* @__PURE__ */ createBaseVNode("th", null, "Created Date"),
        /* @__PURE__ */ createBaseVNode("th", { class: "slds-size_1-of-12" })
      ])
    ], -1));
    const _hoisted_9$8 = ["href"];
    const _hoisted_10$8 = ["href"];
    const _hoisted_11$6 = { class: "slds-grid slds-grid_align-center" };
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      return openBlock(), createElementBlock("div", _hoisted_1$e, [
        $data.isLoadingTerritoryPlans ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$d, [
          createVNode(_component_Icon, {
            category: "standard",
            name: "budget_allocation",
            class: "slds-m-right_small"
          }),
          createBaseVNode("h2", _hoisted_3$d, "Territory Plans (" + toDisplayString(_ctx.$store.territoryPlans.length) + ")", 1),
          $options.canEdit ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: "slds-button slds-button_neutral slds-col_bump-left",
            disabled: _ctx.$store.isLaunchingTerritoryPlanning,
            onClick: _cache[0] || (_cache[0] = (...args) => $options.launchTerritoryPlanningDataset && $options.launchTerritoryPlanningDataset(...args))
          }, "New", 8, _hoisted_4$a)) : createCommentVNode("", true)
        ]),
        _ctx.$store.territoryPlans.length ? (openBlock(), createElementBlock("div", _hoisted_5$a, [
          createBaseVNode("div", _hoisted_6$9, [
            createVNode(_component_Picklist, {
              modelValue: $data.dataSetId,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.dataSetId = $event),
              options: _ctx.$store.territoryPlans,
              idKey: "Id",
              titleKey: "Name",
              labelForId: "Dataset Name",
              class: "filter-picklist"
            }, null, 8, ["modelValue", "options"]),
            $data.dataSetId ? (openBlock(), createBlock(_component_ButtonIcon, {
              key: 0,
              iconCategory: "utility",
              iconName: "new_window",
              size: "small",
              assistiveText: "Open Data Set",
              title: "Open Data Set",
              onClick: $options.openDataSet
            }, null, 8, ["onClick"])) : createCommentVNode("", true)
          ]),
          createBaseVNode("table", _hoisted_7$8, [
            _hoisted_8$8,
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.alignments, (alignment) => {
                return openBlock(), createElementBlock("tr", {
                  key: alignment.Id
                }, [
                  createBaseVNode("td", null, [
                    createBaseVNode("a", {
                      href: `/${alignment.Id}`,
                      target: "_blank"
                    }, toDisplayString(alignment.Name), 9, _hoisted_9$8)
                  ]),
                  createBaseVNode("td", null, [
                    createBaseVNode("a", {
                      href: `/${alignment.CreatedById}`,
                      target: "_blank"
                    }, toDisplayString(alignment.CreatedBy.Name), 9, _hoisted_10$8)
                  ]),
                  createBaseVNode("td", null, toDisplayString(_ctx.$F("DateTime", new Date(alignment.CreatedDate))), 1),
                  createBaseVNode("td", _hoisted_11$6, [
                    $options.canEdit ? (openBlock(), createBlock(_component_ActionMenu, { key: 0 }, {
                      button: withCtx(() => [
                        createVNode(_component_ButtonIcon, {
                          iconCategory: "utility",
                          iconName: "down",
                          variant: "border-filled",
                          size: "x-small",
                          assistiveText: `View Actions`,
                          title: `View Actions`
                        })
                      ]),
                      default: withCtx(() => [
                        createVNode(_component_ActionMenuItem, {
                          label: "Stamp",
                          onClick: ($event) => $options.stampTerritory(alignment)
                        }, null, 8, ["onClick"])
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("", true)
                  ])
                ]);
              }), 128))
            ])
          ])
        ])) : createCommentVNode("", true)
      ]);
    }
    const TerritoryPlans = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f], ["__scopeId", "data-v-318cd094"]]);
    const _sfc_main$e = {
      name: "ConfirmModal",
      components: {
        Button,
        Checkbox,
        Icon,
        Modal
      },
      props: ["config"],
      computed: {
        confirmButtonClass() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.confirmButton) == null ? void 0 : _b.type) ? `slds-button slds-button_${this.config.confirmButton.type}` : "slds-button slds-button_brand";
        },
        confirmButtonText() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.confirmButton) == null ? void 0 : _b.label) ? this.config.confirmButton.label : "Confirm";
        },
        cancelButtonClass() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.cancelButton) == null ? void 0 : _b.type) ? `slds-button slds-button_${this.config.cancelButton.type}` : "slds-button slds-button_neutral";
        },
        cancelButtonText() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.cancelButton) == null ? void 0 : _b.label) ? this.config.cancelButton.label : "Cancel";
        }
      },
      methods: {
        confirm() {
          this.config.callback({ options: this.config.options });
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$d = { class: "slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_align-center" };
    const _hoisted_2$c = { key: 0 };
    const _hoisted_3$c = {
      class: "slds-text-color_weak slds-text-heading_small",
      style: { "text-align": "center" }
    };
    const _hoisted_4$9 = { style: { "white-space": "pre-wrap" } };
    const _hoisted_5$9 = { class: "slds-grid" };
    const _hoisted_6$8 = { class: "slds-col_bump-left" };
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: $props.config.title,
        size: "small",
        detach: "",
        onClose: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_1$d, [
            $props.config.icon ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
              createVNode(_component_Icon, {
                category: $props.config.icon.category,
                name: $props.config.icon.name,
                iconClass: "slds-button__icon",
                assistiveText: $props.config.icon.text,
                size: $props.config.icon.size
              }, null, 8, ["category", "name", "assistiveText", "size"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_3$c, [
                createBaseVNode("span", _hoisted_4$9, toDisplayString($props.config.description), 1)
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.config.options, (option) => {
                return openBlock(), createElementBlock("div", {
                  key: option.id,
                  class: "slds-m-top_small"
                }, [
                  createVNode(_component_Checkbox, {
                    modelValue: option.selected,
                    "onUpdate:modelValue": ($event) => option.selected = $event,
                    labels: { name: option.label }
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "labels"])
                ]);
              }), 128))
            ])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_5$9, [
              createBaseVNode("div", _hoisted_6$8, [
                createVNode(_component_Button, {
                  class: normalizeClass($options.cancelButtonClass),
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($options.cancelButtonText), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createVNode(_component_Button, {
                  class: normalizeClass($options.confirmButtonClass),
                  onClick: $options.confirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($options.confirmButtonText), 1)
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const ConfirmModal = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
    const _sfc_main$d = {
      name: "StampQuotaModal",
      components: {
        Button,
        Icon,
        Modal,
        Spinner
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loadingMsg: "",
          hierarchyDiff: []
        };
      },
      computed: {},
      methods: {
        async stamp() {
          this.loadingMsg = "Loading Plan...";
          const plan = {
            ...SPM.Utils.Quota.Plan.defaults(),
            ...await SPM.Utils.Apex.invoke("GetQuotaPlan", [this.config.plan.Id], { cls: "SPMSharingModel" })
          };
          plan._columns = JSON.parse(plan.sfsp__ReferenceFields__c);
          this.loadingMsg = "Loading Hierarchies...";
          const quotaHierarchy = {
            ...SPM.Utils.Quota.Node.defaults(),
            Id: "all_org",
            Name: "All",
            _data: {}
          };
          const territoryHierarchy = {
            Id: "all_org",
            Name: "All",
            sfsp__SalesNodes__r: []
          };
          const quotaMap = { all_org: quotaHierarchy };
          const territoryMap = { all_org: territoryHierarchy };
          try {
            await Promise.all([
              // quota
              (async () => {
                const quotaNodes = await SPM.Utils.Apex.invoke(
                  "Query",
                  [`
                                SELECT Id, Name, sfsp__Parent__c, sfsp__Owner__r.Name, sfsp__HierarchyReferenceData__c
                                FROM sfsp__SalesNode__c
                                WHERE sfsp__SalesPlan__c = '${plan.Id}'
                                ORDER BY sfsp__Priority__c ASC
                            `]
                );
                quotaNodes.forEach((node) => {
                  const parentNode = quotaMap[node.sfsp__Parent__c || "all_org"] = quotaMap[node.sfsp__Parent__c || "all_org"] || {
                    ...SPM.Utils.Quota.Node.defaults(),
                    Id: node.sfsp__Parent__c || "all_org"
                  };
                  const childNode = quotaMap[node.Id] = quotaMap[node.Id] || {
                    ...SPM.Utils.Quota.Node.defaults(),
                    Id: node.Id
                  };
                  Object.assign(quotaMap[node.Id], {
                    ...node,
                    _parentId: parentNode.Id,
                    _data: JSON.parse(node.sfsp__HierarchyReferenceData__c || "{}")
                  });
                  quotaMap[parentNode.Id].sfsp__SalesNodes__r.push(childNode);
                });
                plan._columns.filter((c) => c.type === "Quota").forEach((c) => SPM.Utils.Quota.Column.calculateRollups(c, { nodeHierarchy: quotaHierarchy }));
                Object.values(quotaMap).forEach((n) => SPM.Utils.Quota.Node.calculateColumns(n, { plan }));
              })(),
              // territory
              (async () => {
                const territoryNodes = await SPM.Utils.Apex.invoke(
                  "Query",
                  [`
                                SELECT Id, Name, sfsp__Parent__c, sfsp__Owner__r.Name
                                FROM sfsp__SalesNode__c
                                WHERE sfsp__Segment__c = '${this.$store.segment.Id}'
                                ORDER BY sfsp__Priority__c ASC
                            `]
                );
                territoryNodes.forEach((node) => {
                  const parentNode = territoryMap[node.sfsp__Parent__c || "all_org"] = territoryMap[node.sfsp__Parent__c || "all_org"] || {
                    Id: node.sfsp__Parent__c || "all_org",
                    sfsp__SalesNodes__r: []
                  };
                  const childNode = territoryMap[node.Id] = territoryMap[node.Id] || {
                    Id: node.Id,
                    sfsp__SalesNodes__r: []
                  };
                  Object.assign(territoryMap[node.Id], {
                    ...node,
                    _parentId: parentNode.Id
                  });
                  territoryMap[parentNode.Id].sfsp__SalesNodes__r.push(childNode);
                });
              })()
            ]);
          } catch (err) {
            this.$store.toast({ state: "error", message: (err == null ? void 0 : err.message) || err, duration: null });
            this.loadingMsg = "";
            return;
          }
          const compareMap = {};
          const isNewHierarchy = territoryHierarchy.sfsp__SalesNodes__r.length === 0;
          if (isNewHierarchy) {
            const buildTerritories = (nodes) => {
              nodes.forEach((n) => {
                compareMap[n.Id] = {
                  sobjectType: "sfsp__SalesNode__c",
                  Name: n.Name,
                  sfsp__Owner__c: n.sfsp__Owner__c,
                  sfsp__HierarchyReferenceData__c: "{}"
                };
                buildTerritories(n.sfsp__SalesNodes__r);
              });
            };
            buildTerritories(quotaHierarchy.sfsp__SalesNodes__r);
          } else {
            const { diff: diff2, map: map2 } = SPM.Utils.Segment.Node.compare({ node: quotaHierarchy, compareNode: territoryHierarchy });
            if (diff2.length > 0) {
              this.hierarchyDiff = diff2;
              this.loadingMsg = "";
              return;
            }
            Object.assign(compareMap, map2);
          }
          const quotasToInclude = plan._columns.filter((c) => c.type === "Quota" && c.includeInQuota).map((c) => c.id);
          Object.entries(compareMap).forEach(([quotaNodeId, territoryNode]) => {
            territoryNode.sfsp__QuotaRollup__c = quotasToInclude.reduce((total, dataId) => total + (quotaMap[quotaNodeId]._data[`${dataId}:Quota`] || 0), 0);
          });
          this.$store.segment.sfsp__QuotaRollup__c = quotaHierarchy.sfsp__SalesNodes__r.reduce((total, node) => {
            quotasToInclude.forEach((dataId) => total += node._data[`${dataId}:Quota`] || 0);
            return total;
          }, 0);
          this.loadingMsg = "Saving Quotas...";
          await SPM.Utils.CRM.upsert({ records: [this.$store.segment, ...Object.values(compareMap)] });
          if (isNewHierarchy) {
            Object.entries(compareMap).forEach(([quotaNodeId, territoryNode]) => {
              var _a;
              territoryNode.sfsp__Segment__c = this.$store.segment.Id;
              territoryNode.sfsp__Parent__c = ((_a = compareMap[quotaMap[quotaNodeId]._parentId]) == null ? void 0 : _a.Id) || "";
            });
            await SPM.Utils.CRM.upsert({ records: Object.values(compareMap) });
            this.$store.territoryStampSize = Object.values(compareMap).length;
          }
          await SPM.Utils.CRM.upsert({
            records: [{
              sobjectType: "sfsp__SalesActivity__c",
              Name: `Stamped Quotas: ${this.$store.segment.Name}`,
              sfsp__Description__c: `Captured ${Object.values(compareMap).length} quotas from ${plan.Name}`,
              sfsp__SalesPlan__c: this.config.plan.Id,
              sfsp__SalesNode__c: this.$store.segment.Id,
              sfsp__Type__c: "Quota Stamp",
              sfsp__Subtype__c: "Created",
              sfsp__Data__c: JSON.stringify({ planName: plan.Name })
            }]
          });
          this.$store.segment._quotaStamp = {
            planName: plan.Name,
            date: Date.now()
          };
          SPM.$store.trackPendoEvent({
            actionType: "SP | Segmentation - Stamp Quota",
            pendoPayload: {
              segmentId: this.$store.segment.Id,
              planId: this.config.plan.Id
            }
          });
          this.$emit("close");
        },
        cancel() {
          this.$emit("close");
        }
      }
    };
    const _withScopeId$8 = (n) => (pushScopeId("data-v-1909c9ea"), n = n(), popScopeId(), n);
    const _hoisted_1$c = { key: 1 };
    const _hoisted_2$b = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("div", null, "Quota cannot be stamped because the territories do not match. Please see the list of issues below and correct them by modifying either your territory or quota plan.", -1));
    const _hoisted_3$b = { class: "slds-table slds-m-top_large" };
    const _hoisted_4$8 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("thead", null, [
      /* @__PURE__ */ createBaseVNode("tr", null, [
        /* @__PURE__ */ createBaseVNode("th", null, "Territory"),
        /* @__PURE__ */ createBaseVNode("th", null, "Reason")
      ])
    ], -1));
    const _hoisted_5$8 = ["title"];
    const _hoisted_6$7 = ["title"];
    const _hoisted_7$7 = {
      key: 2,
      class: "slds-grid slds-grid_vertical slds-align_absolute-center"
    };
    const _hoisted_8$7 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-p-around_large" }, "Stamping will create a new territory hierarchy or enrich the existing one on this segment. Quota rollups will be attached to the segment itself and each territory. You can update this stamp at a later time.", -1));
    const _hoisted_9$7 = { class: "slds-grid" };
    const _hoisted_10$7 = { class: "slds-col_bump-left" };
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        size: "base",
        title: $props.config.title,
        footless: !!$data.loadingMsg,
        hideCloseButton: !!$data.loadingMsg,
        onClose: $options.cancel
      }, {
        tagline: withCtx(() => [
          createTextVNode("Existing stamp data will be overwritten.")
        ]),
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, {
            key: 0,
            style: { "min-height": "200px", "position": "relative", "margin-top": "-30px" }
          }, {
            description: withCtx(() => [
              createTextVNode(toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : $data.hierarchyDiff.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
            _hoisted_2$b,
            createBaseVNode("table", _hoisted_3$b, [
              _hoisted_4$8,
              createBaseVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.hierarchyDiff, (diff2, i2) => {
                  return openBlock(), createElementBlock("tr", { key: i2 }, [
                    createBaseVNode("td", {
                      class: "slds-truncate",
                      title: diff2.label
                    }, toDisplayString(diff2.label), 9, _hoisted_5$8),
                    createBaseVNode("td", {
                      class: "slds-truncate",
                      title: diff2.reason
                    }, toDisplayString(diff2.reason), 9, _hoisted_6$7)
                  ]);
                }), 128))
              ])
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_7$7, [
            createVNode(_component_Icon, {
              category: "utility",
              name: "approval",
              size: "large",
              class: "slds-m-around_medium"
            }),
            _hoisted_8$7
          ]))
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_9$7, [
            createBaseVNode("div", _hoisted_10$7, [
              $data.hierarchyDiff.length > 0 ? (openBlock(), createBlock(_component_Button, {
                key: 0,
                class: "slds-button",
                onClick: $options.cancel
              }, {
                default: withCtx(() => [
                  createTextVNode("Close")
                ]),
                _: 1
              }, 8, ["onClick"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createVNode(_component_Button, {
                  class: "slds-button",
                  onClick: $options.cancel
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                createVNode(_component_Button, {
                  class: "slds-button",
                  variant: "brand",
                  onClick: $options.stamp
                }, {
                  default: withCtx(() => [
                    createTextVNode("Stamp")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ], 64))
            ])
          ])
        ]),
        _: 1
      }, 8, ["title", "footless", "hideCloseButton", "onClose"]);
    }
    const StampQuotaModal = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-1909c9ea"]]);
    const _sfc_main$c = {
      name: "QuotaPlans",
      components: {
        ConfirmModal,
        StampQuotaModal,
        // slds vue
        ActionMenu,
        ActionMenuItem,
        ButtonIcon,
        Spinner,
        Icon
      },
      props: ["segment"],
      data() {
        return {
          plans: null,
          creatingPlan: false,
          confirmModalConfig: null,
          stampModalConfig: null
        };
      },
      computed: {
        canEdit() {
          return this.$store.isAdmin || this.$store.userAccessRecords.some((r) => {
            var _a, _b;
            return r.sfsp__User__c === SPM.currentUser.Id && (r.sfsp__SalesPlan__c || ((_b = (_a = r.sfsp__ApplicationAccess__c) == null ? void 0 : _a.split(";")) == null ? void 0 : _b.includes("Quota Planning")));
          });
        },
        canStamp() {
          return SPM.betaFlags.SP_Quota_Targets && (this.$store.isAdmin || this.$store.userAccessRecords.some((r) => r.sfsp__User__c === SPM.currentUser.Id && r.sfsp__SalesPlan__c));
        }
      },
      async mounted() {
        SPM.Components.QuotaPlans = this;
        this.plans = await SPM.Utils.Apex.invoke("Query", [`
            SELECT Id, Name, CreatedBy.Name, CreatedDate
            FROM sfsp__SalesPlan__c
            WHERE Id IN ('${SPM.Components.Details.externalAssets.filter((a) => a.sfsp__AssetType__c === "Quota Plan").map((a) => a.sfsp__AssetId__c).join("','")}')
                AND sfsp__Status__c != 'Deleted'
            ORDER BY CreatedDate DESC
        `]);
      },
      methods: {
        async launchQuotaBuilder() {
          this.creatingPlan = true;
          const plan = {
            ...SPM.Utils.Quota.Plan.defaults(),
            Name: `${this.segment.Name} Quota`,
            CreatedBy: SPM.currentUser,
            CreatedDate: Date.now()
          };
          await SPM.Utils.CRM.upsert({ records: [plan] });
          this.plans.unshift(plan);
          const externalAsset = {
            sobjectType: "sfsp__SalesNodeExternalAsset__c",
            sfsp__AssetType__c: "Quota Plan",
            sfsp__AssetId__c: plan.Id,
            sfsp__SalesNode__c: this.segment.Id
          };
          await SPM.Utils.CRM.upsert({ records: [externalAsset] });
          SPM.Components.Details.externalAssets.push(externalAsset);
          window.open(`/apex/sfsp__QuotaBuilder?planId=${plan.Id}&segmentId=${this.segment.Id}`);
          this.creatingPlan = false;
        },
        stampPlan(plan) {
          this.stampModalConfig = {
            title: `Stamp ${plan.Name}`,
            plan
          };
        },
        openPlan(plan) {
          window.open(`/apex/sfsp__QuotaBuilder?planId=${plan.Id}&segmentId=${this.segment.Id}`);
        },
        deletePlan(plan) {
          this.confirmModalConfig = {
            title: `Delete ${plan.Name}`,
            description: "Are you sure you want to delete this quota plan?",
            confirmButton: {
              label: "Delete",
              type: "destructive"
            },
            cancelButton: {
              label: "Cancel",
              type: "neutral"
            },
            callback: () => {
              plan.sfsp__Status__c = "Deleted";
              SPM.Utils.Arr.splice(this.plans, (p2) => p2 === plan);
              SPM.Utils.CRM.upsert({ records: [plan] });
              SPM.$store.toast({ message: `${plan.Name} was deleted.` });
            }
          };
        }
      }
    };
    const _withScopeId$7 = (n) => (pushScopeId("data-v-23b341fb"), n = n(), popScopeId(), n);
    const _hoisted_1$b = { class: "slds-card slds-card_boundary" };
    const _hoisted_2$a = { class: "slds-card__header slds-grid slds-grid_vertical-align-center" };
    const _hoisted_3$a = { class: "slds-card__header-title" };
    const _hoisted_4$7 = ["disabled"];
    const _hoisted_5$7 = { class: "slds-table" };
    const _hoisted_6$6 = { key: 0 };
    const _hoisted_7$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("th", null, "Plan Name", -1));
    const _hoisted_8$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("th", null, "Created By", -1));
    const _hoisted_9$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("th", null, "Created Date", -1));
    const _hoisted_10$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("th", { style: { "width": "1px" } }, null, -1));
    const _hoisted_11$5 = [
      _hoisted_7$6,
      _hoisted_8$6,
      _hoisted_9$6,
      _hoisted_10$6
    ];
    const _hoisted_12$5 = ["onClick"];
    const _hoisted_13$5 = ["href"];
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      var _a, _b;
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_ConfirmModal = resolveComponent("ConfirmModal");
      const _component_StampQuotaModal = resolveComponent("StampQuotaModal");
      return openBlock(), createElementBlock("div", _hoisted_1$b, [
        !$data.plans ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$a, [
          createVNode(_component_Icon, {
            category: "standard",
            name: "actions_and_buttons",
            class: "slds-m-right_small"
          }),
          createBaseVNode("h2", _hoisted_3$a, "Quota Plans (" + toDisplayString(((_a = $data.plans) == null ? void 0 : _a.length) || 0) + ")", 1),
          $options.canEdit ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: "slds-button slds-button_neutral slds-col_bump-left",
            disabled: $data.creatingPlan,
            onClick: _cache[0] || (_cache[0] = (...args) => $options.launchQuotaBuilder && $options.launchQuotaBuilder(...args))
          }, toDisplayString($data.creatingPlan ? "Creating Plan..." : "New"), 9, _hoisted_4$7)) : createCommentVNode("", true)
        ]),
        createBaseVNode("table", _hoisted_5$7, [
          createBaseVNode("thead", null, [
            ((_b = $data.plans) == null ? void 0 : _b.length) > 0 ? (openBlock(), createElementBlock("tr", _hoisted_6$6, _hoisted_11$5)) : createCommentVNode("", true)
          ]),
          createBaseVNode("tbody", null, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.plans, (plan) => {
              return openBlock(), createElementBlock("tr", {
                key: plan.Id
              }, [
                createBaseVNode("td", null, [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: withModifiers(($event) => $options.openPlan(plan), ["prevent"])
                  }, toDisplayString(plan.Name), 9, _hoisted_12$5)
                ]),
                createBaseVNode("td", null, [
                  createBaseVNode("a", {
                    href: `/${plan.CreatedBy.Id}`,
                    target: "_blank"
                  }, toDisplayString(plan.CreatedBy.Name), 9, _hoisted_13$5)
                ]),
                createBaseVNode("td", null, toDisplayString(_ctx.$F("DateTime", new Date(plan.CreatedDate))), 1),
                createBaseVNode("td", null, [
                  $options.canEdit ? (openBlock(), createBlock(_component_ActionMenu, { key: 0 }, {
                    button: withCtx(() => [
                      createVNode(_component_ButtonIcon, {
                        iconCategory: "utility",
                        iconName: "down",
                        variant: "border-filled",
                        size: "x-small",
                        assistiveText: `View Actions`,
                        title: `View Actions`
                      })
                    ]),
                    default: withCtx(() => [
                      $options.canStamp ? (openBlock(), createBlock(_component_ActionMenuItem, {
                        key: 0,
                        label: "Stamp",
                        onClick: ($event) => $options.stampPlan(plan)
                      }, null, 8, ["onClick"])) : createCommentVNode("", true),
                      createVNode(_component_ActionMenuItem, {
                        label: "Edit",
                        onClick: ($event) => $options.openPlan(plan)
                      }, null, 8, ["onClick"]),
                      createVNode(_component_ActionMenuItem, {
                        label: "Delete",
                        onClick: ($event) => $options.deletePlan(plan)
                      }, null, 8, ["onClick"])
                    ]),
                    _: 2
                  }, 1024)) : createCommentVNode("", true)
                ])
              ]);
            }), 128))
          ])
        ]),
        $data.confirmModalConfig ? (openBlock(), createBlock(_component_ConfirmModal, {
          key: 1,
          config: $data.confirmModalConfig,
          onClose: _cache[1] || (_cache[1] = ($event) => $data.confirmModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true),
        $data.stampModalConfig ? (openBlock(), createBlock(_component_StampQuotaModal, {
          key: 2,
          config: $data.stampModalConfig,
          onClose: _cache[2] || (_cache[2] = ($event) => $data.stampModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true)
      ]);
    }
    const QuotaPlans = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c], ["__scopeId", "data-v-23b341fb"]]);
    const ConditionalWrapper = {
      name: "ConditionalWrapper",
      functional: true,
      inheritAttrs: false,
      props: {
        element: {
          type: String,
          required: true
        },
        active: Boolean
      },
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        if (this.$props.active) {
          return h(
            this.$props.element,
            {
              ...this.$attrs
            },
            _default
          );
        }
        return _default;
      }
    };
    const ActivityTypes = Object.freeze({
      MANAGEMENT: "Management",
      APPROVAL_PROCESS: "ApprovalProcess",
      STATUS: "Status",
      ALLOCATION: "Allocation",
      ASSIGNMENT: "Assignment",
      HIERARCHY: "Hierarchy",
      SHARING: "Sharing",
      CUSTOM: "Custom"
    });
    const ActivitySubtypes = Object.freeze({
      CREATE: "Created",
      UPDATE: "Updated",
      DELETE: "Deleted",
      REFRESH: "Refreshed",
      ADD: "Added",
      REMOVE: "Removed",
      CUSTOM: "Custom"
    });
    const DefaultActivityName = {
      ActivityNameVNode: (activity) => createVNode(Fragment, null, [createVNode("span", null, [activity.Name])])
    };
    const ActivityNameMatrix = {
      [ActivityTypes.MANAGEMENT]: {
        [ActivitySubtypes.CREATE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Created "), activity.sfsp__RecordType__c, createTextVNode(": ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.loadPlan(activity.sfsp__SalesPlan__c)
          }, {
            default: () => [activity.Name]
          })])
        },
        [ActivitySubtypes.UPDATE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Updated "), activity.sfsp__RecordType__c, createTextVNode(": ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.loadPlan(activity.sfsp__SalesPlan__c)
          }, {
            default: () => [activity.Name]
          })])
        },
        [ActivitySubtypes.DELETE]: {
          ActivityNameVNode: (activity) => createVNode(Fragment, null, [createTextVNode("Deleted "), activity.sfsp__RecordType__c, createTextVNode(": "), activity.Name])
        },
        [ActivitySubtypes.REFRESH]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Updated Assignment Objects")])])
        }
      },
      [ActivityTypes.SHARING]: {
        [ActivitySubtypes.CREATE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Granted user access to ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.loadPlan(activity.sfsp__SalesPlan__c)
          }, {
            default: () => [activity.Name]
          })])
        },
        [ActivitySubtypes.UPDATE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Edited user access for ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.loadPlan(activity.sfsp__SalesPlan__c)
          }, {
            default: () => [activity.Name]
          })])
        },
        [ActivitySubtypes.DELETE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Removed user access from ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.loadPlan(activity.sfsp__SalesPlan__c)
          }, {
            default: () => [activity.Name]
          })])
        },
        [ActivitySubtypes.ADD]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Added "), activity.Name, createTextVNode(" to ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.openSegment(activity.sfsp__SalesNode__c)
          }, {
            default: () => [activity.sfsp__SalesNode__r.Name]
          })])
        },
        [ActivitySubtypes.REMOVE]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [createTextVNode("Removed "), activity.Name, createTextVNode(" from ")]), createVNode(ConditionalWrapper, {
            "element": "a",
            "active": link2,
            "onClick": () => SPM.Components.Root.openSegment(activity.sfsp__SalesNode__c)
          }, {
            default: () => [activity.sfsp__SalesNode__r.Name]
          })])
        }
      },
      [ActivityTypes.CUSTOM]: {
        [ActivitySubtypes.CUSTOM]: {
          ActivityNameVNode: (activity, link2) => createVNode(Fragment, null, [createVNode("span", null, [activity.Name])])
        }
      }
    };
    const ActivityRecordTypes = Object.freeze({
      ASSIGNMENT: "Assignment",
      METRIC: "Metric",
      PLAN: "Plan",
      SCENARIO: "Scenario",
      CUSTOM: "Custom"
    });
    const HistoryTypes = Object.freeze({
      ALL: "all",
      OWN: "own"
    });
    const SortTypes = Object.freeze({
      OLDEST: "ASC",
      NEWEST: "DESC"
    });
    const Utils = UtilsClient({});
    const buildActivityNameVNode = (activity, link2) => {
      var _a, _b;
      if (activity.sfsp__RecordType__c) {
        const allowableRecordTypeForLink = [ActivityRecordTypes.PLAN, ActivityRecordTypes.SCENARIO].includes(activity.sfsp__RecordType__c);
        const parentIsActive = ((_a = activity.sfsp__SalesPlan__r) == null ? void 0 : _a.sfsp__Status__c) === "Active";
        const doLink = link2 && allowableRecordTypeForLink && parentIsActive;
        return (_b = ActivityNameMatrix[activity.sfsp__Type__c][activity.sfsp__Subtype__c]) == null ? void 0 : _b.ActivityNameVNode(activity, doLink);
      } else {
        return DefaultActivityName.ActivityNameVNode(activity);
      }
    };
    const getActivities = async (options = {}) => {
      const {
        batchSize = 10,
        embedLinks = false,
        history,
        maxRecords = 500,
        offset: offset2 = 0,
        // internal use only
        parentId,
        nodeId: nodeId2,
        segments,
        segmentsOnly,
        sort,
        userId
      } = options;
      let query = `
        SELECT
            CreatedDate,
            CreatedById,
            CreatedBy.Name,
            CreatedBy.SmallPhotoUrl,
            Name,
            sfsp__Description__c,
            sfsp__RecordType__c,
            sfsp__SalesPlan__c,
            sfsp__SalesPlan__r.Name,
            sfsp__SalesPlan__r.sfsp__Parent__c,
            sfsp__SalesPlan__r.sfsp__Status__c,
            sfsp__SalesNode__r.Name,
            sfsp__SalesNode__c,
            sfsp__Subtype__c,
            sfsp__Type__c
        FROM sfsp__SalesActivity__c
    `;
      const filters = [];
      if (!SPM.isAdmin && !segmentsOnly) {
        const userAccessRecords = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__SalesPlan__c, sfsp__AccessLevel__c FROM sfsp__SalesUserAccess__c WHERE sfsp__User__c = '${SPM.currentUser.Id}' AND sfsp__SalesPlan__c != NULL`]) || [];
        const availablePlanIds = userAccessRecords.map((ar) => `'${ar.sfsp__SalesPlan__c}'`);
        filters.push(`sfsp__SalesPlan__c IN (${availablePlanIds.length > 0 ? availablePlanIds.join(",") : null})`);
      }
      if (parentId) {
        filters.push(`sfsp__SalesPlan__c = '${parentId}'`);
      }
      if (nodeId2) {
        filters.push(`sfsp__SalesNode__c = '${nodeId2}'`);
      }
      if (segmentsOnly && segments.length > 0) {
        const segmentIds = segments.map((item) => item.Id);
        const segmentsToSearch = segmentIds.map((segmentIds2) => `'${segmentIds2}'`);
        filters.push(`sfsp__SalesNode__c IN (${segmentsToSearch.join(",")})`);
      }
      if (history === HistoryTypes.OWN && userId) {
        filters.push(`CreatedById = '${userId}'`);
      }
      if (filters.length) {
        query += "WHERE ";
        query += filters.join(" AND ");
      }
      query += `
ORDER BY CreatedDate ${sort}`;
      query += `
LIMIT ${Math.min(batchSize, maxRecords - offset2)}`;
      if (offset2) {
        query += `
OFFSET ${offset2}`;
      }
      const result = {
        activities: segmentsOnly && segments.length < 1 ? [] : await Utils.Apex.invoke("Query", [query]) || []
      };
      result.activities.forEach((activity) => {
        activity.nameVNode = buildActivityNameVNode(activity, embedLinks);
      });
      if (offset2 + batchSize < maxRecords && result.activities.length === batchSize) {
        result.queryMore = getActivities.bind(
          void 0,
          {
            ...options,
            offset: Math.min(maxRecords, offset2 + batchSize)
          }
        );
      }
      return result;
    };
    const insertActivities = async (activities = []) => {
      return await Utils.CRM.upsert({
        records: activities.map(({ description, name, parentId, nodeId: nodeId2, recordType, subtype, type }) => ({
          sobjectType: "sfsp__SalesActivity__c",
          Name: name,
          sfsp__Description__c: description,
          sfsp__RecordType__c: recordType,
          sfsp__SalesPlan__c: parentId,
          sfsp__SalesNode__c: nodeId2,
          sfsp__Subtype__c: subtype,
          sfsp__Type__c: type
        }))
      });
    };
    const _sfc_main$b = {
      name: "PlanningTeam",
      components: {
        Spinner,
        Icon,
        Checkbox,
        ButtonIcon,
        ActionMenu,
        ActionMenuItem,
        Card,
        Button
      },
      data() {
        return {
          loading: true,
          viewAll: false
        };
      },
      computed: {
        title() {
          return `Planning Team (${this.teamMembers.length})`;
        },
        teamMembers() {
          const members = [];
          this.$store.userAccessRecords.filter((r) => r.sfsp__SalesNode__c).forEach((user) => {
            var _a;
            const accessList = ((_a = user.sfsp__ApplicationAccess__c) == null ? void 0 : _a.split(";").map((a) => a.trim())) || [];
            const accessObj = {};
            accessList.forEach((a) => accessObj[a] = true);
            members.push({
              id: user.Id,
              userId: user.sfsp__User__c,
              name: user.sfsp__User__r.Name,
              applicationAccess: { ...accessObj },
              addedDate: user.CreateDate
            });
          });
          return members;
        },
        canEdit() {
          return this.$store.isAdmin || this.$store.userAccessRecords.some((r) => r.sfsp__User__c === SPM.currentUser.Id);
        }
      },
      async mounted() {
        this.loading = false;
      },
      methods: {
        openAddTeamMemberModal() {
          SPM.Components.Root.openModal("addTeamMembers", {
            callback: async (toastMsg) => {
              this.$mitt.emit("refresh-activity-history");
              await this.$store.getUserAccessRecords();
              if (toastMsg)
                this.$store.toast({ message: toastMsg, duration: 3e3 });
            }
          });
        },
        async removeUser(recordId) {
          var _a;
          this.loading = true;
          const userAccessRecord = this.$store.userAccessRecords.find((r) => r.Id === recordId);
          await SPM.Utils.CRM.delete({ records: [userAccessRecord] });
          const description = userAccessRecord.sfsp__ApplicationAccess__c ? `User access to ${(_a = userAccessRecord.sfsp__ApplicationAccess__c) == null ? void 0 : _a.replace(";", ", ")} was removed.` : "";
          const activityRecord = {
            description,
            name: userAccessRecord.sfsp__User__r.Name,
            nodeId: this.$store.segment.Id,
            parentId: this.$store.segment.sfsp__SalesPlan__c,
            recordType: ActivityRecordTypes.SCENARIO,
            subtype: ActivitySubtypes.REMOVE,
            type: ActivityTypes.SHARING
          };
          await insertActivities([activityRecord]);
          this.$mitt.emit("refresh-activity-history");
          this.$store.toast({ message: `${userAccessRecord.sfsp__User__r.Name} was removed from the segment.`, duration: 3e3 });
          await this.$store.getUserAccessRecords();
          this.loading = false;
        },
        toggleView() {
          this.viewAll = !this.viewAll;
        }
      }
    };
    const _withScopeId$6 = (n) => (pushScopeId("data-v-9558ca67"), n = n(), popScopeId(), n);
    const _hoisted_1$a = { class: "slds-card slds-card_boundary" };
    const _hoisted_2$9 = { class: "slds-text-align_right slds-no-flex" };
    const _hoisted_3$9 = {
      key: 0,
      id: "team-members-list-view",
      class: "slds-table slds-table_bordered slds-no-row-hover",
      "aria-label": "Users with access"
    };
    const _hoisted_4$6 = { class: "slds-line-height_reset" };
    const _hoisted_5$6 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("th", {
      class: "slds-col slds-size_4-of-12 slds-p-right_small",
      scope: "col"
    }, [
      /* @__PURE__ */ createBaseVNode("div", {
        class: "slds-truncate",
        title: "Team Member"
      }, "Team Member")
    ], -1));
    const _hoisted_6$5 = ["title"];
    const _hoisted_7$5 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("th", {
      class: "slds-col slds-size_1-of-12",
      scope: "col"
    }, [
      /* @__PURE__ */ createBaseVNode("div", {
        class: "slds-truncate",
        title: "Team Member"
      }, "Date Added")
    ], -1));
    const _hoisted_8$5 = {
      key: 0,
      class: "slds-col slds-size_1-of-12",
      scope: "col"
    };
    const _hoisted_9$5 = ["id"];
    const _hoisted_10$5 = {
      "data-label": "User",
      scope: "row",
      class: "slds-col slds-size_4-of-12"
    };
    const _hoisted_11$4 = { class: "slds-col slds-grid slds-grid_vertical-align-center slds-p-right_small" };
    const _hoisted_12$4 = { class: "slds-grid slds-grid_vertical" };
    const _hoisted_13$4 = ["href"];
    const _hoisted_14$3 = ["data-label"];
    const _hoisted_15$2 = {
      "data-label": "Date Added",
      scope: "row",
      class: "slds-col slds-size_1-of-12"
    };
    const _hoisted_16$2 = {
      key: 0,
      "data-label": "Remove",
      class: "action-menu-cell slds-col slds-size_1-of-12"
    };
    const _hoisted_17$2 = { class: "slds-grid slds-grid_align-center" };
    const _hoisted_18$2 = ["id"];
    const _hoisted_19$2 = { key: 1 };
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_Button = resolveComponent("Button");
      const _component_Card = resolveComponent("Card");
      return openBlock(), createElementBlock("div", _hoisted_1$a, [
        $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        createVNode(_component_Card, { title: $options.title }, {
          icon: withCtx(() => [
            createVNode(_component_Icon, {
              category: "standard",
              name: "team_member"
            })
          ]),
          "header-content": withCtx(() => [
            createBaseVNode("div", _hoisted_2$9, [
              $options.canEdit ? (openBlock(), createElementBlock("button", {
                key: 0,
                id: "add-team-members",
                class: "slds-button slds-button_neutral",
                onClick: _cache[0] || (_cache[0] = ($event) => $options.openAddTeamMemberModal())
              }, "Add")) : createCommentVNode("", true)
            ])
          ]),
          body: withCtx(() => [
            $options.teamMembers.length ? (openBlock(), createElementBlock("table", _hoisted_3$9, [
              createBaseVNode("thead", null, [
                createBaseVNode("tr", _hoisted_4$6, [
                  _hoisted_5$6,
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$store.applicationNames, (name) => {
                    return openBlock(), createElementBlock("th", {
                      key: name,
                      class: "slds-col slds-size_3-of-12 slds-p-right_small",
                      scope: "col"
                    }, [
                      createBaseVNode("div", {
                        class: "slds-truncate",
                        title: name
                      }, toDisplayString(name), 9, _hoisted_6$5)
                    ]);
                  }), 128)),
                  _hoisted_7$5,
                  $options.canEdit ? (openBlock(), createElementBlock("th", _hoisted_8$5)) : createCommentVNode("", true)
                ])
              ]),
              createBaseVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($data.viewAll ? $options.teamMembers : $options.teamMembers.slice(0, 5), (user) => {
                  return openBlock(), createElementBlock("tr", {
                    id: `member-${user.name}`,
                    key: `member-${user.name}`
                  }, [
                    createBaseVNode("th", _hoisted_10$5, [
                      createBaseVNode("div", _hoisted_11$4, [
                        createBaseVNode("div", _hoisted_12$4, [
                          createBaseVNode("span", null, [
                            createBaseVNode("a", {
                              href: `/${user.userId}`,
                              target: "_blank"
                            }, toDisplayString(user.name), 9, _hoisted_13$4)
                          ])
                        ])
                      ])
                    ]),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$store.applicationNames, (name) => {
                      return openBlock(), createElementBlock("td", {
                        key: name,
                        "data-label": name,
                        scope: "row",
                        class: "slds-col slds-size_3-of-12"
                      }, [
                        user.applicationAccess[name] ? (openBlock(), createBlock(_component_Checkbox, {
                          key: 0,
                          modelValue: user.applicationAccess[name],
                          "onUpdate:modelValue": ($event) => user.applicationAccess[name] = $event,
                          hideLabel: "",
                          disabled: ""
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])) : createCommentVNode("", true)
                      ], 8, _hoisted_14$3);
                    }), 128)),
                    createBaseVNode("td", _hoisted_15$2, toDisplayString(_ctx.$F("DateTime", user.CreatedDate)), 1),
                    $options.canEdit ? (openBlock(), createElementBlock("td", _hoisted_16$2, [
                      createBaseVNode("div", _hoisted_17$2, [
                        createVNode(_component_ActionMenu, null, {
                          button: withCtx(() => [
                            createVNode(_component_ButtonIcon, {
                              iconCategory: "utility",
                              iconName: "down",
                              variant: "border-filled",
                              size: "x-small",
                              assistiveText: `View Actions`,
                              title: `View Actions`
                            })
                          ]),
                          default: withCtx(() => [
                            createVNode(_component_ActionMenuItem, {
                              label: "",
                              onClick: ($event) => $options.removeUser(user.id)
                            }, {
                              default: withCtx(() => [
                                createBaseVNode("span", {
                                  id: `remove-member-${user.id}`,
                                  class: "slds-text-color_destructive"
                                }, "Remove", 8, _hoisted_18$2)
                              ]),
                              _: 2
                            }, 1032, ["onClick"])
                          ]),
                          _: 2
                        }, 1024)
                      ])
                    ])) : createCommentVNode("", true)
                  ], 8, _hoisted_9$5);
                }), 128))
              ])
            ])) : (openBlock(), createElementBlock("div", _hoisted_19$2))
          ]),
          footer: withCtx(() => [
            $options.teamMembers.length > 5 ? (openBlock(), createBlock(_component_Button, {
              key: 0,
              id: "toggle-list-view",
              variant: "base",
              label: $data.viewAll ? "View Less" : "View All",
              onClick: $options.toggleView
            }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["title"])
      ]);
    }
    const PlanningTeam = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-9558ca67"]]);
    const _sfc_main$a = {
      name: "Details",
      components: {
        TerritoryPlans,
        QuotaPlans,
        PlanningTeam
      },
      props: ["segment"],
      data() {
        return {
          externalAssets: null
        };
      },
      async mounted() {
        SPM.Components.Details = this;
        this.externalAssets = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__AssetType__c, sfsp__AssetId__c FROM sfsp__SalesNodeExternalAsset__c WHERE sfsp__SalesNode__c = '${this.segment.Id}'`]);
      }
    };
    const _hoisted_1$9 = { class: "slds-card slds-p-around_small" };
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_TerritoryPlans = resolveComponent("TerritoryPlans");
      const _component_QuotaPlans = resolveComponent("QuotaPlans");
      const _component_PlanningTeam = resolveComponent("PlanningTeam");
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        $data.externalAssets ? (openBlock(), createBlock(_component_TerritoryPlans, {
          key: 0,
          segment: $props.segment
        }, null, 8, ["segment"])) : createCommentVNode("", true),
        $data.externalAssets ? (openBlock(), createBlock(_component_QuotaPlans, {
          key: 1,
          segment: $props.segment
        }, null, 8, ["segment"])) : createCommentVNode("", true),
        createVNode(_component_PlanningTeam)
      ]);
    }
    const Details = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
    const _sfc_main$9 = {
      name: "ActivityHistoryOptionsPopover",
      components: {
        Popover,
        RadioGroup,
        SLDSButton: Button
      },
      emits: ["apply", "close"],
      props: {
        history: Object,
        sort: String,
        kondo: Boolean
      },
      data() {
        return {
          filters: {
            history: {
              binding: this.$props.history || HistoryTypes.ALL,
              options: [
                {
                  label: "All events",
                  value: HistoryTypes.ALL
                },
                {
                  label: "Events I initiated",
                  value: HistoryTypes.OWN
                }
              ]
            },
            sort: {
              binding: this.$props.sort || SortTypes.OLDEST,
              options: [
                {
                  label: "Newest first",
                  value: SortTypes.NEWEST
                },
                {
                  label: "Oldest first",
                  value: SortTypes.OLDEST
                }
              ]
            }
          }
        };
      },
      methods: {
        applyFilters() {
          this.$emit(
            "apply",
            {
              history: this.filters.history.binding,
              sort: this.filters.sort.binding
            }
          );
        }
      }
    };
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_RadioGroup = resolveComponent("RadioGroup");
      const _component_SLDSButton = resolveComponent("SLDSButton");
      const _component_Popover = resolveComponent("Popover");
      return openBlock(), createBlock(Teleport, { to: "body" }, [
        createVNode(_component_Popover, {
          class: normalizeClass({ "spm-kondo": $props.kondo }),
          onClose: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close")),
          closeOnClickOutside: ""
        }, {
          content: withCtx(() => [
            createVNode(_component_RadioGroup, {
              modelValue: $data.filters.history.binding,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.filters.history.binding = $event),
              class: "slds-m-bottom_medium",
              labels: { name: "History events to show" },
              options: $data.filters.history.options
            }, null, 8, ["modelValue", "options"]),
            createVNode(_component_RadioGroup, {
              modelValue: $data.filters.sort.binding,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.filters.sort.binding = $event),
              labels: { name: "Sort by Created Date" },
              options: $data.filters.sort.options
            }, null, 8, ["modelValue", "options"])
          ]),
          footer: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(["slds-grid slds-grid_vertical-align-center", { "slds-grid_align-end": !$props.kondo }])
            }, [
              $props.kondo ? (openBlock(), createBlock(_component_SLDSButton, {
                key: 0,
                label: "Cancel",
                onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
              })) : createCommentVNode("", true),
              createVNode(_component_SLDSButton, {
                label: "Apply",
                variant: "brand",
                onClick: $options.applyFilters
              }, null, 8, ["onClick"])
            ], 2)
          ]),
          _: 1
        }, 8, ["class"])
      ]);
    }
    const ActivityHistoryOptionsPopover = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
    function toDate(argument) {
      const argStr = Object.prototype.toString.call(argument);
      if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
        return new argument.constructor(+argument);
      } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
        return new Date(argument);
      } else {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    const millisecondsInMinute = 6e4;
    const millisecondsInHour = 36e5;
    function differenceInMilliseconds(dateLeft, dateRight) {
      return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
    }
    function getRoundingMethod(method) {
      return method ? Math[method] : Math.trunc;
    }
    function differenceInHours(dateLeft, dateRight, options) {
      const diff2 = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInHour;
      return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff2);
    }
    function differenceInMinutes(dateLeft, dateRight, options) {
      const diff2 = differenceInMilliseconds(dateLeft, dateRight) / millisecondsInMinute;
      return getRoundingMethod(options == null ? void 0 : options.roundingMethod)(diff2);
    }
    const EmptyStateSVG = "/resource/1730930710198/sfsp__SegmentDetails/dist/empty-state-events.svg";
    const _sfc_main$8 = {
      name: "ActivityHistory",
      components: {
        ButtonIcon,
        Icon,
        Layout,
        LayoutItem,
        Spinner,
        Tooltip
      },
      props: {
        embedLinks: Boolean,
        history: String,
        parentId: String,
        nodeId: String,
        segments: {
          type: Array,
          default: () => []
        },
        segmentsOnly: Boolean,
        sort: String,
        userId: String
      },
      data() {
        return {
          activities: [],
          initialized: false,
          loading: false,
          queryMore: null,
          tooltipSource: null,
          tooltipText: "",
          EmptyStateSVG
        };
      },
      watch: {
        $props: {
          async handler() {
            this.init();
          },
          deep: true,
          immediate: true
        }
      },
      created() {
        this.$mitt.on("refresh-activity-history", this.init);
      },
      mounted() {
        SPM.Components.ActivityHistory = this;
        window.addEventListener("resize", this.onScroll);
      },
      computed: {
        empty() {
          return this.activities.length === 0;
        }
      },
      unmounted() {
        window.removeEventListener("resize", this.onScroll);
        this.$mitt.off("refresh-activity-history", this.init);
      },
      methods: {
        async init() {
          this.activities = [];
          this.queryMore = getActivities.bind(null, this.$props);
          await this.loadActivities();
          if (!this.initialized) {
            this.initialized = true;
            this.$emit("initialized");
          }
        },
        async loadActivities() {
          this.loading = true;
          const { activities, queryMore } = await this.queryMore();
          this.activities.push(
            ...activities.map((activity) => ({
              ...activity,
              ...{
                date: {
                  sinceActivityString: this.transformDate(activity.CreatedDate),
                  // e.g.  March 1, 2023 at 11:40 AM
                  localeString: this.$F("DateTime", new Date(activity.CreatedDate), {
                    month: "long",
                    day: "numeric",
                    year: "numeric",
                    hour: "numeric",
                    minute: "numeric"
                  })
                },
                showDescription: false
              }
            }))
          );
          this.queryMore = queryMore;
          this.loading = false;
          await this.$nextTick(this.onScroll);
        },
        onMouseOverTooltip(text, e) {
          this.tooltipText = text;
          this.tooltipSource = e.target;
        },
        transformDate(epoch) {
          const today = /* @__PURE__ */ new Date();
          const activity = new Date(epoch);
          const minuteDiff = differenceInMinutes(today, activity);
          if (minuteDiff === 0) {
            return "Just Now";
          }
          if (minuteDiff < 60) {
            return `${minuteDiff}m ago`;
          }
          const hourDiff = differenceInHours(today, activity);
          if (hourDiff >= 24) {
            return this.$F("DateTime", activity, { month: "long", day: "numeric", year: "numeric" });
          }
          return `${hourDiff}h ago`;
        },
        async onScroll() {
          if (this.loading || !this.queryMore)
            return;
          const { scrollTop, scrollHeight, clientHeight } = this.$refs.activityHistory ?? {};
          if (scrollTop + clientHeight >= scrollHeight - 5) {
            await this.loadActivities();
            this.$refs.activityHistory.scrollTop = scrollTop;
          }
        },
        async toggleDescription(activity) {
          activity.showDescription = !activity.showDescription;
          await this.$nextTick(this.onScroll);
        },
        getSanitizedDescription(activity) {
          return SPM.Utils.Str.sanitizeHTML(activity.sfsp__Description__c);
        }
      }
    };
    const _withScopeId$5 = (n) => (pushScopeId("data-v-c8156a5b"), n = n(), popScopeId(), n);
    const _hoisted_1$8 = ["src"];
    const _hoisted_2$8 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-heading_medium" }, "No Past History", -1));
    const _hoisted_3$8 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-title" }, "Sales Planning events will show up here.", -1));
    const _hoisted_4$5 = {
      key: 2,
      class: "spm-timeline"
    };
    const _hoisted_5$5 = { class: "spm-timeline__item slds-m-bottom_x-small" };
    const _hoisted_6$4 = { class: "slds-assistive-text" };
    const _hoisted_7$4 = { class: "slds-media" };
    const _hoisted_8$4 = { class: "slds-media__figure" };
    const _hoisted_9$4 = ["src"];
    const _hoisted_10$4 = { class: "slds-media__body" };
    const _hoisted_11$3 = { class: "slds-grid slds-grid_align-spread" };
    const _hoisted_12$3 = {
      class: "slds-col",
      style: { "max-width": "70%" }
    };
    const _hoisted_13$3 = ["title"];
    const _hoisted_14$2 = { class: "slds-text-align_right" };
    const _hoisted_15$1 = ["onMouseover"];
    const _hoisted_16$1 = {
      class: "spm-timeline__data",
      style: { "line-height": "1.5rem" }
    };
    const _hoisted_17$1 = ["href"];
    const _hoisted_18$1 = { key: 0 };
    const _hoisted_19$1 = ["onClick"];
    const _hoisted_20$1 = ["innerHTML"];
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Layout = resolveComponent("Layout");
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: "activity-history-root",
        id: "activityHistory",
        ref: "activityHistory",
        onScroll: _cache[0] || (_cache[0] = (...args) => $options.onScroll && $options.onScroll(...args))
      }, [
        $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        $options.empty ? (openBlock(), createBlock(_component_Layout, {
          key: 1,
          class: "slds-m-vertical_large",
          horizontalAlign: "center",
          verticalAlign: "center",
          vertical: "",
          style: { "min-height": "400px" }
        }, {
          default: withCtx(() => [
            createBaseVNode("img", {
              class: "slds-m-bottom_xx-large",
              src: $data.EmptyStateSVG
            }, null, 8, _hoisted_1$8),
            _hoisted_2$8,
            _hoisted_3$8
          ]),
          _: 1
        })) : (openBlock(), createElementBlock("ul", _hoisted_4$5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.activities, (activity) => {
            return openBlock(), createElementBlock("li", {
              key: activity.Id
            }, [
              createBaseVNode("div", _hoisted_5$5, [
                createBaseVNode("span", _hoisted_6$4, toDisplayString(activity.Name), 1),
                createBaseVNode("div", _hoisted_7$4, [
                  createBaseVNode("div", _hoisted_8$4, [
                    createBaseVNode("img", {
                      class: "spm-timeline__img",
                      src: activity.CreatedBy.SmallPhotoUrl
                    }, null, 8, _hoisted_9$4)
                  ]),
                  createBaseVNode("div", _hoisted_10$4, [
                    createBaseVNode("div", _hoisted_11$3, [
                      createBaseVNode("div", _hoisted_12$3, [
                        createBaseVNode("h3", {
                          class: "slds-truncate",
                          title: activity.Name,
                          style: { "line-height": "1.15rem" }
                        }, [
                          (openBlock(), createBlock(resolveDynamicComponent(activity.nameVNode)))
                        ], 8, _hoisted_13$3)
                      ]),
                      createBaseVNode("div", _hoisted_14$2, [
                        createBaseVNode("p", {
                          class: "spm-timeline__data",
                          onMouseover: ($event) => $options.onMouseOverTooltip(activity.date.localeString, $event)
                        }, toDisplayString(activity.date.sinceActivityString), 41, _hoisted_15$1)
                      ])
                    ]),
                    createBaseVNode("div", _hoisted_16$1, [
                      createBaseVNode("a", {
                        href: `/${activity.CreatedById}`,
                        style: { "color": "currentColor" }
                      }, toDisplayString(activity.CreatedBy.Name), 9, _hoisted_17$1),
                      activity.sfsp__Description__c ? (openBlock(), createElementBlock("span", _hoisted_18$1, [
                        createTextVNode("  |  "),
                        createBaseVNode("span", {
                          class: "slds-text-link_faux",
                          style: { "user-select": "none" },
                          onClick: ($event) => $options.toggleDescription(activity)
                        }, toDisplayString(activity.showDescription ? "Hide" : "Show") + " Description ", 9, _hoisted_19$1)
                      ])) : createCommentVNode("", true)
                    ]),
                    withDirectives(createBaseVNode("div", {
                      innerHTML: $options.getSanitizedDescription(activity),
                      class: "spm-timeline__description slds-m-top_small",
                      style: { "word-wrap": "break-word" }
                    }, null, 8, _hoisted_20$1), [
                      [vShow, activity.showDescription]
                    ])
                  ])
                ])
              ])
            ]);
          }), 128))
        ])),
        $data.tooltipSource && $data.tooltipText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 3,
          source: $data.tooltipSource,
          text: $data.tooltipText
        }, null, 8, ["source", "text"])) : createCommentVNode("", true)
      ], 544);
    }
    const ActivityHistory = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-c8156a5b"]]);
    const _sfc_main$7 = {
      name: "History",
      components: {
        ButtonIcon,
        ActivityHistory,
        ActivityHistoryOptionsPopover
      },
      props: ["segment"],
      data() {
        return {
          isActivityHistoryEmpty: false,
          renderFilterPopover: false,
          history: HistoryTypes.ALL,
          sort: SortTypes.NEWEST
        };
      },
      async mounted() {
        SPM.Components.History = this;
      },
      methods: {
        applyFilters({ history, sort }) {
          this.renderFilterPopover = false;
          this.history = history;
          this.sort = sort;
        },
        onInitialized() {
          this.isActivityHistoryEmpty = this.$refs.activityHistory.empty;
        }
      }
    };
    const _hoisted_1$7 = { class: "slds-card slds-p-around_small" };
    const _hoisted_2$7 = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode("div", { style: { "font-weight": "700" } }, "History", -1);
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_ActivityHistory = resolveComponent("ActivityHistory");
      const _component_ActivityHistoryOptionsPopover = resolveComponent("ActivityHistoryOptionsPopover");
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        createBaseVNode("div", _hoisted_2$7, [
          _hoisted_3$7,
          createVNode(_component_ButtonIcon, {
            class: "slds-col_bump-left",
            assistiveText: "Filter",
            disabled: $data.isActivityHistoryEmpty,
            iconCategory: "utility",
            iconName: "settings",
            size: "x-small",
            title: "Filter",
            variant: "border-filled",
            onClick: _cache[0] || (_cache[0] = ($event) => $data.renderFilterPopover = true)
          }, null, 8, ["disabled"])
        ]),
        createVNode(_component_ActivityHistory, {
          ref: "activityHistory",
          sort: $data.sort,
          segmentsOnly: "",
          segments: [$props.segment],
          class: "slds-m-top_small",
          onInitialized: $options.onInitialized
        }, null, 8, ["sort", "segments", "onInitialized"]),
        $data.renderFilterPopover ? (openBlock(), createBlock(_component_ActivityHistoryOptionsPopover, {
          key: 0,
          history: $data.history,
          sort: $data.sort,
          onApply: $options.applyFilters,
          onClose: _cache[1] || (_cache[1] = ($event) => $data.renderFilterPopover = false)
        }, null, 8, ["history", "sort", "onApply"])) : createCommentVNode("", true)
      ]);
    }
    const History = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
    const _sfc_main$6 = {
      name: "AddTeamMember",
      components: {
        Spinner,
        Picklist,
        Card,
        ButtonIcon,
        Checkbox
      },
      props: ["addedUsers"],
      emits: ["add-user", "remove-user"],
      data() {
        return {
          loading: true,
          selectedUser: null,
          availableUserIds: /* @__PURE__ */ new Set(),
          userOptions: [{
            options: async (term) => {
              term = term.replace(/'/g, "\\'");
              const matchingUsers = await SPM.Utils.Rest.invoke("Query", {
                query: `
                            SELECT Id, Name, FirstName, LastName, UserRole.Name
                            FROM User
                            WHERE Name LIKE '%${term}%'
                            AND Id IN ('${[...this.availableUserIds].join("','")}')
                            LIMIT 10
                        `
              });
              return matchingUsers.filter((user) => {
                var _a;
                return !this.$store.userAccessRecords.find((u) => u.sfsp__User__c === user.Id) && !this.addedUsers.find((u) => u.id === user.Id) && !((_a = SPM.Components.UsersList) == null ? void 0 : _a.planUsers.find((u) => u.sfsp__User__c === user.Id));
              });
            }
          }]
        };
      },
      watch: {
        selectedUser: {
          handler() {
            if (this.selectedUser) {
              this.$emit("add-user", this.selectedUser);
              this.selectedUser = null;
            }
          }
        }
      },
      async mounted() {
        await this.init();
        this.loading = false;
      },
      methods: {
        async init() {
          const availableUserIds = /* @__PURE__ */ new Set();
          await Promise.allSettled([
            availableUserIds.add(...(await SPM.Utils.Apex.invoke("GetUsersWithPermissionSet", ["SalesPlanning"]) || []).map((u) => u.Id)),
            availableUserIds.add(...(await SPM.Utils.Apex.invoke("GetUsersWithPermissionSet", ["SalesPlanningOpsManager"]) || []).map((u) => u.Id)),
            availableUserIds.add(...(await SPM.Utils.Apex.invoke("GetUsersWithPermissionSet", ["SalesPlanningAdmin"]) || []).map((u) => u.Id))
          ]);
          this.availableUserIds = availableUserIds;
        }
      }
    };
    const _withScopeId$4 = (n) => (pushScopeId("data-v-15d7d0ce"), n = n(), popScopeId(), n);
    const _hoisted_1$6 = { class: "slds-col slds-size_6-of-12 slds-p-right_small" };
    const _hoisted_2$6 = {
      class: "slds-media slds-listbox__option slds-listbox__option_plain",
      role: "option"
    };
    const _hoisted_3$6 = { class: "slds-media__body" };
    const _hoisted_4$4 = ["title"];
    const _hoisted_5$4 = {
      id: "added-users",
      class: "slds-table slds-table_bordered slds-no-row-hover slds-table_col-bordered"
    };
    const _hoisted_6$3 = { class: "slds-line-height_reset" };
    const _hoisted_7$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", {
      class: "slds-truncate",
      title: "User"
    }, "User", -1));
    const _hoisted_8$3 = [
      _hoisted_7$3
    ];
    const _hoisted_9$3 = ["title"];
    const _hoisted_10$3 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("th", {
      class: "slds-col slds-size_1-of-12",
      scope: "col"
    }, null, -1));
    const _hoisted_11$2 = ["id"];
    const _hoisted_12$2 = { class: "slds-col slds-grid slds-grid_vertical-align-center slds-p-right_small" };
    const _hoisted_13$2 = { class: "slds-grid slds-grid_vertical" };
    const _hoisted_14$1 = {
      "data-label": "Remove",
      class: "slds-col slds-size_1-of-12"
    };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Card = resolveComponent("Card");
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("div", _hoisted_1$6, [
          createVNode(_component_Picklist, {
            modelValue: (_a = $data.selectedUser) == null ? void 0 : _a.Name,
            id: "userLookup",
            ref: "userLookup",
            options: $data.userOptions,
            labelForId: "userLookup",
            labels: { name: "Users", search: "Add user..." },
            titleKey: "Name",
            idKey: "Id",
            filterable: "",
            onSelectedOption: _cache[0] || (_cache[0] = (user) => $data.selectedUser = user),
            onClear: _cache[1] || (_cache[1] = () => $data.selectedUser = null)
          }, {
            option: withCtx((item) => [
              createBaseVNode("div", _hoisted_2$6, [
                createBaseVNode("span", _hoisted_3$6, [
                  createBaseVNode("span", {
                    class: "slds-truncate",
                    title: item.option.Name
                  }, toDisplayString(item.option.Name), 9, _hoisted_4$4)
                ])
              ])
            ]),
            _: 1
          }, 8, ["modelValue", "options", "labels"])
        ]),
        createVNode(_component_Card, { class: "slds-m-top_medium" }, {
          body: withCtx(() => [
            createBaseVNode("table", _hoisted_5$4, [
              createBaseVNode("thead", null, [
                createBaseVNode("tr", _hoisted_6$3, [
                  createBaseVNode("th", {
                    class: normalizeClass(["slds-col slds-p-right_small", { "slds-size_11-of-12": !_ctx.$store.applicationNames, "slds-size_5-of-12": _ctx.$store.applicationNames }]),
                    scope: "col"
                  }, _hoisted_8$3, 2),
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$store.applicationNames, (name) => {
                    return openBlock(), createElementBlock("th", {
                      key: name,
                      class: "slds-col slds-size_3-of-12 slds-p-right_small",
                      scope: "col"
                    }, [
                      createBaseVNode("div", {
                        class: "slds-truncate",
                        title: name
                      }, toDisplayString(name), 9, _hoisted_9$3)
                    ]);
                  }), 128)),
                  _hoisted_10$3
                ])
              ]),
              createBaseVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.addedUsers, (user) => {
                  return openBlock(), createElementBlock("tr", {
                    id: `addMember-${user.name}`,
                    key: `addMember-${user.name}`
                  }, [
                    createBaseVNode("th", {
                      "data-label": "User",
                      scope: "row",
                      class: normalizeClass(["slds-col slds-size_5-of-12", { "slds-size_11-of-12": !_ctx.$store.applicationNames, "slds-size_5-of-12": _ctx.$store.applicationNames }])
                    }, [
                      createBaseVNode("div", _hoisted_12$2, [
                        createBaseVNode("div", _hoisted_13$2, [
                          createBaseVNode("span", null, toDisplayString(user.name), 1)
                        ])
                      ])
                    ], 2),
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$store.applicationNames, (name) => {
                      return openBlock(), createElementBlock("td", {
                        key: name,
                        class: "slds-col slds-size_3-of-12"
                      }, [
                        createVNode(_component_Checkbox, {
                          modelValue: user.applicationAccess[name],
                          "onUpdate:modelValue": ($event) => user.applicationAccess[name] = $event,
                          hideLabel: ""
                        }, null, 8, ["modelValue", "onUpdate:modelValue"])
                      ]);
                    }), 128)),
                    createBaseVNode("td", _hoisted_14$1, [
                      createVNode(_component_ButtonIcon, {
                        id: `addMember-${user.name}-remove`,
                        class: "slds-button_icon-container",
                        assistiveText: "Remove",
                        iconCategory: "utility",
                        iconName: "delete",
                        variant: "border",
                        title: "Remove",
                        disabled: !$props.addedUsers.length,
                        onClick: ($event) => _ctx.$emit("remove-user", user.id)
                      }, null, 8, ["id", "disabled", "onClick"])
                    ])
                  ], 8, _hoisted_11$2);
                }), 128))
              ])
            ])
          ]),
          _: 1
        })
      ]);
    }
    const AddTeamMember = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-15d7d0ce"]]);
    const userUtils = {
      async saveUsers(addedUsers, segment) {
        const accessRecordsToInsert = /* @__PURE__ */ new Set();
        addedUsers.forEach((user) => {
          accessRecordsToInsert.add({
            sobjectType: "sfsp__SalesUserAccess__c",
            sfsp__SalesNode__c: segment.Id,
            sfsp__User__c: user.id,
            sfsp__ApplicationAccess__c: Object.entries(user.applicationAccess).filter(([key, value]) => value).map(([key, _]) => key).join(";")
          });
        });
        await SPM.Utils.CRM.upsert({ records: accessRecordsToInsert });
        await SPM.Utils.Async.forEachParallel(Array.from(accessRecordsToInsert), async (r) => {
          if (!SPM.chatterEnabled)
            return;
          const accessMsg = r.sfsp__ApplicationAccess__c ? ` with access to ${r.sfsp__ApplicationAccess__c.replace(";", ", ")}` : "";
          const comment = `{${r.sfsp__User__c}} ${SPM.currentUser.Name} added you to <a href="${SPM.orgDomainUrl}/one/one.app#/alohaRedirect/apex/sfsp__SegmentDetails?segmentId=${r.sfsp__SalesNode__c}">${SPM.Utils.Str.htmlEncode(segment.Name)}</a>${accessMsg}.`;
          await SPM.Utils.Apex.invoke("PostFeedItem", [SPM.currentUser.Id, comment]);
        }, 5);
        const activityRecords = [];
        for (const user of addedUsers) {
          const accessRecord = Array.from(accessRecordsToInsert).find((r) => r.sfsp__User__c === user.id);
          activityRecords.push({
            description: accessRecord.sfsp__ApplicationAccess__c ? `Granted access to ${accessRecord.sfsp__ApplicationAccess__c.replace(";", ", ")}.` : "",
            name: user.name,
            nodeId: segment.Id,
            parentId: segment.sfsp__SalesPlan__c,
            recordType: ActivityRecordTypes.SCENARIO,
            subtype: ActivitySubtypes.ADD,
            type: ActivityTypes.SHARING
          });
          const pendoPayload = {
            segmentId: segment.Id
          };
          Object.keys(user.applicationAccess).forEach((a) => pendoPayload[a.replace(/\s/g, "")] = user.applicationAccess[a]);
          SPM.$store.trackPendoEvent({ actionType: "SP | Segmentation - Add team member", pendoPayload });
        }
        await insertActivities(activityRecords);
        return { accessRecordsToInsert, activityRecords };
      }
    };
    const stampUtils = {
      async runPostActions(segment, numRecordsActivityLog, numRecords, numFields, stampedBefore) {
        const activityRecords = [];
        activityRecords.push({
          name: `Stamped ${segment.Name}.`,
          description: `Captured ${numRecordsActivityLog} records in the stamped segment.`,
          nodeId: segment.Id,
          parentId: segment.sfsp__SalesPlan__c,
          type: "Record Stamp",
          subtype: ActivitySubtypes.CREATE
        });
        await insertActivities(activityRecords);
        const pendoPayload = {
          segmentId: segment.Id,
          planId: segment.sfsp__SalesPlan__c,
          nRecords: numRecords,
          nFields: numFields,
          update: stampedBefore
        };
        SPM.$store.trackPendoEvent({ actionType: "SP | Segmentation - Stamp segment", pendoPayload });
      }
    };
    const territoryStampUtils = {
      async deleteTerritoryStamp(store2) {
        var _a;
        const territoryStampRecordstoDelete = await SPM.Utils.Apex.invoke("Query", [`
            SELECT
                Id
            FROM sfsp__SalesNode__c
            WHERE sfsp__Segment__c = '${store2.segment.Id}'
        `]);
        if (territoryStampRecordstoDelete.length > 0) {
          territoryStampRecordstoDelete.forEach((r) => {
            r.sfsp__Segment__c = "";
            r.sfsp__Parent__c = "";
            r.sfsp__SalesPlan__c = "";
            r.sfsp__SalesPlanNode__c = "";
          });
          await SPM.Utils.CRM.upsert({ records: territoryStampRecordstoDelete });
        }
        let nonTerritoryFields = [];
        const segment = (_a = await SPM.Utils.Apex.invoke(
          "Query",
          [`
                SELECT
                    Id,
                    Name,
                    sfsp__ReferenceFields__c
                FROM sfsp__SalesNode__c
                WHERE Id = '${store2.segment.Id}'
            `]
        )) == null ? void 0 : _a[0];
        if (segment && segment.sfsp__ReferenceFields__c) {
          const refFields = JSON.parse(segment.sfsp__ReferenceFields__c);
          nonTerritoryFields = refFields == null ? void 0 : refFields.filter((f) => f.type !== "Territory" && f.type !== "Territory Stamp");
          const segmentNode = {
            sobjectType: "sfsp__SalesNode__c",
            Id: store2.segment.Id,
            sfsp__ReferenceFields__c: nonTerritoryFields.length ? JSON.stringify(nonTerritoryFields) : ""
          };
          await SPM.Utils.CRM.upsert({ records: [].concat(segmentNode) });
        }
        return nonTerritoryFields;
      }
    };
    const _sfc_main$5 = {
      name: "AddTeamMembersModal",
      components: {
        Spinner,
        Button,
        Modal,
        ScopedNotification,
        AddTeamMember
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loading: false,
          addedUsers: []
        };
      },
      methods: {
        addUser(user) {
          if (!user.Id)
            return;
          const newUser = {
            id: user.Id,
            name: user.Name,
            applicationAccess: {
              "Territory Planning": true,
              "Quota Planning": true
            }
          };
          this.addedUsers.unshift(newUser);
        },
        removeUser(userId) {
          this.addedUsers.splice(this.addedUsers.findIndex((user) => user.id === userId), 1);
        },
        async saveUsers() {
          this.loading = true;
          await userUtils.saveUsers(this.addedUsers, this.$store.segment);
          const toastMsg = this.addedUsers.length === 1 ? `${this.addedUsers[0].name} was added.` : `${this.addedUsers.length} team members were added.`;
          this.config.callback(toastMsg);
          this.$emit("close");
          this.loading = false;
        }
      }
    };
    const _hoisted_1$5 = /* @__PURE__ */ createBaseVNode("p", null, "Encourage others to participate in the planning process.", -1);
    const _hoisted_2$5 = { class: "slds-grid" };
    const _hoisted_3$5 = { class: "slds-col_bump-left" };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_AddTeamMember = resolveComponent("AddTeamMember");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        id: "add-team-members-modal",
        ref: "modal",
        size: "base",
        title: "Add team members",
        onClose: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          _hoisted_1$5,
          createVNode(_component_AddTeamMember, {
            addedUsers: $data.addedUsers,
            onAddUser: $options.addUser,
            onRemoveUser: $options.removeUser
          }, null, 8, ["addedUsers", "onAddUser", "onRemoveUser"]),
          $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true)
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_2$5, [
            createBaseVNode("div", _hoisted_3$5, [
              createVNode(_component_Button, {
                class: "slds-button",
                disabled: $data.loading,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, {
                default: withCtx(() => [
                  createTextVNode(" Cancel ")
                ]),
                _: 1
              }, 8, ["disabled"]),
              createVNode(_component_Button, {
                class: "slds-button",
                disabled: $data.loading || !$data.addedUsers.length,
                variant: "brand",
                onClick: $options.saveUsers
              }, {
                default: withCtx(() => [
                  createTextVNode(" Add ")
                ]),
                _: 1
              }, 8, ["disabled", "onClick"])
            ])
          ])
        ]),
        _: 1
      }, 512);
    }
    const AddTeamMembersModal = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      name: "DeleteTerritoryStampModal",
      components: {
        Spinner,
        Button,
        Modal
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          deleting: false
        };
      },
      methods: {
        async deleteStamp() {
          this.deleting = true;
          try {
            await territoryStampUtils.deleteTerritoryStamp(this.$store);
            const activityRecords = [];
            activityRecords.push({
              name: `Deleted territory stamp ${this.config.alignmentName}`,
              nodeId: this.$store.segment.Id,
              parentId: this.$store.segment.sfsp__SalesPlan__c,
              subtype: ActivitySubtypes.DELETE,
              type: "Territory Stamp"
            });
            await insertActivities(activityRecords);
            const pendoPayload = {
              segmentId: this.$store.segment.Id,
              planId: this.$store.segment.sfsp__SalesPlan__r.Id
            };
            SPM.$store.trackPendoEvent({ actionType: "SP | Segmentation - Delete Stamped Territories", pendoPayload });
            SPM.$store.toast({ state: "success", message: "Delete Territory Stamp succeeded.", duration: 5e3 });
          } catch (error) {
            SPM.$store.toast({ state: "error", message: "Delete Territory Stamp failed." });
          } finally {
            this.config.callback();
            this.$emit("close");
          }
        },
        cancel() {
          this.$emit("close");
        }
      }
    };
    const _withScopeId$3 = (n) => (pushScopeId("data-v-99bfc963"), n = n(), popScopeId(), n);
    const _hoisted_1$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-p-vertical_large" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "delete-stamp-msg slds-size_5-of-8 slds-align_absolute-center slds-text-align_center" }, " This will delete all stamped territory data, making it unavailable to planners. ")
    ], -1));
    const _hoisted_2$4 = { class: "slds-grid" };
    const _hoisted_3$4 = { class: "slds-col_bump-left" };
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        id: "delete-territory-stamp-modal",
        ref: "modal",
        size: "base",
        title: "Delete Territory Stamp",
        onClose: $options.cancel
      }, {
        content: withCtx(() => [
          _hoisted_1$4,
          $data.deleting ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true)
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_2$4, [
            createBaseVNode("div", _hoisted_3$4, [
              createVNode(_component_Button, {
                class: "slds-button",
                onClick: $options.cancel
              }, {
                default: withCtx(() => [
                  createTextVNode(" Cancel ")
                ]),
                _: 1
              }, 8, ["onClick"]),
              createVNode(_component_Button, {
                class: "slds-button",
                variant: "brand",
                onClick: $options.deleteStamp
              }, {
                default: withCtx(() => [
                  createTextVNode(" Delete ")
                ]),
                _: 1
              }, 8, ["onClick"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["onClose"]);
    }
    const DeleteTerritoryStampModal = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-99bfc963"]]);
    const _sfc_main$3 = {
      name: "StampModal",
      components: {
        Spinner,
        Button,
        Modal,
        Icon
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loading: false,
          addedUsers: [],
          stampStep: 1
        };
      },
      computed: {
        alreadyStamped() {
          return this.$store.segment.sfsp__StampDataSourceId__c !== null && this.$store.segment.sfsp__StampDataSourceId__c !== void 0;
        },
        recordDiff() {
          return SPM.Components.Overview.recordCount - SPM.Components.Overview.stampedCount;
        },
        recordCount() {
          return SPM.Components.Overview.recordCount;
        },
        stampedCount() {
          return SPM.Components.Overview.stampedCount;
        }
      },
      methods: {
        addUser(user) {
          if (!user.Id)
            return;
          const newUser = {
            id: user.Id,
            name: user.Name,
            applicationAccess: {
              "Territory Planning": true
            }
          };
          this.addedUsers.unshift(newUser);
        },
        removeUser(userId) {
          this.addedUsers.splice(this.addedUsers.findIndex((user) => user.id === userId), 1);
        },
        async finish() {
          this.stampStep = 2;
          this.loading = true;
          const stampedBefore = !!SPM.Components.Overview.segment.sfsp__StampDataSourceId__c;
          let recordsCount = 0;
          let fieldsCount = 0;
          try {
            const { jobId, datasetLabel, numRecords, numFields } = await SPM.Utils.Segment.ExternalData.stampDataSource({
              segmentId: SPM.Components.Overview.segment.Id,
              dataSource: this.$store.dataSource,
              planName: SPM.Components.Overview.segment.sfsp__SalesPlan__r.Name,
              planId: SPM.Components.Overview.segment.sfsp__SalesPlan__r.Id,
              segmentName: SPM.Components.Overview.segment.Name
            });
            await SPM.Utils.Segment.ExternalData.fetchStampJobResults(jobId, SPM.Components.Overview.segment.sfsp__StampDataSourceId__c, datasetLabel, SPM.Components.Overview.segment.Id);
            recordsCount = numRecords;
            fieldsCount = numFields;
          } catch (err) {
            const toastMessage = !SPM.hasDataPipelinesAccess ? "To stamp your segment, ask your Salesforce admin to assign you permissions to create datasets, or to stamp the segment for you." : `Stamping record assignments failed. ${err.error.message}`;
            SPM.$store.toast({ state: "error", message: `${toastMessage}`, duration: null });
            SPM.Utils.Splunk.sendLog({
              logName: "spmStampingJob",
              logPayload: {
                planId: SPM.Components.Overview.segment.sfsp__SalesPlan__r.Id,
                segmentId: SPM.Components.Overview.segment.Id,
                error: err,
                status: "FAILURE"
              }
            });
            return;
          }
          SPM.$store.toast({ state: "success", message: "Stamping record assignments succeeded.", duration: 5e3 });
          stampUtils.runPostActions(SPM.Components.Overview.segment, this.$F("Numeric", recordsCount), recordsCount, fieldsCount, stampedBefore);
          await this.$store.getSegmentRecord(SPM.Components.Overview.segment.Id);
          await SPM.Components.Overview.getDataSetCount();
          this.$mitt.emit("refresh-activity-history");
          this.loading = false;
          this.$emit("close");
        },
        cancel() {
          this.$emit("close");
        }
      }
    };
    const _withScopeId$2 = (n) => (pushScopeId("data-v-efa80d8a"), n = n(), popScopeId(), n);
    const _hoisted_1$3 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-align_absolute-center" }, "Existing stamp data will be overwritten.", -1));
    const _hoisted_2$3 = {
      key: 0,
      class: "slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-p-around--large slds-text-align--center"
    };
    const _hoisted_3$3 = { class: "slds-m-top_medium" };
    const _hoisted_4$3 = { class: "slds-text-title_bold" };
    const _hoisted_5$3 = { key: 0 };
    const _hoisted_6$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-m-top_medium" }, "Stamping will create a static copy of currently assigned records to give you a consistent baseline for planning. You can update this stamp at a later time.", -1));
    const _hoisted_7$2 = {
      key: 1,
      class: "slds-grid"
    };
    const _hoisted_8$2 = {
      class: "slds-grid slds-col slds-grid_vertical-align-center",
      style: { "height": "300px" }
    };
    const _hoisted_9$2 = { class: "slds-grid" };
    const _hoisted_10$2 = { class: "slds-col_bump-left" };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        id: "stamp-modal",
        ref: "modal",
        size: "base",
        title: "Stamp Records",
        footless: $data.loading,
        hideCloseButton: $data.loading,
        onClose: $options.cancel
      }, createSlots({
        tagline: withCtx(() => [
          _hoisted_1$3
        ]),
        content: withCtx(() => [
          $data.stampStep === 1 ? (openBlock(), createElementBlock("div", _hoisted_2$3, [
            createVNode(_component_Icon, {
              category: "utility",
              name: "approval",
              size: "large"
            }),
            createBaseVNode("div", _hoisted_3$3, [
              createBaseVNode("span", _hoisted_4$3, toDisplayString(_ctx.$F("Compact", $options.stampedCount)), 1),
              createVNode(_component_Icon, {
                category: "utility",
                name: "forward",
                size: "xx-small",
                class: "slds-p-left_xx-small slds-p-right_xx-small"
              }),
              createBaseVNode("span", null, toDisplayString(_ctx.$F("Compact", $options.recordCount)), 1),
              createTextVNode(" ("),
              $options.recordDiff > 0 ? (openBlock(), createElementBlock("span", _hoisted_5$3, "+")) : createCommentVNode("", true),
              createTextVNode(toDisplayString(_ctx.$F("Compact", $options.recordDiff)) + ") ", 1)
            ]),
            _hoisted_6$2
          ])) : (openBlock(), createElementBlock("div", _hoisted_7$2, [
            createBaseVNode("div", _hoisted_8$2, [
              $data.loading ? (openBlock(), createBlock(_component_Spinner, {
                key: 0,
                theme: "brand"
              }, {
                description: withCtx(() => [
                  createTextVNode("Preparing to stamp records...")
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ])
          ]))
        ]),
        _: 2
      }, [
        $data.stampStep === 1 ? {
          name: "footer",
          fn: withCtx(() => [
            createBaseVNode("div", _hoisted_9$2, [
              createBaseVNode("div", _hoisted_10$2, [
                createVNode(_component_Button, {
                  class: "slds-button",
                  disabled: $data.loading,
                  onClick: $options.cancel
                }, {
                  default: withCtx(() => [
                    createTextVNode(" Cancel ")
                  ]),
                  _: 1
                }, 8, ["disabled", "onClick"]),
                createVNode(_component_Button, {
                  class: "slds-button",
                  disabled: $data.loading,
                  variant: "brand",
                  onClick: $options.finish
                }, {
                  default: withCtx(() => [
                    createTextVNode(" Stamp ")
                  ]),
                  _: 1
                }, 8, ["disabled", "onClick"])
              ])
            ])
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["footless", "hideCloseButton", "onClose"]);
    }
    const StampModal = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-efa80d8a"]]);
    /*!
     * vuex v4.0.2
     * (c) 2021 Evan You
     * @license MIT
     */
    var storeKey = "store";
    function forEachValue(obj, fn) {
      Object.keys(obj).forEach(function(key) {
        return fn(obj[key], key);
      });
    }
    function isObject(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isPromise(val) {
      return val && typeof val.then === "function";
    }
    function partial(fn, arg) {
      return function() {
        return fn(arg);
      };
    }
    function genericSubscribe(fn, subs, options) {
      if (subs.indexOf(fn) < 0) {
        options && options.prepend ? subs.unshift(fn) : subs.push(fn);
      }
      return function() {
        var i2 = subs.indexOf(fn);
        if (i2 > -1) {
          subs.splice(i2, 1);
        }
      };
    }
    function resetStore(store2, hot) {
      store2._actions = /* @__PURE__ */ Object.create(null);
      store2._mutations = /* @__PURE__ */ Object.create(null);
      store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
      store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
      var state2 = store2.state;
      installModule(store2, state2, [], store2._modules.root, true);
      resetStoreState(store2, state2, hot);
    }
    function resetStoreState(store2, state2, hot) {
      var oldState = store2._state;
      store2.getters = {};
      store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
      var wrappedGetters = store2._wrappedGetters;
      var computedObj = {};
      forEachValue(wrappedGetters, function(fn, key) {
        computedObj[key] = partial(fn, store2);
        Object.defineProperty(store2.getters, key, {
          // TODO: use `computed` when it's possible. at the moment we can't due to
          // https://github.com/vuejs/vuex/pull/1883
          get: function() {
            return computedObj[key]();
          },
          enumerable: true
          // for local getters
        });
      });
      store2._state = reactive({
        data: state2
      });
      if (store2.strict) {
        enableStrictMode(store2);
      }
      if (oldState) {
        if (hot) {
          store2._withCommit(function() {
            oldState.data = null;
          });
        }
      }
    }
    function installModule(store2, rootState, path, module2, hot) {
      var isRoot = !path.length;
      var namespace = store2._modules.getNamespace(path);
      if (module2.namespaced) {
        if (store2._modulesNamespaceMap[namespace] && false) {
          console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
        }
        store2._modulesNamespaceMap[namespace] = module2;
      }
      if (!isRoot && !hot) {
        var parentState = getNestedState(rootState, path.slice(0, -1));
        var moduleName = path[path.length - 1];
        store2._withCommit(function() {
          parentState[moduleName] = module2.state;
        });
      }
      var local = module2.context = makeLocalContext(store2, namespace, path);
      module2.forEachMutation(function(mutation, key) {
        var namespacedType = namespace + key;
        registerMutation(store2, namespacedType, mutation, local);
      });
      module2.forEachAction(function(action, key) {
        var type = action.root ? key : namespace + key;
        var handler = action.handler || action;
        registerAction(store2, type, handler, local);
      });
      module2.forEachGetter(function(getter, key) {
        var namespacedType = namespace + key;
        registerGetter(store2, namespacedType, getter, local);
      });
      module2.forEachChild(function(child, key) {
        installModule(store2, rootState, path.concat(key), child, hot);
      });
    }
    function makeLocalContext(store2, namespace, path) {
      var noNamespace = namespace === "";
      var local = {
        dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
          var args = unifyObjectStyle(_type, _payload, _options);
          var payload = args.payload;
          var options = args.options;
          var type = args.type;
          if (!options || !options.root) {
            type = namespace + type;
          }
          return store2.dispatch(type, payload);
        },
        commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
          var args = unifyObjectStyle(_type, _payload, _options);
          var payload = args.payload;
          var options = args.options;
          var type = args.type;
          if (!options || !options.root) {
            type = namespace + type;
          }
          store2.commit(type, payload, options);
        }
      };
      Object.defineProperties(local, {
        getters: {
          get: noNamespace ? function() {
            return store2.getters;
          } : function() {
            return makeLocalGetters(store2, namespace);
          }
        },
        state: {
          get: function() {
            return getNestedState(store2.state, path);
          }
        }
      });
      return local;
    }
    function makeLocalGetters(store2, namespace) {
      if (!store2._makeLocalGettersCache[namespace]) {
        var gettersProxy = {};
        var splitPos = namespace.length;
        Object.keys(store2.getters).forEach(function(type) {
          if (type.slice(0, splitPos) !== namespace) {
            return;
          }
          var localType = type.slice(splitPos);
          Object.defineProperty(gettersProxy, localType, {
            get: function() {
              return store2.getters[type];
            },
            enumerable: true
          });
        });
        store2._makeLocalGettersCache[namespace] = gettersProxy;
      }
      return store2._makeLocalGettersCache[namespace];
    }
    function registerMutation(store2, type, handler, local) {
      var entry = store2._mutations[type] || (store2._mutations[type] = []);
      entry.push(function wrappedMutationHandler(payload) {
        handler.call(store2, local.state, payload);
      });
    }
    function registerAction(store2, type, handler, local) {
      var entry = store2._actions[type] || (store2._actions[type] = []);
      entry.push(function wrappedActionHandler(payload) {
        var res = handler.call(store2, {
          dispatch: local.dispatch,
          commit: local.commit,
          getters: local.getters,
          state: local.state,
          rootGetters: store2.getters,
          rootState: store2.state
        }, payload);
        if (!isPromise(res)) {
          res = Promise.resolve(res);
        }
        if (store2._devtoolHook) {
          return res.catch(function(err) {
            store2._devtoolHook.emit("vuex:error", err);
            throw err;
          });
        } else {
          return res;
        }
      });
    }
    function registerGetter(store2, type, rawGetter, local) {
      if (store2._wrappedGetters[type]) {
        return;
      }
      store2._wrappedGetters[type] = function wrappedGetter(store22) {
        return rawGetter(
          local.state,
          // local state
          local.getters,
          // local getters
          store22.state,
          // root state
          store22.getters
          // root getters
        );
      };
    }
    function enableStrictMode(store2) {
      watch(function() {
        return store2._state.data;
      }, function() {
      }, { deep: true, flush: "sync" });
    }
    function getNestedState(state2, path) {
      return path.reduce(function(state22, key) {
        return state22[key];
      }, state2);
    }
    function unifyObjectStyle(type, payload, options) {
      if (isObject(type) && type.type) {
        options = payload;
        payload = type;
        type = type.type;
      }
      return { type, payload, options };
    }
    var LABEL_VUEX_BINDINGS = "vuex bindings";
    var MUTATIONS_LAYER_ID = "vuex:mutations";
    var ACTIONS_LAYER_ID = "vuex:actions";
    var INSPECTOR_ID = "vuex";
    var actionId = 0;
    function addDevtools(app, store2) {
      setupDevtoolsPlugin(
        {
          id: "org.vuejs.vuex",
          app,
          label: "Vuex",
          homepage: "https://next.vuex.vuejs.org/",
          logo: "https://vuejs.org/images/icons/favicon-96x96.png",
          packageName: "vuex",
          componentStateTypes: [LABEL_VUEX_BINDINGS]
        },
        function(api) {
          api.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: "Vuex Mutations",
            color: COLOR_LIME_500
          });
          api.addTimelineLayer({
            id: ACTIONS_LAYER_ID,
            label: "Vuex Actions",
            color: COLOR_LIME_500
          });
          api.addInspector({
            id: INSPECTOR_ID,
            label: "Vuex",
            icon: "storage",
            treeFilterPlaceholder: "Filter stores..."
          });
          api.on.getInspectorTree(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              if (payload.filter) {
                var nodes = [];
                flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
                payload.rootNodes = nodes;
              } else {
                payload.rootNodes = [
                  formatStoreForInspectorTree(store2._modules.root, "")
                ];
              }
            }
          });
          api.on.getInspectorState(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              var modulePath = payload.nodeId;
              makeLocalGetters(store2, modulePath);
              payload.state = formatStoreForInspectorState(
                getStoreModule(store2._modules, modulePath),
                modulePath === "root" ? store2.getters : store2._makeLocalGettersCache,
                modulePath
              );
            }
          });
          api.on.editInspectorState(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              var modulePath = payload.nodeId;
              var path = payload.path;
              if (modulePath !== "root") {
                path = modulePath.split("/").filter(Boolean).concat(path);
              }
              store2._withCommit(function() {
                payload.set(store2._state.data, path, payload.state.value);
              });
            }
          });
          store2.subscribe(function(mutation, state2) {
            var data = {};
            if (mutation.payload) {
              data.payload = mutation.payload;
            }
            data.state = state2;
            api.notifyComponentUpdate();
            api.sendInspectorTree(INSPECTOR_ID);
            api.sendInspectorState(INSPECTOR_ID);
            api.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: Date.now(),
                title: mutation.type,
                data
              }
            });
          });
          store2.subscribeAction({
            before: function(action, state2) {
              var data = {};
              if (action.payload) {
                data.payload = action.payload;
              }
              action._id = actionId++;
              action._time = Date.now();
              data.state = state2;
              api.addTimelineEvent({
                layerId: ACTIONS_LAYER_ID,
                event: {
                  time: action._time,
                  title: action.type,
                  groupId: action._id,
                  subtitle: "start",
                  data
                }
              });
            },
            after: function(action, state2) {
              var data = {};
              var duration = Date.now() - action._time;
              data.duration = {
                _custom: {
                  type: "duration",
                  display: duration + "ms",
                  tooltip: "Action duration",
                  value: duration
                }
              };
              if (action.payload) {
                data.payload = action.payload;
              }
              data.state = state2;
              api.addTimelineEvent({
                layerId: ACTIONS_LAYER_ID,
                event: {
                  time: Date.now(),
                  title: action.type,
                  groupId: action._id,
                  subtitle: "end",
                  data
                }
              });
            }
          });
        }
      );
    }
    var COLOR_LIME_500 = 8702998;
    var COLOR_DARK = 6710886;
    var COLOR_WHITE = 16777215;
    var TAG_NAMESPACED = {
      label: "namespaced",
      textColor: COLOR_WHITE,
      backgroundColor: COLOR_DARK
    };
    function extractNameFromPath(path) {
      return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
    }
    function formatStoreForInspectorTree(module2, path) {
      return {
        id: path || "root",
        // all modules end with a `/`, we want the last segment only
        // cart/ -> cart
        // nested/cart/ -> cart
        label: extractNameFromPath(path),
        tags: module2.namespaced ? [TAG_NAMESPACED] : [],
        children: Object.keys(module2._children).map(
          function(moduleName) {
            return formatStoreForInspectorTree(
              module2._children[moduleName],
              path + moduleName + "/"
            );
          }
        )
      };
    }
    function flattenStoreForInspectorTree(result, module2, filter, path) {
      if (path.includes(filter)) {
        result.push({
          id: path || "root",
          label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
          tags: module2.namespaced ? [TAG_NAMESPACED] : []
        });
      }
      Object.keys(module2._children).forEach(function(moduleName) {
        flattenStoreForInspectorTree(result, module2._children[moduleName], filter, path + moduleName + "/");
      });
    }
    function formatStoreForInspectorState(module2, getters2, path) {
      getters2 = path === "root" ? getters2 : getters2[path];
      var gettersKeys = Object.keys(getters2);
      var storeState = {
        state: Object.keys(module2.state).map(function(key) {
          return {
            key,
            editable: true,
            value: module2.state[key]
          };
        })
      };
      if (gettersKeys.length) {
        var tree = transformPathsToObjectTree(getters2);
        storeState.getters = Object.keys(tree).map(function(key) {
          return {
            key: key.endsWith("/") ? extractNameFromPath(key) : key,
            editable: false,
            value: canThrow(function() {
              return tree[key];
            })
          };
        });
      }
      return storeState;
    }
    function transformPathsToObjectTree(getters2) {
      var result = {};
      Object.keys(getters2).forEach(function(key) {
        var path = key.split("/");
        if (path.length > 1) {
          var target = result;
          var leafKey = path.pop();
          path.forEach(function(p2) {
            if (!target[p2]) {
              target[p2] = {
                _custom: {
                  value: {},
                  display: p2,
                  tooltip: "Module",
                  abstract: true
                }
              };
            }
            target = target[p2]._custom.value;
          });
          target[leafKey] = canThrow(function() {
            return getters2[key];
          });
        } else {
          result[key] = canThrow(function() {
            return getters2[key];
          });
        }
      });
      return result;
    }
    function getStoreModule(moduleMap, path) {
      var names = path.split("/").filter(function(n) {
        return n;
      });
      return names.reduce(
        function(module2, moduleName, i2) {
          var child = module2[moduleName];
          if (!child) {
            throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
          }
          return i2 === names.length - 1 ? child : child._children;
        },
        path === "root" ? moduleMap : moduleMap.root._children
      );
    }
    function canThrow(cb) {
      try {
        return cb();
      } catch (e) {
        return e;
      }
    }
    var Module = function Module2(rawModule, runtime) {
      this.runtime = runtime;
      this._children = /* @__PURE__ */ Object.create(null);
      this._rawModule = rawModule;
      var rawState = rawModule.state;
      this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
    };
    var prototypeAccessors$1 = { namespaced: { configurable: true } };
    prototypeAccessors$1.namespaced.get = function() {
      return !!this._rawModule.namespaced;
    };
    Module.prototype.addChild = function addChild(key, module2) {
      this._children[key] = module2;
    };
    Module.prototype.removeChild = function removeChild(key) {
      delete this._children[key];
    };
    Module.prototype.getChild = function getChild(key) {
      return this._children[key];
    };
    Module.prototype.hasChild = function hasChild(key) {
      return key in this._children;
    };
    Module.prototype.update = function update(rawModule) {
      this._rawModule.namespaced = rawModule.namespaced;
      if (rawModule.actions) {
        this._rawModule.actions = rawModule.actions;
      }
      if (rawModule.mutations) {
        this._rawModule.mutations = rawModule.mutations;
      }
      if (rawModule.getters) {
        this._rawModule.getters = rawModule.getters;
      }
    };
    Module.prototype.forEachChild = function forEachChild(fn) {
      forEachValue(this._children, fn);
    };
    Module.prototype.forEachGetter = function forEachGetter(fn) {
      if (this._rawModule.getters) {
        forEachValue(this._rawModule.getters, fn);
      }
    };
    Module.prototype.forEachAction = function forEachAction(fn) {
      if (this._rawModule.actions) {
        forEachValue(this._rawModule.actions, fn);
      }
    };
    Module.prototype.forEachMutation = function forEachMutation(fn) {
      if (this._rawModule.mutations) {
        forEachValue(this._rawModule.mutations, fn);
      }
    };
    Object.defineProperties(Module.prototype, prototypeAccessors$1);
    var ModuleCollection = function ModuleCollection2(rawRootModule) {
      this.register([], rawRootModule, false);
    };
    ModuleCollection.prototype.get = function get2(path) {
      return path.reduce(function(module2, key) {
        return module2.getChild(key);
      }, this.root);
    };
    ModuleCollection.prototype.getNamespace = function getNamespace(path) {
      var module2 = this.root;
      return path.reduce(function(namespace, key) {
        module2 = module2.getChild(key);
        return namespace + (module2.namespaced ? key + "/" : "");
      }, "");
    };
    ModuleCollection.prototype.update = function update$1(rawRootModule) {
      update2([], this.root, rawRootModule);
    };
    ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
      var this$1$1 = this;
      if (runtime === void 0)
        runtime = true;
      var newModule = new Module(rawModule, runtime);
      if (path.length === 0) {
        this.root = newModule;
      } else {
        var parent = this.get(path.slice(0, -1));
        parent.addChild(path[path.length - 1], newModule);
      }
      if (rawModule.modules) {
        forEachValue(rawModule.modules, function(rawChildModule, key) {
          this$1$1.register(path.concat(key), rawChildModule, runtime);
        });
      }
    };
    ModuleCollection.prototype.unregister = function unregister(path) {
      var parent = this.get(path.slice(0, -1));
      var key = path[path.length - 1];
      var child = parent.getChild(key);
      if (!child) {
        return;
      }
      if (!child.runtime) {
        return;
      }
      parent.removeChild(key);
    };
    ModuleCollection.prototype.isRegistered = function isRegistered(path) {
      var parent = this.get(path.slice(0, -1));
      var key = path[path.length - 1];
      if (parent) {
        return parent.hasChild(key);
      }
      return false;
    };
    function update2(path, targetModule, newModule) {
      targetModule.update(newModule);
      if (newModule.modules) {
        for (var key in newModule.modules) {
          if (!targetModule.getChild(key)) {
            return;
          }
          update2(
            path.concat(key),
            targetModule.getChild(key),
            newModule.modules[key]
          );
        }
      }
    }
    function createStore(options) {
      return new Store(options);
    }
    var Store = function Store2(options) {
      var this$1$1 = this;
      if (options === void 0)
        options = {};
      var plugins = options.plugins;
      if (plugins === void 0)
        plugins = [];
      var strict = options.strict;
      if (strict === void 0)
        strict = false;
      var devtools = options.devtools;
      this._committing = false;
      this._actions = /* @__PURE__ */ Object.create(null);
      this._actionSubscribers = [];
      this._mutations = /* @__PURE__ */ Object.create(null);
      this._wrappedGetters = /* @__PURE__ */ Object.create(null);
      this._modules = new ModuleCollection(options);
      this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
      this._subscribers = [];
      this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
      this._devtools = devtools;
      var store2 = this;
      var ref2 = this;
      var dispatch2 = ref2.dispatch;
      var commit2 = ref2.commit;
      this.dispatch = function boundDispatch(type, payload) {
        return dispatch2.call(store2, type, payload);
      };
      this.commit = function boundCommit(type, payload, options2) {
        return commit2.call(store2, type, payload, options2);
      };
      this.strict = strict;
      var state2 = this._modules.root.state;
      installModule(this, state2, [], this._modules.root);
      resetStoreState(this, state2);
      plugins.forEach(function(plugin) {
        return plugin(this$1$1);
      });
    };
    var prototypeAccessors = { state: { configurable: true } };
    Store.prototype.install = function install(app, injectKey) {
      app.provide(injectKey || storeKey, this);
      app.config.globalProperties.$store = this;
      var useDevtools = this._devtools !== void 0 ? this._devtools : false;
      if (useDevtools) {
        addDevtools(app, this);
      }
    };
    prototypeAccessors.state.get = function() {
      return this._state.data;
    };
    prototypeAccessors.state.set = function(v) {
    };
    Store.prototype.commit = function commit(_type, _payload, _options) {
      var this$1$1 = this;
      var ref2 = unifyObjectStyle(_type, _payload, _options);
      var type = ref2.type;
      var payload = ref2.payload;
      var mutation = { type, payload };
      var entry = this._mutations[type];
      if (!entry) {
        return;
      }
      this._withCommit(function() {
        entry.forEach(function commitIterator(handler) {
          handler(payload);
        });
      });
      this._subscribers.slice().forEach(function(sub) {
        return sub(mutation, this$1$1.state);
      });
    };
    Store.prototype.dispatch = function dispatch(_type, _payload) {
      var this$1$1 = this;
      var ref2 = unifyObjectStyle(_type, _payload);
      var type = ref2.type;
      var payload = ref2.payload;
      var action = { type, payload };
      var entry = this._actions[type];
      if (!entry) {
        return;
      }
      try {
        this._actionSubscribers.slice().filter(function(sub) {
          return sub.before;
        }).forEach(function(sub) {
          return sub.before(action, this$1$1.state);
        });
      } catch (e) {
      }
      var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
        return handler(payload);
      })) : entry[0](payload);
      return new Promise(function(resolve2, reject) {
        result.then(function(res) {
          try {
            this$1$1._actionSubscribers.filter(function(sub) {
              return sub.after;
            }).forEach(function(sub) {
              return sub.after(action, this$1$1.state);
            });
          } catch (e) {
          }
          resolve2(res);
        }, function(error) {
          try {
            this$1$1._actionSubscribers.filter(function(sub) {
              return sub.error;
            }).forEach(function(sub) {
              return sub.error(action, this$1$1.state, error);
            });
          } catch (e) {
          }
          reject(error);
        });
      });
    };
    Store.prototype.subscribe = function subscribe(fn, options) {
      return genericSubscribe(fn, this._subscribers, options);
    };
    Store.prototype.subscribeAction = function subscribeAction(fn, options) {
      var subs = typeof fn === "function" ? { before: fn } : fn;
      return genericSubscribe(subs, this._actionSubscribers, options);
    };
    Store.prototype.watch = function watch$1(getter, cb, options) {
      var this$1$1 = this;
      return watch(function() {
        return getter(this$1$1.state, this$1$1.getters);
      }, cb, Object.assign({}, options));
    };
    Store.prototype.replaceState = function replaceState(state2) {
      var this$1$1 = this;
      this._withCommit(function() {
        this$1$1._state.data = state2;
      });
    };
    Store.prototype.registerModule = function registerModule(path, rawModule, options) {
      if (options === void 0)
        options = {};
      if (typeof path === "string") {
        path = [path];
      }
      this._modules.register(path, rawModule);
      installModule(this, this.state, path, this._modules.get(path), options.preserveState);
      resetStoreState(this, this.state);
    };
    Store.prototype.unregisterModule = function unregisterModule(path) {
      var this$1$1 = this;
      if (typeof path === "string") {
        path = [path];
      }
      this._modules.unregister(path);
      this._withCommit(function() {
        var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
        delete parentState[path[path.length - 1]];
      });
      resetStore(this);
    };
    Store.prototype.hasModule = function hasModule(path) {
      if (typeof path === "string") {
        path = [path];
      }
      return this._modules.isRegistered(path);
    };
    Store.prototype.hotUpdate = function hotUpdate(newOptions) {
      this._modules.update(newOptions);
      resetStore(this, true);
    };
    Store.prototype._withCommit = function _withCommit(fn) {
      var committing = this._committing;
      this._committing = true;
      fn();
      this._committing = committing;
    };
    Object.defineProperties(Store.prototype, prototypeAccessors);
    const Limits = {
      HARD_REPORT: 5e4,
      SOFT_TOTAL: 5e4,
      HARD_TOTAL: 1e5,
      FIELD_TOTAL: 20
    };
    const GeoLocation = {
      isLatitude: (lat) => lat && isFinite(lat) && Math.abs(lat) <= 90,
      isLongitude: (lng) => lng && isFinite(lng) && Math.abs(lng) <= 180,
      getRandomLocation: () => {
        const middleUSA = { latitude: 39.8283, longitude: 98.5795 };
        const radius = 944685;
        const randomPoint = randomLocation.randomCirclePoint(middleUSA, radius);
        return { Latitude: randomPoint.latitude, Longitude: randomPoint.longitude };
      }
    };
    const Segment = {
      async getRecords({ dataSource, unitIds }) {
        try {
          if ((unitIds == null ? void 0 : unitIds.size) === 0)
            return [];
          const nodeMap = await SPM.Utils.Segment.Node.buildNodeMap({ nodeId: dataSource.segmentId });
          const crmaDS = await SPM.Utils.Segment.Node.buildDataSource({ planId: nodeMap[dataSource.segmentId].sfsp__SalesPlan__c });
          const crmaRows = [];
          if ((unitIds == null ? void 0 : unitIds.size) > 0) {
            const uniqueIDs = Array.from(unitIds);
            const batchSize = 200;
            for (let i2 = 0; i2 < uniqueIDs.length; i2 += batchSize) {
              const batch = uniqueIDs.slice(i2, i2 + batchSize);
              const batchRecords = await SPM.Utils.Segment.Node.getRecords({ segmentId: dataSource.segmentId, dataSource: crmaDS, nodeMap, uniqueIds: batch });
              crmaRows.push(...batchRecords);
            }
          } else {
            let currentOffset = 0;
            let moreRecords = true;
            while (moreRecords && crmaRows.length <= Limits.HARD_TOTAL) {
              const batchRecords = await SPM.Utils.Segment.Node.getRecords({ segmentId: dataSource.segmentId, dataSource: crmaDS, nodeMap, limit: 7e4, offset: currentOffset });
              if (batchRecords.length > 0) {
                crmaRows.push(...batchRecords);
                currentOffset = crmaRows.length;
              } else {
                moreRecords = false;
              }
            }
          }
          const formattedRecords = crmaRows.reduce((map2, recordMetadata) => {
            const includedMetadata = Object.entries(recordMetadata).reduce((map3, [fieldName, value]) => {
              if (dataSource.metadataFields.find((f) => f.name === fieldName))
                map3[fieldName] = value;
              return map3;
            }, {});
            const unitId = includedMetadata[dataSource.unitIdField];
            const liveRecordId = `${dataSource.id}-${unitId}`;
            let latitude = dataSource.latitudeField ? includedMetadata[dataSource.latitudeField] || "" : "";
            let longitude = dataSource.longitudeField ? includedMetadata[dataSource.longitudeField] || "" : "";
            if (!GeoLocation.isLatitude(latitude) || !GeoLocation.isLongitude(longitude)) {
              latitude = "";
              longitude = "";
            }
            if (!unitIds || unitIds.has(unitId)) {
              map2[liveRecordId] = {
                Id: liveRecordId,
                DataSourceId: dataSource.id,
                UnitId: unitId,
                AreaId: "",
                ContainerId: "",
                Latitude: latitude,
                Longitude: longitude,
                Metadata: {
                  ...includedMetadata
                },
                Config: {
                  assignmentFieldValue: ""
                },
                AggregateUnits: null
              };
            }
            return map2;
          }, {});
          return formattedRecords;
        } catch (e) {
          console.log(e);
          return { error: e };
        }
      },
      async getFields({ dataSource }) {
        try {
          if (!dataSource)
            throw new Error("Unable to retrieve available fields.");
          const nodeMap = await SPM.Utils.Segment.Node.buildNodeMap({ nodeId: dataSource.segmentId });
          if (!nodeMap)
            throw new Error("Unable to retrieve available fields.");
          const crmaDS = await SPM.Utils.Segment.Node.buildDataSource({ planId: nodeMap[dataSource.segmentId].sfsp__SalesPlan__c });
          if (!crmaDS)
            throw new Error("Unable to retrieve available fields.");
          const metadataFields = crmaDS._referenceFields.map((field) => ({
            name: field.id,
            label: field.label,
            dataType: field.isId ? "ID" : field.dataType === "Text" ? "STRING" : "DOUBLE"
          }));
          return metadataFields;
        } catch (e) {
          console.log(e);
          return { error: e };
        }
      }
    };
    const LiveDataUtils = {
      Limits,
      GeoLocation,
      async getLiveData({ dataSources, unitIds }) {
        const liveDataPromises = dataSources.map((dataSource) => {
          if (dataSource.type === "Segment Data Source")
            return Segment.getRecords({ dataSource, unitIds });
        });
        const liveDataResponses = await Promise.allSettled(liveDataPromises);
        let liveRecords = {};
        liveDataResponses.forEach((response) => {
          const data = response.status === "fulfilled" ? response.value : { error: `Something went wrong when retrieving live data.` };
          if (data.error)
            liveRecords.error = data.error;
          else
            liveRecords = { ...liveRecords, ...data };
        });
        if (liveRecords.error) {
          const error = liveRecords.error;
          delete liveRecords.error;
          return { liveRecords, error };
        }
        if (Object.values(liveRecords).filter((lr) => lr.DataSourceId !== "Container").length > Limits.HARD_TOTAL) {
          return { liveRecords, error: formatLabel(MATA.Labels.AlignmentBuilder_Map_HardLimitErrorMessage, [Limits.HARD_TOTAL]) };
        }
        return { liveRecords };
      }
    };
    const MATA$1 = {
      Labels: {
        SetupModal_ColumnSelector_AreaNameAttributeTitle: "Area Name",
        SetupModal_ColumnSelector_AreaLevelAttributeTitle: "Area Level",
        SetupModal_ColumnSelector_OwnerAttributeTitle: "Owner",
        SetupModal_ColumnSelector_UnitCountAttributeTitle: "Units",
        SetupModal_ColumnSelector_SpanOfControlTitle: "Span of Control",
        SetupModal_ColumnSelector_PointsTitle: "Points",
        SetupModal_ColumnSelector_BoundariesTitle: "Boundaries",
        SetupModal_ColumnSelector_ApproximateDiameterTitle: "Approximate Diameter",
        SetupModal_ColumnSelector_AreaTitle: "Area",
        SetupModal_ColumnSelector_GeographicProfileTitle: "Geographic Profile",
        SetupModal_ColumnSelector_BalancePercentageTitle: "Balance Percentage",
        SetupModal_ColumnSelector_OwnerIdTitle: "OwnerId",
        SetupModal_ColumnSelector_ParentTitle: "Parent",
        SetupModal_ColumnSelector_DescriptionTitle: "Description",
        PublishModal_DataSourceOptions_AssignedUsers: "Assigned Users"
      }
    };
    const state = {
      // job details and utils
      job: {},
      allowContainerData: false,
      // alignment data
      units: [],
      // active alignment details
      alignmentId: "",
      // area roles
      areaRoles: [],
      // container sets
      containerSets: [],
      firstUnitId: null,
      lastUnitId: null,
      unitCount: null,
      // global settings
      settings: { "Asynchronous Data Set Creation": true, "Select unassigned by default": false, "PendoEnabled": true, "Use Bulk API": false, "Base62PKChunking": true, "BasicUnitChunkSize": 1e4, "ExtendedUnitChunkSize": 5e3, "ParallelWriting": true, "ParallelWritingBatchSize": 200, "Pre-load unit data": true, "RefreshRemoteActionCSRFToken": false, "DataSet Batch Size": 250, "BuildAlignmentVersion": "" }
    };
    const getters = {
      getNumAreas: (state2, getters2) => () => {
        let count2 = 0;
        state2.hierarchyLevels.forEach((level) => {
          count2 += getters2.getAreasByLevel(level).length;
        });
        return count2;
      },
      getAreasByLevel: (state2) => (level) => {
        const levelAreas = [];
        (function findAreas(areas) {
          areas.forEach((area) => {
            if (area.level === level)
              levelAreas.push(area);
            else
              findAreas(area.areas);
          });
        })(state2.areas);
        return levelAreas;
      },
      getAreaIdMap: (state2) => () => {
        const areaIdMap = {};
        (function addAreas(areas) {
          areas.forEach((a) => {
            areaIdMap[a.id] = a;
            addAreas(a.areas);
          });
        })(state2.areas);
        return areaIdMap;
      },
      getParentArea: (state2, getters2) => (area) => {
        const parentLevel = state2.hierarchyLevels[state2.hierarchyLevels.indexOf(area.level) - 1];
        if (parentLevel) {
          return getters2.getAreasByLevel(parentLevel).find((parent) => parent.areas.find((child) => child.id === area.id));
        }
      },
      getAreaDetails: (state2, getters2) => (area) => {
        const areaDetails = { id: area.id, name: area.name, childAreaIds: [], geographicCenter: null, weightedGeographicCenter: null, units: [], areaCenterCoordinates: area.config.center.coordinates };
        const areas = [area];
        while (areas.length > 0) {
          const currentArea = areas.pop();
          if (currentArea.areas.length > 0) {
            currentArea.areas.forEach((childArea) => {
              areas.push(childArea);
              areaDetails.childAreaIds.push(childArea.id);
            });
          } else {
            const realAreaId = currentArea.id.split("-").pop().replace(/^Unassigned$/, "");
            state2.units.filter((u) => u.AreaId === realAreaId).forEach((unit) => {
              areaDetails.units.push(Object.assign(unit, { unitTypeId: unit.DataSourceId === "Container" ? unit.ContainerSetId : unit.DataSourceId }));
              areaDetails.weightedGeographicCenter = areaDetails.weightedGeographicCenter || [0, 0];
            });
          }
        }
        return areaDetails;
      },
      getDataSourceFields: (state2, getters2) => (id) => {
        const dataSource = state2.alignmentConfig.dataSources.find((ds) => ds.id === id);
        let fields = [];
        fields.push(
          ...dataSource.metadataFields.map((mf) => ({
            id: `Metadata:${mf.name}`,
            name: mf.name,
            label: dataSource.type === "GEO" ? `${mf.label} - ${dataSource.name}` : mf.label,
            type: "Metadata",
            dataType: {
              INT_DATA: "Number",
              DOUBLE_DATA: "Number",
              DOUBLE: "Number",
              CURRENCY_DATA: "Number",
              PERCENT_DATA: "Number",
              Duration: "Duration"
            }[mf.dataType] || "String"
          }))
        );
        if (dataSource.type === "GEO") {
          state2.alignmentConfig.calcAtts.filter((ca) => ca.type !== "Area").forEach((calcAtt) => {
            if (calcAtt.type === "Container" && !calcAtt.dataSources.find((ds) => ds.id === dataSource.id))
              return;
            fields.push({
              id: calcAtt.id,
              label: calcAtt.name,
              type: calcAtt.type,
              dataType: calcAtt.dataType
            });
          });
          state2.alignmentConfig.dataSources.filter((ds) => ds.type !== "GEO").forEach((dataSource2) => {
            getters2.getDataSourceFields(dataSource2.id).filter((f) => f.type === "Metadata" && ["Number", "Duration"].includes(f.dataType)).forEach((metadataField) => {
              fields.push({
                id: metadataField.id.replace(/^Metadata:/, `${dataSource2.id}:`),
                label: metadataField.label,
                type: "Unit",
                dataType: metadataField.dataType
              });
            });
          });
        } else {
          state2.alignmentConfig.calcAtts.filter((ca) => ca.type === "Unit" && ca.dataSources.find((ds) => ds.id === dataSource.id)).forEach((calcAtt) => {
            fields.push({
              id: calcAtt.id,
              label: calcAtt.name,
              type: calcAtt.type,
              dataType: calcAtt.dataType
            });
          });
        }
        return fields;
      },
      getAreaFields: (state2, getters2) => (level) => {
        const fields = [];
        fields.push({ id: "Property:name", label: MATA$1.Labels.SetupModal_ColumnSelector_AreaNameAttributeTitle, type: "Property", dataType: "String" });
        fields.push({ id: "Property:level", label: MATA$1.Labels.SetupModal_ColumnSelector_AreaLevelAttributeTitle, type: "Property", dataType: "String" });
        const specialFieldIds = ["Owner", "OwnerId", "UnitCount", "Boundaries", "Description", "geoProfile", "balanceTarget", "UserCount"];
        if (state2.alignmentConfig.containerSets.find((cs) => cs.id.startsWith("USA_PCB")))
          specialFieldIds.push("Points");
        if (level !== state2.hierarchyLevels[0])
          specialFieldIds.push("Parent");
        if (level !== state2.hierarchyLevels.slice(-1)[0])
          specialFieldIds.push("SpanOfControl");
        specialFieldIds.forEach((fieldId) => {
          const specialField = getters2.getSpecialFields.find((f) => f.id === fieldId);
          fields.push({
            id: `Special:${specialField.id}`,
            label: specialField.label,
            type: "Special",
            dataType: specialField.dataType
          });
        });
        if (state2.alignmentConfig.areaMetadataFields) {
          fields.push(
            ...state2.alignmentConfig.areaMetadataFields.map((mf) => ({
              id: `Metadata:${mf.name}`,
              name: mf.name,
              label: mf.label,
              type: "Metadata",
              dataType: {
                INT_DATA: "Number",
                DOUBLE_DATA: "Number",
                DOUBLE: "Number",
                CURRENCY_DATA: "Number",
                PERCENT_DATA: "Number",
                Duration: "Duration"
              }[mf.dataType] || "String"
            }))
          );
        }
        if (state2.alignmentConfig.calcAtts) {
          fields.push(
            ...state2.alignmentConfig.calcAtts.map((calcAtt) => ({
              id: calcAtt.id,
              label: calcAtt.name,
              type: calcAtt.type,
              dataType: calcAtt.dataType
            }))
          );
        }
        state2.alignmentConfig.dataSources.forEach((dataSource) => {
          getters2.getDataSourceFields(dataSource.id).filter((f) => f.type === "Metadata" && ["Number", "Duration"].includes(f.dataType)).forEach((metadataField) => {
            fields.push({
              id: metadataField.id.replace(/^Metadata:/, `${dataSource.id}:`),
              label: metadataField.label,
              type: dataSource.type === "GEO" ? "Container" : "Unit",
              dataType: metadataField.dataType
            });
          });
        });
        const roles = [];
        state2.areaRoles.forEach((role) => {
          roles.push({
            id: `Role:${role.Id}`,
            label: role.Name,
            name: role.Name,
            type: "Role",
            dataType: "User"
          });
        });
        const ucIndex = fields.findIndex((f) => f.id === "Special:UserCount");
        fields.splice(ucIndex + 1, 0, ...roles);
        return fields;
      },
      getCalcAtts: (state2, getters2) => {
        const unitCalcAtts = [];
        state2.alignmentConfig.dataSources.forEach((dataSource) => {
          dataSource.metadataFields.filter((f) => ["INT_DATA", "DOUBLE_DATA", "DOUBLE", "CURRENCY_DATA", "PERCENT_DATA", "Number", "Duration"].includes(f.dataType)).forEach((field) => {
            const fieldLabel = dataSource.type === "GEO" ? `${field.label} - ${dataSource.name}` : field.label;
            unitCalcAtts.push({
              id: `${dataSource.id}:${field.name}`,
              label: fieldLabel,
              type: dataSource.type === "GEO" ? "Container" : "Unit",
              dataType: field.dataType === "Duration" ? "Duration" : "Number",
              dataSources: [{ id: dataSource.id, expression: `[${fieldLabel}]` }],
              isCalculated: false
            });
          });
        });
        return [...unitCalcAtts, ...state2.alignmentConfig.calcAtts];
      },
      getSpecialFields: (state2, getters2) => [
        {
          id: "UnitCount",
          label: MATA$1.Labels.SetupModal_ColumnSelector_UnitCountAttributeTitle,
          dataType: "Number",
          getAreaValue: (area) => area.SpecialMetadata.UnitCount,
          getUnitValue: (unit) => unit.SpecialMetadata.UnitCount
        },
        {
          id: "UserCount",
          label: MATA$1.Labels.PublishModal_DataSourceOptions_AssignedUsers,
          dataType: "Number",
          getAreaValue: (area) => area.config.users ? area.config.users.filter((u) => state2.areaRoles.map((ar) => ar.Id).includes(u.role)).length : 0,
          getUnitValue: (unit) => store.getters.getArea(unit.AreaId).config.users.length
        },
        {
          id: "SpanOfControl",
          label: MATA$1.Labels.SetupModal_ColumnSelector_SpanOfControlTitle,
          dataType: "Number",
          getAreaValue: (area) => area.areas.filter((a) => a.id !== "Unassigned" && !a.id.startsWith("placeholder-")).length
        },
        {
          id: "Points",
          label: MATA$1.Labels.SetupModal_ColumnSelector_PointsTitle,
          dataType: "Number",
          getAreaValue: (area) => {
            const realAreaIds = [area.id, ...getters2.getAreaDetails(area).childAreaIds].map((id) => id.split("-").pop().replace(/^Unassigned$/, ""));
            return state2.units.filter((u) => u.DataSourceId === "Container" && realAreaIds.includes(u.AreaId)).reduce((total, unit) => total + getters2.getContainer(unit).metadata.child_container_count || 0, 0);
          },
          getUnitValue: (unit) => getters2.getContainer(unit).metadata.child_container_count || 0
        },
        {
          id: "Boundaries",
          label: MATA$1.Labels.SetupModal_ColumnSelector_BoundariesTitle,
          dataType: "Number",
          getAreaValue: (area) => {
            const realAreaIds = [area.id, ...getters2.getAreaDetails(area).childAreaIds].map((id) => id.split("-").pop().replace(/^Unassigned$/, ""));
            return state2.units.filter((u) => u.DataSourceId === "Container" && realAreaIds.includes(u.AreaId)).length;
          }
        },
        {
          id: "geoProfile",
          label: MATA$1.Labels.SetupModal_ColumnSelector_GeographicProfileTitle,
          dataType: "String",
          setAreaValue: (area, geoProfile) => area.config.geoProfile = geoProfile || "Contiguous",
          getAreaValue: (area) => area.config.geoProfile || "Contiguous"
        },
        {
          id: "balanceTarget",
          label: MATA$1.Labels.SetupModal_ColumnSelector_BalancePercentageTitle,
          dataType: "Number",
          setAreaValue: (area, balanceTarget) => area.config.balanceTarget = balanceTarget || 100,
          getAreaValue: (area) => area.config.balanceTarget || 100
        },
        {
          id: "Owner",
          label: MATA$1.Labels.SetupModal_ColumnSelector_OwnerAttributeTitle,
          dataType: "String",
          setAreaValue: (area, ownerId) => {
            area.config.ownerId = ownerId;
            const storeArea = getters2.getArea(area.id);
            storeArea.ownerName = area.ownerName = state2.userLookup[ownerId];
          },
          getAreaValue: (area) => area.ownerName,
          getUnitValue: (unit) => getters2.getActiveLevelAssignment(unit).ownerName
        },
        {
          id: "OwnerId",
          label: MATA$1.Labels.SetupModal_ColumnSelector_OwnerIdTitle,
          dataType: "String",
          setAreaValue: (area, ownerId) => {
            area.config.ownerId = ownerId;
            const storeArea = getters2.getArea(area.id);
            storeArea.ownerName = area.ownerName = state2.userLookup[ownerId];
          },
          getAreaValue: (area) => area.config.ownerId,
          getUnitValue: (unit) => getters2.getActiveLevelAssignment(unit).config.ownerId
        },
        {
          id: "Parent",
          label: MATA$1.Labels.SetupModal_ColumnSelector_ParentTitle,
          dataType: "String",
          getAreaValue: (area) => (getters2.getParentArea(area) || {}).name || "",
          getUnitValue: (unit) => getters2.getActiveLevelAssignment(unit).name
        },
        {
          id: "Description",
          label: MATA$1.Labels.SetupModal_ColumnSelector_DescriptionTitle,
          dataType: "String",
          getAreaValue: (area) => area.description,
          setAreaValue: (area, description) => {
            const storeArea = getters2.getArea(area.id);
            storeArea.description = area.description = description;
          },
          getUnitValue: (unit) => getters2.getActiveLevelAssignment(unit).description
        }
      ]
    };
    const actions = {
      async loadUnitsConcurrent(store2, payload) {
        const getDefragmentedRangeList = async (opts) => {
          const { alignmentId, areaIds: areaIds2 = [], firstUnitId, lastUnitId, dataSourceIds: dataSourceIds2 = [], chunkSize = 1e4, unitCount } = opts;
          const rangeListChunks2 = SPM.Utils.PkChunking.chunkIdRange(firstUnitId, lastUnitId, chunkSize);
          const fragmentation = SPM.Utils.PkChunking.calculateFragmentation(firstUnitId, lastUnitId, unitCount);
          if (fragmentation < 1.5) {
            return Promise.resolve(rangeListChunks2);
          }
          const soqlLimit = 100;
          const rangeBatches = [];
          for (let i2 = 0; i2 < rangeListChunks2.length; i2 += soqlLimit) {
            const batchIds = rangeListChunks2.slice(i2, i2 + soqlLimit);
            rangeBatches.push(batchIds);
          }
          const deFragmentedPromises = rangeBatches.map((rangeListChunks3) => store2.state.job.tpRest("GetRangeChunkUnitCounts", {
            alignmentId,
            firstIds: rangeListChunks3.map((range) => range.first),
            lastIds: rangeListChunks3.map((range) => range.last),
            areaIds: areaIds2,
            dataSourceIds: dataSourceIds2
          }));
          return Promise.all(deFragmentedPromises).then((rangeListUnitCounts) => {
            rangeListUnitCounts = rangeListUnitCounts.flat(Infinity);
            for (let i2 = rangeListUnitCounts.length - 1; i2 > 0; i2--) {
              const lastRangeItem = rangeListUnitCounts[i2];
              const secondLastRangeItem = rangeListUnitCounts[i2 - 1];
              if (lastRangeItem.unitCount + secondLastRangeItem.unitCount < chunkSize) {
                const mergedRange = { first: secondLastRangeItem.first, last: lastRangeItem.last, unitCount: lastRangeItem.unitCount + secondLastRangeItem.unitCount };
                rangeListUnitCounts[i2 - 1] = mergedRange;
                rangeListUnitCounts.splice(i2, 1);
              }
            }
            return rangeListUnitCounts;
          });
        };
        const getUnitsConcurrent = async (opts) => {
          const { alignmentId, areaIds: areaIds2 = [], firstUnitId, lastUnitId, isBasicFieldsRequest = true, dataSourceIds: dataSourceIds2 = [], unitIds = [], containerIds = [], progress = () => {
          }, chunkSize = 1e4 } = opts;
          const rangeListChunks2 = opts.rangeListChunks || store2.state.job.utils.PkChunking.chunkIdRange(firstUnitId, lastUnitId, chunkSize);
          const hasAggregateData2 = dataSourceIds2.some((ds) => ds.aggregateRecord && ds.aggregateRecord === true);
          const basicUnitsPromises = rangeListChunks2.map((range) => {
            return store2.state.job.tpRest("GetUnitData2", { alignmentId, areaIds: areaIds2, dataSourceIds: dataSourceIds2, firstId: range.first, lastId: range.last, isBasicFieldsRequest, hasAggregateData: hasAggregateData2, unitIds, containerIds }).then((response) => {
              const units = response.units.map((ua) => {
                if (isBasicFieldsRequest) {
                  return { Id: ua.Id, AreaId: ua.maps__Area__c || "", DataSourceId: ua.maps__DataSourceId__c, UnitId: ua.maps__UnitId__c, ContainerId: ua.maps__ContainerId__c, Latitude: ua.maps__Location__Latitude__s, Longitude: ua.maps__Location__Longitude__s };
                }
                return { Id: ua.Id, Metadata: JSON.parse(ua.Metadata), Config: JSON.parse(ua.Config), AggregateUnits: JSON.parse(ua.AggregateUnits1 + (ua.AggregateUnits2 || "")) };
              });
              return units;
            }).catch((event) => {
              var _a, _b, _c, _d;
              const message = ((_b = (_a = event == null ? void 0 : event.response) == null ? void 0 : _a.data) == null ? void 0 : _b.length) > 0 ? (_d = (_c = event == null ? void 0 : event.response) == null ? void 0 : _c.data[0]) == null ? void 0 : _d.message : event.message;
              if (["length exceeds maximum", "heap size limit", "maximum size of request reached", "apex heap size too large", "response size exceeded maximum"].find((msg) => message.toLowerCase().includes(msg))) {
                if (chunkSize < 10)
                  throw new Error(`BAD response from salesforce ${message}.`);
                const newOptions = {
                  ...opts,
                  firstUnitId: range.first,
                  lastUnitId: range.last,
                  chunkSize: Math.trunc(chunkSize / 2),
                  //chunk size is ignored if range list chunks are provided
                  // Use the current batches first / last id and half the  existing chunk size to calculate an updated range list
                  rangeListChunks: store2.state.job.utils.PkChunking.splitIdChunk(range.first, range.last, 2)
                };
                return getUnitsConcurrent(newOptions);
              }
              throw event.message;
            });
          });
          return Promise.all(basicUnitsPromises);
        };
        const getUnitDataByIdConcurrent = async (opts) => {
          const { alignmentId, unitIds = [], progress = () => {
          }, isBasicFieldsRequest, hasAggregateData: hasAggregateData2, chunkSize = 5e3 } = opts;
          const batches = [];
          for (let i2 = 0; i2 < unitIds.length; i2 += chunkSize) {
            const batchIds = unitIds.slice(i2, i2 + chunkSize);
            batches.push(batchIds);
          }
          const extendedDataPromises = batches.map(
            (batchIds) => store2.state.job.tpRest("GetUnitDataById", { unitIds: batchIds, alignmentId, isBasicFieldsRequest, hasAggregateData: hasAggregateData2 }).then((response) => {
              const extendedUnits2 = response.units.map((ua) => {
                if (isBasicFieldsRequest) {
                  return { Id: ua.Id, AreaId: ua.maps__Area__c || "", DataSourceId: ua.maps__DataSourceId__c, UnitId: ua.maps__UnitId__c, ContainerId: ua.maps__ContainerId__c, Latitude: ua.maps__Location__Latitude__s, Longitude: ua.maps__Location__Longitude__s };
                }
                return { Id: ua.Id, Metadata: JSON.parse(ua.Metadata), Config: JSON.parse(ua.Config), AggregateUnits: JSON.parse(ua.AggregateUnits1 + (ua.AggregateUnits2 || "")) };
              });
              return extendedUnits2;
            }).catch((event) => {
              var _a, _b, _c, _d;
              const message = ((_b = (_a = event == null ? void 0 : event.response) == null ? void 0 : _a.data) == null ? void 0 : _b.length) > 0 ? (_d = (_c = event == null ? void 0 : event.response) == null ? void 0 : _c.data[0]) == null ? void 0 : _d.message : event.message;
              if (["length exceeds maximum", "heap size limit", "maximum size of request reached", "apex heap size too large", "response size exceeded maximum"].find((msg) => message.toLowerCase().includes(msg))) {
                if (chunkSize < 100)
                  throw new Error(`BAD response from salesforce ${message}.`);
                const newOptions = { ...opts, unitIds: batchIds, chunkSize: Math.trunc(chunkSize / 2) };
                return getUnitDataByIdConcurrent(newOptions);
              }
              throw event.message;
            })
          );
          return Promise.all(extendedDataPromises).then((extendedUnits2) => extendedUnits2);
        };
        const areaIds = payload.areaIds.map((id) => id.includes("Unassigned") ? "" : id);
        const dataSourceIds = payload.dataSourceIds;
        let basicUnits = [];
        const rangeListChunks = await getDefragmentedRangeList({
          alignmentId: store2.state.alignmentId,
          areaIds,
          dataSourceIds,
          firstUnitId: store2.state.firstUnitId,
          lastUnitId: store2.state.lastUnitId,
          unitCount: store2.state.unitCount,
          chunkSize: store2.state.settings.BasicUnitChunkSize
        });
        const unitChunks = await getUnitsConcurrent({
          alignmentId: store2.state.alignmentId,
          isBasicFieldsRequest: true,
          // retrieve fixed size unit data
          areaIds,
          dataSourceIds,
          firstUnitId: store2.state.firstUnitId,
          lastUnitId: store2.state.lastUnitId,
          chunkSize: store2.state.settings.BasicUnitChunkSize,
          rangeListChunks
        });
        basicUnits = unitChunks.flat(Infinity);
        const hasAggregateData = store2.state.alignmentConfig.dataSources.some((ds) => dataSourceIds.includes(ds.id) && ds.aggregateRecords && ds.aggregateRecords === true);
        const extendedUnits = await getUnitDataByIdConcurrent({
          alignmentId: store2.state.alignmentId,
          areaIds,
          dataSourceIds,
          unitIds: basicUnits.map((unit) => unit.Id),
          isBasicFieldsRequest: false,
          // whether to retrieve basic /fixed size field data or large object data like metadata and config fields
          hasAggregateData,
          chunkSize: store2.state.settings.ExtendedUnitChunkSize
        });
        const unitsLookup = new Map(basicUnits.map((unit) => [unit.Id, unit]));
        extendedUnits.flat(Infinity).forEach((extendedUnit) => {
          const unit = unitsLookup.get(extendedUnit.Id);
          for (const property in extendedUnit) {
            unit[property] = extendedUnit[property];
          }
        });
        store2.state.units = Array.from(unitsLookup.values());
        store2.state.liveRecords = /* @__PURE__ */ new Set();
        if (store2.state.alignmentConfig.isLive) {
          const unitIds = null;
          const { liveRecords, error } = await LiveDataUtils.getLiveData({ dataSources: [store2.state.alignmentConfig.dataSources[0]], unitIds });
          if (error)
            return { error };
          payload.selectedAreaIds ? payload.selectedAreaIds.concat(payload.includeUnassigned ? [""] : []) : [];
          store2.state.units.forEach((ua) => {
            const liveRecordId = `${ua.DataSourceId}-${ua.UnitId}`;
            const liveRecord = liveRecords[liveRecordId];
            if (liveRecord) {
              Object.assign(ua.Metadata, liveRecord.Metadata);
              const validLatLong = LiveDataUtils.GeoLocation.isLatitude(liveRecord.Latitude) && LiveDataUtils.GeoLocation.isLongitude(liveRecord.Longitude);
              ua.Latitude = validLatLong ? liveRecord.Latitude : "";
              ua.Longitude = validLatLong ? liveRecord.Longitude : "";
              delete liveRecords[liveRecordId];
            }
          });
        }
        store2.state.units.forEach((u) => u.AreaId = u.AreaId || "");
        if (store2.state.allowContainerData && store2.state.units.find((u) => u.ContainerId)) {
          const containerIdToContainerSetIdMap = {};
          await store2.state.job.utils.Async.forEach(store2.state.alignmentConfig.containerSets, async (currentContainerSet) => {
            const containerData = await store2.state.job.containerS3Client.get(`${currentContainerSet.id}/containers.json`);
            containerData.forEach((c) => containerIdToContainerSetIdMap[c.name] = currentContainerSet.id);
          });
          store2.state.units.filter((u) => u.DataSourceId === "Container").forEach((unit) => {
            unit.ContainerSetId = containerIdToContainerSetIdMap[unit.ContainerId];
          });
        }
        const includeContainers = !!store2.state.units.find((u) => u.DataSourceId === "Container");
        store2.state.alignmentConfig.containerSets.forEach((containerSet) => {
          if (includeContainers && !store2.state.alignmentConfig.dataSources.find((ds) => ds.id === containerSet.id)) {
            store2.state.alignmentConfig.dataSources.push({
              id: containerSet.id,
              name: store2.state.containerSets.find((cs) => cs.id === containerSet.id).label,
              type: "GEO"
            });
          }
        });
        store2.state.alignmentConfig.dataSources.forEach((ds) => {
          ds.metadataFields = ds.metadataFields || [];
        });
        await store2.dispatch("calculateAttributes");
        return "";
      },
      async loadUnitBatch(store2, payload) {
        const unitBatch = await store2.state.job.tpRest("GetUnitData", {
          alignmentId: store2.state.alignmentId,
          areaIds: payload.areaIds.map((id) => id.includes("Unassigned") ? "" : id),
          dataSourceIds: payload.dataSourceIds,
          lastId: payload.lastId
        });
        store2.state.units = unitBatch.units;
        store2.state.units.forEach((u) => u.AreaId = u.AreaId || "");
        if (store2.state.allowContainerData && store2.state.units.find((u) => u.ContainerId)) {
          const containerIdToContainerSetIdMap = {};
          await store2.state.job.utils.Async.forEach(store2.state.alignmentConfig.containerSets, async (currentContainerSet) => {
            const containerData = await store2.state.job.containerS3Client.get(`${currentContainerSet.id}/containers.json`);
            containerData.forEach((c) => containerIdToContainerSetIdMap[c.name] = currentContainerSet.id);
          });
          store2.state.units.filter((u) => u.DataSourceId === "Container").forEach((unit) => {
            unit.ContainerSetId = containerIdToContainerSetIdMap[unit.ContainerId];
          });
        }
        const includeContainers = !!store2.state.units.find((u) => u.DataSourceId === "Container");
        store2.state.alignmentConfig.containerSets.forEach((containerSet) => {
          if (includeContainers && !store2.state.alignmentConfig.dataSources.find((ds) => ds.id === containerSet.id)) {
            store2.state.alignmentConfig.dataSources.push({
              id: containerSet.id,
              name: store2.state.containerSets.find((cs) => cs.id === containerSet.id).label,
              type: "GEO"
            });
          }
        });
        store2.state.alignmentConfig.dataSources.forEach((ds) => {
          ds.metadataFields = ds.metadataFields || [];
        });
        await store2.dispatch("calculateAttributes");
        return unitBatch.lastId;
      },
      async calculateAttributes(store2) {
        const areaIdMap = store2.getters.getAreaIdMap();
        const containerUnitsMap = {};
        const areaUnitsMap = {};
        store2.state.units.forEach((u) => {
          if (u.ContainerId && u.DataSourceId !== "Container") {
            containerUnitsMap[u.ContainerId] = containerUnitsMap[u.ContainerId] || [];
            containerUnitsMap[u.ContainerId].push(u);
          }
          areaUnitsMap[u.AreaId] = areaUnitsMap[u.AreaId] || [];
          areaUnitsMap[u.AreaId].push(u);
        });
        areaUnitsMap.Unassigned = areaUnitsMap[""];
        delete areaUnitsMap[""];
        store2.state.units.forEach((u) => {
          u.CalculatedMetadata = u.CalculatedMetadata || {};
          u.SpecialMetadata = u.SpecialMetadata || {};
        });
        (function init(areas) {
          areas.forEach((a) => {
            if (a.id.startsWith("placeholder-")) {
              const mappedAreaId = a.id.match(/[^-]*$/g)[0];
              areaUnitsMap[a.id] = areaUnitsMap[mappedAreaId];
            }
            a.CalculatedMetadata = a.CalculatedMetadata || {};
            a.SpecialMetadata = a.SpecialMetadata || {};
            a.SpecialMetadata.AssignedUnitCount = (areaUnitsMap[a.id] || []).length;
            init(a.areas);
            a.SpecialMetadata.UnitCount = (areaUnitsMap[a.id] || []).filter((u) => u.DataSourceId !== "Container").length + a.areas.reduce((total, child) => {
              if (child.id === "Unassigned") {
                return 0;
              }
              if (child.id.startsWith("placeholder-")) {
                return total;
              }
              return total + child.SpecialMetadata.UnitCount;
            }, 0);
          });
        })(store2.state.areas);
        store2.state.units.forEach((u) => {
          var _a, _b, _c;
          u.SpecialMetadata.UnitCount = u.DataSourceId === "Container" ? (containerUnitsMap[u.ContainerId] || []).length : 1;
          u.SpecialMetadata.Assignment = (_a = areaIdMap[u.AreaId || "Unassigned"]) == null ? void 0 : _a.name;
          u.SpecialMetadata.OwnerId = ((_b = areaIdMap[u.AreaId || "Unassigned"]) == null ? void 0 : _b.config.ownerId) || "";
          u.SpecialMetadata.OwnerName = ((_c = areaIdMap[u.AreaId || "Unassigned"]) == null ? void 0 : _c.ownerName) || "";
        });
        const attributesToCalculate = [...store2.getters.getCalcAtts];
        let calcAtt;
        let waitingAttributeCount = 0;
        while (calcAtt = attributesToCalculate.shift()) {
          if (waitingAttributeCount > attributesToCalculate.length) {
            throw new Error(`Unable to calculate attributes, please make sure there are no circular references.  First invalid attribute: ${calcAtt.name}`);
          }
          let hasUncalculatedVariables = false;
          calcAtt.dataSources.map((ds) => ds.expression || "[]").forEach((expression) => {
            new MathExpression(expression).variableNames.forEach((variableName) => {
              if ([...attributesToCalculate, calcAtt].find((a) => a.id === variableName)) {
                hasUncalculatedVariables = true;
              }
            });
          });
          if (hasUncalculatedVariables) {
            attributesToCalculate.push(calcAtt);
            waitingAttributeCount++;
            continue;
          }
          waitingAttributeCount = 0;
          if (calcAtt.type === "Unit") {
            store2.state.units.filter((u) => u.DataSourceId !== "Container").forEach((unit) => {
              const dataSource = store2.state.alignmentConfig.dataSources.find((ds) => ds.id === unit.DataSourceId);
              const expression = new MathExpression((calcAtt.dataSources.find((ut) => ut.id === unit.DataSourceId) || {}).expression || "[]");
              const variableValues = /* @__PURE__ */ new Map();
              expression.variableNames.forEach((variableName) => {
                variableValues.set(variableName, 0);
                const variableParts = variableName.split(":");
                if (variableParts.length === 2 && ["MIN", "MAX", "SUM", "AVG"].includes(variableParts[0])) {
                  const functionName = variableParts[0];
                  const fieldLabel = variableParts[1];
                  const attrName = (dataSource.metadataFields.find((f) => f.label === fieldLabel) || {}).name || "";
                  if (dataSource.attributeSummary.metadataFields[attrName]) {
                    variableValues.set(variableName, dataSource.attributeSummary.metadataFields[attrName][functionName] || 0);
                  }
                } else if (variableParts.length === 2 && ["Unit"].includes(variableParts[0])) {
                  variableValues.set(variableName, unit.CalculatedMetadata[variableName] || 0);
                } else {
                  const attrName = (dataSource.metadataFields.find((f) => f.label === variableName) || {}).name || "";
                  variableValues.set(variableName, unit.Metadata[attrName] || 0);
                }
              });
              unit.CalculatedMetadata[calcAtt.id] = expression.evaluate(variableValues);
            });
            store2.state.units.filter((u) => u.DataSourceId === "Container").forEach((unit) => {
              unit.CalculatedMetadata[calcAtt.id] = 0;
              (containerUnitsMap[unit.ContainerId] || []).forEach((childUnit) => {
                unit.CalculatedMetadata[calcAtt.id] += childUnit.CalculatedMetadata[calcAtt.id];
              });
            });
            store2.state.hierarchyLevels.slice().reverse().forEach((level, levelIndex) => {
              store2.getters.getAreasByLevel(level).forEach((area) => {
                const realAreaId = area.id.split("-").pop().replace(/^Unassigned$/, "");
                if (levelIndex === 0 || area.id !== "Unassigned" && (area.areas.length === 0 && area.SpecialMetadata.AssignedUnitCount > 0)) {
                  area.CalculatedMetadata[calcAtt.id] = store2.state.units.filter((u) => u.DataSourceId !== "Container" && u.AreaId === realAreaId).reduce((total, unit) => total + unit.CalculatedMetadata[calcAtt.id], 0);
                } else if (area.id !== "Unassigned" && (area.areas.length > 0 || area.SpecialMetadata.AssignedUnitCount > 0)) {
                  area.CalculatedMetadata[calcAtt.id] = area.areas.reduce((total, area2) => total + area2.CalculatedMetadata[calcAtt.id], 0) + store2.state.units.filter((u) => u.DataSourceId !== "Container" && u.AreaId === realAreaId).reduce((total, unit) => total + unit.CalculatedMetadata[calcAtt.id], 0);
                } else {
                  area.CalculatedMetadata[calcAtt.id] = area.areas.reduce((total, area2) => total + area2.CalculatedMetadata[calcAtt.id], 0);
                }
              });
            });
          } else if (calcAtt.type === "Container") {
            if (!store2.state.allowContainerData)
              continue;
            store2.state.units.filter((u) => u.DataSourceId === "Container").forEach((unit) => {
              const dataSource = store2.state.alignmentConfig.dataSources.find((ds) => ds.id === unit.ContainerSetId);
              const expression = new MathExpression((calcAtt.dataSources.find((ut) => ut.id === unit.ContainerSetId) || {}).expression || "[]");
              const variableValues = /* @__PURE__ */ new Map();
              expression.variableNames.forEach((variableName) => {
                variableValues.set(variableName, 0);
                const variableParts = variableName.split(":");
                if (variableParts.length === 2 && ["Unit", "Container"].includes(variableParts[0])) {
                  variableValues.set(variableName, unit.CalculatedMetadata[variableName] || 0);
                } else {
                  const containerField = store2.getters.getDataSourceFields(dataSource.id).find((f) => f.label === variableName) || {};
                  variableValues.set(
                    variableName,
                    containerField.type === "Metadata" ? unit.Metadata[containerField.id.replace(/^Metadata:/, "")] || 0 : unit.CalculatedMetadata[containerField.id] || 0
                  );
                }
              });
              unit.CalculatedMetadata[calcAtt.id] = expression.evaluate(variableValues);
            });
          } else if (calcAtt.type === "Area") {
            store2.state.hierarchyLevels.slice().reverse().forEach((level, levelIndex) => {
              store2.getters.getAreasByLevel(level).forEach((area) => {
                const expression = new MathExpression((calcAtt.dataSources.find((ut) => ut.id === "Area") || {}).expression || "[]");
                const variableValues = /* @__PURE__ */ new Map();
                expression.variableNames.forEach((variableName) => {
                  variableValues.set(variableName, 0);
                  const variableParts = variableName.split(":");
                  if (variableParts.length === 2 && ["PARENT", "CHILDREN"].includes(variableParts[0])) {
                    const functionName = variableParts[0];
                    const fieldLabel = variableParts[1];
                    const attrName = (store2.state.alignmentConfig.areaMetadataFields.find((f) => f.label === fieldLabel) || {}).name || "";
                    if (functionName === "PARENT") {
                      const parentArea = store2.getters.getParentArea(area);
                      if (parentArea)
                        variableValues.set(variableName, (parentArea.metadata || {})[attrName] || 0);
                    } else if (functionName === "CHILDREN") {
                      variableValues.set(variableName, area.areas.reduce((total, childArea) => total + ((childArea.metadata || {})[attrName] || 0), 0));
                    }
                  } else if (variableParts.length === 2 && ["Unit", "Container", "Area"].includes(variableParts[0])) {
                    variableValues.set(variableName, area.CalculatedMetadata[variableName] || 0);
                  } else {
                    const areaField = store2.getters.getAreaFields(level).find((f) => f.label === variableName) || {};
                    variableValues.set(
                      variableName,
                      areaField.type === "Metadata" ? area.metadata[areaField.id.replace(/^Metadata:/, "")] || 0 : area.CalculatedMetadata[areaField.id] || 0
                    );
                  }
                });
                area.CalculatedMetadata[calcAtt.id] = expression.evaluate(variableValues);
              });
            });
          }
        }
      },
      async openAlignment(store2, payload) {
        const alignmentResponse = await store2.state.job.tpRest("GetAlignment", { alignmentId: payload.id, areaId: "" });
        Object.assign(store2.state, {
          dataSetConfig: JSON.parse(alignmentResponse.dataSetConfig),
          alignmentId: alignmentResponse.id,
          alignmentConfig: Object.assign({}, JSON.parse(alignmentResponse.dataSetConfig), JSON.parse(alignmentResponse.config))
        });
        if (store2.state.alignmentConfig.pkChunkingMetadata) {
          const { firstUnitId, lastUnitId, unitCount } = store2.state.alignmentConfig.pkChunkingMetadata;
          store2.state.firstUnitId = firstUnitId;
          store2.state.lastUnitId = lastUnitId;
          store2.state.unitCount = unitCount;
        }
        store2.state.dataSetConfig.dataSources.forEach((ds) => {
          const alignmentDataSource = store2.state.alignmentConfig.dataSources.find((alignmentDS) => alignmentDS.id === ds.id);
          ds.metadataFields.forEach((field) => {
            if (!alignmentDataSource.metadataFields.find((f) => f.name === field.name)) {
              alignmentDataSource.metadataFields.push(JSON.parse(JSON.stringify(field)));
            }
          });
        });
        store2.state.alignmentConfig.containerSets = store2.state.alignmentConfig.containerSets || [];
        if (store2.state.alignmentConfig.containerSetId) {
          store2.state.alignmentConfig.containerSets = [{ id: store2.state.alignmentConfig.containerSetId, filter: [] }];
        }
        store2.state.alignmentConfig.calcAtts = store2.state.alignmentConfig.calcAtts || [];
        store2.state.alignmentConfig.calcAtts.forEach((calcAtt) => {
          calcAtt.dataType = "Number";
          if (calcAtt.calcAttId)
            calcAtt.calcAttId = `${calcAtt.calcAttType || "Unit"}:${calcAtt.calcAttId}`;
          const fieldMap = { calcAttId: "id", attName: "name", calcAttType: "type", unitTypes: "dataSources" };
          Object.keys(fieldMap).forEach((oldProperty) => {
            if (calcAtt[oldProperty]) {
              calcAtt[fieldMap[oldProperty]] = calcAtt[oldProperty];
              delete calcAtt[oldProperty];
            }
          });
          calcAtt.dataSources.forEach((dataSource) => {
            if (dataSource.unitTypeId) {
              dataSource.id = dataSource.unitTypeId.replace(/^Geo_/, "");
              delete dataSource.unitTypeId;
            }
          });
        });
      }
    };
    const MAX_TERRITORY_LIMIT = 500;
    const MAX_ATTRIBUTES_LIMIT = 5;
    const _sfc_main$2 = {
      name: "StampTerritoryModal",
      components: {
        Spinner,
        Button,
        ButtonIcon,
        Icon,
        Picklist,
        Modal
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          unitsPromise: null,
          loading: true,
          stamping: false,
          tpStore: null,
          availableAttrs: [],
          selectedAttr: null,
          addedAttrs: [],
          nonTerritoryFields: [],
          attrOptions: [{
            options: async (term) => this.availableAttrs.filter((attr) => attr.label.toLowerCase().includes(term.toLowerCase()) && !this.addedAttrs.find((a) => a.id === attr.id))
          }]
        };
      },
      computed: {
        picklistDisabled() {
          return this.addedAttrs.length >= MAX_ATTRIBUTES_LIMIT;
        },
        tooManyTerritories() {
          var _a;
          return ((_a = this.tpStore) == null ? void 0 : _a.getters.getNumAreas()) > MAX_TERRITORY_LIMIT;
        },
        modalTitle() {
          return `Stamp "${this.config.alignment.Name}"`;
        },
        territoryLimit() {
          return MAX_TERRITORY_LIMIT;
        }
      },
      watch: {
        selectedAttr: {
          handler() {
            if (this.selectedAttr) {
              this.addedAttrs.push(this.selectedAttr);
              this.selectedAttr = null;
            }
          }
        }
      },
      async mounted() {
        const excludedAttrs = ["Special:SpanOfControl", "Special:Parent", "Property:name", "Special:Owner", "Special:OwnerId"];
        this.tpStore = await this.openAlignmentStore(this.config.alignment.Id);
        this.tpStore.state.hierarchyLevels.forEach((level) => {
          const levelAttrs = this.tpStore.getters.getAreaFields(level).filter((a) => !excludedAttrs.includes(a.id));
          this.availableAttrs = this.availableAttrs.concat(levelAttrs.filter((attr) => !this.availableAttrs.find((a) => a.id === attr.id)));
        });
        this.availableAttrs.forEach((attr) => attr.type = "Territory");
        if (this.config.update) {
          const referenceFields = JSON.parse(this.$store.segment.sfsp__ReferenceFields__c).filter((f) => f.type === "Territory");
          referenceFields.forEach((rf) => {
            if (this.availableAttrs.find((a) => a.id === rf.id)) {
              this.addedAttrs.push(rf);
            }
          });
        }
        this.loading = false;
      },
      methods: {
        /*  // Demo for showing all data fields and iterate over all areas
        // Uncomment and run function and see alignment data in browser console
        async demoTpData(alignmentId) {
            const tpStore = await this.openAlignmentStore(alignmentId);
            tpStore.state.hierarchyLevels.forEach(level => {
                console.log(`Fields for level ${level}`);
                const areaFields = tpStore.getters.getAreaFields(level);
                const areas = tpStore.getters.getAreasByLevel(level);
                console.log(areaFields);
                areas.forEach(area => {
                    areaFields.forEach(field => {
                        try {
                            const fieldValue = SPM.Utils.Area.getFieldValue(tpStore, area, field.id);
                            console.log(`${field.label} - Id: ${field.id} - Value: ${fieldValue}`);
                        } catch (error) {
                            console.log(error);
                        }
                    });
                });
            });
        }, */
        // Invoke to instantiate tp store
        async openAlignmentStore(alignmentId) {
          const tpStore = createStore({
            state: Object.assign(JSON.parse(JSON.stringify(state)), { storeIndex: 1, color: "#4EBA8B" }),
            getters,
            actions
          });
          tpStore.state.job = {
            tpRest(action, data) {
              return SPM.Utils.Rest.invoke("tpRest", { action, data });
            }
          };
          await tpStore.dispatch("openAlignment", { id: alignmentId });
          const hierarchyResponse = await SPM.Utils.Rest.invoke("tpRest", { action: "GetAlignmentHierarchy", data: { alignmentId } });
          tpStore.state.hierarchyLevels = hierarchyResponse.hierarchyLevels;
          tpStore.state.areas = hierarchyResponse.areas;
          tpStore.state.activeLevel = tpStore.state.hierarchyLevels.slice(-1)[0];
          (function trimFocus(parent, levelIndex) {
            for (let i2 = parent.areas.length - 1; i2 >= 0; i2--) {
              const area = parent.areas[i2];
              area.level = tpStore.state.hierarchyLevels[levelIndex];
              area.ownerName = (hierarchyResponse.owners.find((o) => o.Id.slice(0, 15) === area.config.ownerId) || {}).Name || "";
              if (area.areas.length > 0) {
                trimFocus(area, levelIndex + 1);
                if (area.areas.length === 0)
                  parent.areas.splice(i2, 1);
              }
            }
          })(tpStore.state, 0);
          if (tpStore.state.settings.Base62PKChunking) {
            this.unitsPromise = tpStore.dispatch("loadUnitsConcurrent", {
              areaIds: [],
              dataSourceIds: [],
              lastId: void 0
            });
          } else {
            this.unitsPromise = new Promise((resolveUnits, rejectUnits) => {
              const getUnitBatch = async (lastId) => {
                lastId = await tpStore.dispatch("loadUnitBatch", {
                  areaIds: [],
                  dataSourceIds: [],
                  lastId
                });
                if (!lastId) {
                  resolveUnits();
                } else {
                  return getUnitBatch(lastId);
                }
              };
              getUnitBatch("");
            });
          }
          return tpStore;
        },
        removeAttr(attr) {
          const attrId = attr.currentTarget.id.slice(attr.currentTarget.id.indexOf("addAttr-") + "addAttr-".length, attr.currentTarget.id.indexOf("-remove"));
          this.addedAttrs.splice(this.addedAttrs.findIndex((a) => a.id === attrId), 1);
        },
        async deletePreviousStamp() {
          this.nonTerritoryFields = await territoryStampUtils.deleteTerritoryStamp(this.$store);
          this.nonTerritoryFields.push({
            id: this.config.alignment.Id,
            name: this.config.alignment.Name,
            createdDate: Date.now(),
            type: "Territory Stamp"
          });
        },
        async getAreaFieldValues(area, areaFields) {
          const areaFieldValues = {};
          areaFields.forEach((field) => {
            if (this.addedAttrs.find((a) => a.id === field.id)) {
              try {
                if (field.dataType === "Number") {
                  areaFieldValues[field.id] = { SUM: SPM.Utils.Area.getFieldValue(this.tpStore, area, field.id) };
                } else {
                  areaFieldValues[field.id] = { VALUE: SPM.Utils.Area.getFieldValue(this.tpStore, area, field.id) };
                }
              } catch (e) {
              }
            }
          });
          return areaFieldValues;
        },
        async createStamp() {
          var _a;
          const referenceFields = this.addedAttrs.concat(this.nonTerritoryFields);
          const segmentNode = {
            sobjectType: "sfsp__SalesNode__c",
            Id: this.$store.segment.Id,
            sfsp__ReferenceFields__c: JSON.stringify(referenceFields)
          };
          await SPM.Utils.CRM.upsert({ records: [].concat(segmentNode) });
          const idMap = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 < this.tpStore.state.hierarchyLevels.length; i2++) {
            const level = this.tpStore.state.hierarchyLevels[i2];
            const recordsToCreate = [];
            const areas = this.tpStore.getters.getAreasByLevel(level);
            const areaFields = this.tpStore.getters.getAreaFields(level);
            for (let j = 0; j < areas.length; j++) {
              const area = areas[j];
              const areaFieldValues = await this.getAreaFieldValues(area, areaFields);
              const ownerId = await SPM.Utils.Area.getFieldValue(this.tpStore, area, "Special:OwnerId");
              const node = {
                sobjectType: "sfsp__SalesNode__c",
                Name: area.name,
                sfsp__Segment__c: this.$store.segment.Id,
                sfsp__Parent__c: this.tpStore.getters.getParentArea(area) ? (_a = idMap.get(this.tpStore.getters.getParentArea(area).id)) == null ? void 0 : _a.Id : "",
                sfsp__Owner__c: ownerId,
                sfsp__HierarchyReferenceData__c: JSON.stringify(areaFieldValues)
              };
              idMap.set(area.id, node);
              recordsToCreate.push(node);
            }
            await SPM.Utils.CRM.upsert({ records: recordsToCreate });
          }
        },
        async finish() {
          this.stamping = true;
          const startTime = window.performance.now();
          try {
            await this.unitsPromise;
            await this.deletePreviousStamp();
            await this.createStamp();
            const activityRecords = [];
            activityRecords.push({
              name: this.config.update ? `Updated territory stamp ${this.config.alignment.Name}` : `Stamped territory alignment ${this.config.alignment.Name}`,
              description: `Captured ${this.tpStore.getters.getNumAreas()} territories in the alignment.`,
              nodeId: this.$store.segment.Id,
              parentId: this.$store.segment.sfsp__SalesPlan__c,
              type: "Territory Stamp",
              subtype: this.config.update ? ActivitySubtypes.UPDATE : ActivitySubtypes.CREATE
            });
            await insertActivities(activityRecords);
            const pendoPayload = {
              segmentId: this.$store.segment.Id,
              planId: this.$store.segment.sfsp__SalesPlan__r.Id,
              nTerritories: this.tpStore.getters.getNumAreas(),
              nAttributes: this.addedAttrs.length + 2,
              // +2 to include Territory and Owner
              update: this.config.update
            };
            SPM.$store.trackPendoEvent({ actionType: "SP | Segmentation - Stamp Territories", pendoPayload });
            SPM.Utils.Splunk.sendLog({
              logName: "spmStampingTerritoriesJob",
              logPayload: {
                planId: this.$store.segment.sfsp__SalesPlan__r.Id,
                segmentId: this.$store.segment.Id,
                nTerritories: this.tpStore.getters.getNumAreas(),
                nAttributes: this.addedAttrs.length + 2,
                executionTime: window.performance.now() - startTime,
                status: "SUCCESS"
              }
            });
            SPM.$store.toast({ state: "success", message: "Stamping territories succeeded.", duration: 5e3 });
          } catch (error) {
            SPM.$store.toast({ state: "error", message: "Stamping territories failed." });
          } finally {
            this.config.callback();
            this.$emit("close");
          }
        },
        cancel() {
          this.$emit("close");
        }
      }
    };
    const _withScopeId$1 = (n) => (pushScopeId("data-v-42fc156d"), n = n(), popScopeId(), n);
    const _hoisted_1$2 = { key: 0 };
    const _hoisted_2$2 = { class: "slds-align_absolute-center" };
    const _hoisted_3$2 = { class: "slds-m-left_xx-large slds-m-right_xx-large slds-size_7-of-12" };
    const _hoisted_4$2 = { class: "slds-align_absolute-center" };
    const _hoisted_5$2 = { class: "slds-m-bottom_medium" };
    const _hoisted_6$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("tr", null, [
      /* @__PURE__ */ createBaseVNode("td", { class: "slds-align_absolute-center slds-text-align_center" }, [
        /* @__PURE__ */ createBaseVNode("div", { class: "errorContentHeader" }, "Territory Limit Reached")
      ])
    ], -1));
    const _hoisted_7$1 = { class: "slds-align_absolute-center slds-text-align_center" };
    const _hoisted_8$1 = { class: "errorContentBody" };
    const _hoisted_9$1 = {
      key: 0,
      class: "slds-p-around_large"
    };
    const _hoisted_10$1 = { style: { "height": "100px" } };
    const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("tr", null, [
      /* @__PURE__ */ createBaseVNode("td", null, [
        /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-align_center" }, "Stamping territories...")
      ])
    ], -1));
    const _hoisted_12$1 = { key: 1 };
    const _hoisted_13$1 = { class: "searchBody" };
    const _hoisted_14 = { class: "slds-col slds-p-around_medium" };
    const _hoisted_15 = {
      class: "slds-media slds-listbox__option slds-listbox__option_plain",
      role: "option"
    };
    const _hoisted_16 = { class: "slds-media__body" };
    const _hoisted_17 = ["title"];
    const _hoisted_18 = {
      key: 0,
      class: "attrLimitReached slds-box slds-box_x-small slds-grid slds-m-top_small"
    };
    const _hoisted_19 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-m-left_small" }, "Attribute limit reached.", -1));
    const _hoisted_20 = { class: "searchSelection slds-p-around_medium" };
    const _hoisted_21 = {
      id: "added-attributes",
      class: "slds-table"
    };
    const _hoisted_22 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("tr", null, [
      /* @__PURE__ */ createBaseVNode("td", { class: "attrHeader" }, "Attribute"),
      /* @__PURE__ */ createBaseVNode("td", { class: "slds-size_2-of-12" })
    ], -1));
    const _hoisted_23 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("td", { class: "attrBody" }, "Territory", -1));
    const _hoisted_24 = { class: "slds-size_2-of-12 slds-align_absolute-center" };
    const _hoisted_25 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("td", { class: "attrBody" }, "Owner", -1));
    const _hoisted_26 = { class: "slds-size_2-of-12 slds-align_absolute-center" };
    const _hoisted_27 = ["id"];
    const _hoisted_28 = { class: "attrBody" };
    const _hoisted_29 = { class: "slds-size_2-of-12 slds-align_absolute-center" };
    const _hoisted_30 = { key: 0 };
    const _hoisted_31 = { class: "slds-grid" };
    const _hoisted_32 = { class: "slds-col_bump-left" };
    const _hoisted_33 = {
      key: 1,
      class: "slds-grid"
    };
    const _hoisted_34 = { class: "slds-col_bump-left" };
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        id: "stamp-territory-modal",
        ref: "modal",
        size: "base",
        title: $options.modalTitle,
        footless: $data.stamping,
        onClose: $options.cancel
      }, {
        tagline: withCtx(() => [
          createTextVNode(" Existing stamp data will be overwritten. ")
        ]),
        content: withCtx(() => {
          var _a;
          return [
            $options.tooManyTerritories ? (openBlock(), createElementBlock("div", _hoisted_1$2, [
              createBaseVNode("div", _hoisted_2$2, [
                createBaseVNode("table", _hoisted_3$2, [
                  createBaseVNode("tr", null, [
                    createBaseVNode("td", _hoisted_4$2, [
                      createBaseVNode("div", _hoisted_5$2, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: "error",
                          size: "large",
                          variant: "error",
                          iconClass: ["slds-input__icon"]
                        })
                      ])
                    ])
                  ]),
                  _hoisted_6$1,
                  createBaseVNode("tr", null, [
                    createBaseVNode("td", _hoisted_7$1, [
                      createBaseVNode("div", _hoisted_8$1, "Please reduce the total amount of territories to fewer than " + toDisplayString($options.territoryLimit) + " or select a different alignment.", 1)
                    ])
                  ])
                ])
              ])
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              $data.stamping ? (openBlock(), createElementBlock("div", _hoisted_9$1, [
                createBaseVNode("table", null, [
                  createBaseVNode("tr", null, [
                    createBaseVNode("td", _hoisted_10$1, [
                      createVNode(_component_Spinner, {
                        size: "large",
                        theme: "brand",
                        withoutContainer: ""
                      })
                    ])
                  ]),
                  _hoisted_11$1
                ])
              ])) : (openBlock(), createElementBlock("div", _hoisted_12$1, [
                createBaseVNode("div", _hoisted_13$1, [
                  createBaseVNode("div", _hoisted_14, [
                    createVNode(_component_Picklist, {
                      id: "attrLookup",
                      ref: "attrLookup",
                      modelValue: (_a = $data.selectedAttr) == null ? void 0 : _a.id,
                      options: $data.attrOptions,
                      labelForId: "attrLookup",
                      labels: { name: "Add Attributes", search: "Search..." },
                      titleKey: "label",
                      idKey: "id",
                      filterable: "",
                      disabled: $options.picklistDisabled,
                      onSelectedOption: _cache[0] || (_cache[0] = (attr) => $data.selectedAttr = attr),
                      onClear: _cache[1] || (_cache[1] = () => $data.selectedAttr = null)
                    }, {
                      option: withCtx((item) => [
                        createBaseVNode("div", _hoisted_15, [
                          createBaseVNode("span", _hoisted_16, [
                            createBaseVNode("span", {
                              class: "slds-truncate",
                              title: item.option.label
                            }, toDisplayString(item.option.label), 9, _hoisted_17)
                          ])
                        ])
                      ]),
                      _: 1
                    }, 8, ["modelValue", "options", "labels", "disabled"]),
                    $options.picklistDisabled ? (openBlock(), createElementBlock("div", _hoisted_18, [
                      createVNode(_component_Icon, {
                        category: "utility",
                        name: "info",
                        size: "x-small",
                        iconClass: ["slds-input__icon"]
                      }),
                      _hoisted_19
                    ])) : createCommentVNode("", true)
                  ])
                ]),
                createBaseVNode("div", _hoisted_20, [
                  createBaseVNode("table", _hoisted_21, [
                    createBaseVNode("tbody", null, [
                      _hoisted_22,
                      createBaseVNode("tr", null, [
                        _hoisted_23,
                        createBaseVNode("td", _hoisted_24, [
                          createVNode(_component_Icon, {
                            category: "utility",
                            name: "lock",
                            size: "x-small",
                            iconClass: ["slds-input__icon"]
                          })
                        ])
                      ]),
                      createBaseVNode("tr", null, [
                        _hoisted_25,
                        createBaseVNode("td", _hoisted_26, [
                          createVNode(_component_Icon, {
                            category: "utility",
                            name: "lock",
                            size: "x-small",
                            iconClass: ["slds-input__icon"]
                          })
                        ])
                      ]),
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.addedAttrs, (attr) => {
                        return openBlock(), createElementBlock("tr", {
                          id: `addAttr-${attr.id}`,
                          key: `addAttr-${attr.id}`
                        }, [
                          createBaseVNode("td", _hoisted_28, toDisplayString(attr.label), 1),
                          createBaseVNode("td", _hoisted_29, [
                            createVNode(_component_ButtonIcon, {
                              id: `addAttr-${attr.id}-remove`,
                              class: "slds-button_icon-container",
                              assistiveText: "Remove",
                              iconCategory: "utility",
                              iconName: "close",
                              title: "Remove",
                              onClick: $options.removeAttr
                            }, null, 8, ["id", "onClick"])
                          ])
                        ], 8, _hoisted_27);
                      }), 128))
                    ])
                  ])
                ]),
                $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true)
              ]))
            ], 64))
          ];
        }),
        footer: withCtx(() => [
          $options.tooManyTerritories ? (openBlock(), createElementBlock("div", _hoisted_30, [
            createBaseVNode("div", _hoisted_31, [
              createBaseVNode("div", _hoisted_32, [
                createVNode(_component_Button, {
                  class: "slds-button",
                  onClick: $options.cancel
                }, {
                  default: withCtx(() => [
                    createTextVNode(" Close ")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])) : (openBlock(), createElementBlock("div", _hoisted_33, [
            createBaseVNode("div", _hoisted_34, [
              createVNode(_component_Button, {
                class: "slds-button",
                disabled: $data.loading,
                onClick: $options.cancel
              }, {
                default: withCtx(() => [
                  createTextVNode(" Cancel ")
                ]),
                _: 1
              }, 8, ["disabled", "onClick"]),
              createVNode(_component_Button, {
                class: "slds-button",
                disabled: $data.loading,
                variant: "brand",
                onClick: $options.finish
              }, {
                default: withCtx(() => [
                  createTextVNode(" Stamp ")
                ]),
                _: 1
              }, 8, ["disabled", "onClick"])
            ])
          ]))
        ]),
        _: 1
      }, 8, ["title", "footless", "onClose"]);
    }
    const StampTerritoryModal = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-42fc156d"]]);
    const _sfc_main$1 = {
      name: "ViewStampedTerritoriesModal",
      components: {
        Spinner,
        Button,
        Modal,
        Icon
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loading: false,
          stampDetails: [],
          referenceFields: []
        };
      },
      computed: {
        dynamicHeaders() {
          const headersSet = /* @__PURE__ */ new Set();
          this.referenceFields.forEach((field) => {
            headersSet.add(field.label);
          });
          return Array.from(headersSet);
        },
        parsedStampDetails() {
          return SPM.Utils.Segment.TerritoryStampUtils.parsedStampDetails(this.stampDetails, this.referenceFields);
        },
        hierarchicalStampDetails() {
          return SPM.Utils.Segment.TerritoryStampUtils.hierarchicalStampDetails(this.parsedStampDetails);
        },
        showQuotaRollups() {
          return SPM.betaFlags.SP_Quota_Targets;
        }
      },
      async created() {
        this.loading = true;
        try {
          await this.fetchStampedDetails();
        } finally {
          this.loading = false;
        }
      },
      mounted() {
        const fields = JSON.parse(this.$store.segment.sfsp__ReferenceFields__c || "[]").filter((field) => field.type === "Territory");
        this.referenceFields = fields;
      },
      methods: {
        async fetchStampedDetails() {
          try {
            const response = await SPM.Utils.Apex.invoke("Query", [
              `SELECT Id, Name, sfsp__HierarchyReferenceData__c, sfsp__QuotaRollup__c, sfsp__Parent__c, sfsp__Owner__c, sfsp__Owner__r.Name, sfsp__ReferenceFields__c, sfsp__Segment__c FROM sfsp__SalesNode__c WHERE sfsp__Segment__c = '${this.$store.segment.Id}'`
            ]);
            this.stampDetails = response;
          } catch (error) {
            SPM.$store.toast({ state: "error", message: "Error fetching territory stamp details." });
          }
        },
        isNumber(value) {
          return typeof value === "number";
        },
        cancel() {
          this.$emit("close");
        }
      }
    };
    const _withScopeId = (n) => (pushScopeId("data-v-22655bbf"), n = n(), popScopeId(), n);
    const _hoisted_1$1 = {
      key: 0,
      class: "loading-container"
    };
    const _hoisted_2$1 = {
      key: 1,
      class: "stamp-table-container"
    };
    const _hoisted_3$1 = { class: "slds-table slds-table_bordered" };
    const _hoisted_4$1 = { class: "slds-line-height_reset" };
    const _hoisted_5$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("th", { class: "stamp-table-headers" }, "Name", -1));
    const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("th", { class: "stamp-table-headers" }, "Owner", -1));
    const _hoisted_7 = {
      key: 0,
      class: "stamp-table-headers"
    };
    const _hoisted_8 = { class: "stamp-table-data" };
    const _hoisted_9 = {
      key: 0,
      class: "stamp-table-data"
    };
    const _hoisted_10 = { key: 0 };
    const _hoisted_11 = { key: 1 };
    const _hoisted_12 = { class: "slds-grid" };
    const _hoisted_13 = { class: "slds-col_bump-left" };
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        id: "view-stamp-modal",
        ref: "modal",
        size: "large",
        title: "Stamped Territories",
        footless: $data.loading,
        hideCloseButton: $data.loading,
        onClose: $options.cancel
      }, {
        content: withCtx(() => [
          $data.loading ? (openBlock(), createElementBlock("div", _hoisted_1$1, [
            createVNode(_component_Spinner, { theme: "brand" })
          ])) : (openBlock(), createElementBlock("div", _hoisted_2$1, [
            createBaseVNode("table", _hoisted_3$1, [
              createBaseVNode("thead", null, [
                createBaseVNode("tr", _hoisted_4$1, [
                  _hoisted_5$1,
                  _hoisted_6,
                  $options.showQuotaRollups ? (openBlock(), createElementBlock("th", _hoisted_7, "Quota")) : createCommentVNode("", true),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.dynamicHeaders, (header, index) => {
                    return openBlock(), createElementBlock("th", {
                      key: index,
                      class: "stamp-table-headers"
                    }, toDisplayString(header), 1);
                  }), 128))
                ])
              ]),
              createBaseVNode("tbody", null, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.hierarchicalStampDetails, (detail) => {
                  var _a;
                  return openBlock(), createElementBlock("tr", {
                    key: detail.Id
                  }, [
                    createBaseVNode("td", {
                      style: normalizeStyle({ paddingLeft: `${detail.indent * 15 + 12}px` }),
                      class: "stamp-table-data"
                    }, toDisplayString(detail.Name), 5),
                    createBaseVNode("td", _hoisted_8, toDisplayString((_a = detail.sfsp__Owner__r) == null ? void 0 : _a.Name), 1),
                    $options.showQuotaRollups ? (openBlock(), createElementBlock("td", _hoisted_9, toDisplayString(_ctx.$F("Compact", detail.sfsp__QuotaRollup__c || 0)), 1)) : createCommentVNode("", true),
                    (openBlock(true), createElementBlock(Fragment, null, renderList($options.dynamicHeaders, (header) => {
                      return openBlock(), createElementBlock("td", {
                        key: header,
                        class: "stamp-table-data"
                      }, [
                        $options.isNumber(detail.data[header]) ? (openBlock(), createElementBlock("span", _hoisted_10, toDisplayString(_ctx.$F("Numeric", detail.data[header])), 1)) : (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString(detail.data[header] || ""), 1))
                      ]);
                    }), 128))
                  ]);
                }), 128))
              ])
            ])
          ]))
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_12, [
            createBaseVNode("div", _hoisted_13, [
              createVNode(_component_Button, {
                class: "slds-button",
                disabled: $data.loading,
                onClick: $options.cancel
              }, {
                default: withCtx(() => [
                  createTextVNode(" Close ")
                ]),
                _: 1
              }, 8, ["disabled", "onClick"])
            ])
          ])
        ]),
        _: 1
      }, 8, ["footless", "hideCloseButton", "onClose"]);
    }
    const ViewStampedTerritoriesModal = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-22655bbf"]]);
    const _sfc_main = {
      name: "AppRoot",
      components: {
        PageHeader,
        Overview,
        Details,
        History,
        NoAccess,
        AddTeamMembersModal,
        DeleteTerritoryStampModal,
        StampModal,
        StampTerritoryModal,
        ViewStampedTerritoriesModal,
        // slds
        Spinner,
        Toasts
      },
      data() {
        return {
          loadingMsg: "Loading segment...",
          modals: {
            addTeamMembers: false,
            deleteTerritoryStamp: false,
            stamp: false,
            stampTerritory: false,
            viewStamped: false
          },
          modalConfig: {}
        };
      },
      async created() {
        if (SPM.UITheme === "Theme4d") {
          document.body.style.marginTop = "-1.25rem";
        }
      },
      async mounted() {
        SPM.Components.Root = this;
        await this.$store.loadSegment();
        this.loadingMsg = "";
      },
      methods: {
        openModal(name, config) {
          this.modalConfig = {
            callback: () => {
            },
            ...config || {}
          };
          this.modals[name] = true;
        }
      }
    };
    const _hoisted_1 = { key: 1 };
    const _hoisted_2 = {
      key: 6,
      class: "slds-p-around_small"
    };
    const _hoisted_3 = {
      key: 1,
      class: "slds-grid"
    };
    const _hoisted_4 = { class: "slds-col slds-size_2-of-3" };
    const _hoisted_5 = { class: "slds-col slds-size_1-of-3 slds-p-left_small" };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Toasts = resolveComponent("Toasts");
      const _component_NoAccess = resolveComponent("NoAccess");
      const _component_AddTeamMembersModal = resolveComponent("AddTeamMembersModal");
      const _component_StampModal = resolveComponent("StampModal");
      const _component_ViewStampedTerritoriesModal = resolveComponent("ViewStampedTerritoriesModal");
      const _component_StampTerritoryModal = resolveComponent("StampTerritoryModal");
      const _component_DeleteTerritoryStampModal = resolveComponent("DeleteTerritoryStampModal");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_PageHeader = resolveComponent("PageHeader");
      const _component_Overview = resolveComponent("Overview");
      const _component_Details = resolveComponent("Details");
      const _component_History = resolveComponent("History");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_Toasts, {
          toasts: _ctx.$store.toasts
        }, null, 8, ["toasts"]),
        _ctx.$store.noAccess === true ? (openBlock(), createBlock(_component_NoAccess, {
          key: 0,
          id: "noAccess",
          type: "segment"
        })) : (openBlock(), createElementBlock("div", _hoisted_1, [
          $data.modals.addTeamMembers ? (openBlock(), createBlock(_component_AddTeamMembersModal, {
            key: 0,
            config: $data.modalConfig,
            onClose: _cache[0] || (_cache[0] = ($event) => $data.modals.addTeamMembers = false)
          }, null, 8, ["config"])) : createCommentVNode("", true),
          $data.modals.stamp ? (openBlock(), createBlock(_component_StampModal, {
            key: 1,
            config: $data.modalConfig,
            onClose: _cache[1] || (_cache[1] = ($event) => $data.modals.stamp = false)
          }, null, 8, ["config"])) : createCommentVNode("", true),
          $data.modals.viewStamped ? (openBlock(), createBlock(_component_ViewStampedTerritoriesModal, {
            key: 2,
            config: $data.modalConfig,
            onClose: _cache[2] || (_cache[2] = ($event) => $data.modals.viewStamped = false)
          }, null, 8, ["config"])) : createCommentVNode("", true),
          $data.modals.stampTerritory ? (openBlock(), createBlock(_component_StampTerritoryModal, {
            key: 3,
            config: $data.modalConfig,
            onClose: _cache[3] || (_cache[3] = ($event) => $data.modals.stampTerritory = false)
          }, null, 8, ["config"])) : createCommentVNode("", true),
          $data.modals.deleteTerritoryStamp ? (openBlock(), createBlock(_component_DeleteTerritoryStampModal, {
            key: 4,
            config: $data.modalConfig,
            onClose: _cache[4] || (_cache[4] = ($event) => $data.modals.deleteTerritoryStamp = false)
          }, null, 8, ["config"])) : createCommentVNode("", true),
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 5 }, {
            description: withCtx(() => [
              createTextVNode(toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          !$data.loadingMsg ? (openBlock(), createElementBlock("div", _hoisted_2, [
            _ctx.$store.segment ? (openBlock(), createBlock(_component_PageHeader, {
              key: 0,
              segment: _ctx.$store.segment
            }, null, 8, ["segment"])) : createCommentVNode("", true),
            createVNode(_component_Overview, {
              class: "slds-m-bottom_small",
              segment: _ctx.$store.segment
            }, null, 8, ["segment"]),
            _ctx.$store.segment ? (openBlock(), createElementBlock("div", _hoisted_3, [
              createBaseVNode("div", _hoisted_4, [
                createVNode(_component_Details, {
                  segment: _ctx.$store.segment
                }, null, 8, ["segment"])
              ]),
              createBaseVNode("div", _hoisted_5, [
                createVNode(_component_History, {
                  class: "slds-grid slds-grid_vertical slds-scrollable_none",
                  style: { "max-height": "667px" },
                  segment: _ctx.$store.segment
                }, null, 8, ["segment"])
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]))
      ]);
    }
    const Root = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
    const useStore = defineStore("main", {
      state: () => ({
        // splunk
        txnId: getGUID(),
        // segment
        segment: {},
        dataSource: {},
        applicationNames: [],
        // user access
        noAccess: null,
        userAccessRecords: [],
        // toasts
        toasts: [],
        showOnLoadToasts: true,
        // territory plans
        isLaunchingTerritoryPlanning: false,
        territoryPlans: [],
        // territory stamp
        territoryStampRoot: {},
        territoryStampSize: 0
      }),
      getters: {
        hasDataPipelinesAccess: (state2) => SPM.hasDataPipelinesAccess,
        isAdmin: (state2) => SPM.isAdmin,
        isManager: (state2) => SPM.isManager
      },
      actions: {
        async loadSegment() {
          const params = new URLSearchParams(window.location.search);
          const segmentId = params.get("segmentId");
          if (!segmentId) {
            alert("No Segment Found");
            return;
          }
          await this.getSegmentRecord(segmentId);
          await this.getUserAccessRecords();
          this.noAccess = !(this.isAdmin || this.userAccessRecords.find((u) => u.sfsp__User__c === SPM.currentUser.Id));
          if (this.noAccess)
            return;
          this.dataSource = this.segment.sfsp__SalesPlan__r.sfsp__SalesDataSource__r;
          if (this.dataSource) {
            this.dataSource._referenceFields = JSON.parse(this.dataSource.sfsp__ReferenceFields__c);
            this.dataSource._dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: this.dataSource.sfsp__SourceId__c });
          }
          await this.getApplicationNames();
          await SPM.Utils.Segment.TPDataSet.fetchRelatedAlignments();
          await this.getTerritoryStamp();
        },
        async getSegmentRecord(segmentId) {
          var _a, _b, _c;
          this.segment = (_a = await SPM.Utils.Apex.invoke(
            "Query",
            [`
                    SELECT
                        Id,
                        Name,
                        sfsp__HierarchyReferenceData__c,
                        sfsp__ReferenceFields__c,
                        sfsp__StampDataSourceId__c,
                        sfsp__SalesPlan__r.Id,
                        sfsp__SalesPlan__r.Name,
                        sfsp__SalesPlan__r.sfsp__SalesDataSource__r.sfsp__SourceId__c,
                        sfsp__SalesPlan__r.sfsp__SalesDataSource__r.sfsp__ReferenceFields__c,
                        sfsp__Owner__r.Name,
                        sfsp__QuotaRollup__c,
                        sfsp__Target__c,
                        (SELECT Id, Name, CreatedDate, sfsp__Type__c, sfsp__Data__c FROM sfsp__SalesNodeActivities__r WHERE sfsp__Type__c = 'Quota Stamp' ORDER BY CreatedDate DESC)
                    FROM sfsp__SalesNode__c
                    WHERE Id = '${segmentId}'
                `]
          )) == null ? void 0 : _a[0];
          const quotaStampActivity = (_c = (_b = this.segment) == null ? void 0 : _b.sfsp__SalesNodeActivities__r) == null ? void 0 : _c.find((a) => a.sfsp__Type__c === "Quota Stamp");
          if (quotaStampActivity) {
            const quotaStampData = JSON.parse((quotaStampActivity == null ? void 0 : quotaStampActivity.sfsp__Data__c) || "{}");
            this.segment._quotaStamp = {
              planName: quotaStampData.planName,
              date: quotaStampActivity.CreatedDate
            };
          }
        },
        async getApplicationNames() {
          this.applicationNames = await SPM.Utils.Apex.invoke("GetApplicationAccessValues", []);
        },
        async getUserAccessRecords() {
          try {
            this.userAccessRecords = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT 
                        Id,
                        CreatedDate,
                        sfsp__User__c,
                        sfsp__User__r.Name,
                        sfsp__SalesNode__c,
                        sfsp__SalesPlan__c,
                        sfsp__ApplicationAccess__c
                    FROM sfsp__SalesUserAccess__c
                    WHERE sfsp__SalesNode__c = '${this.segment.Id}'
                    OR sfsp__SalesPlan__c = '${this.segment.sfsp__SalesPlan__r.Id}'
                    ORDER BY CreatedDate DESC
                `]);
          } catch (err) {
            this.toast({ message: "Unable to fetch segment users.", state: "error", duration: 5e3 });
          }
        },
        async getTerritoryStamp() {
          this.territoryStampSize = await SPM.Utils.Apex.invoke("CountQuery", [`
                SELECT
                    COUNT()
                FROM sfsp__SalesNode__c
                WHERE sfsp__Segment__c = '${this.segment.Id}'
            `]);
          if (this.territoryStampSize > 0) {
            const territoryStampMetadata = JSON.parse(this.segment.sfsp__ReferenceFields__c || "[]").find((f) => f.type === "Territory Stamp");
            this.territoryStampRoot = {
              Name: territoryStampMetadata == null ? void 0 : territoryStampMetadata.name,
              Id: territoryStampMetadata == null ? void 0 : territoryStampMetadata.id,
              CreatedDate: territoryStampMetadata == null ? void 0 : territoryStampMetadata.createdDate
            };
          }
        },
        async refreshTerritoryStamp() {
          await this.getSegmentRecord(this.segment.Id);
          await this.getTerritoryStamp();
        },
        async recoverDataSet(datasetId) {
          if (datasetId === this.segment.sfsp__StampDataSourceId__c) {
            await SPM.Utils.Segment.Node.resetStampedDataSource(this.segment.Id);
            this.toast({ showOnce: true, state: "warning", message: "Stamp was deleted. You can stamp your segment again, or ask your Salesforce admin for help.", duration: 5e3 });
            await this.getSegmentRecord(this.segment.Id);
            await SPM.Components.Overview.loadRecords();
          } else {
            this.toast({ showOnce: true, state: "error", message: "Segment data was deleted. Ask your Salesforce admin for help.", duration: null });
            this.noAccess = true;
          }
        },
        trackPendoEvent(payload) {
          if (pendo.visitorId) {
            pendo.track(payload.actionType, payload.pendoPayload);
          } else {
            console.log("Pendo is unable to track this event");
          }
        },
        toast(options) {
          if (!options.message) {
            throw new Error("Missing message argument.");
          }
          this.toasts.push({
            // defaults
            ...{
              duration: 5e3,
              position: "top-center",
              state: "success"
            },
            ...options
          });
        }
      }
    });
    SPM.Utils = UtilsClient({ Buffer: buffer.Buffer, Papa });
    SPM.Utils.Quota = QuotaUtils;
    SPM.Components = {};
    SPM.$store = {
      txnId: getGUID()
    };
    SPM.app = createApp({
      components: { IconSettings },
      render() {
        return h(
          IconSettings,
          {
            iconPath: `/resource/${(/* @__PURE__ */ new Date()).getTime()}/sfsp__SLDSAssets/icons`
          },
          () => [h(Root)]
        );
      }
    });
    const pinia = createPinia();
    SPM.app.use(pinia);
    const emitter = mitt();
    SPM.app.config.globalProperties.$mitt = emitter;
    SPM.app.config.globalProperties.$store = SPM.$store = useStore();
    SPM.app.config.globalProperties.$getErrorsByField = (field) => field.$errors.map((error) => error.$message);
    const locale = SPM.currentUser.Locale.replace("sh_ME_USD", "sh-ME").replace("_", "-").slice(0, 5);
    const formatters = {
      Currency: new Intl.NumberFormat(locale, { style: "currency", currency: SPM.currentUser.CurrencyIsoCode, maximumFractionDigits: 0 }),
      Numeric: new Intl.NumberFormat(locale, { style: "decimal", maximumFractionDigits: 0 }),
      Compact: new Intl.NumberFormat("en", { notation: "compact" }),
      DateTime: (options = {}) => new Intl.DateTimeFormat(locale, options)
    };
    SPM.app.config.globalProperties.$F = (type, value, options) => type === "DateTime" ? formatters[type](options).format(value) : formatters[type].format(value);
    SPM.app.mount("#vue-root");
    SPM.version = 246;
    SPM.app.config.errorHandler = (ex, vm, info) => {
      var _a, _b;
      if ((ex == null ? void 0 : ex.type) === "RemoteActionException") {
        const { error } = ex;
        SPM.$store.toast({
          message: error.type,
          subMessage: error.message,
          state: "error",
          duration: 0
        });
        return;
      }
      const errorCode = ((_a = ex.response) == null ? void 0 : _a.data[0].errorCode) || "";
      const errorMsg = ((_b = ex.response) == null ? void 0 : _b.data[0].message) || "";
      if (errorCode === "FUNCTIONALITY_NOT_ENABLED") {
        SPM.$store.toast({ showOnce: true, state: "warning", message: "Some features may not work properly. Please contact your admin to ensure you are properly licensed.", duration: null });
        SPM.$store.noAccess = true;
      }
      if (errorMsg.includes("Edgemart not found"))
        SPM.$store.recoverDataSet(errorMsg.split(":")[1].trim());
      console.log("Vue Error", ex, vm, info);
    };
  }
});
export default require_bundle();
