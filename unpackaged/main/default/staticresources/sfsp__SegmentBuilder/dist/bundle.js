var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var require_bundle = __commonJS({
  "bundle.js"(exports, module) {
    /**
    * @vue/shared v3.4.18
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    function makeMap(str, expectsLowerCase) {
      const set2 = new Set(str.split(","));
      return expectsLowerCase ? (val) => set2.has(val.toLowerCase()) : (val) => set2.has(val);
    }
    const EMPTY_OBJ = {};
    const EMPTY_ARR = [];
    const NOOP = () => {
    };
    const NO = () => false;
    const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
    (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
    const isModelListener = (key) => key.startsWith("onUpdate:");
    const extend$3 = Object.assign;
    const remove$1 = (arr, el) => {
      const i = arr.indexOf(el);
      if (i > -1) {
        arr.splice(i, 1);
      }
    };
    const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
    const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
    const isArray$2 = Array.isArray;
    const isMap = (val) => toTypeString(val) === "[object Map]";
    const isSet = (val) => toTypeString(val) === "[object Set]";
    const isDate$2 = (val) => toTypeString(val) === "[object Date]";
    const isFunction$2 = (val) => typeof val === "function";
    const isString$2 = (val) => typeof val === "string";
    const isSymbol = (val) => typeof val === "symbol";
    const isObject$2 = (val) => val !== null && typeof val === "object";
    const isPromise = (val) => {
      return (isObject$2(val) || isFunction$2(val)) && isFunction$2(val.then) && isFunction$2(val.catch);
    };
    const objectToString = Object.prototype.toString;
    const toTypeString = (value) => objectToString.call(value);
    const toRawType = (value) => {
      return toTypeString(value).slice(8, -1);
    };
    const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
    const isIntegerKey = (key) => isString$2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
    const isReservedProp = /* @__PURE__ */ makeMap(
      // the leading comma is intentional so empty string "" is also included
      ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
    );
    const cacheStringFunction = (fn) => {
      const cache = /* @__PURE__ */ Object.create(null);
      return (str) => {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
      };
    };
    const camelizeRE = /-(\w)/g;
    const camelize = cacheStringFunction((str) => {
      return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
    });
    const hyphenateRE = /\B([A-Z])/g;
    const hyphenate = cacheStringFunction(
      (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
    );
    const capitalize = cacheStringFunction((str) => {
      return str.charAt(0).toUpperCase() + str.slice(1);
    });
    const toHandlerKey = cacheStringFunction((str) => {
      const s = str ? `on${capitalize(str)}` : ``;
      return s;
    });
    const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
    const invokeArrayFns = (fns, arg) => {
      for (let i = 0; i < fns.length; i++) {
        fns[i](arg);
      }
    };
    const def = (obj, key, value) => {
      Object.defineProperty(obj, key, {
        configurable: true,
        enumerable: false,
        value
      });
    };
    const looseToNumber = (val) => {
      const n = parseFloat(val);
      return isNaN(n) ? val : n;
    };
    const toNumber = (val) => {
      const n = isString$2(val) ? Number(val) : NaN;
      return isNaN(n) ? val : n;
    };
    let _globalThis;
    const getGlobalThis = () => {
      return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
    };
    function normalizeStyle(value) {
      if (isArray$2(value)) {
        const res = {};
        for (let i = 0; i < value.length; i++) {
          const item = value[i];
          const normalized = isString$2(item) ? parseStringStyle(item) : normalizeStyle(item);
          if (normalized) {
            for (const key in normalized) {
              res[key] = normalized[key];
            }
          }
        }
        return res;
      } else if (isString$2(value) || isObject$2(value)) {
        return value;
      }
    }
    const listDelimiterRE = /;(?![^(]*\))/g;
    const propertyDelimiterRE = /:([^]+)/;
    const styleCommentRE = /\/\*[^]*?\*\//g;
    function parseStringStyle(cssText) {
      const ret = {};
      cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
        if (item) {
          const tmp = item.split(propertyDelimiterRE);
          tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
        }
      });
      return ret;
    }
    function normalizeClass(value) {
      let res = "";
      if (isString$2(value)) {
        res = value;
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          const normalized = normalizeClass(value[i]);
          if (normalized) {
            res += normalized + " ";
          }
        }
      } else if (isObject$2(value)) {
        for (const name2 in value) {
          if (value[name2]) {
            res += name2 + " ";
          }
        }
      }
      return res.trim();
    }
    function normalizeProps(props) {
      if (!props)
        return null;
      let { class: klass, style } = props;
      if (klass && !isString$2(klass)) {
        props.class = normalizeClass(klass);
      }
      if (style) {
        props.style = normalizeStyle(style);
      }
      return props;
    }
    const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
    const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
    function includeBooleanAttr(value) {
      return !!value || value === "";
    }
    function looseCompareArrays(a, b) {
      if (a.length !== b.length)
        return false;
      let equal = true;
      for (let i = 0; equal && i < a.length; i++) {
        equal = looseEqual(a[i], b[i]);
      }
      return equal;
    }
    function looseEqual(a, b) {
      if (a === b)
        return true;
      let aValidType = isDate$2(a);
      let bValidType = isDate$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? a.getTime() === b.getTime() : false;
      }
      aValidType = isSymbol(a);
      bValidType = isSymbol(b);
      if (aValidType || bValidType) {
        return a === b;
      }
      aValidType = isArray$2(a);
      bValidType = isArray$2(b);
      if (aValidType || bValidType) {
        return aValidType && bValidType ? looseCompareArrays(a, b) : false;
      }
      aValidType = isObject$2(a);
      bValidType = isObject$2(b);
      if (aValidType || bValidType) {
        if (!aValidType || !bValidType) {
          return false;
        }
        const aKeysCount = Object.keys(a).length;
        const bKeysCount = Object.keys(b).length;
        if (aKeysCount !== bKeysCount) {
          return false;
        }
        for (const key in a) {
          const aHasKey = a.hasOwnProperty(key);
          const bHasKey = b.hasOwnProperty(key);
          if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
            return false;
          }
        }
      }
      return String(a) === String(b);
    }
    const toDisplayString = (val) => {
      return isString$2(val) ? val : val == null ? "" : isArray$2(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$2(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
    };
    const replacer = (_key, val) => {
      if (val && val.__v_isRef) {
        return replacer(_key, val.value);
      } else if (isMap(val)) {
        return {
          [`Map(${val.size})`]: [...val.entries()].reduce(
            (entries, [key, val2], i) => {
              entries[stringifySymbol(key, i) + " =>"] = val2;
              return entries;
            },
            {}
          )
        };
      } else if (isSet(val)) {
        return {
          [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
        };
      } else if (isSymbol(val)) {
        return stringifySymbol(val);
      } else if (isObject$2(val) && !isArray$2(val) && !isPlainObject$1(val)) {
        return String(val);
      }
      return val;
    };
    const stringifySymbol = (v, i = "") => {
      var _a;
      return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
    };
    /**
    * @vue/reactivity v3.4.18
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    let activeEffectScope;
    class EffectScope {
      constructor(detached = false) {
        this.detached = detached;
        this._active = true;
        this.effects = [];
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
          this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
            this
          ) - 1;
        }
      }
      get active() {
        return this._active;
      }
      run(fn) {
        if (this._active) {
          const currentEffectScope = activeEffectScope;
          try {
            activeEffectScope = this;
            return fn();
          } finally {
            activeEffectScope = currentEffectScope;
          }
        }
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      on() {
        activeEffectScope = this;
      }
      /**
       * This should only be called on non-detached scopes
       * @internal
       */
      off() {
        activeEffectScope = this.parent;
      }
      stop(fromParent) {
        if (this._active) {
          let i, l;
          for (i = 0, l = this.effects.length; i < l; i++) {
            this.effects[i].stop();
          }
          for (i = 0, l = this.cleanups.length; i < l; i++) {
            this.cleanups[i]();
          }
          if (this.scopes) {
            for (i = 0, l = this.scopes.length; i < l; i++) {
              this.scopes[i].stop(true);
            }
          }
          if (!this.detached && this.parent && !fromParent) {
            const last = this.parent.scopes.pop();
            if (last && last !== this) {
              this.parent.scopes[this.index] = last;
              last.index = this.index;
            }
          }
          this.parent = void 0;
          this._active = false;
        }
      }
    }
    function recordEffectScope(effect2, scope = activeEffectScope) {
      if (scope && scope.active) {
        scope.effects.push(effect2);
      }
    }
    function getCurrentScope() {
      return activeEffectScope;
    }
    let activeEffect;
    class ReactiveEffect {
      constructor(fn, trigger2, scheduler, scope) {
        this.fn = fn;
        this.trigger = trigger2;
        this.scheduler = scheduler;
        this.active = true;
        this.deps = [];
        this._dirtyLevel = 4;
        this._trackId = 0;
        this._runnings = 0;
        this._shouldSchedule = false;
        this._depsLength = 0;
        recordEffectScope(this, scope);
      }
      get dirty() {
        if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
          this._dirtyLevel = 1;
          pauseTracking();
          for (let i = 0; i < this._depsLength; i++) {
            const dep = this.deps[i];
            if (dep.computed) {
              triggerComputed(dep.computed);
              if (this._dirtyLevel >= 4) {
                break;
              }
            }
          }
          if (this._dirtyLevel === 1) {
            this._dirtyLevel = 0;
          }
          resetTracking();
        }
        return this._dirtyLevel >= 4;
      }
      set dirty(v) {
        this._dirtyLevel = v ? 4 : 0;
      }
      run() {
        this._dirtyLevel = 0;
        if (!this.active) {
          return this.fn();
        }
        let lastShouldTrack = shouldTrack;
        let lastEffect = activeEffect;
        try {
          shouldTrack = true;
          activeEffect = this;
          this._runnings++;
          preCleanupEffect(this);
          return this.fn();
        } finally {
          postCleanupEffect(this);
          this._runnings--;
          activeEffect = lastEffect;
          shouldTrack = lastShouldTrack;
        }
      }
      stop() {
        var _a;
        if (this.active) {
          preCleanupEffect(this);
          postCleanupEffect(this);
          (_a = this.onStop) == null ? void 0 : _a.call(this);
          this.active = false;
        }
      }
    }
    function triggerComputed(computed2) {
      return computed2.value;
    }
    function preCleanupEffect(effect2) {
      effect2._trackId++;
      effect2._depsLength = 0;
    }
    function postCleanupEffect(effect2) {
      if (effect2.deps.length > effect2._depsLength) {
        for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
          cleanupDepEffect(effect2.deps[i], effect2);
        }
        effect2.deps.length = effect2._depsLength;
      }
    }
    function cleanupDepEffect(dep, effect2) {
      const trackId = dep.get(effect2);
      if (trackId !== void 0 && effect2._trackId !== trackId) {
        dep.delete(effect2);
        if (dep.size === 0) {
          dep.cleanup();
        }
      }
    }
    let shouldTrack = true;
    let pauseScheduleStack = 0;
    const trackStack = [];
    function pauseTracking() {
      trackStack.push(shouldTrack);
      shouldTrack = false;
    }
    function resetTracking() {
      const last = trackStack.pop();
      shouldTrack = last === void 0 ? true : last;
    }
    function pauseScheduling() {
      pauseScheduleStack++;
    }
    function resetScheduling() {
      pauseScheduleStack--;
      while (!pauseScheduleStack && queueEffectSchedulers.length) {
        queueEffectSchedulers.shift()();
      }
    }
    function trackEffect(effect2, dep, debuggerEventExtraInfo) {
      if (dep.get(effect2) !== effect2._trackId) {
        dep.set(effect2, effect2._trackId);
        const oldDep = effect2.deps[effect2._depsLength];
        if (oldDep !== dep) {
          if (oldDep) {
            cleanupDepEffect(oldDep, effect2);
          }
          effect2.deps[effect2._depsLength++] = dep;
        } else {
          effect2._depsLength++;
        }
      }
    }
    const queueEffectSchedulers = [];
    function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
      pauseScheduling();
      for (const effect2 of dep.keys()) {
        let tracking;
        if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);
          effect2._dirtyLevel = dirtyLevel;
        }
        if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {
          effect2.trigger();
          if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {
            effect2._shouldSchedule = false;
            if (effect2.scheduler) {
              queueEffectSchedulers.push(effect2.scheduler);
            }
          }
        }
      }
      resetScheduling();
    }
    const createDep = (cleanup, computed2) => {
      const dep = /* @__PURE__ */ new Map();
      dep.cleanup = cleanup;
      dep.computed = computed2;
      return dep;
    };
    const targetMap = /* @__PURE__ */ new WeakMap();
    const ITERATE_KEY = Symbol("");
    const MAP_KEY_ITERATE_KEY = Symbol("");
    function track(target, type, key) {
      if (shouldTrack && activeEffect) {
        let depsMap = targetMap.get(target);
        if (!depsMap) {
          targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
        }
        let dep = depsMap.get(key);
        if (!dep) {
          depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
        }
        trackEffect(
          activeEffect,
          dep
        );
      }
    }
    function trigger(target, type, key, newValue, oldValue, oldTarget) {
      const depsMap = targetMap.get(target);
      if (!depsMap) {
        return;
      }
      let deps = [];
      if (type === "clear") {
        deps = [...depsMap.values()];
      } else if (key === "length" && isArray$2(target)) {
        const newLength = Number(newValue);
        depsMap.forEach((dep, key2) => {
          if (key2 === "length" || !isSymbol(key2) && key2 >= newLength) {
            deps.push(dep);
          }
        });
      } else {
        if (key !== void 0) {
          deps.push(depsMap.get(key));
        }
        switch (type) {
          case "add":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            } else if (isIntegerKey(key)) {
              deps.push(depsMap.get("length"));
            }
            break;
          case "delete":
            if (!isArray$2(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
              if (isMap(target)) {
                deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
              }
            }
            break;
          case "set":
            if (isMap(target)) {
              deps.push(depsMap.get(ITERATE_KEY));
            }
            break;
        }
      }
      pauseScheduling();
      for (const dep of deps) {
        if (dep) {
          triggerEffects(
            dep,
            4
          );
        }
      }
      resetScheduling();
    }
    const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
    const builtInSymbols = new Set(
      /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
    );
    const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
    function createArrayInstrumentations() {
      const instrumentations = {};
      ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
        instrumentations[key] = function(...args) {
          const arr = toRaw(this);
          for (let i = 0, l = this.length; i < l; i++) {
            track(arr, "get", i + "");
          }
          const res = arr[key](...args);
          if (res === -1 || res === false) {
            return arr[key](...args.map(toRaw));
          } else {
            return res;
          }
        };
      });
      ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
        instrumentations[key] = function(...args) {
          pauseTracking();
          pauseScheduling();
          const res = toRaw(this)[key].apply(this, args);
          resetScheduling();
          resetTracking();
          return res;
        };
      });
      return instrumentations;
    }
    function hasOwnProperty$2(key) {
      const obj = toRaw(this);
      track(obj, "has", key);
      return obj.hasOwnProperty(key);
    }
    class BaseReactiveHandler {
      constructor(_isReadonly = false, _shallow = false) {
        this._isReadonly = _isReadonly;
        this._shallow = _shallow;
      }
      get(target, key, receiver) {
        const isReadonly2 = this._isReadonly, shallow = this._shallow;
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_isShallow") {
          return shallow;
        } else if (key === "__v_raw") {
          if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
          // this means the reciever is a user proxy of the reactive proxy
          Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
            return target;
          }
          return;
        }
        const targetIsArray = isArray$2(target);
        if (!isReadonly2) {
          if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
            return Reflect.get(arrayInstrumentations, key, receiver);
          }
          if (key === "hasOwnProperty") {
            return hasOwnProperty$2;
          }
        }
        const res = Reflect.get(target, key, receiver);
        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
          return res;
        }
        if (!isReadonly2) {
          track(target, "get", key);
        }
        if (shallow) {
          return res;
        }
        if (isRef(res)) {
          return targetIsArray && isIntegerKey(key) ? res : res.value;
        }
        if (isObject$2(res)) {
          return isReadonly2 ? readonly(res) : reactive(res);
        }
        return res;
      }
    }
    class MutableReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(false, shallow);
      }
      set(target, key, value, receiver) {
        let oldValue = target[key];
        if (!this._shallow) {
          const isOldValueReadonly = isReadonly(oldValue);
          if (!isShallow(value) && !isReadonly(value)) {
            oldValue = toRaw(oldValue);
            value = toRaw(value);
          }
          if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
            if (isOldValueReadonly) {
              return false;
            } else {
              oldValue.value = value;
              return true;
            }
          }
        }
        const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
        const result = Reflect.set(target, key, value, receiver);
        if (target === toRaw(receiver)) {
          if (!hadKey) {
            trigger(target, "add", key, value);
          } else if (hasChanged(value, oldValue)) {
            trigger(target, "set", key, value);
          }
        }
        return result;
      }
      deleteProperty(target, key) {
        const hadKey = hasOwn(target, key);
        target[key];
        const result = Reflect.deleteProperty(target, key);
        if (result && hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      }
      has(target, key) {
        const result = Reflect.has(target, key);
        if (!isSymbol(key) || !builtInSymbols.has(key)) {
          track(target, "has", key);
        }
        return result;
      }
      ownKeys(target) {
        track(
          target,
          "iterate",
          isArray$2(target) ? "length" : ITERATE_KEY
        );
        return Reflect.ownKeys(target);
      }
    }
    class ReadonlyReactiveHandler extends BaseReactiveHandler {
      constructor(shallow = false) {
        super(true, shallow);
      }
      set(target, key) {
        return true;
      }
      deleteProperty(target, key) {
        return true;
      }
    }
    const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
    const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
    const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
      true
    );
    const toShallow = (value) => value;
    const getProto = (v) => Reflect.getPrototypeOf(v);
    function get$3(target, key, isReadonly2 = false, isShallow2 = false) {
      target = target["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has: has2 } = getProto(rawTarget);
      const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
      if (has2.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has2.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    }
    function has(key, isReadonly2 = false) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!isReadonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    }
    function size(target, isReadonly2 = false) {
      target = target["__v_raw"];
      !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    }
    function add$2(value) {
      value = toRaw(value);
      const target = toRaw(this);
      const proto2 = getProto(target);
      const hadKey = proto2.has.call(target, value);
      if (!hadKey) {
        target.add(value);
        trigger(target, "add", value, value);
      }
      return this;
    }
    function set$3(key, value) {
      value = toRaw(value);
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      const oldValue = get2.call(target, key);
      target.set(key, value);
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
      return this;
    }
    function deleteEntry(key) {
      const target = toRaw(this);
      const { has: has2, get: get2 } = getProto(target);
      let hadKey = has2.call(target, key);
      if (!hadKey) {
        key = toRaw(key);
        hadKey = has2.call(target, key);
      }
      get2 ? get2.call(target, key) : void 0;
      const result = target.delete(key);
      if (hadKey) {
        trigger(target, "delete", key, void 0);
      }
      return result;
    }
    function clear() {
      const target = toRaw(this);
      const hadItems = target.size !== 0;
      const result = target.clear();
      if (hadItems) {
        trigger(target, "clear", void 0, void 0);
      }
      return result;
    }
    function createForEach(isReadonly2, isShallow2) {
      return function forEach2(callback, thisArg) {
        const observed = this;
        const target = observed["__v_raw"];
        const rawTarget = toRaw(target);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
        return target.forEach((value, key) => {
          return callback.call(thisArg, wrap(value), wrap(key), observed);
        });
      };
    }
    function createIterableMethod(method, isReadonly2, isShallow2) {
      return function(...args) {
        const target = this["__v_raw"];
        const rawTarget = toRaw(target);
        const targetIsMap = isMap(rawTarget);
        const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
        const isKeyOnly = method === "keys" && targetIsMap;
        const innerIterator = target[method](...args);
        const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
        !isReadonly2 && track(
          rawTarget,
          "iterate",
          isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
        );
        return {
          // iterator protocol
          next() {
            const { value, done } = innerIterator.next();
            return done ? { value, done } : {
              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
              done
            };
          },
          // iterable protocol
          [Symbol.iterator]() {
            return this;
          }
        };
      };
    }
    function createReadonlyMethod(type) {
      return function(...args) {
        return type === "delete" ? false : type === "clear" ? void 0 : this;
      };
    }
    function createInstrumentations() {
      const mutableInstrumentations2 = {
        get(key) {
          return get$3(this, key);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$3,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, false)
      };
      const shallowInstrumentations2 = {
        get(key) {
          return get$3(this, key, false, true);
        },
        get size() {
          return size(this);
        },
        has,
        add: add$2,
        set: set$3,
        delete: deleteEntry,
        clear,
        forEach: createForEach(false, true)
      };
      const readonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, false)
      };
      const shallowReadonlyInstrumentations2 = {
        get(key) {
          return get$3(this, key, true, true);
        },
        get size() {
          return size(this, true);
        },
        has(key) {
          return has.call(this, key, true);
        },
        add: createReadonlyMethod("add"),
        set: createReadonlyMethod("set"),
        delete: createReadonlyMethod("delete"),
        clear: createReadonlyMethod("clear"),
        forEach: createForEach(true, true)
      };
      const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
      iteratorMethods.forEach((method) => {
        mutableInstrumentations2[method] = createIterableMethod(
          method,
          false,
          false
        );
        readonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          false
        );
        shallowInstrumentations2[method] = createIterableMethod(
          method,
          false,
          true
        );
        shallowReadonlyInstrumentations2[method] = createIterableMethod(
          method,
          true,
          true
        );
      });
      return [
        mutableInstrumentations2,
        readonlyInstrumentations2,
        shallowInstrumentations2,
        shallowReadonlyInstrumentations2
      ];
    }
    const [
      mutableInstrumentations,
      readonlyInstrumentations,
      shallowInstrumentations,
      shallowReadonlyInstrumentations
    ] = /* @__PURE__ */ createInstrumentations();
    function createInstrumentationGetter(isReadonly2, shallow) {
      const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
      return (target, key, receiver) => {
        if (key === "__v_isReactive") {
          return !isReadonly2;
        } else if (key === "__v_isReadonly") {
          return isReadonly2;
        } else if (key === "__v_raw") {
          return target;
        }
        return Reflect.get(
          hasOwn(instrumentations, key) && key in target ? instrumentations : target,
          key,
          receiver
        );
      };
    }
    const mutableCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, false)
    };
    const shallowCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(false, true)
    };
    const readonlyCollectionHandlers = {
      get: /* @__PURE__ */ createInstrumentationGetter(true, false)
    };
    const reactiveMap = /* @__PURE__ */ new WeakMap();
    const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
    const readonlyMap = /* @__PURE__ */ new WeakMap();
    const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
    function targetTypeMap(rawType) {
      switch (rawType) {
        case "Object":
        case "Array":
          return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
          return 2;
        default:
          return 0;
      }
    }
    function getTargetType(value) {
      return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
    }
    function reactive(target) {
      if (isReadonly(target)) {
        return target;
      }
      return createReactiveObject(
        target,
        false,
        mutableHandlers,
        mutableCollectionHandlers,
        reactiveMap
      );
    }
    function shallowReactive(target) {
      return createReactiveObject(
        target,
        false,
        shallowReactiveHandlers,
        shallowCollectionHandlers,
        shallowReactiveMap
      );
    }
    function readonly(target) {
      return createReactiveObject(
        target,
        true,
        readonlyHandlers,
        readonlyCollectionHandlers,
        readonlyMap
      );
    }
    function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
      if (!isObject$2(target)) {
        return target;
      }
      if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
        return target;
      }
      const existingProxy = proxyMap.get(target);
      if (existingProxy) {
        return existingProxy;
      }
      const targetType = getTargetType(target);
      if (targetType === 0) {
        return target;
      }
      const proxy = new Proxy(
        target,
        targetType === 2 ? collectionHandlers : baseHandlers
      );
      proxyMap.set(target, proxy);
      return proxy;
    }
    function isReactive(value) {
      if (isReadonly(value)) {
        return isReactive(value["__v_raw"]);
      }
      return !!(value && value["__v_isReactive"]);
    }
    function isReadonly(value) {
      return !!(value && value["__v_isReadonly"]);
    }
    function isShallow(value) {
      return !!(value && value["__v_isShallow"]);
    }
    function isProxy(value) {
      return isReactive(value) || isReadonly(value);
    }
    function toRaw(observed) {
      const raw = observed && observed["__v_raw"];
      return raw ? toRaw(raw) : observed;
    }
    function markRaw(value) {
      if (Object.isExtensible(value)) {
        def(value, "__v_skip", true);
      }
      return value;
    }
    const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
    const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
    class ComputedRefImpl {
      constructor(getter, _setter, isReadonly2, isSSR) {
        this._setter = _setter;
        this.dep = void 0;
        this.__v_isRef = true;
        this["__v_isReadonly"] = false;
        this.effect = new ReactiveEffect(
          () => getter(this._value),
          () => triggerRefValue(
            this,
            this.effect._dirtyLevel === 2 ? 2 : 3
          )
        );
        this.effect.computed = this;
        this.effect.active = this._cacheable = !isSSR;
        this["__v_isReadonly"] = isReadonly2;
      }
      get value() {
        const self2 = toRaw(this);
        if ((!self2._cacheable || self2.effect.dirty) && hasChanged(self2._value, self2._value = self2.effect.run())) {
          triggerRefValue(self2, 4);
        }
        trackRefValue(self2);
        if (self2.effect._dirtyLevel >= 2) {
          triggerRefValue(self2, 2);
        }
        return self2._value;
      }
      set value(newValue) {
        this._setter(newValue);
      }
      // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
      get _dirty() {
        return this.effect.dirty;
      }
      set _dirty(v) {
        this.effect.dirty = v;
      }
      // #endregion
    }
    function computed$1(getterOrOptions, debugOptions, isSSR = false) {
      let getter;
      let setter;
      const onlyGetter = isFunction$2(getterOrOptions);
      if (onlyGetter) {
        getter = getterOrOptions;
        setter = NOOP;
      } else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
      }
      const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
      return cRef;
    }
    function trackRefValue(ref2) {
      var _a;
      if (shouldTrack && activeEffect) {
        ref2 = toRaw(ref2);
        trackEffect(
          activeEffect,
          (_a = ref2.dep) != null ? _a : ref2.dep = createDep(
            () => ref2.dep = void 0,
            ref2 instanceof ComputedRefImpl ? ref2 : void 0
          )
        );
      }
    }
    function triggerRefValue(ref2, dirtyLevel = 4, newVal) {
      ref2 = toRaw(ref2);
      const dep = ref2.dep;
      if (dep) {
        triggerEffects(
          dep,
          dirtyLevel
        );
      }
    }
    function isRef(r) {
      return !!(r && r.__v_isRef === true);
    }
    function unref(ref2) {
      return isRef(ref2) ? ref2.value : ref2;
    }
    const shallowUnwrapHandlers = {
      get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
      set: (target, key, value, receiver) => {
        const oldValue = target[key];
        if (isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        } else {
          return Reflect.set(target, key, value, receiver);
        }
      }
    };
    function proxyRefs(objectWithRefs) {
      return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
    }
    /**
    * @vue/runtime-core v3.4.18
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const stack = [];
    function warn$1(msg, ...args) {
      pauseTracking();
      const instance = stack.length ? stack[stack.length - 1].component : null;
      const appWarnHandler = instance && instance.appContext.config.warnHandler;
      const trace = getComponentTrace();
      if (appWarnHandler) {
        callWithErrorHandling(
          appWarnHandler,
          instance,
          11,
          [
            msg + args.join(""),
            instance && instance.proxy,
            trace.map(
              ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
            ).join("\n"),
            trace
          ]
        );
      } else {
        const warnArgs = [`[Vue warn]: ${msg}`, ...args];
        if (trace.length && // avoid spamming console during tests
        true) {
          warnArgs.push(`
`, ...formatTrace(trace));
        }
        console.warn(...warnArgs);
      }
      resetTracking();
    }
    function getComponentTrace() {
      let currentVNode = stack[stack.length - 1];
      if (!currentVNode) {
        return [];
      }
      const normalizedStack = [];
      while (currentVNode) {
        const last = normalizedStack[0];
        if (last && last.vnode === currentVNode) {
          last.recurseCount++;
        } else {
          normalizedStack.push({
            vnode: currentVNode,
            recurseCount: 0
          });
        }
        const parentInstance = currentVNode.component && currentVNode.component.parent;
        currentVNode = parentInstance && parentInstance.vnode;
      }
      return normalizedStack;
    }
    function formatTrace(trace) {
      const logs = [];
      trace.forEach((entry, i) => {
        logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
      });
      return logs;
    }
    function formatTraceEntry({ vnode, recurseCount }) {
      const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
      const isRoot = vnode.component ? vnode.component.parent == null : false;
      const open = ` at <${formatComponentName(
        vnode.component,
        vnode.type,
        isRoot
      )}`;
      const close = `>` + postfix;
      return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
    }
    function formatProps(props) {
      const res = [];
      const keys2 = Object.keys(props);
      keys2.slice(0, 3).forEach((key) => {
        res.push(...formatProp(key, props[key]));
      });
      if (keys2.length > 3) {
        res.push(` ...`);
      }
      return res;
    }
    function formatProp(key, value, raw) {
      if (isString$2(value)) {
        value = JSON.stringify(value);
        return raw ? value : [`${key}=${value}`];
      } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
        return raw ? value : [`${key}=${value}`];
      } else if (isRef(value)) {
        value = formatProp(key, toRaw(value.value), true);
        return raw ? value : [`${key}=Ref<`, value, `>`];
      } else if (isFunction$2(value)) {
        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
      } else {
        value = toRaw(value);
        return raw ? value : [`${key}=`, value];
      }
    }
    function callWithErrorHandling(fn, instance, type, args) {
      let res;
      try {
        res = args ? fn(...args) : fn();
      } catch (err) {
        handleError(err, instance, type);
      }
      return res;
    }
    function callWithAsyncErrorHandling(fn, instance, type, args) {
      if (isFunction$2(fn)) {
        const res = callWithErrorHandling(fn, instance, type, args);
        if (res && isPromise(res)) {
          res.catch((err) => {
            handleError(err, instance, type);
          });
        }
        return res;
      }
      const values = [];
      for (let i = 0; i < fn.length; i++) {
        values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
      }
      return values;
    }
    function handleError(err, instance, type, throwInDev = true) {
      const contextVNode = instance ? instance.vnode : null;
      if (instance) {
        let cur = instance.parent;
        const exposedInstance = instance.proxy;
        const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
        while (cur) {
          const errorCapturedHooks = cur.ec;
          if (errorCapturedHooks) {
            for (let i = 0; i < errorCapturedHooks.length; i++) {
              if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
                return;
              }
            }
          }
          cur = cur.parent;
        }
        const appErrorHandler = instance.appContext.config.errorHandler;
        if (appErrorHandler) {
          callWithErrorHandling(
            appErrorHandler,
            null,
            10,
            [err, exposedInstance, errorInfo]
          );
          return;
        }
      }
      logError(err, type, contextVNode, throwInDev);
    }
    function logError(err, type, contextVNode, throwInDev = true) {
      {
        console.error(err);
      }
    }
    let isFlushing = false;
    let isFlushPending = false;
    const queue = [];
    let flushIndex = 0;
    const pendingPostFlushCbs = [];
    let activePostFlushCbs = null;
    let postFlushIndex = 0;
    const resolvedPromise = /* @__PURE__ */ Promise.resolve();
    let currentFlushPromise = null;
    function nextTick(fn) {
      const p2 = currentFlushPromise || resolvedPromise;
      return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
    }
    function findInsertionIndex(id2) {
      let start2 = flushIndex + 1;
      let end2 = queue.length;
      while (start2 < end2) {
        const middle = start2 + end2 >>> 1;
        const middleJob = queue[middle];
        const middleJobId = getId(middleJob);
        if (middleJobId < id2 || middleJobId === id2 && middleJob.pre) {
          start2 = middle + 1;
        } else {
          end2 = middle;
        }
      }
      return start2;
    }
    function queueJob(job) {
      if (!queue.length || !queue.includes(
        job,
        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
      )) {
        if (job.id == null) {
          queue.push(job);
        } else {
          queue.splice(findInsertionIndex(job.id), 0, job);
        }
        queueFlush();
      }
    }
    function queueFlush() {
      if (!isFlushing && !isFlushPending) {
        isFlushPending = true;
        currentFlushPromise = resolvedPromise.then(flushJobs);
      }
    }
    function invalidateJob(job) {
      const i = queue.indexOf(job);
      if (i > flushIndex) {
        queue.splice(i, 1);
      }
    }
    function queuePostFlushCb(cb) {
      if (!isArray$2(cb)) {
        if (!activePostFlushCbs || !activePostFlushCbs.includes(
          cb,
          cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
        )) {
          pendingPostFlushCbs.push(cb);
        }
      } else {
        pendingPostFlushCbs.push(...cb);
      }
      queueFlush();
    }
    function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
      for (; i < queue.length; i++) {
        const cb = queue[i];
        if (cb && cb.pre) {
          if (instance && cb.id !== instance.uid) {
            continue;
          }
          queue.splice(i, 1);
          i--;
          cb();
        }
      }
    }
    function flushPostFlushCbs(seen) {
      if (pendingPostFlushCbs.length) {
        const deduped = [...new Set(pendingPostFlushCbs)].sort(
          (a, b) => getId(a) - getId(b)
        );
        pendingPostFlushCbs.length = 0;
        if (activePostFlushCbs) {
          activePostFlushCbs.push(...deduped);
          return;
        }
        activePostFlushCbs = deduped;
        for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
          activePostFlushCbs[postFlushIndex]();
        }
        activePostFlushCbs = null;
        postFlushIndex = 0;
      }
    }
    const getId = (job) => job.id == null ? Infinity : job.id;
    const comparator = (a, b) => {
      const diff2 = getId(a) - getId(b);
      if (diff2 === 0) {
        if (a.pre && !b.pre)
          return -1;
        if (b.pre && !a.pre)
          return 1;
      }
      return diff2;
    };
    function flushJobs(seen) {
      isFlushPending = false;
      isFlushing = true;
      queue.sort(comparator);
      try {
        for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
          const job = queue[flushIndex];
          if (job && job.active !== false) {
            if (false)
              ;
            callWithErrorHandling(job, null, 14);
          }
        }
      } finally {
        flushIndex = 0;
        queue.length = 0;
        flushPostFlushCbs();
        isFlushing = false;
        currentFlushPromise = null;
        if (queue.length || pendingPostFlushCbs.length) {
          flushJobs();
        }
      }
    }
    function emit(instance, event, ...rawArgs) {
      if (instance.isUnmounted)
        return;
      const props = instance.vnode.props || EMPTY_OBJ;
      let args = rawArgs;
      const isModelListener2 = event.startsWith("update:");
      const modelArg = isModelListener2 && event.slice(7);
      if (modelArg && modelArg in props) {
        const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
        const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
        if (trim2) {
          args = rawArgs.map((a) => isString$2(a) ? a.trim() : a);
        }
        if (number) {
          args = rawArgs.map(looseToNumber);
        }
      }
      let handlerName;
      let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
      props[handlerName = toHandlerKey(camelize(event))];
      if (!handler && isModelListener2) {
        handler = props[handlerName = toHandlerKey(hyphenate(event))];
      }
      if (handler) {
        callWithAsyncErrorHandling(
          handler,
          instance,
          6,
          args
        );
      }
      const onceHandler = props[handlerName + `Once`];
      if (onceHandler) {
        if (!instance.emitted) {
          instance.emitted = {};
        } else if (instance.emitted[handlerName]) {
          return;
        }
        instance.emitted[handlerName] = true;
        callWithAsyncErrorHandling(
          onceHandler,
          instance,
          6,
          args
        );
      }
    }
    function normalizeEmitsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.emitsCache;
      const cached = cache.get(comp);
      if (cached !== void 0) {
        return cached;
      }
      const raw = comp.emits;
      let normalized = {};
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendEmits = (raw2) => {
          const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
          if (normalizedFromExtend) {
            hasExtends = true;
            extend$3(normalized, normalizedFromExtend);
          }
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendEmits);
        }
        if (comp.extends) {
          extendEmits(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendEmits);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, null);
        }
        return null;
      }
      if (isArray$2(raw)) {
        raw.forEach((key) => normalized[key] = null);
      } else {
        extend$3(normalized, raw);
      }
      if (isObject$2(comp)) {
        cache.set(comp, normalized);
      }
      return normalized;
    }
    function isEmitListener(options, key) {
      if (!options || !isOn(key)) {
        return false;
      }
      key = key.slice(2).replace(/Once$/, "");
      return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
    }
    let currentRenderingInstance = null;
    let currentScopeId = null;
    function setCurrentRenderingInstance(instance) {
      const prev = currentRenderingInstance;
      currentRenderingInstance = instance;
      currentScopeId = instance && instance.type.__scopeId || null;
      return prev;
    }
    function pushScopeId(id2) {
      currentScopeId = id2;
    }
    function popScopeId() {
      currentScopeId = null;
    }
    function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
      if (!ctx)
        return fn;
      if (fn._n) {
        return fn;
      }
      const renderFnWithContext = (...args) => {
        if (renderFnWithContext._d) {
          setBlockTracking(-1);
        }
        const prevInstance = setCurrentRenderingInstance(ctx);
        let res;
        try {
          res = fn(...args);
        } finally {
          setCurrentRenderingInstance(prevInstance);
          if (renderFnWithContext._d) {
            setBlockTracking(1);
          }
        }
        return res;
      };
      renderFnWithContext._n = true;
      renderFnWithContext._c = true;
      renderFnWithContext._d = true;
      return renderFnWithContext;
    }
    function markAttrsAccessed() {
    }
    function renderComponentRoot(instance) {
      const {
        type: Component,
        vnode,
        proxy,
        withProxy,
        props,
        propsOptions: [propsOptions],
        slots,
        attrs,
        emit: emit2,
        render,
        renderCache,
        data,
        setupState,
        ctx,
        inheritAttrs
      } = instance;
      let result;
      let fallthroughAttrs;
      const prev = setCurrentRenderingInstance(instance);
      try {
        if (vnode.shapeFlag & 4) {
          const proxyToUse = withProxy || proxy;
          const thisProxy = false ? new Proxy(proxyToUse, {
            get(target, key, receiver) {
              warn$1(
                `Property '${String(
                  key
                )}' was accessed via 'this'. Avoid using 'this' in templates.`
              );
              return Reflect.get(target, key, receiver);
            }
          }) : proxyToUse;
          result = normalizeVNode(
            render.call(
              thisProxy,
              proxyToUse,
              renderCache,
              props,
              setupState,
              data,
              ctx
            )
          );
          fallthroughAttrs = attrs;
        } else {
          const render2 = Component;
          if (false)
            ;
          result = normalizeVNode(
            render2.length > 1 ? render2(
              props,
              false ? {
                get attrs() {
                  markAttrsAccessed();
                  return attrs;
                },
                slots,
                emit: emit2
              } : { attrs, slots, emit: emit2 }
            ) : render2(
              props,
              null
              /* we know it doesn't need it */
            )
          );
          fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
        }
      } catch (err) {
        blockStack.length = 0;
        handleError(err, instance, 1);
        result = createVNode(Comment);
      }
      let root2 = result;
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys2 = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root2;
        if (keys2.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys2.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(
                fallthroughAttrs,
                propsOptions
              );
            }
            root2 = cloneVNode(root2, fallthroughAttrs);
          }
        }
      }
      if (vnode.dirs) {
        root2 = cloneVNode(root2);
        root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        root2.transition = vnode.transition;
      }
      {
        result = root2;
      }
      setCurrentRenderingInstance(prev);
      return result;
    }
    const getFunctionalFallthrough = (attrs) => {
      let res;
      for (const key in attrs) {
        if (key === "class" || key === "style" || isOn(key)) {
          (res || (res = {}))[key] = attrs[key];
        }
      }
      return res;
    };
    const filterModelListeners = (attrs, props) => {
      const res = {};
      for (const key in attrs) {
        if (!isModelListener(key) || !(key.slice(9) in props)) {
          res[key] = attrs[key];
        }
      }
      return res;
    };
    function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
      const { props: prevProps, children: prevChildren, component } = prevVNode;
      const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
      const emits = component.emitsOptions;
      if (nextVNode.dirs || nextVNode.transition) {
        return true;
      }
      if (optimized && patchFlag >= 0) {
        if (patchFlag & 1024) {
          return true;
        }
        if (patchFlag & 16) {
          if (!prevProps) {
            return !!nextProps;
          }
          return hasPropsChanged(prevProps, nextProps, emits);
        } else if (patchFlag & 8) {
          const dynamicProps = nextVNode.dynamicProps;
          for (let i = 0; i < dynamicProps.length; i++) {
            const key = dynamicProps[i];
            if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
              return true;
            }
          }
        }
      } else {
        if (prevChildren || nextChildren) {
          if (!nextChildren || !nextChildren.$stable) {
            return true;
          }
        }
        if (prevProps === nextProps) {
          return false;
        }
        if (!prevProps) {
          return !!nextProps;
        }
        if (!nextProps) {
          return true;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      }
      return false;
    }
    function hasPropsChanged(prevProps, nextProps, emitsOptions) {
      const nextKeys = Object.keys(nextProps);
      if (nextKeys.length !== Object.keys(prevProps).length) {
        return true;
      }
      for (let i = 0; i < nextKeys.length; i++) {
        const key = nextKeys[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
          return true;
        }
      }
      return false;
    }
    function updateHOCHostEl({ vnode, parent }, el) {
      while (parent) {
        const root2 = parent.subTree;
        if (root2.suspense && root2.suspense.activeBranch === vnode) {
          root2.el = vnode.el;
        }
        if (root2 === vnode) {
          (vnode = parent.vnode).el = el;
          parent = parent.parent;
        } else {
          break;
        }
      }
    }
    const COMPONENTS = "components";
    const DIRECTIVES = "directives";
    function resolveComponent(name2, maybeSelfReference) {
      return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
    }
    const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
    function resolveDynamicComponent(component) {
      if (isString$2(component)) {
        return resolveAsset(COMPONENTS, component, false) || component;
      } else {
        return component || NULL_DYNAMIC_COMPONENT;
      }
    }
    function resolveDirective(name2) {
      return resolveAsset(DIRECTIVES, name2);
    }
    function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
      const instance = currentRenderingInstance || currentInstance;
      if (instance) {
        const Component = instance.type;
        if (type === COMPONENTS) {
          const selfName = getComponentName(
            Component,
            false
          );
          if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
            return Component;
          }
        }
        const res = (
          // local registration
          // check instance[type] first which is resolved for options API
          resolve(instance[type] || Component[type], name2) || // global registration
          resolve(instance.appContext[type], name2)
        );
        if (!res && maybeSelfReference) {
          return Component;
        }
        return res;
      }
    }
    function resolve(registry, name2) {
      return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
    }
    const isSuspense = (type) => type.__isSuspense;
    function queueEffectWithSuspense(fn, suspense) {
      if (suspense && suspense.pendingBranch) {
        if (isArray$2(fn)) {
          suspense.effects.push(...fn);
        } else {
          suspense.effects.push(fn);
        }
      } else {
        queuePostFlushCb(fn);
      }
    }
    const ssrContextKey = Symbol.for("v-scx");
    const useSSRContext = () => {
      {
        const ctx = inject(ssrContextKey);
        return ctx;
      }
    };
    function watchPostEffect(effect2, options) {
      return doWatch(
        effect2,
        null,
        { flush: "post" }
      );
    }
    const INITIAL_WATCHER_VALUE = {};
    function watch(source, cb, options) {
      return doWatch(source, cb, options);
    }
    function doWatch(source, cb, {
      immediate,
      deep,
      flush,
      once,
      onTrack,
      onTrigger
    } = EMPTY_OBJ) {
      if (cb && once) {
        const _cb = cb;
        cb = (...args) => {
          _cb(...args);
          unwatch();
        };
      }
      const instance = currentInstance;
      const reactiveGetter = (source2) => deep === true ? source2 : (
        // for deep: false, only traverse root-level properties
        traverse(source2, deep === false ? 1 : void 0)
      );
      let getter;
      let forceTrigger = false;
      let isMultiSource = false;
      if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
      } else if (isReactive(source)) {
        getter = () => reactiveGetter(source);
        forceTrigger = true;
      } else if (isArray$2(source)) {
        isMultiSource = true;
        forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
        getter = () => source.map((s) => {
          if (isRef(s)) {
            return s.value;
          } else if (isReactive(s)) {
            return reactiveGetter(s);
          } else if (isFunction$2(s)) {
            return callWithErrorHandling(s, instance, 2);
          } else
            ;
        });
      } else if (isFunction$2(source)) {
        if (cb) {
          getter = () => callWithErrorHandling(source, instance, 2);
        } else {
          getter = () => {
            if (cleanup) {
              cleanup();
            }
            return callWithAsyncErrorHandling(
              source,
              instance,
              3,
              [onCleanup]
            );
          };
        }
      } else {
        getter = NOOP;
      }
      if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
      }
      let cleanup;
      let onCleanup = (fn) => {
        cleanup = effect2.onStop = () => {
          callWithErrorHandling(fn, instance, 4);
          cleanup = effect2.onStop = void 0;
        };
      };
      let ssrCleanup;
      if (isInSSRComponentSetup) {
        onCleanup = NOOP;
        if (!cb) {
          getter();
        } else if (immediate) {
          callWithAsyncErrorHandling(cb, instance, 3, [
            getter(),
            isMultiSource ? [] : void 0,
            onCleanup
          ]);
        }
        if (flush === "sync") {
          const ctx = useSSRContext();
          ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
        } else {
          return NOOP;
        }
      }
      let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
      const job = () => {
        if (!effect2.active || !effect2.dirty) {
          return;
        }
        if (cb) {
          const newValue = effect2.run();
          if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
            if (cleanup) {
              cleanup();
            }
            callWithAsyncErrorHandling(cb, instance, 3, [
              newValue,
              // pass undefined as the old value when it's changed for the first time
              oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
              onCleanup
            ]);
            oldValue = newValue;
          }
        } else {
          effect2.run();
        }
      };
      job.allowRecurse = !!cb;
      let scheduler;
      if (flush === "sync") {
        scheduler = job;
      } else if (flush === "post") {
        scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
      } else {
        job.pre = true;
        if (instance)
          job.id = instance.uid;
        scheduler = () => queueJob(job);
      }
      const effect2 = new ReactiveEffect(getter, NOOP, scheduler);
      const scope = getCurrentScope();
      const unwatch = () => {
        effect2.stop();
        if (scope) {
          remove$1(scope.effects, effect2);
        }
      };
      if (cb) {
        if (immediate) {
          job();
        } else {
          oldValue = effect2.run();
        }
      } else if (flush === "post") {
        queuePostRenderEffect(
          effect2.run.bind(effect2),
          instance && instance.suspense
        );
      } else {
        effect2.run();
      }
      if (ssrCleanup)
        ssrCleanup.push(unwatch);
      return unwatch;
    }
    function instanceWatch(source, value, options) {
      const publicThis = this.proxy;
      const getter = isString$2(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
      let cb;
      if (isFunction$2(value)) {
        cb = value;
      } else {
        cb = value.handler;
        options = value;
      }
      const reset = setCurrentInstance(this);
      const res = doWatch(getter, cb.bind(publicThis), options);
      reset();
      return res;
    }
    function createPathGetter(ctx, path) {
      const segments = path.split(".");
      return () => {
        let cur = ctx;
        for (let i = 0; i < segments.length && cur; i++) {
          cur = cur[segments[i]];
        }
        return cur;
      };
    }
    function traverse(value, depth, currentDepth = 0, seen) {
      if (!isObject$2(value) || value["__v_skip"]) {
        return value;
      }
      if (depth && depth > 0) {
        if (currentDepth >= depth) {
          return value;
        }
        currentDepth++;
      }
      seen = seen || /* @__PURE__ */ new Set();
      if (seen.has(value)) {
        return value;
      }
      seen.add(value);
      if (isRef(value)) {
        traverse(value.value, depth, currentDepth, seen);
      } else if (isArray$2(value)) {
        for (let i = 0; i < value.length; i++) {
          traverse(value[i], depth, currentDepth, seen);
        }
      } else if (isSet(value) || isMap(value)) {
        value.forEach((v) => {
          traverse(v, depth, currentDepth, seen);
        });
      } else if (isPlainObject$1(value)) {
        for (const key in value) {
          traverse(value[key], depth, currentDepth, seen);
        }
      }
      return value;
    }
    function withDirectives(vnode, directives) {
      if (currentRenderingInstance === null) {
        return vnode;
      }
      const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;
      const bindings = vnode.dirs || (vnode.dirs = []);
      for (let i = 0; i < directives.length; i++) {
        let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
        if (dir) {
          if (isFunction$2(dir)) {
            dir = {
              mounted: dir,
              updated: dir
            };
          }
          if (dir.deep) {
            traverse(value);
          }
          bindings.push({
            dir,
            instance,
            value,
            oldValue: void 0,
            arg,
            modifiers
          });
        }
      }
      return vnode;
    }
    function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
      const bindings = vnode.dirs;
      const oldBindings = prevVNode && prevVNode.dirs;
      for (let i = 0; i < bindings.length; i++) {
        const binding = bindings[i];
        if (oldBindings) {
          binding.oldValue = oldBindings[i].value;
        }
        let hook = binding.dir[name2];
        if (hook) {
          pauseTracking();
          callWithAsyncErrorHandling(hook, instance, 8, [
            vnode.el,
            binding,
            vnode,
            prevVNode
          ]);
          resetTracking();
        }
      }
    }
    const leaveCbKey = Symbol("_leaveCb");
    const enterCbKey$1 = Symbol("_enterCb");
    function useTransitionState() {
      const state = {
        isMounted: false,
        isLeaving: false,
        isUnmounting: false,
        leavingVNodes: /* @__PURE__ */ new Map()
      };
      onMounted(() => {
        state.isMounted = true;
      });
      onBeforeUnmount(() => {
        state.isUnmounting = true;
      });
      return state;
    }
    const TransitionHookValidator = [Function, Array];
    const BaseTransitionPropsValidators = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      // enter
      onBeforeEnter: TransitionHookValidator,
      onEnter: TransitionHookValidator,
      onAfterEnter: TransitionHookValidator,
      onEnterCancelled: TransitionHookValidator,
      // leave
      onBeforeLeave: TransitionHookValidator,
      onLeave: TransitionHookValidator,
      onAfterLeave: TransitionHookValidator,
      onLeaveCancelled: TransitionHookValidator,
      // appear
      onBeforeAppear: TransitionHookValidator,
      onAppear: TransitionHookValidator,
      onAfterAppear: TransitionHookValidator,
      onAppearCancelled: TransitionHookValidator
    };
    const BaseTransitionImpl = {
      name: `BaseTransition`,
      props: BaseTransitionPropsValidators,
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevTransitionKey;
        return () => {
          const children2 = slots.default && getTransitionRawChildren(slots.default(), true);
          if (!children2 || !children2.length) {
            return;
          }
          let child = children2[0];
          if (children2.length > 1) {
            for (const c of children2) {
              if (c.type !== Comment) {
                child = c;
                break;
              }
            }
          }
          const rawProps = toRaw(props);
          const { mode } = rawProps;
          if (state.isLeaving) {
            return emptyPlaceholder(child);
          }
          const innerChild = getKeepAliveChild(child);
          if (!innerChild) {
            return emptyPlaceholder(child);
          }
          const enterHooks = resolveTransitionHooks(
            innerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(innerChild, enterHooks);
          const oldChild = instance.subTree;
          const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
          let transitionKeyChanged = false;
          const { getTransitionKey } = innerChild.type;
          if (getTransitionKey) {
            const key = getTransitionKey();
            if (prevTransitionKey === void 0) {
              prevTransitionKey = key;
            } else if (key !== prevTransitionKey) {
              prevTransitionKey = key;
              transitionKeyChanged = true;
            }
          }
          if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
            const leavingHooks = resolveTransitionHooks(
              oldInnerChild,
              rawProps,
              state,
              instance
            );
            setTransitionHooks(oldInnerChild, leavingHooks);
            if (mode === "out-in") {
              state.isLeaving = true;
              leavingHooks.afterLeave = () => {
                state.isLeaving = false;
                if (instance.update.active !== false) {
                  instance.effect.dirty = true;
                  instance.update();
                }
              };
              return emptyPlaceholder(child);
            } else if (mode === "in-out" && innerChild.type !== Comment) {
              leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                const leavingVNodesCache = getLeavingNodesForType(
                  state,
                  oldInnerChild
                );
                leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                el[leaveCbKey] = () => {
                  earlyRemove();
                  el[leaveCbKey] = void 0;
                  delete enterHooks.delayedLeave;
                };
                enterHooks.delayedLeave = delayedLeave;
              };
            }
          }
          return child;
        };
      }
    };
    const BaseTransition = BaseTransitionImpl;
    function getLeavingNodesForType(state, vnode) {
      const { leavingVNodes } = state;
      let leavingVNodesCache = leavingVNodes.get(vnode.type);
      if (!leavingVNodesCache) {
        leavingVNodesCache = /* @__PURE__ */ Object.create(null);
        leavingVNodes.set(vnode.type, leavingVNodesCache);
      }
      return leavingVNodesCache;
    }
    function resolveTransitionHooks(vnode, props, state, instance) {
      const {
        appear,
        mode,
        persisted = false,
        onBeforeEnter,
        onEnter,
        onAfterEnter,
        onEnterCancelled,
        onBeforeLeave,
        onLeave,
        onAfterLeave,
        onLeaveCancelled,
        onBeforeAppear,
        onAppear,
        onAfterAppear,
        onAppearCancelled
      } = props;
      const key = String(vnode.key);
      const leavingVNodesCache = getLeavingNodesForType(state, vnode);
      const callHook2 = (hook, args) => {
        hook && callWithAsyncErrorHandling(
          hook,
          instance,
          9,
          args
        );
      };
      const callAsyncHook = (hook, args) => {
        const done = args[1];
        callHook2(hook, args);
        if (isArray$2(hook)) {
          if (hook.every((hook2) => hook2.length <= 1))
            done();
        } else if (hook.length <= 1) {
          done();
        }
      };
      const hooks2 = {
        mode,
        persisted,
        beforeEnter(el) {
          let hook = onBeforeEnter;
          if (!state.isMounted) {
            if (appear) {
              hook = onBeforeAppear || onBeforeEnter;
            } else {
              return;
            }
          }
          if (el[leaveCbKey]) {
            el[leaveCbKey](
              true
              /* cancelled */
            );
          }
          const leavingVNode = leavingVNodesCache[key];
          if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
            leavingVNode.el[leaveCbKey]();
          }
          callHook2(hook, [el]);
        },
        enter(el) {
          let hook = onEnter;
          let afterHook = onAfterEnter;
          let cancelHook = onEnterCancelled;
          if (!state.isMounted) {
            if (appear) {
              hook = onAppear || onEnter;
              afterHook = onAfterAppear || onAfterEnter;
              cancelHook = onAppearCancelled || onEnterCancelled;
            } else {
              return;
            }
          }
          let called = false;
          const done = el[enterCbKey$1] = (cancelled) => {
            if (called)
              return;
            called = true;
            if (cancelled) {
              callHook2(cancelHook, [el]);
            } else {
              callHook2(afterHook, [el]);
            }
            if (hooks2.delayedLeave) {
              hooks2.delayedLeave();
            }
            el[enterCbKey$1] = void 0;
          };
          if (hook) {
            callAsyncHook(hook, [el, done]);
          } else {
            done();
          }
        },
        leave(el, remove2) {
          const key2 = String(vnode.key);
          if (el[enterCbKey$1]) {
            el[enterCbKey$1](
              true
              /* cancelled */
            );
          }
          if (state.isUnmounting) {
            return remove2();
          }
          callHook2(onBeforeLeave, [el]);
          let called = false;
          const done = el[leaveCbKey] = (cancelled) => {
            if (called)
              return;
            called = true;
            remove2();
            if (cancelled) {
              callHook2(onLeaveCancelled, [el]);
            } else {
              callHook2(onAfterLeave, [el]);
            }
            el[leaveCbKey] = void 0;
            if (leavingVNodesCache[key2] === vnode) {
              delete leavingVNodesCache[key2];
            }
          };
          leavingVNodesCache[key2] = vnode;
          if (onLeave) {
            callAsyncHook(onLeave, [el, done]);
          } else {
            done();
          }
        },
        clone(vnode2) {
          return resolveTransitionHooks(vnode2, props, state, instance);
        }
      };
      return hooks2;
    }
    function emptyPlaceholder(vnode) {
      if (isKeepAlive(vnode)) {
        vnode = cloneVNode(vnode);
        vnode.children = null;
        return vnode;
      }
    }
    function getKeepAliveChild(vnode) {
      return isKeepAlive(vnode) ? (
        // #7121 ensure get the child component subtree in case
        // it's been replaced during HMR
        vnode.children ? vnode.children[0] : void 0
      ) : vnode;
    }
    function setTransitionHooks(vnode, hooks2) {
      if (vnode.shapeFlag & 6 && vnode.component) {
        setTransitionHooks(vnode.component.subTree, hooks2);
      } else if (vnode.shapeFlag & 128) {
        vnode.ssContent.transition = hooks2.clone(vnode.ssContent);
        vnode.ssFallback.transition = hooks2.clone(vnode.ssFallback);
      } else {
        vnode.transition = hooks2;
      }
    }
    function getTransitionRawChildren(children2, keepComment = false, parentKey) {
      let ret = [];
      let keyedFragmentCount = 0;
      for (let i = 0; i < children2.length; i++) {
        let child = children2[i];
        const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
        if (child.type === Fragment) {
          if (child.patchFlag & 128)
            keyedFragmentCount++;
          ret = ret.concat(
            getTransitionRawChildren(child.children, keepComment, key)
          );
        } else if (keepComment || child.type !== Comment) {
          ret.push(key != null ? cloneVNode(child, { key }) : child);
        }
      }
      if (keyedFragmentCount > 1) {
        for (let i = 0; i < ret.length; i++) {
          ret[i].patchFlag = -2;
        }
      }
      return ret;
    }
    const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
    const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
    function onActivated(hook, target) {
      registerKeepAliveHook(hook, "a", target);
    }
    function onDeactivated(hook, target) {
      registerKeepAliveHook(hook, "da", target);
    }
    function registerKeepAliveHook(hook, type, target = currentInstance) {
      const wrappedHook = hook.__wdc || (hook.__wdc = () => {
        let current = target;
        while (current) {
          if (current.isDeactivated) {
            return;
          }
          current = current.parent;
        }
        return hook();
      });
      injectHook(type, wrappedHook, target);
      if (target) {
        let current = target.parent;
        while (current && current.parent) {
          if (isKeepAlive(current.parent.vnode)) {
            injectToKeepAliveRoot(wrappedHook, type, target, current);
          }
          current = current.parent;
        }
      }
    }
    function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
      const injected = injectHook(
        type,
        hook,
        keepAliveRoot,
        true
        /* prepend */
      );
      onUnmounted(() => {
        remove$1(keepAliveRoot[type], injected);
      }, target);
    }
    function injectHook(type, hook, target = currentInstance, prepend = false) {
      if (target) {
        const hooks2 = target[type] || (target[type] = []);
        const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
          if (target.isUnmounted) {
            return;
          }
          pauseTracking();
          const reset = setCurrentInstance(target);
          const res = callWithAsyncErrorHandling(hook, target, type, args);
          reset();
          resetTracking();
          return res;
        });
        if (prepend) {
          hooks2.unshift(wrappedHook);
        } else {
          hooks2.push(wrappedHook);
        }
        return wrappedHook;
      }
    }
    const createHook = (lifecycle) => (hook, target = currentInstance) => (
      // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
      (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
    );
    const onBeforeMount = createHook("bm");
    const onMounted = createHook("m");
    const onBeforeUpdate = createHook("bu");
    const onUpdated = createHook("u");
    const onBeforeUnmount = createHook("bum");
    const onUnmounted = createHook("um");
    const onServerPrefetch = createHook("sp");
    const onRenderTriggered = createHook(
      "rtg"
    );
    const onRenderTracked = createHook(
      "rtc"
    );
    function onErrorCaptured(hook, target = currentInstance) {
      injectHook("ec", hook, target);
    }
    function renderList(source, renderItem, cache, index) {
      let ret;
      const cached = cache && cache[index];
      if (isArray$2(source) || isString$2(source)) {
        ret = new Array(source.length);
        for (let i = 0, l = source.length; i < l; i++) {
          ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
        }
      } else if (typeof source === "number") {
        ret = new Array(source);
        for (let i = 0; i < source; i++) {
          ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
        }
      } else if (isObject$2(source)) {
        if (source[Symbol.iterator]) {
          ret = Array.from(
            source,
            (item, i) => renderItem(item, i, void 0, cached && cached[i])
          );
        } else {
          const keys2 = Object.keys(source);
          ret = new Array(keys2.length);
          for (let i = 0, l = keys2.length; i < l; i++) {
            const key = keys2[i];
            ret[i] = renderItem(source[key], key, i, cached && cached[i]);
          }
        }
      } else {
        ret = [];
      }
      if (cache) {
        cache[index] = ret;
      }
      return ret;
    }
    function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
      if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
        if (name2 !== "default")
          props.name = name2;
        return createVNode("slot", props, fallback && fallback());
      }
      let slot = slots[name2];
      if (slot && slot._c) {
        slot._d = false;
      }
      openBlock();
      const validSlotContent = slot && ensureValidVNode(slot(props));
      const rendered = createBlock(
        Fragment,
        {
          key: props.key || // slot content array of a dynamic conditional slot may have a branch
          // key attached in the `createSlots` helper, respect that
          validSlotContent && validSlotContent.key || `_${name2}`
        },
        validSlotContent || (fallback ? fallback() : []),
        validSlotContent && slots._ === 1 ? 64 : -2
      );
      if (!noSlotted && rendered.scopeId) {
        rendered.slotScopeIds = [rendered.scopeId + "-s"];
      }
      if (slot && slot._c) {
        slot._d = true;
      }
      return rendered;
    }
    function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
        if (!isVNode(child))
          return true;
        if (child.type === Comment)
          return false;
        if (child.type === Fragment && !ensureValidVNode(child.children))
          return false;
        return true;
      }) ? vnodes : null;
    }
    function toHandlers(obj, preserveCaseIfNecessary) {
      const ret = {};
      for (const key in obj) {
        ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
      }
      return ret;
    }
    const getPublicInstance = (i) => {
      if (!i)
        return null;
      if (isStatefulComponent(i))
        return getExposeProxy(i) || i.proxy;
      return getPublicInstance(i.parent);
    };
    const publicPropertiesMap = (
      // Move PURE marker to new line to workaround compiler discarding it
      // due to type annotation
      /* @__PURE__ */ extend$3(/* @__PURE__ */ Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => i.props,
        $attrs: (i) => i.attrs,
        $slots: (i) => i.slots,
        $refs: (i) => i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => resolveMergedOptions(i),
        $forceUpdate: (i) => i.f || (i.f = () => {
          i.effect.dirty = true;
          queueJob(i.update);
        }),
        $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
        $watch: (i) => instanceWatch.bind(i)
      })
    );
    const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
    const PublicInstanceProxyHandlers = {
      get({ _: instance }, key) {
        const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
        let normalizedProps;
        if (key[0] !== "$") {
          const n = accessCache[key];
          if (n !== void 0) {
            switch (n) {
              case 1:
                return setupState[key];
              case 2:
                return data[key];
              case 4:
                return ctx[key];
              case 3:
                return props[key];
            }
          } else if (hasSetupBinding(setupState, key)) {
            accessCache[key] = 1;
            return setupState[key];
          } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
            accessCache[key] = 2;
            return data[key];
          } else if (
            // only cache other properties when instance has declared (thus stable)
            // props
            (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
          ) {
            accessCache[key] = 3;
            return props[key];
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
            accessCache[key] = 4;
            return ctx[key];
          } else if (shouldCacheAccess) {
            accessCache[key] = 0;
          }
        }
        const publicGetter = publicPropertiesMap[key];
        let cssModule, globalProperties;
        if (publicGetter) {
          if (key === "$attrs") {
            track(instance, "get", key);
          }
          return publicGetter(instance);
        } else if (
          // css module (injected by vue-loader)
          (cssModule = type.__cssModules) && (cssModule = cssModule[key])
        ) {
          return cssModule;
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4;
          return ctx[key];
        } else if (
          // global properties
          globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
        ) {
          {
            return globalProperties[key];
          }
        } else
          ;
      },
      set({ _: instance }, key, value) {
        const { data, setupState, ctx } = instance;
        if (hasSetupBinding(setupState, key)) {
          setupState[key] = value;
          return true;
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          data[key] = value;
          return true;
        } else if (hasOwn(instance.props, key)) {
          return false;
        }
        if (key[0] === "$" && key.slice(1) in instance) {
          return false;
        } else {
          {
            ctx[key] = value;
          }
        }
        return true;
      },
      has({
        _: { data, setupState, accessCache, ctx, appContext, propsOptions }
      }, key) {
        let normalizedProps;
        return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
      },
      defineProperty(target, key, descriptor) {
        if (descriptor.get != null) {
          target._.accessCache[key] = 0;
        } else if (hasOwn(descriptor, "value")) {
          this.set(target, key, descriptor.value, null);
        }
        return Reflect.defineProperty(target, key, descriptor);
      }
    };
    function normalizePropsOrEmits(props) {
      return isArray$2(props) ? props.reduce(
        (normalized, p2) => (normalized[p2] = null, normalized),
        {}
      ) : props;
    }
    let shouldCacheAccess = true;
    function applyOptions(instance) {
      const options = resolveMergedOptions(instance);
      const publicThis = instance.proxy;
      const ctx = instance.ctx;
      shouldCacheAccess = false;
      if (options.beforeCreate) {
        callHook$1(options.beforeCreate, instance, "bc");
      }
      const {
        // state
        data: dataOptions,
        computed: computedOptions,
        methods,
        watch: watchOptions,
        provide: provideOptions,
        inject: injectOptions,
        // lifecycle
        created,
        beforeMount,
        mounted,
        beforeUpdate,
        updated,
        activated,
        deactivated,
        beforeDestroy,
        beforeUnmount,
        destroyed,
        unmounted,
        render,
        renderTracked,
        renderTriggered,
        errorCaptured,
        serverPrefetch,
        // public API
        expose,
        inheritAttrs,
        // assets
        components,
        directives,
        filters
      } = options;
      const checkDuplicateProperties = null;
      if (injectOptions) {
        resolveInjections(injectOptions, ctx, checkDuplicateProperties);
      }
      if (methods) {
        for (const key in methods) {
          const methodHandler = methods[key];
          if (isFunction$2(methodHandler)) {
            {
              ctx[key] = methodHandler.bind(publicThis);
            }
          }
        }
      }
      if (dataOptions) {
        const data = dataOptions.call(publicThis, publicThis);
        if (!isObject$2(data))
          ;
        else {
          instance.data = reactive(data);
        }
      }
      shouldCacheAccess = true;
      if (computedOptions) {
        for (const key in computedOptions) {
          const opt = computedOptions[key];
          const get2 = isFunction$2(opt) ? opt.bind(publicThis, publicThis) : isFunction$2(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
          const set2 = !isFunction$2(opt) && isFunction$2(opt.set) ? opt.set.bind(publicThis) : NOOP;
          const c = computed({
            get: get2,
            set: set2
          });
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => c.value,
            set: (v) => c.value = v
          });
        }
      }
      if (watchOptions) {
        for (const key in watchOptions) {
          createWatcher(watchOptions[key], ctx, publicThis, key);
        }
      }
      if (provideOptions) {
        const provides = isFunction$2(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
        Reflect.ownKeys(provides).forEach((key) => {
          provide(key, provides[key]);
        });
      }
      if (created) {
        callHook$1(created, instance, "c");
      }
      function registerLifecycleHook(register, hook) {
        if (isArray$2(hook)) {
          hook.forEach((_hook) => register(_hook.bind(publicThis)));
        } else if (hook) {
          register(hook.bind(publicThis));
        }
      }
      registerLifecycleHook(onBeforeMount, beforeMount);
      registerLifecycleHook(onMounted, mounted);
      registerLifecycleHook(onBeforeUpdate, beforeUpdate);
      registerLifecycleHook(onUpdated, updated);
      registerLifecycleHook(onActivated, activated);
      registerLifecycleHook(onDeactivated, deactivated);
      registerLifecycleHook(onErrorCaptured, errorCaptured);
      registerLifecycleHook(onRenderTracked, renderTracked);
      registerLifecycleHook(onRenderTriggered, renderTriggered);
      registerLifecycleHook(onBeforeUnmount, beforeUnmount);
      registerLifecycleHook(onUnmounted, unmounted);
      registerLifecycleHook(onServerPrefetch, serverPrefetch);
      if (isArray$2(expose)) {
        if (expose.length) {
          const exposed = instance.exposed || (instance.exposed = {});
          expose.forEach((key) => {
            Object.defineProperty(exposed, key, {
              get: () => publicThis[key],
              set: (val) => publicThis[key] = val
            });
          });
        } else if (!instance.exposed) {
          instance.exposed = {};
        }
      }
      if (render && instance.render === NOOP) {
        instance.render = render;
      }
      if (inheritAttrs != null) {
        instance.inheritAttrs = inheritAttrs;
      }
      if (components)
        instance.components = components;
      if (directives)
        instance.directives = directives;
    }
    function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
      if (isArray$2(injectOptions)) {
        injectOptions = normalizeInject(injectOptions);
      }
      for (const key in injectOptions) {
        const opt = injectOptions[key];
        let injected;
        if (isObject$2(opt)) {
          if ("default" in opt) {
            injected = inject(
              opt.from || key,
              opt.default,
              true
            );
          } else {
            injected = inject(opt.from || key);
          }
        } else {
          injected = inject(opt);
        }
        if (isRef(injected)) {
          Object.defineProperty(ctx, key, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          ctx[key] = injected;
        }
      }
    }
    function callHook$1(hook, instance, type) {
      callWithAsyncErrorHandling(
        isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
        instance,
        type
      );
    }
    function createWatcher(raw, ctx, publicThis, key) {
      const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
      if (isString$2(raw)) {
        const handler = ctx[raw];
        if (isFunction$2(handler)) {
          watch(getter, handler);
        }
      } else if (isFunction$2(raw)) {
        watch(getter, raw.bind(publicThis));
      } else if (isObject$2(raw)) {
        if (isArray$2(raw)) {
          raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
        } else {
          const handler = isFunction$2(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
          if (isFunction$2(handler)) {
            watch(getter, handler, raw);
          }
        }
      } else
        ;
    }
    function resolveMergedOptions(instance) {
      const base = instance.type;
      const { mixins, extends: extendsOptions } = base;
      const {
        mixins: globalMixins,
        optionsCache: cache,
        config: { optionMergeStrategies }
      } = instance.appContext;
      const cached = cache.get(base);
      let resolved;
      if (cached) {
        resolved = cached;
      } else if (!globalMixins.length && !mixins && !extendsOptions) {
        {
          resolved = base;
        }
      } else {
        resolved = {};
        if (globalMixins.length) {
          globalMixins.forEach(
            (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
          );
        }
        mergeOptions(resolved, base, optionMergeStrategies);
      }
      if (isObject$2(base)) {
        cache.set(base, resolved);
      }
      return resolved;
    }
    function mergeOptions(to2, from2, strats, asMixin = false) {
      const { mixins, extends: extendsOptions } = from2;
      if (extendsOptions) {
        mergeOptions(to2, extendsOptions, strats, true);
      }
      if (mixins) {
        mixins.forEach(
          (m) => mergeOptions(to2, m, strats, true)
        );
      }
      for (const key in from2) {
        if (asMixin && key === "expose")
          ;
        else {
          const strat = internalOptionMergeStrats[key] || strats && strats[key];
          to2[key] = strat ? strat(to2[key], from2[key]) : from2[key];
        }
      }
      return to2;
    }
    const internalOptionMergeStrats = {
      data: mergeDataFn,
      props: mergeEmitsOrPropsOptions,
      emits: mergeEmitsOrPropsOptions,
      // objects
      methods: mergeObjectOptions,
      computed: mergeObjectOptions,
      // lifecycle
      beforeCreate: mergeAsArray,
      created: mergeAsArray,
      beforeMount: mergeAsArray,
      mounted: mergeAsArray,
      beforeUpdate: mergeAsArray,
      updated: mergeAsArray,
      beforeDestroy: mergeAsArray,
      beforeUnmount: mergeAsArray,
      destroyed: mergeAsArray,
      unmounted: mergeAsArray,
      activated: mergeAsArray,
      deactivated: mergeAsArray,
      errorCaptured: mergeAsArray,
      serverPrefetch: mergeAsArray,
      // assets
      components: mergeObjectOptions,
      directives: mergeObjectOptions,
      // watch
      watch: mergeWatchOptions,
      // provide / inject
      provide: mergeDataFn,
      inject: mergeInject
    };
    function mergeDataFn(to2, from2) {
      if (!from2) {
        return to2;
      }
      if (!to2) {
        return from2;
      }
      return function mergedDataFn() {
        return extend$3(
          isFunction$2(to2) ? to2.call(this, this) : to2,
          isFunction$2(from2) ? from2.call(this, this) : from2
        );
      };
    }
    function mergeInject(to2, from2) {
      return mergeObjectOptions(normalizeInject(to2), normalizeInject(from2));
    }
    function normalizeInject(raw) {
      if (isArray$2(raw)) {
        const res = {};
        for (let i = 0; i < raw.length; i++) {
          res[raw[i]] = raw[i];
        }
        return res;
      }
      return raw;
    }
    function mergeAsArray(to2, from2) {
      return to2 ? [...new Set([].concat(to2, from2))] : from2;
    }
    function mergeObjectOptions(to2, from2) {
      return to2 ? extend$3(/* @__PURE__ */ Object.create(null), to2, from2) : from2;
    }
    function mergeEmitsOrPropsOptions(to2, from2) {
      if (to2) {
        if (isArray$2(to2) && isArray$2(from2)) {
          return [.../* @__PURE__ */ new Set([...to2, ...from2])];
        }
        return extend$3(
          /* @__PURE__ */ Object.create(null),
          normalizePropsOrEmits(to2),
          normalizePropsOrEmits(from2 != null ? from2 : {})
        );
      } else {
        return from2;
      }
    }
    function mergeWatchOptions(to2, from2) {
      if (!to2)
        return from2;
      if (!from2)
        return to2;
      const merged = extend$3(/* @__PURE__ */ Object.create(null), to2);
      for (const key in from2) {
        merged[key] = mergeAsArray(to2[key], from2[key]);
      }
      return merged;
    }
    function createAppContext() {
      return {
        app: null,
        config: {
          isNativeTag: NO,
          performance: false,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: /* @__PURE__ */ Object.create(null),
        optionsCache: /* @__PURE__ */ new WeakMap(),
        propsCache: /* @__PURE__ */ new WeakMap(),
        emitsCache: /* @__PURE__ */ new WeakMap()
      };
    }
    let uid$1 = 0;
    function createAppAPI(render, hydrate) {
      return function createApp2(rootComponent, rootProps = null) {
        if (!isFunction$2(rootComponent)) {
          rootComponent = extend$3({}, rootComponent);
        }
        if (rootProps != null && !isObject$2(rootProps)) {
          rootProps = null;
        }
        const context = createAppContext();
        const installedPlugins = /* @__PURE__ */ new WeakSet();
        let isMounted = false;
        const app = context.app = {
          _uid: uid$1++,
          _component: rootComponent,
          _props: rootProps,
          _container: null,
          _context: context,
          _instance: null,
          version: version$2,
          get config() {
            return context.config;
          },
          set config(v) {
          },
          use(plugin, ...options) {
            if (installedPlugins.has(plugin))
              ;
            else if (plugin && isFunction$2(plugin.install)) {
              installedPlugins.add(plugin);
              plugin.install(app, ...options);
            } else if (isFunction$2(plugin)) {
              installedPlugins.add(plugin);
              plugin(app, ...options);
            } else
              ;
            return app;
          },
          mixin(mixin) {
            {
              if (!context.mixins.includes(mixin)) {
                context.mixins.push(mixin);
              }
            }
            return app;
          },
          component(name2, component) {
            if (!component) {
              return context.components[name2];
            }
            context.components[name2] = component;
            return app;
          },
          directive(name2, directive) {
            if (!directive) {
              return context.directives[name2];
            }
            context.directives[name2] = directive;
            return app;
          },
          mount(rootContainer, isHydrate, namespace2) {
            if (!isMounted) {
              const vnode = createVNode(rootComponent, rootProps);
              vnode.appContext = context;
              if (namespace2 === true) {
                namespace2 = "svg";
              } else if (namespace2 === false) {
                namespace2 = void 0;
              }
              if (isHydrate && hydrate) {
                hydrate(vnode, rootContainer);
              } else {
                render(vnode, rootContainer, namespace2);
              }
              isMounted = true;
              app._container = rootContainer;
              rootContainer.__vue_app__ = app;
              return getExposeProxy(vnode.component) || vnode.component.proxy;
            }
          },
          unmount() {
            if (isMounted) {
              render(null, app._container);
              delete app._container.__vue_app__;
            }
          },
          provide(key, value) {
            context.provides[key] = value;
            return app;
          },
          runWithContext(fn) {
            const lastApp = currentApp;
            currentApp = app;
            try {
              return fn();
            } finally {
              currentApp = lastApp;
            }
          }
        };
        return app;
      };
    }
    let currentApp = null;
    function provide(key, value) {
      if (!currentInstance)
        ;
      else {
        let provides = currentInstance.provides;
        const parentProvides = currentInstance.parent && currentInstance.parent.provides;
        if (parentProvides === provides) {
          provides = currentInstance.provides = Object.create(parentProvides);
        }
        provides[key] = value;
      }
    }
    function inject(key, defaultValue, treatDefaultAsFactory = false) {
      const instance = currentInstance || currentRenderingInstance;
      if (instance || currentApp) {
        const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
        if (provides && key in provides) {
          return provides[key];
        } else if (arguments.length > 1) {
          return treatDefaultAsFactory && isFunction$2(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
        } else
          ;
      }
    }
    function initProps(instance, rawProps, isStateful, isSSR = false) {
      const props = {};
      const attrs = {};
      def(attrs, InternalObjectKey, 1);
      instance.propsDefaults = /* @__PURE__ */ Object.create(null);
      setFullProps(instance, rawProps, props, attrs);
      for (const key in instance.propsOptions[0]) {
        if (!(key in props)) {
          props[key] = void 0;
        }
      }
      if (isStateful) {
        instance.props = isSSR ? props : shallowReactive(props);
      } else {
        if (!instance.type.props) {
          instance.props = attrs;
        } else {
          instance.props = props;
        }
      }
      instance.attrs = attrs;
    }
    function updateProps(instance, rawProps, rawPrevProps, optimized) {
      const {
        props,
        attrs,
        vnode: { patchFlag }
      } = instance;
      const rawCurrentProps = toRaw(props);
      const [options] = instance.propsOptions;
      let hasAttrsChanged = false;
      if (
        // always force full diff in dev
        // - #1942 if hmr is enabled with sfc component
        // - vite#872 non-sfc component used by sfc component
        (optimized || patchFlag > 0) && !(patchFlag & 16)
      ) {
        if (patchFlag & 8) {
          const propsToUpdate = instance.vnode.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            let key = propsToUpdate[i];
            if (isEmitListener(instance.emitsOptions, key)) {
              continue;
            }
            const value = rawProps[key];
            if (options) {
              if (hasOwn(attrs, key)) {
                if (value !== attrs[key]) {
                  attrs[key] = value;
                  hasAttrsChanged = true;
                }
              } else {
                const camelizedKey = camelize(key);
                props[camelizedKey] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  camelizedKey,
                  value,
                  instance,
                  false
                );
              }
            } else {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            }
          }
        }
      } else {
        if (setFullProps(instance, rawProps, props, attrs)) {
          hasAttrsChanged = true;
        }
        let kebabKey;
        for (const key in rawCurrentProps) {
          if (!rawProps || // for camelCase
          !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
          // and converted to camelCase (#955)
          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
            if (options) {
              if (rawPrevProps && // for camelCase
              (rawPrevProps[key] !== void 0 || // for kebab-case
              rawPrevProps[kebabKey] !== void 0)) {
                props[key] = resolvePropValue(
                  options,
                  rawCurrentProps,
                  key,
                  void 0,
                  instance,
                  true
                );
              }
            } else {
              delete props[key];
            }
          }
        }
        if (attrs !== rawCurrentProps) {
          for (const key in attrs) {
            if (!rawProps || !hasOwn(rawProps, key) && true) {
              delete attrs[key];
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (hasAttrsChanged) {
        trigger(instance, "set", "$attrs");
      }
    }
    function setFullProps(instance, rawProps, props, attrs) {
      const [options, needCastKeys] = instance.propsOptions;
      let hasAttrsChanged = false;
      let rawCastValues;
      if (rawProps) {
        for (let key in rawProps) {
          if (isReservedProp(key)) {
            continue;
          }
          const value = rawProps[key];
          let camelKey;
          if (options && hasOwn(options, camelKey = camelize(key))) {
            if (!needCastKeys || !needCastKeys.includes(camelKey)) {
              props[camelKey] = value;
            } else {
              (rawCastValues || (rawCastValues = {}))[camelKey] = value;
            }
          } else if (!isEmitListener(instance.emitsOptions, key)) {
            if (!(key in attrs) || value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
      if (needCastKeys) {
        const rawCurrentProps = toRaw(props);
        const castValues = rawCastValues || EMPTY_OBJ;
        for (let i = 0; i < needCastKeys.length; i++) {
          const key = needCastKeys[i];
          props[key] = resolvePropValue(
            options,
            rawCurrentProps,
            key,
            castValues[key],
            instance,
            !hasOwn(castValues, key)
          );
        }
      }
      return hasAttrsChanged;
    }
    function resolvePropValue(options, props, key, value, instance, isAbsent) {
      const opt = options[key];
      if (opt != null) {
        const hasDefault = hasOwn(opt, "default");
        if (hasDefault && value === void 0) {
          const defaultValue = opt.default;
          if (opt.type !== Function && !opt.skipFactory && isFunction$2(defaultValue)) {
            const { propsDefaults } = instance;
            if (key in propsDefaults) {
              value = propsDefaults[key];
            } else {
              const reset = setCurrentInstance(instance);
              value = propsDefaults[key] = defaultValue.call(
                null,
                props
              );
              reset();
            }
          } else {
            value = defaultValue;
          }
        }
        if (opt[
          0
          /* shouldCast */
        ]) {
          if (isAbsent && !hasDefault) {
            value = false;
          } else if (opt[
            1
            /* shouldCastTrue */
          ] && (value === "" || value === hyphenate(key))) {
            value = true;
          }
        }
      }
      return value;
    }
    function normalizePropsOptions(comp, appContext, asMixin = false) {
      const cache = appContext.propsCache;
      const cached = cache.get(comp);
      if (cached) {
        return cached;
      }
      const raw = comp.props;
      const normalized = {};
      const needCastKeys = [];
      let hasExtends = false;
      if (!isFunction$2(comp)) {
        const extendProps = (raw2) => {
          hasExtends = true;
          const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
          extend$3(normalized, props);
          if (keys2)
            needCastKeys.push(...keys2);
        };
        if (!asMixin && appContext.mixins.length) {
          appContext.mixins.forEach(extendProps);
        }
        if (comp.extends) {
          extendProps(comp.extends);
        }
        if (comp.mixins) {
          comp.mixins.forEach(extendProps);
        }
      }
      if (!raw && !hasExtends) {
        if (isObject$2(comp)) {
          cache.set(comp, EMPTY_ARR);
        }
        return EMPTY_ARR;
      }
      if (isArray$2(raw)) {
        for (let i = 0; i < raw.length; i++) {
          const normalizedKey = camelize(raw[i]);
          if (validatePropName(normalizedKey)) {
            normalized[normalizedKey] = EMPTY_OBJ;
          }
        }
      } else if (raw) {
        for (const key in raw) {
          const normalizedKey = camelize(key);
          if (validatePropName(normalizedKey)) {
            const opt = raw[key];
            const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$2(opt) ? { type: opt } : extend$3({}, opt);
            if (prop) {
              const booleanIndex = getTypeIndex(Boolean, prop.type);
              const stringIndex = getTypeIndex(String, prop.type);
              prop[
                0
                /* shouldCast */
              ] = booleanIndex > -1;
              prop[
                1
                /* shouldCastTrue */
              ] = stringIndex < 0 || booleanIndex < stringIndex;
              if (booleanIndex > -1 || hasOwn(prop, "default")) {
                needCastKeys.push(normalizedKey);
              }
            }
          }
        }
      }
      const res = [normalized, needCastKeys];
      if (isObject$2(comp)) {
        cache.set(comp, res);
      }
      return res;
    }
    function validatePropName(key) {
      if (key[0] !== "$" && !isReservedProp(key)) {
        return true;
      }
      return false;
    }
    function getType(ctor) {
      const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
      return match ? match[2] : ctor === null ? "null" : "";
    }
    function isSameType(a, b) {
      return getType(a) === getType(b);
    }
    function getTypeIndex(type, expectedTypes) {
      if (isArray$2(expectedTypes)) {
        return expectedTypes.findIndex((t) => isSameType(t, type));
      } else if (isFunction$2(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
      }
      return -1;
    }
    const isInternalKey = (key) => key[0] === "_" || key === "$stable";
    const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
    const normalizeSlot = (key, rawSlot, ctx) => {
      if (rawSlot._n) {
        return rawSlot;
      }
      const normalized = withCtx((...args) => {
        if (false)
          ;
        return normalizeSlotValue(rawSlot(...args));
      }, ctx);
      normalized._c = false;
      return normalized;
    };
    const normalizeObjectSlots = (rawSlots, slots, instance) => {
      const ctx = rawSlots._ctx;
      for (const key in rawSlots) {
        if (isInternalKey(key))
          continue;
        const value = rawSlots[key];
        if (isFunction$2(value)) {
          slots[key] = normalizeSlot(key, value, ctx);
        } else if (value != null) {
          const normalized = normalizeSlotValue(value);
          slots[key] = () => normalized;
        }
      }
    };
    const normalizeVNodeSlots = (instance, children2) => {
      const normalized = normalizeSlotValue(children2);
      instance.slots.default = () => normalized;
    };
    const initSlots = (instance, children2) => {
      if (instance.vnode.shapeFlag & 32) {
        const type = children2._;
        if (type) {
          instance.slots = toRaw(children2);
          def(children2, "_", type);
        } else {
          normalizeObjectSlots(
            children2,
            instance.slots = {}
          );
        }
      } else {
        instance.slots = {};
        if (children2) {
          normalizeVNodeSlots(instance, children2);
        }
      }
      def(instance.slots, InternalObjectKey, 1);
    };
    const updateSlots = (instance, children2, optimized) => {
      const { vnode, slots } = instance;
      let needDeletionCheck = true;
      let deletionComparisonTarget = EMPTY_OBJ;
      if (vnode.shapeFlag & 32) {
        const type = children2._;
        if (type) {
          if (optimized && type === 1) {
            needDeletionCheck = false;
          } else {
            extend$3(slots, children2);
            if (!optimized && type === 1) {
              delete slots._;
            }
          }
        } else {
          needDeletionCheck = !children2.$stable;
          normalizeObjectSlots(children2, slots);
        }
        deletionComparisonTarget = children2;
      } else if (children2) {
        normalizeVNodeSlots(instance, children2);
        deletionComparisonTarget = { default: 1 };
      }
      if (needDeletionCheck) {
        for (const key in slots) {
          if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
            delete slots[key];
          }
        }
      }
    };
    function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
      if (isArray$2(rawRef)) {
        rawRef.forEach(
          (r, i) => setRef(
            r,
            oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
            parentSuspense,
            vnode,
            isUnmount
          )
        );
        return;
      }
      if (isAsyncWrapper(vnode) && !isUnmount) {
        return;
      }
      const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
      const value = isUnmount ? null : refValue;
      const { i: owner, r: ref3 } = rawRef;
      const oldRef = oldRawRef && oldRawRef.r;
      const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
      const setupState = owner.setupState;
      if (oldRef != null && oldRef !== ref3) {
        if (isString$2(oldRef)) {
          refs[oldRef] = null;
          if (hasOwn(setupState, oldRef)) {
            setupState[oldRef] = null;
          }
        } else if (isRef(oldRef)) {
          oldRef.value = null;
        }
      }
      if (isFunction$2(ref3)) {
        callWithErrorHandling(ref3, owner, 12, [value, refs]);
      } else {
        const _isString = isString$2(ref3);
        const _isRef = isRef(ref3);
        if (_isString || _isRef) {
          const doSet = () => {
            if (rawRef.f) {
              const existing = _isString ? hasOwn(setupState, ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
              if (isUnmount) {
                isArray$2(existing) && remove$1(existing, refValue);
              } else {
                if (!isArray$2(existing)) {
                  if (_isString) {
                    refs[ref3] = [refValue];
                    if (hasOwn(setupState, ref3)) {
                      setupState[ref3] = refs[ref3];
                    }
                  } else {
                    ref3.value = [refValue];
                    if (rawRef.k)
                      refs[rawRef.k] = ref3.value;
                  }
                } else if (!existing.includes(refValue)) {
                  existing.push(refValue);
                }
              }
            } else if (_isString) {
              refs[ref3] = value;
              if (hasOwn(setupState, ref3)) {
                setupState[ref3] = value;
              }
            } else if (_isRef) {
              ref3.value = value;
              if (rawRef.k)
                refs[rawRef.k] = value;
            } else
              ;
          };
          if (value) {
            doSet.id = -1;
            queuePostRenderEffect(doSet, parentSuspense);
          } else {
            doSet();
          }
        }
      }
    }
    const queuePostRenderEffect = queueEffectWithSuspense;
    function createRenderer(options) {
      return baseCreateRenderer(options);
    }
    function baseCreateRenderer(options, createHydrationFns) {
      const target = getGlobalThis();
      target.__VUE__ = true;
      const {
        insert: hostInsert,
        remove: hostRemove,
        patchProp: hostPatchProp,
        createElement: hostCreateElement,
        createText: hostCreateText,
        createComment: hostCreateComment,
        setText: hostSetText,
        setElementText: hostSetElementText,
        parentNode: hostParentNode,
        nextSibling: hostNextSibling,
        setScopeId: hostSetScopeId = NOOP,
        insertStaticContent: hostInsertStaticContent
      } = options;
      const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace2 = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
        if (n1 === n2) {
          return;
        }
        if (n1 && !isSameVNodeType(n1, n2)) {
          anchor = getNextHostNode(n1);
          unmount(n1, parentComponent, parentSuspense, true);
          n1 = null;
        }
        if (n2.patchFlag === -2) {
          optimized = false;
          n2.dynamicChildren = null;
        }
        const { type, ref: ref3, shapeFlag } = n2;
        switch (type) {
          case Text:
            processText(n1, n2, container, anchor);
            break;
          case Comment:
            processCommentNode(n1, n2, container, anchor);
            break;
          case Static:
            if (n1 == null) {
              mountStaticNode(n2, container, anchor, namespace2);
            }
            break;
          case Fragment:
            processFragment(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            break;
          default:
            if (shapeFlag & 1) {
              processElement(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 6) {
              processComponent(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (shapeFlag & 64) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else if (shapeFlag & 128) {
              type.process(
                n1,
                n2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized,
                internals
              );
            } else
              ;
        }
        if (ref3 != null && parentComponent) {
          setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
        }
      };
      const processText = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateText(n2.children),
            container,
            anchor
          );
        } else {
          const el = n2.el = n1.el;
          if (n2.children !== n1.children) {
            hostSetText(el, n2.children);
          }
        }
      };
      const processCommentNode = (n1, n2, container, anchor) => {
        if (n1 == null) {
          hostInsert(
            n2.el = hostCreateComment(n2.children || ""),
            container,
            anchor
          );
        } else {
          n2.el = n1.el;
        }
      };
      const mountStaticNode = (n2, container, anchor, namespace2) => {
        [n2.el, n2.anchor] = hostInsertStaticContent(
          n2.children,
          container,
          anchor,
          namespace2,
          n2.el,
          n2.anchor
        );
      };
      const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostInsert(el, container, nextSibling);
          el = next;
        }
        hostInsert(anchor, container, nextSibling);
      };
      const removeStaticNode = ({ el, anchor }) => {
        let next;
        while (el && el !== anchor) {
          next = hostNextSibling(el);
          hostRemove(el);
          el = next;
        }
        hostRemove(anchor);
      };
      const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        if (n2.type === "svg") {
          namespace2 = "svg";
        } else if (n2.type === "math") {
          namespace2 = "mathml";
        }
        if (n1 == null) {
          mountElement(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          patchElement(
            n1,
            n2,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let el;
        let vnodeHook;
        const { props, shapeFlag, transition, dirs } = vnode;
        el = vnode.el = hostCreateElement(
          vnode.type,
          namespace2,
          props && props.is,
          props
        );
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(
            vnode.children,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(vnode, namespace2),
            slotScopeIds,
            optimized
          );
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
        if (props) {
          for (const key in props) {
            if (key !== "value" && !isReservedProp(key)) {
              hostPatchProp(
                el,
                key,
                null,
                props[key],
                namespace2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in props) {
            hostPatchProp(el, "value", null, props.value, namespace2);
          }
          if (vnodeHook = props.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        const needCallTransitionHooks = needTransition(parentSuspense, transition);
        if (needCallTransitionHooks) {
          transition.beforeEnter(el);
        }
        hostInsert(el, container, anchor);
        if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            needCallTransitionHooks && transition.enter(el);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
      };
      const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
        if (scopeId) {
          hostSetScopeId(el, scopeId);
        }
        if (slotScopeIds) {
          for (let i = 0; i < slotScopeIds.length; i++) {
            hostSetScopeId(el, slotScopeIds[i]);
          }
        }
        if (parentComponent) {
          let subTree = parentComponent.subTree;
          if (vnode === subTree) {
            const parentVNode = parentComponent.vnode;
            setScopeId(
              el,
              parentVNode,
              parentVNode.scopeId,
              parentVNode.slotScopeIds,
              parentComponent.parent
            );
          }
        }
      };
      const mountChildren = (children2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized, start2 = 0) => {
        for (let i = start2; i < children2.length; i++) {
          const child = children2[i] = optimized ? cloneIfMounted(children2[i]) : normalizeVNode(children2[i]);
          patch(
            null,
            child,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
      };
      const patchElement = (n1, n2, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const el = n2.el = n1.el;
        let { patchFlag, dynamicChildren, dirs } = n2;
        patchFlag |= n1.patchFlag & 16;
        const oldProps = n1.props || EMPTY_OBJ;
        const newProps = n2.props || EMPTY_OBJ;
        let vnodeHook;
        parentComponent && toggleRecurse(parentComponent, false);
        if (vnodeHook = newProps.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        }
        if (dirs) {
          invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
        }
        parentComponent && toggleRecurse(parentComponent, true);
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            el,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds
          );
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            el,
            null,
            parentComponent,
            parentSuspense,
            resolveChildrenNamespace(n2, namespace2),
            slotScopeIds,
            false
          );
        }
        if (patchFlag > 0) {
          if (patchFlag & 16) {
            patchProps(
              el,
              n2,
              oldProps,
              newProps,
              parentComponent,
              parentSuspense,
              namespace2
            );
          } else {
            if (patchFlag & 2) {
              if (oldProps.class !== newProps.class) {
                hostPatchProp(el, "class", null, newProps.class, namespace2);
              }
            }
            if (patchFlag & 4) {
              hostPatchProp(el, "style", oldProps.style, newProps.style, namespace2);
            }
            if (patchFlag & 8) {
              const propsToUpdate = n2.dynamicProps;
              for (let i = 0; i < propsToUpdate.length; i++) {
                const key = propsToUpdate[i];
                const prev = oldProps[key];
                const next = newProps[key];
                if (next !== prev || key === "value") {
                  hostPatchProp(
                    el,
                    key,
                    prev,
                    next,
                    namespace2,
                    n1.children,
                    parentComponent,
                    parentSuspense,
                    unmountChildren
                  );
                }
              }
            }
          }
          if (patchFlag & 1) {
            if (n1.children !== n2.children) {
              hostSetElementText(el, n2.children);
            }
          }
        } else if (!optimized && dynamicChildren == null) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace2
          );
        }
        if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
            dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
          }, parentSuspense);
        }
      };
      const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace2, slotScopeIds) => {
        for (let i = 0; i < newChildren.length; i++) {
          const oldVNode = oldChildren[i];
          const newVNode = newChildren[i];
          const container = (
            // oldVNode may be an errored async setup() component inside Suspense
            // which will not have a mounted element
            oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
            // of the Fragment itself so it can move its children.
            (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
            // which also requires the correct parent container
            !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
            oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
              // In other cases, the parent container is not actually used so we
              // just pass the block element here to avoid a DOM parentNode call.
              fallbackContainer
            )
          );
          patch(
            oldVNode,
            newVNode,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            true
          );
        }
      };
      const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace2) => {
        if (oldProps !== newProps) {
          if (oldProps !== EMPTY_OBJ) {
            for (const key in oldProps) {
              if (!isReservedProp(key) && !(key in newProps)) {
                hostPatchProp(
                  el,
                  key,
                  oldProps[key],
                  null,
                  namespace2,
                  vnode.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
          for (const key in newProps) {
            if (isReservedProp(key))
              continue;
            const next = newProps[key];
            const prev = oldProps[key];
            if (next !== prev && key !== "value") {
              hostPatchProp(
                el,
                key,
                prev,
                next,
                namespace2,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
          if ("value" in newProps) {
            hostPatchProp(el, "value", oldProps.value, newProps.value, namespace2);
          }
        }
      };
      const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
        const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
        let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
        if (fragmentSlotScopeIds) {
          slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
        }
        if (n1 == null) {
          hostInsert(fragmentStartAnchor, container, anchor);
          hostInsert(fragmentEndAnchor, container, anchor);
          mountChildren(
            // #10007
            // such fragment like `<></>` will be compiled into
            // a fragment which doesn't have a children.
            // In this case fallback to an empty array
            n2.children || [],
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        } else {
          if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
          // of renderSlot() with no valid children
          n1.dynamicChildren) {
            patchBlockChildren(
              n1.dynamicChildren,
              dynamicChildren,
              container,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds
            );
            if (
              // #2080 if the stable fragment has a key, it's a <template v-for> that may
              //  get moved around. Make sure all root level vnodes inherit el.
              // #2134 or if it's a component root, it may also get moved around
              // as the component is being moved.
              n2.key != null || parentComponent && n2 === parentComponent.subTree
            ) {
              traverseStaticChildren(
                n1,
                n2,
                true
                /* shallow */
              );
            }
          } else {
            patchChildren(
              n1,
              n2,
              container,
              fragmentEndAnchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          }
        }
      };
      const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        n2.slotScopeIds = slotScopeIds;
        if (n1 == null) {
          if (n2.shapeFlag & 512) {
            parentComponent.ctx.activate(
              n2,
              container,
              anchor,
              namespace2,
              optimized
            );
          } else {
            mountComponent(
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              optimized
            );
          }
        } else {
          updateComponent(n1, n2, optimized);
        }
      };
      const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace2, optimized) => {
        const instance = initialVNode.component = createComponentInstance(
          initialVNode,
          parentComponent,
          parentSuspense
        );
        if (isKeepAlive(initialVNode)) {
          instance.ctx.renderer = internals;
        }
        {
          setupComponent(instance);
        }
        if (instance.asyncDep) {
          parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
          if (!initialVNode.el) {
            const placeholder = instance.subTree = createVNode(Comment);
            processCommentNode(null, placeholder, container, anchor);
          }
        } else {
          setupRenderEffect(
            instance,
            initialVNode,
            container,
            anchor,
            parentSuspense,
            namespace2,
            optimized
          );
        }
      };
      const updateComponent = (n1, n2, optimized) => {
        const instance = n2.component = n1.component;
        if (shouldUpdateComponent(n1, n2, optimized)) {
          if (instance.asyncDep && !instance.asyncResolved) {
            updateComponentPreRender(instance, n2, optimized);
            return;
          } else {
            instance.next = n2;
            invalidateJob(instance.update);
            instance.effect.dirty = true;
            instance.update();
          }
        } else {
          n2.el = n1.el;
          instance.vnode = n2;
        }
      };
      const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace2, optimized) => {
        const componentUpdateFn = () => {
          if (!instance.isMounted) {
            let vnodeHook;
            const { el, props } = initialVNode;
            const { bm, m, parent } = instance;
            const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
            toggleRecurse(instance, false);
            if (bm) {
              invokeArrayFns(bm);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
              invokeVNodeHook(vnodeHook, parent, initialVNode);
            }
            toggleRecurse(instance, true);
            if (el && hydrateNode) {
              const hydrateSubTree = () => {
                instance.subTree = renderComponentRoot(instance);
                hydrateNode(
                  el,
                  instance.subTree,
                  instance,
                  parentSuspense,
                  null
                );
              };
              if (isAsyncWrapperVNode) {
                initialVNode.type.__asyncLoader().then(
                  // note: we are moving the render call into an async callback,
                  // which means it won't track dependencies - but it's ok because
                  // a server-rendered async wrapper is already in resolved state
                  // and it will never need to change.
                  () => !instance.isUnmounted && hydrateSubTree()
                );
              } else {
                hydrateSubTree();
              }
            } else {
              const subTree = instance.subTree = renderComponentRoot(instance);
              patch(
                null,
                subTree,
                container,
                anchor,
                instance,
                parentSuspense,
                namespace2
              );
              initialVNode.el = subTree.el;
            }
            if (m) {
              queuePostRenderEffect(m, parentSuspense);
            }
            if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
              const scopedInitialVNode = initialVNode;
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
                parentSuspense
              );
            }
            if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
              instance.a && queuePostRenderEffect(instance.a, parentSuspense);
            }
            instance.isMounted = true;
            initialVNode = container = anchor = null;
          } else {
            let { next, bu, u, parent, vnode } = instance;
            {
              const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
              if (nonHydratedAsyncRoot) {
                if (next) {
                  next.el = vnode.el;
                  updateComponentPreRender(instance, next, optimized);
                }
                nonHydratedAsyncRoot.asyncDep.then(() => {
                  if (!instance.isUnmounted) {
                    componentUpdateFn();
                  }
                });
                return;
              }
            }
            let originNext = next;
            let vnodeHook;
            toggleRecurse(instance, false);
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            } else {
              next = vnode;
            }
            if (bu) {
              invokeArrayFns(bu);
            }
            if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
              invokeVNodeHook(vnodeHook, parent, next, vnode);
            }
            toggleRecurse(instance, true);
            const nextTree = renderComponentRoot(instance);
            const prevTree = instance.subTree;
            instance.subTree = nextTree;
            patch(
              prevTree,
              nextTree,
              // parent may have changed if it's in a teleport
              hostParentNode(prevTree.el),
              // anchor may have changed if it's in a fragment
              getNextHostNode(prevTree),
              instance,
              parentSuspense,
              namespace2
            );
            next.el = nextTree.el;
            if (originNext === null) {
              updateHOCHostEl(instance, nextTree.el);
            }
            if (u) {
              queuePostRenderEffect(u, parentSuspense);
            }
            if (vnodeHook = next.props && next.props.onVnodeUpdated) {
              queuePostRenderEffect(
                () => invokeVNodeHook(vnodeHook, parent, next, vnode),
                parentSuspense
              );
            }
          }
        };
        const effect2 = instance.effect = new ReactiveEffect(
          componentUpdateFn,
          NOOP,
          () => queueJob(update),
          instance.scope
          // track it in component's effect scope
        );
        const update = instance.update = () => {
          if (effect2.dirty) {
            effect2.run();
          }
        };
        update.id = instance.uid;
        toggleRecurse(instance, true);
        update();
      };
      const updateComponentPreRender = (instance, nextVNode, optimized) => {
        nextVNode.component = instance;
        const prevProps = instance.vnode.props;
        instance.vnode = nextVNode;
        instance.next = null;
        updateProps(instance, nextVNode.props, prevProps, optimized);
        updateSlots(instance, nextVNode.children, optimized);
        pauseTracking();
        flushPreFlushCbs(instance);
        resetTracking();
      };
      const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized = false) => {
        const c1 = n1 && n1.children;
        const prevShapeFlag = n1 ? n1.shapeFlag : 0;
        const c2 = n2.children;
        const { patchFlag, shapeFlag } = n2;
        if (patchFlag > 0) {
          if (patchFlag & 128) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          } else if (patchFlag & 256) {
            patchUnkeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
            return;
          }
        }
        if (shapeFlag & 8) {
          if (prevShapeFlag & 16) {
            unmountChildren(c1, parentComponent, parentSuspense);
          }
          if (c2 !== c1) {
            hostSetElementText(container, c2);
          }
        } else {
          if (prevShapeFlag & 16) {
            if (shapeFlag & 16) {
              patchKeyedChildren(
                c1,
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else {
              unmountChildren(c1, parentComponent, parentSuspense, true);
            }
          } else {
            if (prevShapeFlag & 8) {
              hostSetElementText(container, "");
            }
            if (shapeFlag & 16) {
              mountChildren(
                c2,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            }
          }
        }
      };
      const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        c1 = c1 || EMPTY_ARR;
        c2 = c2 || EMPTY_ARR;
        const oldLength = c1.length;
        const newLength = c2.length;
        const commonLength = Math.min(oldLength, newLength);
        let i;
        for (i = 0; i < commonLength; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          patch(
            c1[i],
            nextChild,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized
          );
        }
        if (oldLength > newLength) {
          unmountChildren(
            c1,
            parentComponent,
            parentSuspense,
            true,
            false,
            commonLength
          );
        } else {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace2,
            slotScopeIds,
            optimized,
            commonLength
          );
        }
      };
      const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace2, slotScopeIds, optimized) => {
        let i = 0;
        const l2 = c2.length;
        let e1 = c1.length - 1;
        let e2 = l2 - 1;
        while (i <= e1 && i <= e2) {
          const n1 = c1[i];
          const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          i++;
        }
        while (i <= e1 && i <= e2) {
          const n1 = c1[e1];
          const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
          if (isSameVNodeType(n1, n2)) {
            patch(
              n1,
              n2,
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace2,
              slotScopeIds,
              optimized
            );
          } else {
            break;
          }
          e1--;
          e2--;
        }
        if (i > e1) {
          if (i <= e2) {
            const nextPos = e2 + 1;
            const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
            while (i <= e2) {
              patch(
                null,
                c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              i++;
            }
          }
        } else if (i > e2) {
          while (i <= e1) {
            unmount(c1[i], parentComponent, parentSuspense, true);
            i++;
          }
        } else {
          const s1 = i;
          const s2 = i;
          const keyToNewIndexMap = /* @__PURE__ */ new Map();
          for (i = s2; i <= e2; i++) {
            const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
            if (nextChild.key != null) {
              keyToNewIndexMap.set(nextChild.key, i);
            }
          }
          let j;
          let patched = 0;
          const toBePatched = e2 - s2 + 1;
          let moved = false;
          let maxNewIndexSoFar = 0;
          const newIndexToOldIndexMap = new Array(toBePatched);
          for (i = 0; i < toBePatched; i++)
            newIndexToOldIndexMap[i] = 0;
          for (i = s1; i <= e1; i++) {
            const prevChild = c1[i];
            if (patched >= toBePatched) {
              unmount(prevChild, parentComponent, parentSuspense, true);
              continue;
            }
            let newIndex;
            if (prevChild.key != null) {
              newIndex = keyToNewIndexMap.get(prevChild.key);
            } else {
              for (j = s2; j <= e2; j++) {
                if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                  newIndex = j;
                  break;
                }
              }
            }
            if (newIndex === void 0) {
              unmount(prevChild, parentComponent, parentSuspense, true);
            } else {
              newIndexToOldIndexMap[newIndex - s2] = i + 1;
              if (newIndex >= maxNewIndexSoFar) {
                maxNewIndexSoFar = newIndex;
              } else {
                moved = true;
              }
              patch(
                prevChild,
                c2[newIndex],
                container,
                null,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
              patched++;
            }
          }
          const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
          j = increasingNewIndexSequence.length - 1;
          for (i = toBePatched - 1; i >= 0; i--) {
            const nextIndex = s2 + i;
            const nextChild = c2[nextIndex];
            const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
            if (newIndexToOldIndexMap[i] === 0) {
              patch(
                null,
                nextChild,
                container,
                anchor,
                parentComponent,
                parentSuspense,
                namespace2,
                slotScopeIds,
                optimized
              );
            } else if (moved) {
              if (j < 0 || i !== increasingNewIndexSequence[j]) {
                move(nextChild, container, anchor, 2);
              } else {
                j--;
              }
            }
          }
        }
      };
      const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
        const { el, type, transition, children: children2, shapeFlag } = vnode;
        if (shapeFlag & 6) {
          move(vnode.component.subTree, container, anchor, moveType);
          return;
        }
        if (shapeFlag & 128) {
          vnode.suspense.move(container, anchor, moveType);
          return;
        }
        if (shapeFlag & 64) {
          type.move(vnode, container, anchor, internals);
          return;
        }
        if (type === Fragment) {
          hostInsert(el, container, anchor);
          for (let i = 0; i < children2.length; i++) {
            move(children2[i], container, anchor, moveType);
          }
          hostInsert(vnode.anchor, container, anchor);
          return;
        }
        if (type === Static) {
          moveStaticNode(vnode, container, anchor);
          return;
        }
        const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
        if (needTransition2) {
          if (moveType === 0) {
            transition.beforeEnter(el);
            hostInsert(el, container, anchor);
            queuePostRenderEffect(() => transition.enter(el), parentSuspense);
          } else {
            const { leave, delayLeave, afterLeave } = transition;
            const remove22 = () => hostInsert(el, container, anchor);
            const performLeave = () => {
              leave(el, () => {
                remove22();
                afterLeave && afterLeave();
              });
            };
            if (delayLeave) {
              delayLeave(el, remove22, performLeave);
            } else {
              performLeave();
            }
          }
        } else {
          hostInsert(el, container, anchor);
        }
      };
      const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
        const {
          type,
          props,
          ref: ref3,
          children: children2,
          dynamicChildren,
          shapeFlag,
          patchFlag,
          dirs
        } = vnode;
        if (ref3 != null) {
          setRef(ref3, null, parentSuspense, vnode, true);
        }
        if (shapeFlag & 256) {
          parentComponent.ctx.deactivate(vnode);
          return;
        }
        const shouldInvokeDirs = shapeFlag & 1 && dirs;
        const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
        let vnodeHook;
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
        if (shapeFlag & 6) {
          unmountComponent(vnode.component, parentSuspense, doRemove);
        } else {
          if (shapeFlag & 128) {
            vnode.suspense.unmount(parentSuspense, doRemove);
            return;
          }
          if (shouldInvokeDirs) {
            invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
          }
          if (shapeFlag & 64) {
            vnode.type.remove(
              vnode,
              parentComponent,
              parentSuspense,
              optimized,
              internals,
              doRemove
            );
          } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
          (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
            unmountChildren(
              dynamicChildren,
              parentComponent,
              parentSuspense,
              false,
              true
            );
          } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
            unmountChildren(children2, parentComponent, parentSuspense);
          }
          if (doRemove) {
            remove2(vnode);
          }
        }
        if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
          queuePostRenderEffect(() => {
            vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
            shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
          }, parentSuspense);
        }
      };
      const remove2 = (vnode) => {
        const { type, el, anchor, transition } = vnode;
        if (type === Fragment) {
          {
            removeFragment(el, anchor);
          }
          return;
        }
        if (type === Static) {
          removeStaticNode(vnode);
          return;
        }
        const performRemove = () => {
          hostRemove(el);
          if (transition && !transition.persisted && transition.afterLeave) {
            transition.afterLeave();
          }
        };
        if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
          const { leave, delayLeave } = transition;
          const performLeave = () => leave(el, performRemove);
          if (delayLeave) {
            delayLeave(vnode.el, performRemove, performLeave);
          } else {
            performLeave();
          }
        } else {
          performRemove();
        }
      };
      const removeFragment = (cur, end2) => {
        let next;
        while (cur !== end2) {
          next = hostNextSibling(cur);
          hostRemove(cur);
          cur = next;
        }
        hostRemove(end2);
      };
      const unmountComponent = (instance, parentSuspense, doRemove) => {
        const { bum, scope, update, subTree, um } = instance;
        if (bum) {
          invokeArrayFns(bum);
        }
        scope.stop();
        if (update) {
          update.active = false;
          unmount(subTree, instance, parentSuspense, doRemove);
        }
        if (um) {
          queuePostRenderEffect(um, parentSuspense);
        }
        queuePostRenderEffect(() => {
          instance.isUnmounted = true;
        }, parentSuspense);
        if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
          parentSuspense.deps--;
          if (parentSuspense.deps === 0) {
            parentSuspense.resolve();
          }
        }
      };
      const unmountChildren = (children2, parentComponent, parentSuspense, doRemove = false, optimized = false, start2 = 0) => {
        for (let i = start2; i < children2.length; i++) {
          unmount(children2[i], parentComponent, parentSuspense, doRemove, optimized);
        }
      };
      const getNextHostNode = (vnode) => {
        if (vnode.shapeFlag & 6) {
          return getNextHostNode(vnode.component.subTree);
        }
        if (vnode.shapeFlag & 128) {
          return vnode.suspense.next();
        }
        return hostNextSibling(vnode.anchor || vnode.el);
      };
      let isFlushing2 = false;
      const render = (vnode, container, namespace2) => {
        if (vnode == null) {
          if (container._vnode) {
            unmount(container._vnode, null, null, true);
          }
        } else {
          patch(
            container._vnode || null,
            vnode,
            container,
            null,
            null,
            null,
            namespace2
          );
        }
        if (!isFlushing2) {
          isFlushing2 = true;
          flushPreFlushCbs();
          flushPostFlushCbs();
          isFlushing2 = false;
        }
        container._vnode = vnode;
      };
      const internals = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: options
      };
      let hydrate;
      let hydrateNode;
      if (createHydrationFns) {
        [hydrate, hydrateNode] = createHydrationFns(
          internals
        );
      }
      return {
        render,
        hydrate,
        createApp: createAppAPI(render, hydrate)
      };
    }
    function resolveChildrenNamespace({ type, props }, currentNamespace) {
      return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
    }
    function toggleRecurse({ effect: effect2, update }, allowed) {
      effect2.allowRecurse = update.allowRecurse = allowed;
    }
    function needTransition(parentSuspense, transition) {
      return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    }
    function traverseStaticChildren(n1, n2, shallow = false) {
      const ch1 = n1.children;
      const ch2 = n2.children;
      if (isArray$2(ch1) && isArray$2(ch2)) {
        for (let i = 0; i < ch1.length; i++) {
          const c1 = ch1[i];
          let c2 = ch2[i];
          if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
            if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
              c2 = ch2[i] = cloneIfMounted(ch2[i]);
              c2.el = c1.el;
            }
            if (!shallow)
              traverseStaticChildren(c1, c2);
          }
          if (c2.type === Text) {
            c2.el = c1.el;
          }
        }
      }
    }
    function getSequence(arr) {
      const p2 = arr.slice();
      const result = [0];
      let i, j, u, v, c;
      const len = arr.length;
      for (i = 0; i < len; i++) {
        const arrI = arr[i];
        if (arrI !== 0) {
          j = result[result.length - 1];
          if (arr[j] < arrI) {
            p2[i] = j;
            result.push(i);
            continue;
          }
          u = 0;
          v = result.length - 1;
          while (u < v) {
            c = u + v >> 1;
            if (arr[result[c]] < arrI) {
              u = c + 1;
            } else {
              v = c;
            }
          }
          if (arrI < arr[result[u]]) {
            if (u > 0) {
              p2[i] = result[u - 1];
            }
            result[u] = i;
          }
        }
      }
      u = result.length;
      v = result[u - 1];
      while (u-- > 0) {
        result[u] = v;
        v = p2[v];
      }
      return result;
    }
    function locateNonHydratedAsyncRoot(instance) {
      const subComponent = instance.subTree.component;
      if (subComponent) {
        if (subComponent.asyncDep && !subComponent.asyncResolved) {
          return subComponent;
        } else {
          return locateNonHydratedAsyncRoot(subComponent);
        }
      }
    }
    const isTeleport = (type) => type.__isTeleport;
    const Fragment = Symbol.for("v-fgt");
    const Text = Symbol.for("v-txt");
    const Comment = Symbol.for("v-cmt");
    const Static = Symbol.for("v-stc");
    const blockStack = [];
    let currentBlock = null;
    function openBlock(disableTracking = false) {
      blockStack.push(currentBlock = disableTracking ? null : []);
    }
    function closeBlock() {
      blockStack.pop();
      currentBlock = blockStack[blockStack.length - 1] || null;
    }
    let isBlockTreeEnabled = 1;
    function setBlockTracking(value) {
      isBlockTreeEnabled += value;
    }
    function setupBlock(vnode) {
      vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
      closeBlock();
      if (isBlockTreeEnabled > 0 && currentBlock) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    function createElementBlock(type, props, children2, patchFlag, dynamicProps, shapeFlag) {
      return setupBlock(
        createBaseVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          shapeFlag,
          true
        )
      );
    }
    function createBlock(type, props, children2, patchFlag, dynamicProps) {
      return setupBlock(
        createVNode(
          type,
          props,
          children2,
          patchFlag,
          dynamicProps,
          true
        )
      );
    }
    function isVNode(value) {
      return value ? value.__v_isVNode === true : false;
    }
    function isSameVNodeType(n1, n2) {
      return n1.type === n2.type && n1.key === n2.key;
    }
    const InternalObjectKey = `__vInternal`;
    const normalizeKey = ({ key }) => key != null ? key : null;
    const normalizeRef = ({
      ref: ref3,
      ref_key,
      ref_for
    }) => {
      if (typeof ref3 === "number") {
        ref3 = "" + ref3;
      }
      return ref3 != null ? isString$2(ref3) || isRef(ref3) || isFunction$2(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
    };
    function createBaseVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
      const vnode = {
        __v_isVNode: true,
        __v_skip: true,
        type,
        props,
        key: props && normalizeKey(props),
        ref: props && normalizeRef(props),
        scopeId: currentScopeId,
        slotScopeIds: null,
        children: children2,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag,
        patchFlag,
        dynamicProps,
        dynamicChildren: null,
        appContext: null,
        ctx: currentRenderingInstance
      };
      if (needFullChildrenNormalization) {
        normalizeChildren(vnode, children2);
        if (shapeFlag & 128) {
          type.normalize(vnode);
        }
      } else if (children2) {
        vnode.shapeFlag |= isString$2(children2) ? 8 : 16;
      }
      if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
      !isBlockNode && // has current parent block
      currentBlock && // presence of a patch flag indicates this node needs patching on updates.
      // component nodes also should always be patched, because even if the
      // component doesn't need to update, it needs to persist the instance on to
      // the next vnode so that it can be properly unmounted later.
      (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
      // vnode should not be considered dynamic due to handler caching.
      vnode.patchFlag !== 32) {
        currentBlock.push(vnode);
      }
      return vnode;
    }
    const createVNode = _createVNode;
    function _createVNode(type, props = null, children2 = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
      if (!type || type === NULL_DYNAMIC_COMPONENT) {
        type = Comment;
      }
      if (isVNode(type)) {
        const cloned = cloneVNode(
          type,
          props,
          true
          /* mergeRef: true */
        );
        if (children2) {
          normalizeChildren(cloned, children2);
        }
        if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
          if (cloned.shapeFlag & 6) {
            currentBlock[currentBlock.indexOf(type)] = cloned;
          } else {
            currentBlock.push(cloned);
          }
        }
        cloned.patchFlag |= -2;
        return cloned;
      }
      if (isClassComponent(type)) {
        type = type.__vccOpts;
      }
      if (props) {
        props = guardReactiveProps(props);
        let { class: klass, style } = props;
        if (klass && !isString$2(klass)) {
          props.class = normalizeClass(klass);
        }
        if (isObject$2(style)) {
          if (isProxy(style) && !isArray$2(style)) {
            style = extend$3({}, style);
          }
          props.style = normalizeStyle(style);
        }
      }
      const shapeFlag = isString$2(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$2(type) ? 2 : 0;
      return createBaseVNode(
        type,
        props,
        children2,
        patchFlag,
        dynamicProps,
        shapeFlag,
        isBlockNode,
        true
      );
    }
    function guardReactiveProps(props) {
      if (!props)
        return null;
      return isProxy(props) || InternalObjectKey in props ? extend$3({}, props) : props;
    }
    function cloneVNode(vnode, extraProps, mergeRef = false) {
      const { props, ref: ref3, patchFlag, children: children2 } = vnode;
      const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
      const cloned = {
        __v_isVNode: true,
        __v_skip: true,
        type: vnode.type,
        props: mergedProps,
        key: mergedProps && normalizeKey(mergedProps),
        ref: extraProps && extraProps.ref ? (
          // #2078 in the case of <component :is="vnode" ref="extra"/>
          // if the vnode itself already has a ref, cloneVNode will need to merge
          // the refs so the single vnode can be set on multiple refs
          mergeRef && ref3 ? isArray$2(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
        ) : ref3,
        scopeId: vnode.scopeId,
        slotScopeIds: vnode.slotScopeIds,
        children: children2,
        target: vnode.target,
        targetAnchor: vnode.targetAnchor,
        staticCount: vnode.staticCount,
        shapeFlag: vnode.shapeFlag,
        // if the vnode is cloned with extra props, we can no longer assume its
        // existing patch flag to be reliable and need to add the FULL_PROPS flag.
        // note: preserve flag for fragments since they use the flag for children
        // fast paths only.
        patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
        dynamicProps: vnode.dynamicProps,
        dynamicChildren: vnode.dynamicChildren,
        appContext: vnode.appContext,
        dirs: vnode.dirs,
        transition: vnode.transition,
        // These should technically only be non-null on mounted VNodes. However,
        // they *should* be copied for kept-alive vnodes. So we just always copy
        // them since them being non-null during a mount doesn't affect the logic as
        // they will simply be overwritten.
        component: vnode.component,
        suspense: vnode.suspense,
        ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
        ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
        el: vnode.el,
        anchor: vnode.anchor,
        ctx: vnode.ctx,
        ce: vnode.ce
      };
      return cloned;
    }
    function createTextVNode(text = " ", flag = 0) {
      return createVNode(Text, null, text, flag);
    }
    function createStaticVNode(content, numberOfNodes) {
      const vnode = createVNode(Static, null, content);
      vnode.staticCount = numberOfNodes;
      return vnode;
    }
    function createCommentVNode(text = "", asBlock = false) {
      return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
    }
    function normalizeVNode(child) {
      if (child == null || typeof child === "boolean") {
        return createVNode(Comment);
      } else if (isArray$2(child)) {
        return createVNode(
          Fragment,
          null,
          // #3666, avoid reference pollution when reusing vnode
          child.slice()
        );
      } else if (typeof child === "object") {
        return cloneIfMounted(child);
      } else {
        return createVNode(Text, null, String(child));
      }
    }
    function cloneIfMounted(child) {
      return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
    }
    function normalizeChildren(vnode, children2) {
      let type = 0;
      const { shapeFlag } = vnode;
      if (children2 == null) {
        children2 = null;
      } else if (isArray$2(children2)) {
        type = 16;
      } else if (typeof children2 === "object") {
        if (shapeFlag & (1 | 64)) {
          const slot = children2.default;
          if (slot) {
            slot._c && (slot._d = false);
            normalizeChildren(vnode, slot());
            slot._c && (slot._d = true);
          }
          return;
        } else {
          type = 32;
          const slotFlag = children2._;
          if (!slotFlag && !(InternalObjectKey in children2)) {
            children2._ctx = currentRenderingInstance;
          } else if (slotFlag === 3 && currentRenderingInstance) {
            if (currentRenderingInstance.slots._ === 1) {
              children2._ = 1;
            } else {
              children2._ = 2;
              vnode.patchFlag |= 1024;
            }
          }
        }
      } else if (isFunction$2(children2)) {
        children2 = { default: children2, _ctx: currentRenderingInstance };
        type = 32;
      } else {
        children2 = String(children2);
        if (shapeFlag & 64) {
          type = 16;
          children2 = [createTextVNode(children2)];
        } else {
          type = 8;
        }
      }
      vnode.children = children2;
      vnode.shapeFlag |= type;
    }
    function mergeProps(...args) {
      const ret = {};
      for (let i = 0; i < args.length; i++) {
        const toMerge = args[i];
        for (const key in toMerge) {
          if (key === "class") {
            if (ret.class !== toMerge.class) {
              ret.class = normalizeClass([ret.class, toMerge.class]);
            }
          } else if (key === "style") {
            ret.style = normalizeStyle([ret.style, toMerge.style]);
          } else if (isOn(key)) {
            const existing = ret[key];
            const incoming = toMerge[key];
            if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
              ret[key] = existing ? [].concat(existing, incoming) : incoming;
            }
          } else if (key !== "") {
            ret[key] = toMerge[key];
          }
        }
      }
      return ret;
    }
    function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
      callWithAsyncErrorHandling(hook, instance, 7, [
        vnode,
        prevVNode
      ]);
    }
    const emptyAppContext = createAppContext();
    let uid = 0;
    function createComponentInstance(vnode, parent, suspense) {
      const type = vnode.type;
      const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
      const instance = {
        uid: uid++,
        vnode,
        type,
        parent,
        appContext,
        root: null,
        // to be immediately set
        next: null,
        subTree: null,
        // will be set synchronously right after creation
        effect: null,
        update: null,
        // will be set synchronously right after creation
        scope: new EffectScope(
          true
          /* detached */
        ),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: parent ? parent.provides : Object.create(appContext.provides),
        accessCache: null,
        renderCache: [],
        // local resolved assets
        components: null,
        directives: null,
        // resolved props and emits options
        propsOptions: normalizePropsOptions(type, appContext),
        emitsOptions: normalizeEmitsOptions(type, appContext),
        // emit
        emit: null,
        // to be set immediately
        emitted: null,
        // props default value
        propsDefaults: EMPTY_OBJ,
        // inheritAttrs
        inheritAttrs: type.inheritAttrs,
        // state
        ctx: EMPTY_OBJ,
        data: EMPTY_OBJ,
        props: EMPTY_OBJ,
        attrs: EMPTY_OBJ,
        slots: EMPTY_OBJ,
        refs: EMPTY_OBJ,
        setupState: EMPTY_OBJ,
        setupContext: null,
        attrsProxy: null,
        slotsProxy: null,
        // suspense related
        suspense,
        suspenseId: suspense ? suspense.pendingId : 0,
        asyncDep: null,
        asyncResolved: false,
        // lifecycle hooks
        // not using enums here because it results in computed properties
        isMounted: false,
        isUnmounted: false,
        isDeactivated: false,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
      };
      {
        instance.ctx = { _: instance };
      }
      instance.root = parent ? parent.root : instance;
      instance.emit = emit.bind(null, instance);
      if (vnode.ce) {
        vnode.ce(instance);
      }
      return instance;
    }
    let currentInstance = null;
    const getCurrentInstance = () => currentInstance || currentRenderingInstance;
    let internalSetCurrentInstance;
    let setInSSRSetupState;
    {
      const g = getGlobalThis();
      const registerGlobalSetter = (key, setter) => {
        let setters;
        if (!(setters = g[key]))
          setters = g[key] = [];
        setters.push(setter);
        return (v) => {
          if (setters.length > 1)
            setters.forEach((set2) => set2(v));
          else
            setters[0](v);
        };
      };
      internalSetCurrentInstance = registerGlobalSetter(
        `__VUE_INSTANCE_SETTERS__`,
        (v) => currentInstance = v
      );
      setInSSRSetupState = registerGlobalSetter(
        `__VUE_SSR_SETTERS__`,
        (v) => isInSSRComponentSetup = v
      );
    }
    const setCurrentInstance = (instance) => {
      const prev = currentInstance;
      internalSetCurrentInstance(instance);
      instance.scope.on();
      return () => {
        instance.scope.off();
        internalSetCurrentInstance(prev);
      };
    };
    const unsetCurrentInstance = () => {
      currentInstance && currentInstance.scope.off();
      internalSetCurrentInstance(null);
    };
    function isStatefulComponent(instance) {
      return instance.vnode.shapeFlag & 4;
    }
    let isInSSRComponentSetup = false;
    function setupComponent(instance, isSSR = false) {
      isSSR && setInSSRSetupState(isSSR);
      const { props, children: children2 } = instance.vnode;
      const isStateful = isStatefulComponent(instance);
      initProps(instance, props, isStateful, isSSR);
      initSlots(instance, children2);
      const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
      isSSR && setInSSRSetupState(false);
      return setupResult;
    }
    function setupStatefulComponent(instance, isSSR) {
      const Component = instance.type;
      instance.accessCache = /* @__PURE__ */ Object.create(null);
      instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
      const { setup } = Component;
      if (setup) {
        const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
        const reset = setCurrentInstance(instance);
        pauseTracking();
        const setupResult = callWithErrorHandling(
          setup,
          instance,
          0,
          [
            instance.props,
            setupContext
          ]
        );
        resetTracking();
        reset();
        if (isPromise(setupResult)) {
          setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
          if (isSSR) {
            return setupResult.then((resolvedResult) => {
              handleSetupResult(instance, resolvedResult, isSSR);
            }).catch((e) => {
              handleError(e, instance, 0);
            });
          } else {
            instance.asyncDep = setupResult;
          }
        } else {
          handleSetupResult(instance, setupResult, isSSR);
        }
      } else {
        finishComponentSetup(instance, isSSR);
      }
    }
    function handleSetupResult(instance, setupResult, isSSR) {
      if (isFunction$2(setupResult)) {
        if (instance.type.__ssrInlineRender) {
          instance.ssrRender = setupResult;
        } else {
          instance.render = setupResult;
        }
      } else if (isObject$2(setupResult)) {
        instance.setupState = proxyRefs(setupResult);
      } else
        ;
      finishComponentSetup(instance, isSSR);
    }
    let compile;
    function finishComponentSetup(instance, isSSR, skipOptions) {
      const Component = instance.type;
      if (!instance.render) {
        if (!isSSR && compile && !Component.render) {
          const template = Component.template || resolveMergedOptions(instance).template;
          if (template) {
            const { isCustomElement, compilerOptions } = instance.appContext.config;
            const { delimiters, compilerOptions: componentCompilerOptions } = Component;
            const finalCompilerOptions = extend$3(
              extend$3(
                {
                  isCustomElement,
                  delimiters
                },
                compilerOptions
              ),
              componentCompilerOptions
            );
            Component.render = compile(template, finalCompilerOptions);
          }
        }
        instance.render = Component.render || NOOP;
      }
      {
        const reset = setCurrentInstance(instance);
        pauseTracking();
        try {
          applyOptions(instance);
        } finally {
          resetTracking();
          reset();
        }
      }
    }
    function getAttrsProxy(instance) {
      return instance.attrsProxy || (instance.attrsProxy = new Proxy(
        instance.attrs,
        {
          get(target, key) {
            track(instance, "get", "$attrs");
            return target[key];
          }
        }
      ));
    }
    function createSetupContext(instance) {
      const expose = (exposed) => {
        instance.exposed = exposed || {};
      };
      {
        return {
          get attrs() {
            return getAttrsProxy(instance);
          },
          slots: instance.slots,
          emit: instance.emit,
          expose
        };
      }
    }
    function getExposeProxy(instance) {
      if (instance.exposed) {
        return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
          get(target, key) {
            if (key in target) {
              return target[key];
            } else if (key in publicPropertiesMap) {
              return publicPropertiesMap[key](instance);
            }
          },
          has(target, key) {
            return key in target || key in publicPropertiesMap;
          }
        }));
      }
    }
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
    function getComponentName(Component, includeInferred = true) {
      return isFunction$2(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
    }
    function formatComponentName(instance, Component, isRoot = false) {
      let name2 = getComponentName(Component);
      if (!name2 && Component.__file) {
        const match = Component.__file.match(/([^/\\]+)\.\w+$/);
        if (match) {
          name2 = match[1];
        }
      }
      if (!name2 && instance && instance.parent) {
        const inferFromRegistry = (registry) => {
          for (const key in registry) {
            if (registry[key] === Component) {
              return key;
            }
          }
        };
        name2 = inferFromRegistry(
          instance.components || instance.parent.type.components
        ) || inferFromRegistry(instance.appContext.components);
      }
      return name2 ? classify(name2) : isRoot ? `App` : `Anonymous`;
    }
    function isClassComponent(value) {
      return isFunction$2(value) && "__vccOpts" in value;
    }
    const computed = (getterOrOptions, debugOptions) => {
      return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
    };
    function h(type, propsOrChildren, children2) {
      const l = arguments.length;
      if (l === 2) {
        if (isObject$2(propsOrChildren) && !isArray$2(propsOrChildren)) {
          if (isVNode(propsOrChildren)) {
            return createVNode(type, null, [propsOrChildren]);
          }
          return createVNode(type, propsOrChildren);
        } else {
          return createVNode(type, null, propsOrChildren);
        }
      } else {
        if (l > 3) {
          children2 = Array.prototype.slice.call(arguments, 2);
        } else if (l === 3 && isVNode(children2)) {
          children2 = [children2];
        }
        return createVNode(type, propsOrChildren, children2);
      }
    }
    const version$2 = "3.4.18";
    /**
    * @vue/runtime-dom v3.4.18
    * (c) 2018-present Yuxi (Evan) You and Vue contributors
    * @license MIT
    **/
    const svgNS = "http://www.w3.org/2000/svg";
    const mathmlNS = "http://www.w3.org/1998/Math/MathML";
    const doc = typeof document !== "undefined" ? document : null;
    const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
    const nodeOps = {
      insert: (child, parent, anchor) => {
        parent.insertBefore(child, anchor || null);
      },
      remove: (child) => {
        const parent = child.parentNode;
        if (parent) {
          parent.removeChild(child);
        }
      },
      createElement: (tag, namespace2, is, props) => {
        const el = namespace2 === "svg" ? doc.createElementNS(svgNS, tag) : namespace2 === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
        if (tag === "select" && props && props.multiple != null) {
          el.setAttribute("multiple", props.multiple);
        }
        return el;
      },
      createText: (text) => doc.createTextNode(text),
      createComment: (text) => doc.createComment(text),
      setText: (node, text) => {
        node.nodeValue = text;
      },
      setElementText: (el, text) => {
        el.textContent = text;
      },
      parentNode: (node) => node.parentNode,
      nextSibling: (node) => node.nextSibling,
      querySelector: (selector2) => doc.querySelector(selector2),
      setScopeId(el, id2) {
        el.setAttribute(id2, "");
      },
      // __UNSAFE__
      // Reason: innerHTML.
      // Static content here can only come from compiled templates.
      // As long as the user only uses trusted templates, this is safe.
      insertStaticContent(content, parent, anchor, namespace2, start2, end2) {
        const before = anchor ? anchor.previousSibling : parent.lastChild;
        if (start2 && (start2 === end2 || start2.nextSibling)) {
          while (true) {
            parent.insertBefore(start2.cloneNode(true), anchor);
            if (start2 === end2 || !(start2 = start2.nextSibling))
              break;
          }
        } else {
          templateContainer.innerHTML = namespace2 === "svg" ? `<svg>${content}</svg>` : namespace2 === "mathml" ? `<math>${content}</math>` : content;
          const template = templateContainer.content;
          if (namespace2 === "svg" || namespace2 === "mathml") {
            const wrapper = template.firstChild;
            while (wrapper.firstChild) {
              template.appendChild(wrapper.firstChild);
            }
            template.removeChild(wrapper);
          }
          parent.insertBefore(template, anchor);
        }
        return [
          // first
          before ? before.nextSibling : parent.firstChild,
          // last
          anchor ? anchor.previousSibling : parent.lastChild
        ];
      }
    };
    const TRANSITION = "transition";
    const ANIMATION = "animation";
    const vtcKey = Symbol("_vtc");
    const Transition$1 = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
    Transition$1.displayName = "Transition";
    const DOMTransitionPropsValidators = {
      name: String,
      type: String,
      css: {
        type: Boolean,
        default: true
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
    };
    const TransitionPropsValidators = Transition$1.props = /* @__PURE__ */ extend$3(
      {},
      BaseTransitionPropsValidators,
      DOMTransitionPropsValidators
    );
    const callHook = (hook, args = []) => {
      if (isArray$2(hook)) {
        hook.forEach((h2) => h2(...args));
      } else if (hook) {
        hook(...args);
      }
    };
    const hasExplicitCallback = (hook) => {
      return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
    };
    function resolveTransitionProps(rawProps) {
      const baseProps = {};
      for (const key in rawProps) {
        if (!(key in DOMTransitionPropsValidators)) {
          baseProps[key] = rawProps[key];
        }
      }
      if (rawProps.css === false) {
        return baseProps;
      }
      const {
        name: name2 = "v",
        type,
        duration,
        enterFromClass = `${name2}-enter-from`,
        enterActiveClass = `${name2}-enter-active`,
        enterToClass = `${name2}-enter-to`,
        appearFromClass = enterFromClass,
        appearActiveClass = enterActiveClass,
        appearToClass = enterToClass,
        leaveFromClass = `${name2}-leave-from`,
        leaveActiveClass = `${name2}-leave-active`,
        leaveToClass = `${name2}-leave-to`
      } = rawProps;
      const durations = normalizeDuration(duration);
      const enterDuration = durations && durations[0];
      const leaveDuration = durations && durations[1];
      const {
        onBeforeEnter,
        onEnter,
        onEnterCancelled,
        onLeave,
        onLeaveCancelled,
        onBeforeAppear = onBeforeEnter,
        onAppear = onEnter,
        onAppearCancelled = onEnterCancelled
      } = baseProps;
      const finishEnter = (el, isAppear, done) => {
        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
        done && done();
      };
      const finishLeave = (el, done) => {
        el._isLeaving = false;
        removeTransitionClass(el, leaveFromClass);
        removeTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveActiveClass);
        done && done();
      };
      const makeEnterHook = (isAppear) => {
        return (el, done) => {
          const hook = isAppear ? onAppear : onEnter;
          const resolve2 = () => finishEnter(el, isAppear, done);
          callHook(hook, [el, resolve2]);
          nextFrame(() => {
            removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
            addTransitionClass(el, isAppear ? appearToClass : enterToClass);
            if (!hasExplicitCallback(hook)) {
              whenTransitionEnds(el, type, enterDuration, resolve2);
            }
          });
        };
      };
      return extend$3(baseProps, {
        onBeforeEnter(el) {
          callHook(onBeforeEnter, [el]);
          addTransitionClass(el, enterFromClass);
          addTransitionClass(el, enterActiveClass);
        },
        onBeforeAppear(el) {
          callHook(onBeforeAppear, [el]);
          addTransitionClass(el, appearFromClass);
          addTransitionClass(el, appearActiveClass);
        },
        onEnter: makeEnterHook(false),
        onAppear: makeEnterHook(true),
        onLeave(el, done) {
          el._isLeaving = true;
          const resolve2 = () => finishLeave(el, done);
          addTransitionClass(el, leaveFromClass);
          forceReflow();
          addTransitionClass(el, leaveActiveClass);
          nextFrame(() => {
            if (!el._isLeaving) {
              return;
            }
            removeTransitionClass(el, leaveFromClass);
            addTransitionClass(el, leaveToClass);
            if (!hasExplicitCallback(onLeave)) {
              whenTransitionEnds(el, type, leaveDuration, resolve2);
            }
          });
          callHook(onLeave, [el, resolve2]);
        },
        onEnterCancelled(el) {
          finishEnter(el, false);
          callHook(onEnterCancelled, [el]);
        },
        onAppearCancelled(el) {
          finishEnter(el, true);
          callHook(onAppearCancelled, [el]);
        },
        onLeaveCancelled(el) {
          finishLeave(el);
          callHook(onLeaveCancelled, [el]);
        }
      });
    }
    function normalizeDuration(duration) {
      if (duration == null) {
        return null;
      } else if (isObject$2(duration)) {
        return [NumberOf(duration.enter), NumberOf(duration.leave)];
      } else {
        const n = NumberOf(duration);
        return [n, n];
      }
    }
    function NumberOf(val) {
      const res = toNumber(val);
      return res;
    }
    function addTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
      (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
    }
    function removeTransitionClass(el, cls) {
      cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.delete(cls);
        if (!_vtc.size) {
          el[vtcKey] = void 0;
        }
      }
    }
    function nextFrame(cb) {
      requestAnimationFrame(() => {
        requestAnimationFrame(cb);
      });
    }
    let endId = 0;
    function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
      const id2 = el._endId = ++endId;
      const resolveIfNotStale = () => {
        if (id2 === el._endId) {
          resolve2();
        }
      };
      if (explicitTimeout) {
        return setTimeout(resolveIfNotStale, explicitTimeout);
      }
      const { type, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
      if (!type) {
        return resolve2();
      }
      const endEvent = type + "end";
      let ended = 0;
      const end2 = () => {
        el.removeEventListener(endEvent, onEnd);
        resolveIfNotStale();
      };
      const onEnd = (e) => {
        if (e.target === el && ++ended >= propCount) {
          end2();
        }
      };
      setTimeout(() => {
        if (ended < propCount) {
          end2();
        }
      }, timeout2 + 1);
      el.addEventListener(endEvent, onEnd);
    }
    function getTransitionInfo(el, expectedType) {
      const styles = window.getComputedStyle(el);
      const getStyleProperties = (key) => (styles[key] || "").split(", ");
      const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
      const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
      const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
      const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
      const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
      const animationTimeout = getTimeout(animationDelays, animationDurations);
      let type = null;
      let timeout2 = 0;
      let propCount = 0;
      if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
          type = TRANSITION;
          timeout2 = transitionTimeout;
          propCount = transitionDurations.length;
        }
      } else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
          type = ANIMATION;
          timeout2 = animationTimeout;
          propCount = animationDurations.length;
        }
      } else {
        timeout2 = Math.max(transitionTimeout, animationTimeout);
        type = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
        propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
      }
      const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
        getStyleProperties(`${TRANSITION}Property`).toString()
      );
      return {
        type,
        timeout: timeout2,
        propCount,
        hasTransform
      };
    }
    function getTimeout(delays, durations) {
      while (delays.length < durations.length) {
        delays = delays.concat(delays);
      }
      return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
    }
    function toMs(s) {
      if (s === "auto")
        return 0;
      return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
    }
    function forceReflow() {
      return document.body.offsetHeight;
    }
    function patchClass(el, value, isSVG) {
      const transitionClasses = el[vtcKey];
      if (transitionClasses) {
        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
      }
      if (value == null) {
        el.removeAttribute("class");
      } else if (isSVG) {
        el.setAttribute("class", value);
      } else {
        el.className = value;
      }
    }
    const vShowOldKey = Symbol("_vod");
    const vShow = {
      beforeMount(el, { value }, { transition }) {
        el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
        if (transition && value) {
          transition.beforeEnter(el);
        } else {
          setDisplay(el, value);
        }
      },
      mounted(el, { value }, { transition }) {
        if (transition && value) {
          transition.enter(el);
        }
      },
      updated(el, { value, oldValue }, { transition }) {
        if (!value === !oldValue && el.style.display === el[vShowOldKey])
          return;
        if (transition) {
          if (value) {
            transition.beforeEnter(el);
            setDisplay(el, true);
            transition.enter(el);
          } else {
            transition.leave(el, () => {
              setDisplay(el, false);
            });
          }
        } else {
          setDisplay(el, value);
        }
      },
      beforeUnmount(el, { value }) {
        setDisplay(el, value);
      }
    };
    function setDisplay(el, value) {
      el.style.display = value ? el[vShowOldKey] : "none";
    }
    const CSS_VAR_TEXT = Symbol("");
    function useCssVars(getter) {
      const instance = getCurrentInstance();
      if (!instance) {
        return;
      }
      const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {
        Array.from(
          document.querySelectorAll(`[data-v-owner="${instance.uid}"]`)
        ).forEach((node) => setVarsOnNode(node, vars));
      };
      const setVars = () => {
        const vars = getter(instance.proxy);
        setVarsOnVNode(instance.subTree, vars);
        updateTeleports(vars);
      };
      watchPostEffect(setVars);
      onMounted(() => {
        const ob = new MutationObserver(setVars);
        ob.observe(instance.subTree.el.parentNode, { childList: true });
        onUnmounted(() => ob.disconnect());
      });
    }
    function setVarsOnVNode(vnode, vars) {
      if (vnode.shapeFlag & 128) {
        const suspense = vnode.suspense;
        vnode = suspense.activeBranch;
        if (suspense.pendingBranch && !suspense.isHydrating) {
          suspense.effects.push(() => {
            setVarsOnVNode(suspense.activeBranch, vars);
          });
        }
      }
      while (vnode.component) {
        vnode = vnode.component.subTree;
      }
      if (vnode.shapeFlag & 1 && vnode.el) {
        setVarsOnNode(vnode.el, vars);
      } else if (vnode.type === Fragment) {
        vnode.children.forEach((c) => setVarsOnVNode(c, vars));
      } else if (vnode.type === Static) {
        let { el, anchor } = vnode;
        while (el) {
          setVarsOnNode(el, vars);
          if (el === anchor)
            break;
          el = el.nextSibling;
        }
      }
    }
    function setVarsOnNode(el, vars) {
      if (el.nodeType === 1) {
        const style = el.style;
        let cssText = "";
        for (const key in vars) {
          style.setProperty(`--${key}`, vars[key]);
          cssText += `--${key}: ${vars[key]};`;
        }
        style[CSS_VAR_TEXT] = cssText;
      }
    }
    const displayRE = /(^|;)\s*display\s*:/;
    function patchStyle(el, prev, next) {
      const style = el.style;
      const isCssString = isString$2(next);
      const currentDisplay = style.display;
      let hasControlledDisplay = false;
      if (next && !isCssString) {
        if (prev && !isString$2(prev)) {
          for (const key in prev) {
            if (next[key] == null) {
              setStyle(style, key, "");
            }
          }
        }
        for (const key in next) {
          if (key === "display") {
            hasControlledDisplay = true;
          }
          setStyle(style, key, next[key]);
        }
      } else {
        if (isCssString) {
          if (prev !== next) {
            const cssVarText = style[CSS_VAR_TEXT];
            if (cssVarText) {
              next += ";" + cssVarText;
            }
            style.cssText = next;
            hasControlledDisplay = displayRE.test(next);
          }
        } else if (prev) {
          el.removeAttribute("style");
        }
      }
      if (vShowOldKey in el) {
        el[vShowOldKey] = hasControlledDisplay ? style.display : "";
        style.display = currentDisplay;
      }
    }
    const importantRE = /\s*!important$/;
    function setStyle(style, name2, val) {
      if (isArray$2(val)) {
        val.forEach((v) => setStyle(style, name2, v));
      } else {
        if (val == null)
          val = "";
        if (name2.startsWith("--")) {
          style.setProperty(name2, val);
        } else {
          const prefixed = autoPrefix(style, name2);
          if (importantRE.test(val)) {
            style.setProperty(
              hyphenate(prefixed),
              val.replace(importantRE, ""),
              "important"
            );
          } else {
            style[prefixed] = val;
          }
        }
      }
    }
    const prefixes = ["Webkit", "Moz", "ms"];
    const prefixCache = {};
    function autoPrefix(style, rawName) {
      const cached = prefixCache[rawName];
      if (cached) {
        return cached;
      }
      let name2 = camelize(rawName);
      if (name2 !== "filter" && name2 in style) {
        return prefixCache[rawName] = name2;
      }
      name2 = capitalize(name2);
      for (let i = 0; i < prefixes.length; i++) {
        const prefixed = prefixes[i] + name2;
        if (prefixed in style) {
          return prefixCache[rawName] = prefixed;
        }
      }
      return rawName;
    }
    const xlinkNS = "http://www.w3.org/1999/xlink";
    function patchAttr(el, key, value, isSVG, instance) {
      if (isSVG && key.startsWith("xlink:")) {
        if (value == null) {
          el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
        } else {
          el.setAttributeNS(xlinkNS, key, value);
        }
      } else {
        const isBoolean2 = isSpecialBooleanAttr(key);
        if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
          el.removeAttribute(key);
        } else {
          el.setAttribute(key, isBoolean2 ? "" : value);
        }
      }
    }
    function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
      if (key === "innerHTML" || key === "textContent") {
        if (prevChildren) {
          unmountChildren(prevChildren, parentComponent, parentSuspense);
        }
        el[key] = value == null ? "" : value;
        return;
      }
      const tag = el.tagName;
      if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
      !tag.includes("-")) {
        el._value = value;
        const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
        const newValue = value == null ? "" : value;
        if (oldValue !== newValue) {
          el.value = newValue;
        }
        if (value == null) {
          el.removeAttribute(key);
        }
        return;
      }
      let needRemove = false;
      if (value === "" || value == null) {
        const type = typeof el[key];
        if (type === "boolean") {
          value = includeBooleanAttr(value);
        } else if (value == null && type === "string") {
          value = "";
          needRemove = true;
        } else if (type === "number") {
          value = 0;
          needRemove = true;
        }
      }
      try {
        el[key] = value;
      } catch (e) {
      }
      needRemove && el.removeAttribute(key);
    }
    function addEventListener(el, event, handler, options) {
      el.addEventListener(event, handler, options);
    }
    function removeEventListener(el, event, handler, options) {
      el.removeEventListener(event, handler, options);
    }
    const veiKey = Symbol("_vei");
    function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
      const invokers = el[veiKey] || (el[veiKey] = {});
      const existingInvoker = invokers[rawName];
      if (nextValue && existingInvoker) {
        existingInvoker.value = nextValue;
      } else {
        const [name2, options] = parseName(rawName);
        if (nextValue) {
          const invoker = invokers[rawName] = createInvoker(nextValue, instance);
          addEventListener(el, name2, invoker, options);
        } else if (existingInvoker) {
          removeEventListener(el, name2, existingInvoker, options);
          invokers[rawName] = void 0;
        }
      }
    }
    const optionsModifierRE = /(?:Once|Passive|Capture)$/;
    function parseName(name2) {
      let options;
      if (optionsModifierRE.test(name2)) {
        options = {};
        let m;
        while (m = name2.match(optionsModifierRE)) {
          name2 = name2.slice(0, name2.length - m[0].length);
          options[m[0].toLowerCase()] = true;
        }
      }
      const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
      return [event, options];
    }
    let cachedNow = 0;
    const p = /* @__PURE__ */ Promise.resolve();
    const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
    function createInvoker(initialValue, instance) {
      const invoker = (e) => {
        if (!e._vts) {
          e._vts = Date.now();
        } else if (e._vts <= invoker.attached) {
          return;
        }
        callWithAsyncErrorHandling(
          patchStopImmediatePropagation(e, invoker.value),
          instance,
          5,
          [e]
        );
      };
      invoker.value = initialValue;
      invoker.attached = getNow();
      return invoker;
    }
    function patchStopImmediatePropagation(e, value) {
      if (isArray$2(value)) {
        const originalStop = e.stopImmediatePropagation;
        e.stopImmediatePropagation = () => {
          originalStop.call(e);
          e._stopped = true;
        };
        return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
      } else {
        return value;
      }
    }
    const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
    key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
    const patchProp = (el, key, prevValue, nextValue, namespace2, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
      const isSVG = namespace2 === "svg";
      if (key === "class") {
        patchClass(el, nextValue, isSVG);
      } else if (key === "style") {
        patchStyle(el, prevValue, nextValue);
      } else if (isOn(key)) {
        if (!isModelListener(key)) {
          patchEvent(el, key, prevValue, nextValue, parentComponent);
        }
      } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
        patchDOMProp(
          el,
          key,
          nextValue,
          prevChildren,
          parentComponent,
          parentSuspense,
          unmountChildren
        );
      } else {
        if (key === "true-value") {
          el._trueValue = nextValue;
        } else if (key === "false-value") {
          el._falseValue = nextValue;
        }
        patchAttr(el, key, nextValue, isSVG);
      }
    };
    function shouldSetAsProp(el, key, value, isSVG) {
      if (isSVG) {
        if (key === "innerHTML" || key === "textContent") {
          return true;
        }
        if (key in el && isNativeOn(key) && isFunction$2(value)) {
          return true;
        }
        return false;
      }
      if (key === "spellcheck" || key === "draggable" || key === "translate") {
        return false;
      }
      if (key === "form") {
        return false;
      }
      if (key === "list" && el.tagName === "INPUT") {
        return false;
      }
      if (key === "type" && el.tagName === "TEXTAREA") {
        return false;
      }
      if (key === "width" || key === "height") {
        const tag = el.tagName;
        if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
          return false;
        }
      }
      if (isNativeOn(key) && isString$2(value)) {
        return false;
      }
      return key in el;
    }
    const positionMap = /* @__PURE__ */ new WeakMap();
    const newPositionMap = /* @__PURE__ */ new WeakMap();
    const moveCbKey = Symbol("_moveCb");
    const enterCbKey = Symbol("_enterCb");
    const TransitionGroupImpl = {
      name: "TransitionGroup",
      props: /* @__PURE__ */ extend$3({}, TransitionPropsValidators, {
        tag: String,
        moveClass: String
      }),
      setup(props, { slots }) {
        const instance = getCurrentInstance();
        const state = useTransitionState();
        let prevChildren;
        let children2;
        onUpdated(() => {
          if (!prevChildren.length) {
            return;
          }
          const moveClass = props.moveClass || `${props.name || "v"}-move`;
          if (!hasCSSTransform(
            prevChildren[0].el,
            instance.vnode.el,
            moveClass
          )) {
            return;
          }
          prevChildren.forEach(callPendingCbs);
          prevChildren.forEach(recordPosition);
          const movedChildren = prevChildren.filter(applyTranslation);
          forceReflow();
          movedChildren.forEach((c) => {
            const el = c.el;
            const style = el.style;
            addTransitionClass(el, moveClass);
            style.transform = style.webkitTransform = style.transitionDuration = "";
            const cb = el[moveCbKey] = (e) => {
              if (e && e.target !== el) {
                return;
              }
              if (!e || /transform$/.test(e.propertyName)) {
                el.removeEventListener("transitionend", cb);
                el[moveCbKey] = null;
                removeTransitionClass(el, moveClass);
              }
            };
            el.addEventListener("transitionend", cb);
          });
        });
        return () => {
          const rawProps = toRaw(props);
          const cssTransitionProps = resolveTransitionProps(rawProps);
          let tag = rawProps.tag || Fragment;
          prevChildren = children2;
          children2 = slots.default ? getTransitionRawChildren(slots.default()) : [];
          for (let i = 0; i < children2.length; i++) {
            const child = children2[i];
            if (child.key != null) {
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
            }
          }
          if (prevChildren) {
            for (let i = 0; i < prevChildren.length; i++) {
              const child = prevChildren[i];
              setTransitionHooks(
                child,
                resolveTransitionHooks(child, cssTransitionProps, state, instance)
              );
              positionMap.set(child, child.el.getBoundingClientRect());
            }
          }
          return createVNode(tag, null, children2);
        };
      }
    };
    const removeMode = (props) => delete props.mode;
    /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
    const TransitionGroup = TransitionGroupImpl;
    function callPendingCbs(c) {
      const el = c.el;
      if (el[moveCbKey]) {
        el[moveCbKey]();
      }
      if (el[enterCbKey]) {
        el[enterCbKey]();
      }
    }
    function recordPosition(c) {
      newPositionMap.set(c, c.el.getBoundingClientRect());
    }
    function applyTranslation(c) {
      const oldPos = positionMap.get(c);
      const newPos = newPositionMap.get(c);
      const dx = oldPos.left - newPos.left;
      const dy = oldPos.top - newPos.top;
      if (dx || dy) {
        const s = c.el.style;
        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = "0s";
        return c;
      }
    }
    function hasCSSTransform(el, root2, moveClass) {
      const clone2 = el.cloneNode();
      const _vtc = el[vtcKey];
      if (_vtc) {
        _vtc.forEach((cls) => {
          cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
        });
      }
      moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
      clone2.style.display = "none";
      const container = root2.nodeType === 1 ? root2 : root2.parentNode;
      container.appendChild(clone2);
      const { hasTransform } = getTransitionInfo(clone2);
      container.removeChild(clone2);
      return hasTransform;
    }
    const getModelAssigner = (vnode) => {
      const fn = vnode.props["onUpdate:modelValue"] || false;
      return isArray$2(fn) ? (value) => invokeArrayFns(fn, value) : fn;
    };
    function onCompositionStart(e) {
      e.target.composing = true;
    }
    function onCompositionEnd(e) {
      const target = e.target;
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    }
    const assignKey = Symbol("_assign");
    const vModelText = {
      created(el, { modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        const castToNumber = number || vnode.props && vnode.props.type === "number";
        addEventListener(el, lazy ? "change" : "input", (e) => {
          if (e.target.composing)
            return;
          let domValue = el.value;
          if (trim2) {
            domValue = domValue.trim();
          }
          if (castToNumber) {
            domValue = looseToNumber(domValue);
          }
          el[assignKey](domValue);
        });
        if (trim2) {
          addEventListener(el, "change", () => {
            el.value = el.value.trim();
          });
        }
        if (!lazy) {
          addEventListener(el, "compositionstart", onCompositionStart);
          addEventListener(el, "compositionend", onCompositionEnd);
          addEventListener(el, "change", onCompositionEnd);
        }
      },
      // set value on mounted so it's after min/max for type="range"
      mounted(el, { value }) {
        el.value = value == null ? "" : value;
      },
      beforeUpdate(el, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (el.composing)
          return;
        const elValue = number || el.type === "number" ? looseToNumber(el.value) : el.value;
        const newValue = value == null ? "" : value;
        if (elValue === newValue) {
          return;
        }
        if (document.activeElement === el && el.type !== "range") {
          if (lazy) {
            return;
          }
          if (trim2 && el.value.trim() === newValue) {
            return;
          }
        }
        el.value = newValue;
      }
    };
    const vModelRadio = {
      created(el, { value }, vnode) {
        el.checked = looseEqual(value, vnode.props.value);
        el[assignKey] = getModelAssigner(vnode);
        addEventListener(el, "change", () => {
          el[assignKey](getValue(el));
        });
      },
      beforeUpdate(el, { value, oldValue }, vnode) {
        el[assignKey] = getModelAssigner(vnode);
        if (value !== oldValue) {
          el.checked = looseEqual(value, vnode.props.value);
        }
      }
    };
    function getValue(el) {
      return "_value" in el ? el._value : el.value;
    }
    const systemModifiers = ["ctrl", "shift", "alt", "meta"];
    const modifierGuards = {
      stop: (e) => e.stopPropagation(),
      prevent: (e) => e.preventDefault(),
      self: (e) => e.target !== e.currentTarget,
      ctrl: (e) => !e.ctrlKey,
      shift: (e) => !e.shiftKey,
      alt: (e) => !e.altKey,
      meta: (e) => !e.metaKey,
      left: (e) => "button" in e && e.button !== 0,
      middle: (e) => "button" in e && e.button !== 1,
      right: (e) => "button" in e && e.button !== 2,
      exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
    };
    const withModifiers = (fn, modifiers) => {
      const cache = fn._withMods || (fn._withMods = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
        for (let i = 0; i < modifiers.length; i++) {
          const guard = modifierGuards[modifiers[i]];
          if (guard && guard(event, modifiers))
            return;
        }
        return fn(event, ...args);
      });
    };
    const keyNames = {
      esc: "escape",
      space: " ",
      up: "arrow-up",
      left: "arrow-left",
      right: "arrow-right",
      down: "arrow-down",
      delete: "backspace"
    };
    const withKeys = (fn, modifiers) => {
      const cache = fn._withKeys || (fn._withKeys = {});
      const cacheKey = modifiers.join(".");
      return cache[cacheKey] || (cache[cacheKey] = (event) => {
        if (!("key" in event)) {
          return;
        }
        const eventKey = hyphenate(event.key);
        if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
          return fn(event);
        }
      });
    };
    const rendererOptions = /* @__PURE__ */ extend$3({ patchProp }, nodeOps);
    let renderer;
    function ensureRenderer() {
      return renderer || (renderer = createRenderer(rendererOptions));
    }
    const createApp = (...args) => {
      const app = ensureRenderer().createApp(...args);
      const { mount } = app;
      app.mount = (containerOrSelector) => {
        const container = normalizeContainer(containerOrSelector);
        if (!container)
          return;
        const component = app._component;
        if (!isFunction$2(component) && !component.render && !component.template) {
          component.template = container.innerHTML;
        }
        container.innerHTML = "";
        const proxy = mount(container, false, resolveRootNamespace(container));
        if (container instanceof Element) {
          container.removeAttribute("v-cloak");
          container.setAttribute("data-v-app", "");
        }
        return proxy;
      };
      return app;
    };
    function resolveRootNamespace(container) {
      if (container instanceof SVGElement) {
        return "svg";
      }
      if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
        return "mathml";
      }
    }
    function normalizeContainer(container) {
      if (isString$2(container)) {
        const res = document.querySelector(container);
        return res;
      }
      return container;
    }
    const IconSettings = {
      name: "IconSettings",
      render() {
        const _default = this.$slots.default ? this.$slots.default()[0] : null;
        return _default;
      },
      props: {
        iconPath: String,
        actionSpritePath: String,
        customSpritePath: String,
        doctypeSpritePath: String,
        standardSpritePath: String,
        utilitySpritePath: String
      },
      provide() {
        return {
          $__getIconSettings: () => this.$props
        };
      }
    };
    const getGUID = () => {
      function s4() {
        return Math.floor((1 + Math.random()) * 65536).toString(16).substring(1);
      }
      return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
    };
    const hasOwnProperty$1 = (object, prop) => Object.prototype.hasOwnProperty.call(object, prop);
    const getMissingProps = (object, props) => {
      const missing = [];
      props.forEach((prop) => {
        if (!hasOwnProperty$1(object, prop)) {
          missing.push(prop);
        }
      });
      return missing;
    };
    function bind$1(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    const { toString: toString$1 } = Object.prototype;
    const { getPrototypeOf } = Object;
    const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString$1.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    const typeOfTest = (type) => (thing) => typeof thing === type;
    const { isArray: isArray$1 } = Array;
    const isUndefined$1 = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    const isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    const isString$1 = typeOfTest("string");
    const isFunction$1 = typeOfTest("function");
    const isNumber$1 = typeOfTest("number");
    const isObject$1 = (thing) => thing !== null && typeof thing === "object";
    const isBoolean = (thing) => thing === true || thing === false;
    const isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
    };
    const isDate$1 = kindOfTest("Date");
    const isFile = kindOfTest("File");
    const isBlob = kindOfTest("Blob");
    const isFileList = kindOfTest("FileList");
    const isStream = (val) => isObject$1(val) && isFunction$1(val.pipe);
    const isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    const isURLSearchParams = kindOfTest("URLSearchParams");
    const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray$1(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys2.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys2[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      key = key.toLowerCase();
      const keys2 = Object.keys(obj);
      let i = keys2.length;
      let _key;
      while (i-- > 0) {
        _key = keys2[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    const _global = (() => {
      if (typeof globalThis !== "undefined")
        return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    const isContextDefined = (context) => !isUndefined$1(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray$1(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    const extend$2 = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    const inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    const toArray$1 = (thing) => {
      if (!thing)
        return null;
      if (isArray$1(thing))
        return thing;
      let i = thing.length;
      if (!isNumber$1(i))
        return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[Symbol.iterator];
      const iterator = generator.call(obj);
      let result;
      while ((result = iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    const isHTMLForm = kindOfTest("HTMLFormElement");
    const toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer2(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    const isRegExp = kindOfTest("RegExp");
    const reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name2) => {
        let ret;
        if ((ret = reducer(descriptor, name2, obj)) !== false) {
          reducedDescriptors[name2] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name2) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
          return false;
        }
        const value = obj[name2];
        if (!isFunction$1(value))
          return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name2 + "'");
          };
        }
      });
    };
    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray$1(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    const noop$1 = () => {
    };
    const toFiniteNumber = (value, defaultValue) => {
      value = +value;
      return Number.isFinite(value) ? value : defaultValue;
    };
    const ALPHA = "abcdefghijklmnopqrstuvwxyz";
    const DIGIT = "0123456789";
    const ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      while (size2--) {
        str += alphabet[Math.random() * length | 0];
      }
      return str;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
    }
    const toJSONObject = (obj) => {
      const stack2 = new Array(10);
      const visit = (source, i) => {
        if (isObject$1(source)) {
          if (stack2.indexOf(source) >= 0) {
            return;
          }
          if (!("toJSON" in source)) {
            stack2[i] = source;
            const target = isArray$1(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined$1(reducedValue) && (target[key] = reducedValue);
            });
            stack2[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    const isAsyncFn = kindOfTest("AsyncFunction");
    const isThenable = (thing) => thing && (isObject$1(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    const utils$1 = {
      isArray: isArray$1,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isBoolean,
      isObject: isObject$1,
      isPlainObject,
      isUndefined: isUndefined$1,
      isDate: isDate$1,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend: extend$2,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray: toArray$1,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop: noop$1,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      ALPHABET,
      generateString,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON2() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    const prototype$1 = AxiosError.prototype;
    const descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    const httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token2, i) {
        token2 = removeBrackets(token2);
        return !dots && i ? "[" + token2 + "]" : token2;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack2 = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value))
          return;
        if (stack2.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack2.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack2.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    const prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name2, value) {
      this._pairs.push([name2, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id2) {
        if (this.handlers[id2]) {
          this.handlers[id2] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn(h2);
          }
        });
      }
    }
    const transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    const platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    const hasStandardBrowserEnv = ((product) => {
      return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
    })(typeof navigator !== "undefined" && navigator.product);
    const hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserEnv,
      hasStandardBrowserWebWorkerEnv
    }, Symbol.toStringTag, { value: "Module" }));
    const platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    }
    function parsePropPath(name2) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys2 = Object.keys(arr);
      let i;
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name2 = path[index++];
        if (name2 === "__proto__")
          return true;
        const isNumericKey = Number.isFinite(+name2);
        const isLast = index >= path.length;
        name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name2)) {
            target[name2] = [target[name2], value];
          } else {
            target[name2] = value;
          }
          return !isNumericKey;
        }
        if (!target[name2] || !utils$1.isObject(target[name2])) {
          target[name2] = [];
        }
        const result = buildPath(path, value, target[name2], index);
        if (result && utils$1.isArray(target[name2])) {
          target[name2] = arrayToObject(target[name2]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name2, value) => {
          buildPath(parsePropPath(name2), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    const defaults$2 = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults$2.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults$2.headers[method] = {};
    });
    const defaults$3 = defaults$2;
    const ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    const parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    const $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens2 = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens2[match[1]] = match[2];
      }
      return tokens2;
    }
    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
      if (utils$1.isFunction(filter2)) {
        return filter2.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value))
        return;
      if (utils$1.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
      }
      if (utils$1.isRegExp(filter2)) {
        return filter2.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher2) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher2 || matchHeaderValue(this, this[key], key, matcher2)));
        }
        return false;
      }
      delete(header, matcher2) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher2 || matchHeaderValue(self2, self2[key], key, matcher2))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher2) {
        const keys2 = Object.keys(this);
        let i = keys2.length;
        let deleted = false;
        while (i--) {
          const key = keys2[i];
          if (!matcher2 || matchHeaderValue(this, this[key], key, matcher2, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format2) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format2 ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed2 = new this(first);
        targets.forEach((target) => computed2.set(target));
        return computed2;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    const AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$3;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve2, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    const cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name2, value, expires, path, domain, secure) {
          const cookie = [name2 + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name2) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name2) {
          this.write(name2, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        const msie = /(msie|trident)/i.test(navigator.userAgent);
        const urlParsingNode = document.createElement("a");
        let originURL;
        function resolveURL(url) {
          let href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min2) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min2 = min2 !== void 0 ? min2 : 1e3;
      return function push(chunkLength) {
        const now2 = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now2;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now2;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now2 - firstSampleTS < min2) {
          return;
        }
        const passed = startedAt && now2 - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function progressEventReducer(listener, isDownloadStream) {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return (e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e
        };
        data[isDownloadStream ? "download" : "upload"] = true;
        listener(data);
      };
    }
    const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    const xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject) {
        let requestData = config.data;
        const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
        let { responseType, withXSRFToken } = config;
        let onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        let contentType;
        if (utils$1.isFormData(requestData)) {
          if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
            requestHeaders.setContentType(false);
          } else if ((contentType = requestHeaders.getContentType()) !== false) {
            const [type, ...tokens2] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
            requestHeaders.setContentType([type || "multipart/form-data", ...tokens2].join("; "));
          }
        }
        let request = new XMLHttpRequest();
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
        }
        const fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve2(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError2() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (platform.hasStandardBrowserEnv) {
          withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders.set(config.xsrfHeaderName, xsrfValue);
            }
          }
        }
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
        }
        if (config.cancelToken || config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    const renderReason = (reason) => `- ${reason}`;
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    const adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id2;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id2}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id2 || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$3.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
      };
      utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    const VERSION = "1.6.7";
    const validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    const deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys2 = Object.keys(options);
      let i = keys2.length;
      while (i-- > 0) {
        const opt = keys2[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    const validator = {
      assertOptions,
      validators: validators$1
    };
    const validators = validator.validators;
    class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy;
            Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
            const stack2 = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            if (!err.stack) {
              err.stack = stack2;
            } else if (stack2 && !String(err.stack).endsWith(stack2.replace(/^.+\n.+\n/, ""))) {
              err.stack += "\n" + stack2;
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    const Axios$1 = Axios;
    class CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve2) {
          resolvePromise = resolve2;
        });
        const token2 = this;
        this.promise.then((cancel) => {
          if (!token2._listeners)
            return;
          let i = token2._listeners.length;
          while (i-- > 0) {
            token2._listeners[i](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve2) => {
            token2.subscribe(resolve2);
            _resolve = resolve2;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token2.reason) {
            return;
          }
          token2.reason = new CanceledError(message, config, request);
          resolvePromise(token2.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token2 = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token2,
          cancel
        };
      }
    }
    const CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    const HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    const HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind$1(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    const axios = createInstance(defaults$3);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    const Node$3 = function() {
      this.keys = /* @__PURE__ */ new Map();
      this.childCount = 0;
      this.end = false;
      this.setEnd = function() {
        this.end = true;
      };
      this.isEnd = function() {
        return this.end;
      };
    };
    const Trie = function() {
      this.root = new Node$3();
      this.add = function(input, node = this.root) {
        if (input.length === 0) {
          node.setEnd();
          return;
        }
        node.childCount++;
        if (!node.keys.has(input[0])) {
          node.keys.set(input[0], new Node$3());
          return this.add(input.substr(1), node.keys.get(input[0]));
        }
        return this.add(input.substr(1), node.keys.get(input[0]));
      };
      this.countChildren = function(word) {
        let node = this.findNode(word);
        if (node === false)
          return -1;
        return node.childCount;
      };
      this.isWord = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        return !!(node.keys.has(word) && node.keys.get(word).isEnd());
      };
      this.findNode = (word) => {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (node.keys.get(word))
          return node.keys.get(word);
        else
          return false;
      };
      this.prefixMatchingWords = (prefix) => {
        const words = new Array();
        let node = this.findNode(prefix);
        if (!node)
          return words;
        if (node.childCount === 0)
          return [prefix];
        const search = function(node2, string) {
          if (node2.keys.size != 0) {
            for (const letter of node2.keys.keys()) {
              search(node2.keys.get(letter), string.concat(letter));
            }
            if (node2.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(node, new String());
        if (words.length > 0) {
          return words.map((word) => `${prefix}${word}`);
        }
        return [];
      };
      this.countDirectChildren = function(word) {
        let node = this.root;
        while (word.length > 1) {
          if (!node.keys.has(word[0])) {
            return false;
          }
          node = node.keys.get(word[0]);
          word = word.substr(1);
        }
        if (!node.keys.has(word))
          return false;
        if (node.keys.get(word).isEnd()) {
          return 0;
        }
        return node.keys.get(word).keys.size;
      };
      this.print = function() {
        const words = new Array();
        const search = function(node, string) {
          if (node.keys.size != 0) {
            for (const letter of node.keys.keys()) {
              search(node.keys.get(letter), string.concat(letter));
            }
            if (node.isEnd()) {
              words.push(string);
            }
          } else {
            string.length > 0 ? words.push(string) : void 0;
          }
        };
        search(this.root, new String());
        return words.length > 0 ? words : mo;
      };
    };
    const Trie$1 = { Trie };
    const Symbols = {
      Circle: {
        label: "Circle",
        marker: "●",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <circle r="24" cy="26" cx="26" style="fill:#706e6b;stroke:#706e6b;stroke-width:3.847;stroke-linejoin:round;fill-opacity:1;stroke-opacity:1"/>
            </svg>
        `
      },
      Square: {
        label: "Square",
        marker: "■",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path style="fill:#706e6b;fill-opacity:1;stroke:#706e6b;stroke-width:3.77953;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="M1.889765 1.889765h48v48h-48z"/>
            </svg>
        `
      },
      Pyramid: {
        label: "Pyramid",
        marker: "▲",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path  d="M52 52 25 0 0 52Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Triangle: {
        label: "Triangle",
        marker: "▼",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="m0 0 27 52L52 0Z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Diamond: {
        label: "Diamond",
        marker: "◆",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M26 0 0 26l26 26 26-26Z" style="fill:#706e6b;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Star: {
        label: "Star",
        marker: "★",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path transform="matrix(1.04945 0 0 1.10341 -.23623862 1.1584795)" d="m25.000001 0 7.347315 14.887288 16.429097 2.387288-11.888207 11.588136 2.806425 16.362713L25 37.5l-14.694632 7.725424 2.806426-16.362712L1.2235873 17.274575l16.4290967-2.387287Z" style="fill:#706e6b;fill-rule:evenodd;stroke:#706e6b;stroke-width:.929286;stroke-opacity:1;fill-opacity:1"/>
            </svg>
        `
      },
      Parallelogram: {
        label: "Parallelogram",
        marker: "▰",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52-2.6e-7H10L0 51.999999h43z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Rectangle: {
        label: "Rectangle",
        marker: "▬",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M52 10H0v32h52z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      },
      Box: {
        label: "Box",
        marker: "▮",
        svg: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52" width="1.0rem" height="1.0rem">
                <path d="M43 0 10-2.6e-7V52l33-.000001z" style="fill:#706e6b;fill-opacity:1;stroke:none;stroke-width:1px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"/>
            </svg>
        `
      }
    };
    const MapUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Symbols
    }, Symbol.toStringTag, { value: "Module" }));
    function SegClient({ Buffer: Buffer2, Papa } = {}) {
      const Rule = {
        toSaql(rule, dataSource) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: dataSource._referenceFields.find((f) => f.id === item.sfsp__Field__c).dataType === "Numeric" ? "Numeric" : "Text"
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        }
      };
      const Filter = {
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i = 0; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        toSaql(filter2) {
          const { field, operator, value = "", dataType } = filter2;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] && ${field} is not null)` : `${field} not in ["${values.join('","')}"]` : value ? `${field} != "${value}"` : `(${field} != "" && ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              case "doesnotcontain":
                return values.length > 1 ? `(${values.map((v) => `!(${field} matches "${v}")`).join(" && ")})` : `!(${field} matches "${value}")`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: ""
        }),
        getDataSetCountSaql({ datasetId, versionId }) {
          return `
                -- load records
                q = load "${datasetId}/${versionId}";
    
                -- results
                results = group q by all;
                results = foreach results generate count() as count;
            `;
        },
        // saql generation
        generateHierarchySaql({ node, nodeMap, dataSource, fields = [] }) {
          if (!node._parentId) {
            return `
                    ------------------------------------
                    -- Records
                    ------------------------------------
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    ------------------------------------
                    -- Filters
                    ------------------------------------
    
                    -- all org
                    all_org = group q by all;
                    ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}
    
                    ------------------------------------
                    -- Projections
                    ------------------------------------
                    ${Object.keys(nodeMap).map((id2) => `
                        ${id2} = group ${id2} by all;
                        ${id2} = foreach ${id2} generate ${[
              `"${id2}" as __NodeId`,
              `count() as __Records`,
              ...fields.map((f) => `sum(${f}) as ${f}`)
            ].join(", ")};
                    `).join("")}
    
                    ------------------------------------
                    -- Results
                    ------------------------------------
                    ${Object.keys(nodeMap).length > 1 ? `results = union ${Object.keys(nodeMap).join(", ")};` : `results = limit ${Object.keys(nodeMap)[0]} 1;`}
                `.replace(/^ */gm, "");
          }
          return `
                -- ${node.Name}
                ${node.Id} = filter ${node._parentId} by ${this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id })};
                ${node.sfsp__SalesNodes__r.map((childNode) => this.generateHierarchySaql({ node: childNode, nodeMap, dataSource, fields })).join("")}`;
        },
        generateNodeFilterSaql({ node, nodeMap, dataSource, descendantFilters = [], isBurndown = false }) {
          descendantFilters.push(this.generateRules({ node, nodeMap, dataSource, uniqueIdField: dataSource._referenceFields.find((f) => f.isId).id, isBurndown }));
          if (!node._parentId) {
            return `
                    -- load records
                    q = load "${dataSource._dataset.id}/${dataSource._dataset.currentVersionId}";
    
                    -- filters
                    results = filter q by (${descendantFilters.join(") && (")});
                `;
          }
          return this.generateNodeFilterSaql({ node: nodeMap[node._parentId], nodeMap, dataSource, descendantFilters });
        },
        generateRules({ node, nodeMap, dataSource, uniqueIdField, isBurndown }) {
          const burndownNodes = isBurndown ? node.sfsp__SalesNodes__r : [];
          if (node.sfsp__SalesNodeRules__r.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} ${node.Id === "all_org" ? "is not null" : "is null"}`;
          const saqlParts = [];
          if (node.sfsp__SalesNodeRules__r.length) {
            const matchingRulesLogic = this.getRuleLogic({ node });
            const matchingRulesFilterExpression = Filter.mergeBooleanFilter(
              matchingRulesLogic,
              node.sfsp__SalesNodeRules__r.map((r) => Rule.toSaql(r, dataSource))
            );
            saqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${this.generateRules({ node: childNode, nodeMap, dataSource, uniqueIdField })})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        // rule logic
        getRuleLogic({ node }) {
          const existingRuleLogic = node.sfsp__RuleLogics__c;
          if (existingRuleLogic)
            return existingRuleLogic;
          return node.sfsp__SalesNodeRules__r.length === 0 ? "" : Array(node.sfsp__SalesNodeRules__r.length).fill().map((item, i) => i + 1).join(" or ");
        },
        setRuleLogic({ node, logic }) {
          node.sfsp__RuleLogics__c = logic;
        },
        // hierarchy
        async buildNodeMap({ nodeId: nodeId2 }) {
          const nodeMap = {
            all_org: {
              ...SPM.Utils.Segment.Node.defaults(),
              Id: "all_org",
              Name: "All Org"
            }
          };
          const loadAncestors = async (parentId) => {
            let [node] = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        sfsp__SalesPlan__c,
                        sfsp__Parent__c,
                        ${Array(5).fill().map((item, i) => {
              const prefix = Array(i + 1).fill().map(() => "sfsp__Parent__r").join(".");
              return `
                                ${prefix}.Name,
                                ${prefix}.sfsp__Parent__c,
                                ${prefix}.sfsp__RuleLogics__c,
                            `;
            }).join("")}
                        sfsp__RuleLogics__c
                    FROM sfsp__SalesNode__c
                    WHERE Id = '${parentId}'
                `]);
            while (node) {
              nodeMap[node.Id] = {
                ...SPM.Utils.Segment.Node.defaults(),
                ...node,
                _parentId: node.sfsp__Parent__c || "all_org"
              };
              if (node.sfsp__Parent__c && !node.sfsp__Parent__r) {
                await loadAncestors(node.sfsp__Parent__c);
              }
              node = node.sfsp__Parent__r;
            }
          };
          await loadAncestors(nodeId2);
          const rules = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c,
                    (
                        SELECT Id, sfsp__SalesNodeRule__r.sfsp__SalesNode__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                        FROM sfsp__SalesNodeRuleItems__r
                        ORDER BY sfsp__SortOrder__c
                    )
                FROM sfsp__SalesNodeRule__c
                WHERE sfsp__SalesNode__c IN ('${Object.keys(nodeMap).filter((id2) => id2 !== "all_org").join(`','`)}')
                ORDER BY sfsp__SortOrder__c
            `]);
          rules.forEach((r) => nodeMap[r.sfsp__SalesNode__c].sfsp__SalesNodeRules__r.push(r));
          return nodeMap;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node._parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.sfsp__SalesNodes__r || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        compare({ node, compareNode, breadcrumbs = [] }) {
          const diff2 = [];
          const map2 = {};
          node.sfsp__SalesNodes__r.forEach((n) => {
            const matchingNodeIndex = compareNode.sfsp__SalesNodes__r.findIndex((n2) => n2.Name === n.Name);
            if (matchingNodeIndex !== -1) {
              const matchingNode = compareNode.sfsp__SalesNodes__r.splice(matchingNodeIndex, 1)[0];
              map2[n.Id] = matchingNode;
              const childCompareResults = Node2.compare({ node: n, compareNode: matchingNode, breadcrumbs: [...breadcrumbs, n] });
              diff2.push(...childCompareResults.diff);
              Object.assign(map2, childCompareResults.map);
            } else {
              diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Target Not Found" });
            }
          });
          compareNode.sfsp__SalesNodes__r.forEach((n) => {
            diff2.push({ node: n, label: [...breadcrumbs, n].map(({ Name }) => Name).join(" -> "), reason: "Source Not Found" });
          });
          return { diff: diff2, map: map2 };
        },
        // queries
        async getRecordCount({ segmentId, dataSource, nodeMap }) {
          var _a;
          nodeMap = nodeMap || await Node2.buildNodeMap({ segmentId });
          const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[nodeId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = group results by all;
                results = foreach results generate count() as count;
            `.replace(/^ */gm, "") });
          return ((_a = aggregateResults == null ? void 0 : aggregateResults.records[0]) == null ? void 0 : _a.count) || 0;
        },
        async resetStampedDataSource(segmentId) {
          await SPM.Utils.CRM.upsert({ records: [{
            Id: segmentId,
            sfsp__StampDataSourceId__c: ""
          }] });
        },
        async buildDataSource({ planId }) {
          const [dataSource] = await SPM.Utils.Apex.invoke("Query", [`
                SELECT Id, Name, sfsp__SourceId__c, sfsp__ReferenceFields__c
                FROM sfsp__SalesDataSource__c
                WHERE Id IN (SELECT sfsp__SalesDataSource__c FROM sfsp__SalesPlan__c WHERE Id = '${planId}')
            `]);
          dataSource._referenceFields = JSON.parse(dataSource.sfsp__ReferenceFields__c);
          dataSource._dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: dataSource.sfsp__SourceId__c });
          return dataSource;
        },
        async getRecords({ segmentId, dataSource, nodeMap, uniqueIds = [], limit = 1, offset: offset2 }) {
          nodeMap = nodeMap || await this.buildNodeMap({ segmentId });
          if (uniqueIds.length > 0)
            limit = uniqueIds.length;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", {
            query: `
                    ${Node2.generateNodeFilterSaql({
              node: nodeMap[segmentId],
              nodeMap,
              dataSource,
              uniqueIds
            })}

                    -- results
                    results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                    ${offset2 ? `results = offset results ${offset2};` : ""}
                    results = limit results ${limit};
                `.replace(/^ */gm, "")
          });
          return results.records;
        }
      };
      const ExternalData = {
        async getNumericScaleData({ dataSource }) {
          const scaleData = /* @__PURE__ */ new Map();
          const metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataSource._dataset.currentVersionUrl });
          metadata.measures.forEach((m) => {
            scaleData.set(m.fullyQualifiedName, m.format.decimalDigits);
          });
          return scaleData;
        },
        generateCsvMetadata({ segmentId, dataSource, scaleDataMap, datasetName, datasetLabel }) {
          const fields = [];
          dataSource._referenceFields.forEach((f) => {
            const field = {
              fullyQualifiedName: f.id,
              name: f.id,
              label: f.label,
              isUniqueId: false,
              type: f.dataType,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.dataType === "Numeric") {
              field.precision = 18;
              field.scale = scaleDataMap.get(f.id) || 0;
              field.defaultValue = 0;
            }
            fields.push(field);
          });
          const csvMetadata = {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: "SegmentData",
                label: "Segment Data",
                name: "SegmentData",
                description: "",
                fields
              }
            ]
          };
          return csvMetadata;
        },
        async waitDataflowJobComplete({ jobId, retries = 5 }) {
          let waitInMilliseconds = 1e4;
          while (retries > 0) {
            const response = await SPM.Utils.Rest.invoke("GetCurrentDataflowJob", { id: jobId });
            if (!["Failure", "Warning", "Success"].includes(response.status)) {
              await SPM.Utils.Async.wait(waitInMilliseconds);
              waitInMilliseconds *= 2;
              retries--;
            } else if (["Success", "Warning"].includes(response.status)) {
              return true;
            } else if (["Failure"].includes(response.status)) {
              return false;
            }
          }
          return false;
        },
        async stampDataSource({ segmentId, dataSource, planName, planId, segmentName }) {
          var _a;
          const nodeMap = await Node2.buildNodeMap({ nodeId: segmentId });
          const scaleDataMap = await ExternalData.getNumericScaleData({ dataSource });
          const datasetName = planId + "_" + segmentId;
          const datasetLabel = (planName + " - " + segmentName).slice(0, 80);
          const csvMetadata = ExternalData.generateCsvMetadata({
            segmentId,
            dataSource,
            scaleDataMap
          });
          const crmafolder = await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id
                    FROM Folder
                    WHERE Type = 'Insights' AND Name = '${dataSource._dataset.folder.label}'
            `]);
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDatasetName: dataSource._dataset.name,
              stampDatasetName: datasetLabel,
              jobName: "Stamp Records"
            }
          });
          const stampJobStartTime = performance.now();
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: datasetName, label: datasetLabel, app: (_a = crmafolder[0]) == null ? void 0 : _a.Id, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const batchSize = 5e4;
          let batchNum = 0;
          let batchStats = [];
          let datasetRowMap = {};
          let csvParts = [];
          let recordBatches = [];
          let partNumber = 0;
          let offset2 = 0;
          let doMore = true;
          const uniqueIdField = dataSource._referenceFields.find((f) => f.isId).id;
          const saql = `
                ${Node2.generateNodeFilterSaql({
            node: nodeMap[segmentId],
            nodeMap,
            dataSource
          })}
    
                -- results
                results = foreach results generate ${dataSource._referenceFields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                results = order results by ${dataSource._referenceFields.find((f) => f.isId).id};
            `;
          while (doMore) {
            datasetRowMap = {};
            csvParts = [];
            const saqlBatch = saql + `
                results = offset results ${offset2};
                results = limit results ${batchSize};
                `;
            const downloadStartTime = performance.now();
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saqlBatch.replace(/^ */gm, "") });
            const downloadEndTime = performance.now();
            if (results.records.length === 0) {
              doMore = false;
              continue;
            }
            batchNum++;
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            const csv = Papa.unparse(recordBatches[0]);
            const chunkSize = 9e6;
            Papa.parse(csv, {
              chunkSize,
              chunk(results2, parser) {
                csvParts.unshift(Papa.unparse(results2.data));
              }
            });
            const uploadStartTime = performance.now();
            await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
              const base64String = Buffer2.from(`${data}\r
`).toString("base64");
              const csvPart = base64String;
              partNumber += 1;
              const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
              if (!partResponse.success)
                throw partResponse.errors[0] || "";
            }, 5);
            const uploadEndtime = performance.now();
            batchStats.push({
              numRows: results.records.length,
              downloadTime: downloadEndTime - downloadStartTime,
              uploadTime: uploadEndtime - uploadStartTime
            });
            offset2 += results.records.length;
          }
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
          SPM.Utils.Splunk.sendLog({
            logName: "spmStampingJob",
            logPayload: {
              planId,
              segmentId,
              origDataset: {
                id: dataSource._dataset.id,
                name: dataSource._dataset.name,
                numRows: dataSource._dataset.currentVersionTotalRowCount,
                numColumns: csvMetadata.objects[0].fields.length
              },
              stampDataset: {
                name: datasetLabel,
                numRows: offset2,
                numColumns: csvMetadata.objects[0].fields.length
              },
              jobRunTime: Math.round(performance.now() - stampJobStartTime),
              numBatches: batchNum,
              batchStats,
              crmaJobId: jobResponse.id,
              status: "SUCCESS"
            }
          });
          return { jobId: jobResponse.id, datasetLabel, numRecords: offset2, numFields: csvMetadata.objects[0].fields.length };
        },
        async fetchStampJobResults(jobId, datasetId, datasetLabel, segmentId) {
          const jobStatus = await ExternalData.waitDataflowJobComplete({ jobId });
          if (!jobStatus) {
            SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
            return;
          }
          if (datasetId) {
            const datasetResponse = await SPM.Utils.Rest.invoke("GetDataset", { id: datasetId });
            try {
              if (datasetResponse.label !== datasetLabel) {
                await SPM.Utils.Rest.invoke("PatchDataset", { id: datasetId, metadata: { label: datasetLabel } });
              }
            } catch (err) {
            }
          } else {
            const datasetsResponse = await SPM.Utils.Rest.invoke("GetDatasets", { alias: datasetLabel.replaceAll("'", "%5C%27") });
            if (!(datasetsResponse == null ? void 0 : datasetsResponse.length)) {
              SPM.$store.toast({ state: "error", message: `${errorToastMessage}`, duration: null });
              return;
            }
            const dataset = datasetsResponse[0];
            await SPM.Utils.CRM.upsert({ records: [{
              Id: segmentId,
              sfsp__StampDataSourceId__c: dataset.id
            }] });
          }
        }
      };
      const TPDataSet = {
        async fetchRelatedDataSets() {
          let dataSets = [];
          const externalAssets = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__AssetType__c, sfsp__AssetId__c FROM sfsp__SalesNodeExternalAsset__c WHERE sfsp__SalesNode__c = '${SPM.$store.segment.Id}'`]);
          try {
            dataSets = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        Name,
                        maps__Config__c,
                        (SELECT Id, Name, CreatedById, CreatedBy.Name, CreatedDate FROM maps__Alignments__r WHERE maps__Status__c != 'Deleted')
                    FROM maps__TPDataSet__c
                    WHERE Id IN ('${externalAssets.filter((a) => a.sfsp__AssetType__c === "Territory Plan").map((a) => a.sfsp__AssetId__c).join("','")}') AND maps__Status__c != 'Deleted'
                `]);
          } catch (err) {
          }
          const matchingDataSets = dataSets.filter((ds) => {
            return JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id);
          });
          SPM.$store.$patch((state) => state.TPDataSets = matchingDataSets);
          return matchingDataSets || [];
        },
        async fetchRelatedAlignments() {
          const alignments = [];
          const dataSets = await TPDataSet.fetchRelatedDataSets();
          dataSets.forEach((ds) => {
            if ((ds == null ? void 0 : ds.maps__Alignments__r) && JSON.parse(ds.maps__Config__c).dataSources.find((s) => s.type === "Segment Data Source" && s.segmentId === SPM.$store.segment.Id))
              alignments.push(...ds == null ? void 0 : ds.maps__Alignments__r);
          });
          SPM.$store.$patch((state) => state.TPAlignments = alignments);
          return alignments;
        }
      };
      const TerritoryStampUtils = {
        parsedStampDetails(stampDetails, referenceFields) {
          return stampDetails.map((detail) => {
            const hierarchyData = JSON.parse(detail.sfsp__HierarchyReferenceData__c);
            const parsedData = {};
            Object.keys(hierarchyData).forEach((key) => {
              const referenceMetadata = referenceFields.find((f) => f.type === "Territory" && f.id === key);
              parsedData[key] = "";
              if (referenceMetadata.dataType === "Number") {
                parsedData[key] = hierarchyData[key].SUM;
              } else if (referenceMetadata.dataType === "String") {
                parsedData[key] = hierarchyData[key].VALUE;
              }
            });
            const labeledData = referenceFields.reduce((acc, field) => {
              const keyValue = parsedData[field.id];
              if (keyValue === void 0) {
                if (field.dataType === "Number") {
                  acc[field.label] = 0;
                } else {
                  acc[field.label] = "";
                }
              } else {
                acc[field.label] = keyValue;
              }
              return acc;
            }, {});
            return {
              ...detail,
              data: labeledData
            };
          });
        },
        hierarchicalStampDetails(parsedStampDetails) {
          const detailsMap = /* @__PURE__ */ new Map();
          parsedStampDetails.forEach((detail) => {
            detail.children = [];
            detailsMap.set(detail.Id, detail);
          });
          const rootDetails = [];
          detailsMap.forEach((detail) => {
            if (detail.sfsp__Parent__c) {
              const parentDetail = detailsMap.get(detail.sfsp__Parent__c);
              if (parentDetail) {
                parentDetail.children.push(detail);
              }
            } else {
              rootDetails.push(detail);
            }
          });
          const result = [];
          const traverse2 = (details, indent) => {
            details.forEach((detail) => {
              detail.indent = indent;
              result.push(detail);
              traverse2(detail.children, indent + 1);
            });
          };
          traverse2(rootDetails, 0);
          return result;
        }
      };
      return {
        Rule,
        Filter,
        Node: Node2,
        ExternalData,
        TPDataSet,
        TerritoryStampUtils
      };
    }
    const deconstructFQAPIName = (field = []) => {
      const parts = field.split(".");
      return {
        field: parts[parts.length - 1],
        lookups: parts.splice(0, parts.length - 1)
      };
    };
    const getValueFromRecord = (fullyQualifiedApiName, record = {}) => {
      const { field, lookups = [] } = deconstructFQAPIName(fullyQualifiedApiName);
      const obj = lookups.reduce((r, l) => r == null ? void 0 : r[l], record);
      return obj == null ? void 0 : obj[field];
    };
    function UtilsClient({ Buffer: Buffer2, Papa, randomLocation } = {}) {
      const Apex = {
        async invoke(action, params = [], { cls = "SPMRemoteActions" } = {}) {
          const startTime = window.performance.now();
          const promise = new Promise((resolve2) => {
            const args = [
              `sfsp.${cls}.${action}`,
              ...params,
              (data, event) => resolve2({ data, event })
            ];
            Visualforce.remoting.Manager.invokeAction(...args, { buffer: false, escape: false, timeout: 12e4 });
          });
          const result = await promise;
          if (!result.event.status) {
            throw {
              type: "RemoteActionException",
              error: result.event
            };
          } else {
            if (action === "Query") {
              SPM.Utils.Splunk.sendLog({
                logName: "spmAPEX",
                logPayload: {
                  query: params[0],
                  returnCount: result.data.length,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
            return result.data;
          }
        }
      };
      const Rest = {
        async invoke() {
          const [method, params = {}] = arguments;
          const headers = { Authorization: `Bearer ${SPM.SessionId}` };
          const promise = new SPM.Utils.DeferredPromise();
          const response = await this.Actions[method](headers, params);
          promise.resolve(response);
          if (SPM.Utils.Debug) {
            promise.then((r) => {
              console.groupCollapsed(method);
              [params, r].forEach((obj) => console.log(obj));
              console.groupEnd();
            }).catch((err) => {
              console.groupCollapsed(method);
              [params, err].forEach((obj) => console.log(obj));
              console.groupEnd();
            });
          }
          return promise;
        },
        Actions: {
          async Query(headers, { query }) {
            const startTime = window.performance.now();
            const records = [];
            let { data: results } = await axios({
              method: "GET",
              url: "/services/data/v53.0/query",
              params: {
                q: query
              },
              headers
            });
            records.push(...results.records);
            while (results.nextRecordsUrl) {
              results = (await axios({ method: "GET", url: results.nextRecordsUrl, headers })).data;
              records.push(...results.records);
            }
            records.forEach((r) => {
              Object.keys(r).forEach((key) => {
                var _a;
                if ((_a = r[key]) == null ? void 0 : _a.records) {
                  r[key] = r[key].records;
                }
              });
            });
            SPM.Utils.Splunk.sendLog({
              logName: "spmREST",
              logPayload: {
                query,
                returnCount: records.length,
                executionTime: window.performance.now() - startTime
              }
            });
            return records;
          },
          async Insert(headers, { records }) {
            if (records.length === 0)
              return [];
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v53.0/composite/sobjects",
              data: {
                allOrNone: true,
                records
              },
              headers
            });
            return results;
          },
          async Delete(headers, { ids }) {
            const batches = [];
            while (ids.length)
              batches.push(ids.splice(0, 1e3));
            await Async.forEachParallel(batches, async (batch) => {
              await axios({
                method: "DELETE",
                url: "/services/data/v53.0/composite/sobjects",
                params: {
                  ids: batch.join(",")
                },
                headers
              });
            }, 5);
          },
          async tpRest(headers, { action, data }) {
            const { data: results } = await axios({
              method: "POST",
              url: `/services/apexrest/maps/TPRest/${action}`,
              data,
              headers
            });
            return results.data;
          },
          async ToolingQuery(headers, query) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/tooling/query/?q=${query}`,
              headers
            });
            return results;
          },
          async ToolingSObject(headers, { sObject }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/tooling/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async ToolingSObjectPatch(headers, { url, metadata }) {
            const { data: results } = await axios({
              method: "PATCH",
              url,
              data: metadata,
              headers
            });
            return results;
          },
          async SObjects(headers) {
            const { data: results } = await axios({
              method: "GET",
              url: "/services/data/v53.0/sobjects",
              headers
            });
            return results;
          },
          async SObject(headers, { sObject }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/sobjects/${sObject}/describe`,
              headers
            });
            return results;
          },
          async RunSaql(headers, { query }) {
            var _a, _b;
            const startTime = window.performance.now();
            let res;
            try {
              const { data: results } = await axios({
                method: "POST",
                url: "/services/data/v53.0/wave/query",
                data: {
                  query
                },
                headers
              });
              res = results;
              return results;
            } catch (e) {
              SPM.$store.toast({ message: e.response.data[0].message, duration: 5e3, state: "error" });
              return { records: [] };
            } finally {
              SPM.Utils.Splunk.sendLog({
                logName: "spmSAQL",
                logPayload: {
                  query,
                  returnCount: ((_b = (_a = res == null ? void 0 : res.results) == null ? void 0 : _a.records) == null ? void 0 : _b.length) || 0,
                  executionTime: window.performance.now() - startTime
                }
              });
            }
          },
          async GetDataflows(headers, { alias }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflows?hasCurrentOnly&q=${alias}`,
              headers
            });
            return results.dataflows || [];
          },
          async UpdateDataflow(headers, { dataflowId, definition }) {
            const { data: results } = await axios({
              method: "PATCH",
              url: `/services/data/v50.0/wave/dataflows/${dataflowId}`,
              data: {
                definition
              },
              headers
            });
            return results;
          },
          async RunDataflow(headers, { dataflowId }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v53.0/wave/dataflowjobs",
              data: {
                dataflowId,
                command: "Start"
              },
              headers
            });
            return results;
          },
          async GetDatasets(headers, { alias, hasCurrentOnly = true }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets?hasCurrentOnly=${hasCurrentOnly}&q=${alias}&filterGroup=Supplemental`,
              headers
            });
            return results.datasets || [];
          },
          async GetDataset(headers, { id: id2 }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/datasets/${id2}?t=${Date.now()}`,
              headers
            });
            return results;
          },
          async PatchDataset(headers, { id: id2, metadata }) {
            await axios({
              method: "PATCH",
              url: `/services/data/v53.0/wave/datasets/${id2}`,
              data: metadata,
              headers
            });
          },
          async GetDatasetMetadata(headers, { url }) {
            const { data: results } = await axios({
              method: "GET",
              url: `${url}/xmds/main`,
              headers
            });
            return results;
          },
          async GetCurrentDataflowJob(headers, { id: id2 }) {
            const { data: results } = await axios({
              method: "GET",
              url: `/services/data/v53.0/wave/dataflowjobs/`,
              headers
            });
            results.dataflowJobs.filter((f) => f.label.includes(id2));
            results.dataflowJobs.sort((a, b) => new Date(b.createdDate) - new Date(a.createdDate));
            return results.dataflowJobs[0];
          },
          async CreateExternalDataJob(headers, { metadata, alias, label, app, operation }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalData",
              data: {
                Format: "Csv",
                LicenseType: SPM.isScratch ? "EinsteinAnalytics" : "Sonic",
                EdgemartAlias: alias,
                EdgemartLabel: label || alias,
                EdgemartContainer: app || "",
                Operation: operation,
                Action: "None",
                NotificationSent: "Always",
                MetadataJson: metadata
              },
              headers
            });
            return results;
          },
          async UploadCsvPart(headers, { parentId, csvPart, partNumber }) {
            const { data: results } = await axios({
              method: "POST",
              url: "/services/data/v56.0/sobjects/InsightsExternalDataPart",
              data: {
                DataFile: csvPart,
                InsightsExternalDataId: parentId,
                PartNumber: partNumber
              },
              headers
            });
            return results;
          },
          async StartExternalDataJob(headers, { parentId }) {
            const { data: results } = await axios({
              method: "PATCH",
              url: `/services/data/v56.0/sobjects/InsightsExternalData/${parentId}`,
              data: {
                Action: "Process"
              },
              headers
            });
            return results;
          },
          async UploadAutoAssignmentData(headers, { scus, mapping }) {
            const uploadResponse = await Apex.invoke("GetAutoAssignmentUploadUrl", []);
            const data = {
              records: scus,
              mapping: mapping || {
                "Unique Id": "Id",
                "Assignment": "Assignment",
                "Boundaries": "Boundaries",
                "Locked": "Locked",
                "Latitude": "Latitude",
                "Longitude": "Longitude",
                "Weight": "Weight",
                "Volume": "Volume"
              }
            };
            await axios({
              method: "PUT",
              url: uploadResponse.externalDataUrl,
              headers: { "Content-Type": "application/json" },
              data
            });
            return uploadResponse.requestId;
          },
          async MoveDatasetToSharedFolder(headers, { datasetId }) {
            let response = await Apex.invoke("MoveDatasetToSharedFolder", [datasetId]);
            if (!response.success) {
              const folder = await Apex.invoke("Query", [`SELECT Id FROM Folder where Type = 'Insights' AND DeveloperName = 'Sales_Planning'`]);
              const data = {
                folder: { id: folder[0].Id }
              };
              ({ data: response } = await axios({
                method: "PATCH",
                url: `/services/data/v56.0/wave/datasets/${datasetId}`,
                headers,
                data
              }));
            }
            return response;
          }
        }
      };
      const HTTP = {
        async get({ url }) {
          const results = await axios({
            method: "GET",
            url
          });
          return results;
        }
      };
      const CRM = {
        MasterDetailRelationships: {
          sfsp__SalesNodeRuleItem__c: {
            sfsp__SalesNodeRule__c: true
          }
        },
        upsert: async ({ records, onProgress = () => {
        } }) => {
          const recordsToInsert = [];
          const recordsToUpdate = [];
          records.forEach((r) => (r.Id ? recordsToUpdate : recordsToInsert).push(r));
          const batches = [];
          while (recordsToInsert.length)
            batches.push({ type: "InsertSObjects", records: recordsToInsert.splice(0, 1e3) });
          while (recordsToUpdate.length)
            batches.push({ type: "UpdateSObjects", records: recordsToUpdate.splice(0, 1e3) });
          let recordsUpserted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            const primitiveRecords = batch.records.map((r) => {
              return Object.keys(r).reduce((obj, key) => {
                var _a, _b;
                const isPrivate = key.startsWith("_");
                const isTypeWithId = key === "sobjectType" && r.Id;
                const isChildRecords = key.endsWith("__r");
                const isUpdateMaster = batch.type === "UpdateSObjects" && ((_b = (_a = CRM.MasterDetailRelationships) == null ? void 0 : _a[r.sobjectType]) == null ? void 0 : _b[key]);
                const isReserved = ["CreatedBy", "CreatedById", "CreatedDate"].includes(key);
                if (!isPrivate && !isTypeWithId && !isChildRecords && !isUpdateMaster && !isReserved)
                  obj[key] = r[key];
                return obj;
              }, {});
            });
            const response = await Apex.invoke(batch.type, [primitiveRecords, true]);
            if (batch.type === "InsertSObjects") {
              response.forEach((r, i) => batch.records[i].Id = r.Id);
            }
            recordsUpserted += batch.records.length;
            onProgress(Math.floor(100 * recordsUpserted / records.length));
          }, 5);
        },
        delete: async ({ records, onProgress = () => {
        } }) => {
          const recordIdsToDelete = records.map((r) => r.Id).sort();
          const batches = [];
          while (recordIdsToDelete.length)
            batches.push(recordIdsToDelete.splice(0, 1e3));
          let recordsDeleted = 0;
          await Async.forEachParallel(batches, async (batch) => {
            await Apex.invoke("DeleteIds", [batch, true]);
            recordsDeleted += batch.length;
            onProgress(Math.floor(100 * recordsDeleted / records.length));
          }, 5);
        }
      };
      const CRMA = {
        async checkDatasets(assignmentObject, options, callback = () => {
        }) {
          var _a, _b, _c;
          const toasts = [];
          const updateDatasets = async ({ recordsDataset, assignmentsDataset }) => {
            let canShare = true;
            await SPM.Utils.Async.forEachParallel([recordsDataset, assignmentsDataset], async (dataset) => {
              if (dataset.folder.name !== "Sales_Planning") {
                try {
                  const response = await SPM.Utils.Rest.invoke("MoveDatasetToSharedFolder", { datasetId: dataset.id });
                  if (response.folder)
                    dataset.folder = { name: "Sales_Planning" };
                } catch (err) {
                  canShare = false;
                }
              }
            });
            if (!canShare) {
              toasts.push({ showOnce: true, state: "warning", message: "This plan cannot be shared. Please see your admin about adding a Sales Planning app if you need to share with others." });
            }
            recordsDataset.dataflowStatus = "";
            assignmentsDataset.dataflowStatus = "";
            Object.assign(storeAssignment, { recordsDataset, assignmentsDataset, totalCount: recordsDataset.currentVersionTotalRowCount, assignmentCount: storeAssignment.assignmentCount || 0 });
            if (assignmentAsyncJob)
              Object.assign(assignmentAsyncJob, { status: "Success" });
            storeAssignment.asyncJob.status = "Success";
            callback();
          };
          const checkDataflowJobs = async (assignmentObject2, retries = 5) => {
            const { dataflowJobs } = await SPM.Utils.Apex.invoke("GetDataflowJobs", [SPM.$store.plan.Id, assignmentObject2.id]);
            const assignmentsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Assignments`);
            });
            const recordsJob = dataflowJobs.find((df) => {
              var _a2;
              return (_a2 = df == null ? void 0 : df.label) == null ? void 0 : _a2.startsWith(`${SPM.$store.plan.Id}_${assignmentObject2.id}_Records`);
            });
            if (!recordsJob || !assignmentsJob) {
              const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
              if (datasetResponse2) {
                await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                return 0;
              }
              await Async.wait(1e4);
              return retries;
            } else {
              assignmentObject2.recordsDataset.dataflowStatus = recordsJob.status;
              assignmentObject2.assignmentsDataset.dataflowStatus = assignmentsJob.status;
              if (!["Failure", "Warning", "Success"].includes(recordsJob.status) || !["Failure", "Warning", "Success"].includes(assignmentsJob.status)) {
                await Async.wait(1e4);
                return retries;
              } else if (["Success", "Warning"].includes(recordsJob.status) && ["Success", "Warning"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2) {
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                  if (["create", "update"].includes(options == null ? void 0 : options.type)) {
                    toasts.push(
                      recordsJob.status === "Warning" ? { message: `Assignment Object "${assignmentObject2.label}" was created with some warnings.`, duration: null, state: "warning", subMessage: `${SPM.orgDomainUrl}/analytics/dataManager` } : { message: `Assignment Object "${assignmentObject2.label}" was ${(options == null ? void 0 : options.type) === "create" ? "created" : "updated"}.`, duration: 3e3, state: "success" }
                    );
                    if (assignmentObject2.asyncJob.type === "Refresh Assignment Object")
                      await SPM.Utils.AssignmentObject.updateReferenceFields({ assignmentObject: assignmentObject2 });
                  }
                  return 0;
                }
                if (retries - 1 === 1) {
                  try {
                    await Promise.allSettled([
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                      SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
                    ]);
                  } catch (err) {
                  }
                }
                await Async.wait(1e4);
                return retries - 1;
              } else if (["Failure"].includes(recordsJob.status) || ["Failure"].includes(assignmentsJob.status)) {
                const datasetResponse2 = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject2.id, planId: SPM.$store.plan.Id });
                if (datasetResponse2)
                  await updateDatasets({ recordsDataset: datasetResponse2.recordsDataset, assignmentsDataset: datasetResponse2.assignmentsDataset });
                toasts.push({ message: `Assignment Object "${assignmentObject2.label}" dataflow had a failure ${(options == null ? void 0 : options.type) === "create" ? "creating" : options.type === "update" ? "updating" : "loading"}.`, duration: null, state: "error", subMessage: `Records: ${recordsJob.message}, Assignments: ${assignmentsJob.message}` });
                return 0;
              }
            }
          };
          const checkAsyncJobs = async (assignmentObject2) => {
            const latestJob = (await SPM.Utils.AssignmentObject.getSalesAsyncJobs({ objectId: assignmentObject2.id, statusFilter: ["Queued", "Running", "Waiting", "Failure"] }))[0] || false;
            if (!latestJob)
              return;
            SPM.$store.$patch((state) => {
              const storeSalesAsyncJob = SPM.$store.salesAsyncJobs.find((job) => job.Id === latestJob.Id);
              if (storeSalesAsyncJob)
                Object.assign(storeSalesAsyncJob, latestJob);
              const storeAssignmentObject = state.assignmentObjects.find((a) => a.id === assignmentObject2.id);
              if (storeAssignmentObject.recordsDataset && latestJob.sfsp__Status__c === "Waiting") {
                CRM.upsert({ records: [{ Id: latestJob.Id, sfsp__Status__c: "Success" }] });
                latestJob.sfsp__Status__c = "Success";
              }
              Object.assign(storeAssignmentObject.asyncJob, { id: latestJob.Id, type: latestJob.sfsp__Type__c, status: latestJob.sfsp__Status__c, details: latestJob.sfsp__Details__c });
              state.hasChanged = true;
            });
            if (!["Success", "Warning"].includes(latestJob.sfsp__Status__c)) {
              if (["Failure"].includes(latestJob.sfsp__Status__c)) {
                return latestJob;
              } else {
                await Async.wait(5e3);
                return await checkAsyncJobs(assignmentObject2);
              }
            }
          };
          const assignmentAsyncJob = SPM.$store.salesAsyncJobs.find((s) => s.sfsp__SalesAssignmentObject__c === assignmentObject.Id);
          const storeAssignment = SPM.$store.assignmentObjects.find((a) => a.id === assignmentObject.Id);
          if (!storeAssignment) {
            const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
            if (asyncJobIndex > -1)
              SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            if (options.type === "delete") {
              callback();
              toasts.push({ message: `Assignment Object "${options.assignmentObject.sfsp__Label__c}" was deleted.`, duration: 3e3, state: "success" });
            }
            return;
          }
          let datasetResponse = null;
          try {
            datasetResponse = await SPM.Utils.AssignmentObject.loadDatasets({ assignmentObjectId: assignmentObject.Id, planId: SPM.$store.plan.Id });
          } catch (err) {
            const errorCode = ((_a = err.response) == null ? void 0 : _a.data[0].errorCode) || null;
            if (errorCode === "FUNCTIONALITY_NOT_ENABLED")
              toasts.push({ showOnce: true, state: "warning", message: "Some features may not work properly. Please contact your admin to ensure you are properly licensed.", duration: null });
          }
          if (datasetResponse)
            await updateDatasets({ recordsDataset: datasetResponse.recordsDataset, assignmentsDataset: datasetResponse.assignmentsDataset });
          if (assignmentAsyncJob) {
            const failedJob = await checkAsyncJobs(storeAssignment);
            if (!failedJob) {
              let retries = await checkDataflowJobs(storeAssignment, 5);
              while (retries !== 0) {
                retries = await checkDataflowJobs(storeAssignment, retries);
                await Async.wait(2e3);
              }
            } else {
              SPM.$store.toast({ message: `Can’t ${options.type === "create" ? "create" : "update"} the ${options.assignmentObject.sfsp__Label__c} assignment object. Try again or contact Salesforce Customer Support.`, duration: null, state: "error" });
            }
            if (failedJob || ["Warning", "Success"].includes(storeAssignment.asyncJob.status)) {
              if (assignmentAsyncJob.sfsp__Splunk__c)
                SPM.Utils.Splunk.sendLog(JSON.parse(assignmentAsyncJob.sfsp__Splunk__c));
              try {
                await SPM.Utils.CRM.delete({ records: [{ Id: assignmentAsyncJob.Id }] });
              } catch (err) {
              }
              const asyncJobIndex = SPM.$store.salesAsyncJobs.findIndex((j) => j.Id === assignmentAsyncJob.Id);
              if (asyncJobIndex > -1)
                SPM.$store.salesAsyncJobs.splice(asyncJobIndex, 1);
            }
          }
          if (!((_b = storeAssignment == null ? void 0 : storeAssignment.recordsDataset) == null ? void 0 : _b.dimensions) || !((_c = storeAssignment == null ? void 0 : storeAssignment.assignmentsDataset) == null ? void 0 : _c.dimensions)) {
            try {
              const settle2 = await Promise.allSettled([
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Records`]),
                SPM.Utils.Apex.invoke("MoveDatasetToSharedFolderByAlias", [`${SPM.$store.plan.Id}_${storeAssignment.id}_Assignments`])
              ]);
              await checkDataflowJobs(storeAssignment, 1);
              if (settle2.some((s) => s.status === "rejected")) {
                toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
              }
            } catch (err) {
              toasts.push({ state: "error", message: `Unable to load ${storeAssignment.label}. Please contact your admin to ensure Sales Planning is properly configured.`, duration: null });
            }
          }
          toasts.forEach((toast) => {
            if (SPM.$store.showOnLoadToasts || !toast.showOnce)
              SPM.$store.toast(toast);
          });
          SPM.$store.showOnLoadToasts = false;
          return;
        }
      };
      const Async = {
        forEach: async (array2, callback) => {
          for (let i = 0; i < array2.length; i++) {
            await callback(array2[i], i, array2);
          }
        },
        forEachParallel: (array2, callback, threads) => {
          array2 = array2.map((item) => item);
          return Promise.all(
            threads ? Array(threads).fill().map(() => (async () => {
              for (let item; item = array2.shift(); )
                await callback(item);
            })()) : array2.map((item, index) => (async () => callback(item, index, array2))())
          );
        },
        forEachBulk: async (array2, callback, blockCount) => {
          let blockStart = 0;
          while (blockStart < array2.length) {
            const blockEnd = Math.min(blockStart + blockCount, array2.length);
            for (let i = blockStart; i < blockEnd; i++) {
              callback(array2[i]);
            }
            blockStart += blockCount;
            await Async.wait(1);
          }
        },
        wrapper: (callback) => (resolveAsync, rejectAsync) => {
          callback().then(resolveAsync).catch((err) => rejectAsync(err));
        },
        wait(milliseconds2, callback = async () => {
        }) {
          return new Promise((resolve2, reject) => setTimeout(() => {
            callback().then((val) => resolve2(val)).catch(reject);
          }, milliseconds2));
        }
      };
      const Store = {
        on(store, event, callback) {
          store.$onAction(async ({ name: name2, args, after }) => {
            if (name2 === "emit" && args[0] === event)
              after(callback);
          });
        }
      };
      const Obj = {
        get(obj = {}, path, def2 = "") {
          const fullPath = path.replace(/\[/g, ".").replace(/]/g, "").split(".").filter(Boolean);
          return fullPath.every((part) => {
            obj = obj[part];
            return obj !== null && obj !== void 0;
          }) ? obj : def2;
        },
        compare(a, b, criteria) {
          const aVal = a[criteria];
          const bVal = b[criteria];
          if (aVal > bVal)
            return 1;
          if (aVal < bVal)
            return -1;
          return 0;
        },
        shallowCompare(a, b) {
          return Object.keys(a).length === Object.keys(b).length && Object.keys(a).every((key) => b.hasOwnProperty(key) && a[key] === b[key]);
        }
      };
      const Arr = {
        move(arr, from2, to2) {
          arr.splice(to2, 0, arr.splice(from2, 1)[0]);
        },
        splice(arr, fn) {
          if (arr.length === 0)
            return [];
          const spliced = [];
          arr.length - 1;
          for (let i2 = arr.length - 1; i2 >= 0; i2--) {
            if (fn(arr[i2]))
              spliced.push(arr.splice(i2, 1)[0]);
          }
          return spliced;
        }
      };
      const Tree2 = {
        inspect({ node, nodeCount = 1, depth = 1 }) {
          var _a;
          let maxDepth = depth;
          (_a = node == null ? void 0 : node.children) == null ? void 0 : _a.forEach((child) => {
            const childDetails = this.inspect({ node: child, depth: depth + 1 });
            nodeCount += childDetails.nodeCount;
            maxDepth = Math.max(maxDepth, childDetails.maxDepth);
          });
          return { nodeCount, maxDepth };
        }
      };
      const Rule = {
        RuleItem: {
          ETMOperators: {
            equals: "==",
            notEqual: "!=",
            lessThan: "<",
            lessOrEqual: "<=",
            greaterThan: ">",
            greaterOrEqual: ">=",
            contains: "like",
            notContain: "doesnotcontain",
            startsWith: "startsWith"
          },
          fromFilter(filter2) {
            const isMeasure = typeof filter2.value === "object";
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter2.key,
              sfsp__Operator__c: isMeasure ? "between" : "==",
              sfsp__Value__c: isMeasure ? `${filter2.value.from},${filter2.value.to}` : filter2.value
            };
          },
          fromRecordFilter(filter2) {
            return {
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filter2.field,
              sfsp__Operator__c: filter2.operator,
              sfsp__Value__c: filter2.value
            };
          }
        },
        fromFilterSet(filterSet, assignmentObjectId, startItemIndex = 1) {
          const booleanFilterParts = [];
          const ruleItems = [];
          const ancestorFilters = filterSet[0].slice(0, filterSet[0].length - 1);
          const filters = filterSet.map((fs) => fs.slice(-1)[0]);
          if (ancestorFilters.length) {
            booleanFilterParts.push(ancestorFilters.map((f, index) => startItemIndex + index + ruleItems.length).join(" and "));
            ruleItems.push(...ancestorFilters.map((f) => Rule.RuleItem.fromFilter(f)));
          }
          const isMeasure = typeof filters[0].value === "object";
          if (isMeasure) {
            const indices = filters.map((f, index) => startItemIndex + index + ruleItems.length);
            booleanFilterParts.push(`(${indices.join(" or ")})`);
            ruleItems.push(...filters.map((f) => SPM.Utils.Rule.RuleItem.fromFilter(f)));
          } else {
            booleanFilterParts.push(String(startItemIndex + ruleItems.length));
            ruleItems.push({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: filters[0].key,
              sfsp__Operator__c: "==",
              sfsp__Value__c: filters.map((f) => f.value).join(",")
            });
          }
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            sfsp__BooleanFilter__c: booleanFilterParts.join(" and "),
            sfsp__SalesNodeRuleItems__r: ruleItems.map((ruleItem, i) => ({
              ...ruleItem,
              sfsp__SortOrder__c: i + 1
            }))
          };
        },
        fromBoundaries({ boundaries, boundaryObject }) {
          const containerSet = SPM.$store.containerSets[boundaryObject.containerSetId];
          let availableContainers = containerSet.containers;
          if (!boundaryObject.includesPoints) {
            availableContainers = Object.keys(availableContainers).filter((key) => !availableContainers[key].parent).reduce((res, key) => (res[key] = availableContainers[key], res), {});
          }
          const ruleItemOperator = "startsWith";
          boundaries = SPM.Utils.Rule.simplifyValues(Object.values(availableContainers).map((c) => c.name), boundaries);
          const ruleItemValues = [];
          let currentValue = "";
          boundaries.forEach((boundary) => {
            if (currentValue.length + boundary.length + 1 >= 1e3) {
              ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
              currentValue = "";
            }
            currentValue += `${boundary},`;
          });
          if (currentValue)
            ruleItemValues.push(currentValue.slice(0, currentValue.length - 1));
          return {
            sobjectType: "sfsp__SalesNodeRule__c",
            Name: containerSet.label,
            sfsp__SalesNodeBoundary__c: boundaryObject.id,
            sfsp__SortOrder__c: 1,
            sfsp__FilterLogic__c: "any",
            sfsp__BooleanFilter__c: Array(ruleItemValues.length).fill().map((v, i) => i + 1).join(" or "),
            sfsp__SalesNodeRuleItems__r: ruleItemValues.map((value, i) => ({
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              sfsp__Field__c: boundaryObject.name,
              sfsp__Operator__c: ruleItemOperator,
              sfsp__Value__c: value,
              sfsp__SortOrder__c: i + 1
            }))
          };
        },
        toString(rule) {
          const expressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => `${item.sfsp__Field__c} ${item.sfsp__Operator__c} ${JSON.stringify(item.sfsp__Value__c)}`);
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, expressions);
        },
        toSaql(rule, assignmentObject) {
          const saqlExpressions = rule.sfsp__SalesNodeRuleItems__r.map((item) => {
            return Filter.toSaql({
              field: item.sfsp__Field__c,
              operator: item.sfsp__Operator__c,
              value: item.sfsp__Value__c,
              dataType: rule.sfsp__SalesNodeBoundary__c ? "Text" : assignmentObject.referenceFields.find((f) => f.id === item.sfsp__Field__c).type
            });
          });
          return Filter.mergeBooleanFilter(rule.sfsp__BooleanFilter__c, saqlExpressions);
        },
        simplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const selectedTrie = new Trie$1.Trie();
          selectedValues.forEach((v) => selectedTrie.add(v));
          const simplifiedValues = /* @__PURE__ */ new Set();
          selectedValues.forEach((value) => {
            for (let i = 1; i <= value.length; i++) {
              const matchString = value.slice(0, i);
              if (selectedTrie.countChildren(matchString) === allTrie.countChildren(matchString)) {
                simplifiedValues.add(matchString);
                break;
              }
            }
          });
          return [...simplifiedValues];
        },
        unsimplifyValues(allValues, selectedValues) {
          const allTrie = new Trie$1.Trie();
          allValues.forEach((v) => allTrie.add(v));
          const unsimplifiedValues = selectedValues.map((v) => allTrie.prefixMatchingWords(v)).flat();
          return unsimplifiedValues;
        },
        validateCustomLogic(expression, numCriteria) {
          if (!expression || numCriteria == 0) {
            return false;
          }
          var numCritArr = [];
          for (let i = 1; i <= numCriteria; i++) {
            numCritArr.push(i.toString());
          }
          const pattern = /\d+/g;
          const values = expression.match(pattern);
          if (values) {
            for (let i = 0; i < values.length; i++) {
              if (values[i] < 1 || values[i] > numCriteria) {
                return false;
              }
              let position = numCritArr.indexOf(values[i]);
              if (position >= 0)
                numCritArr.splice(position, 1);
            }
          }
          if (numCritArr.length !== 0) {
            return false;
          }
          return this.validateBooleanExpr(expression);
        },
        validateBooleanExpr(expression) {
          let expressionLC = expression.toLowerCase();
          const pattern = /\(\d+\)|\d+ (?:and|or|\|\||\&\&) \d+|\d+/g;
          while (true) {
            const replaced = expressionLC.replace(pattern, "1");
            if (replaced == "1")
              return true;
            if (replaced == expressionLC)
              return false;
            expressionLC = replaced;
          }
        }
      };
      const Filter = {
        toSaql(filter2) {
          const { field, operator, value = "", dataType } = filter2;
          if (dataType === "Text") {
            let values = value.split(",");
            values = values.map((v) => v.trimStart());
            switch (operator) {
              case "==":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} in ["${values.join('","')}"] || ${field} is null)` : `${field} in ["${values.join('","')}"]` : value ? `${field} == "${value}"` : `(${field} == "" || ${field} is null)`;
              case "!=":
                return values.length > 1 ? values.some((v) => !v) ? `(${field} not in ["${values.join('","')}"] || ${field} is null)` : `${field} not in ["${values.join('","')}"]` : value ? `(${field} != "${value}" || ${field} is null)` : `(${field} != "" || ${field} is not null)`;
              case "like":
                return values.length > 1 ? `(${values.map((v) => `${field} like "%${v}%"`).join(" || ")})` : `${field} like "%${value}%"`;
              case "startsWith":
                return values.length > 1 ? `(${values.map((v) => `${field} like "${v}%"`).join(" || ")})` : `${field} like "${value}%"`;
              default:
                return `${field} ${operator} "${value}"`;
            }
          } else {
            switch (operator) {
              case "between":
                const [from2, to2] = value.split(",");
                return `(${field} >= ${from2} && ${field} <= ${to2})`;
              default:
                return `${field} ${operator} ${value}`;
            }
          }
        },
        evaluate({ filters, filterLogic, record }) {
          if (filters.length === 0)
            return true;
          const expressions = filters.map((filter2) => {
            const { field, operator, value = "", dataType } = filter2;
            const values = operator === "between" ? [value] : value.split(",");
            const recordValue = record[field];
            const recordValueLower = (recordValue || "").toString().toLowerCase();
            return values.some((v) => {
              switch (operator) {
                case "==":
                  return recordValue == v;
                case "!=":
                  return recordValue != v;
                case "like":
                  return recordValueLower.includes(v.toLowerCase());
                case "startsWith":
                  return recordValueLower.startsWith(v.toLowerCase());
                case "between":
                  const [from2, to2] = v.split(",");
                  return recordValue >= from2 && recordValue <= to2;
                case "<":
                  return recordValue < v;
                case "<=":
                  return recordValue <= v;
                case ">":
                  return recordValue > v;
                case ">=":
                  return recordValue >= v;
                default:
                  return false;
              }
            });
          });
          const mergedExpressions = Filter.mergeBooleanFilter(filterLogic, expressions);
          return Function(`"use strict";return (${mergedExpressions})`)();
        },
        mergeBooleanFilter(booleanFilter, expressions) {
          booleanFilter = booleanFilter.toLowerCase().replaceAll(" and ", " && ").replaceAll(" or ", " || ");
          let result = "";
          let currentToken = "";
          for (let i = 0; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken) {
              result += expressions[parseInt(currentToken) - 1];
              currentToken = "";
            }
            result += char;
          }
          if (currentToken)
            result += expressions[parseInt(currentToken) - 1];
          return result;
        },
        removeBooleanFilterExpression(booleanFilter, expressionIndex, startIndex = 0) {
          booleanFilter = booleanFilter.toLowerCase();
          expressionIndex = String(expressionIndex);
          let currentToken = "";
          let matchingIndex;
          for (let i = startIndex; i < booleanFilter.length; i++) {
            const char = booleanFilter[i];
            if (/[0-9]/.test(char)) {
              currentToken += char;
              continue;
            }
            if (currentToken === expressionIndex) {
              matchingIndex = i - String(expressionIndex).length;
              break;
            }
            if (Number(currentToken) > Number(expressionIndex)) {
              const newToken = String(Number(currentToken) - 1);
              booleanFilter = `${booleanFilter.slice(0, i - 1)}${newToken}${booleanFilter.slice(i - 1 + currentToken.length)}`;
              if (newToken.length < expressionIndex.length)
                i--;
            }
            currentToken = "";
          }
          if (!matchingIndex && currentToken === expressionIndex) {
            matchingIndex = booleanFilter.length - String(expressionIndex).length;
          } else if (!matchingIndex && currentToken && Number(currentToken) > Number(expressionIndex)) {
            const newToken = String(Number(currentToken) - 1);
            booleanFilter = booleanFilter.replace(new RegExp(`${currentToken}$`), newToken);
          }
          if (matchingIndex) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, matchingIndex, expressionIndex.length);
            return Filter.removeBooleanFilterExpression(
              `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`,
              expressionIndex,
              start2
            );
          }
          let paramIndex;
          while ((paramIndex = booleanFilter.indexOf("()")) !== -1) {
            const { start: start2, end: end2 } = Filter.getOperatorBounds(booleanFilter, paramIndex, 2);
            booleanFilter = `${booleanFilter.slice(0, start2)}${booleanFilter.slice(end2)}`;
          }
          return booleanFilter;
        },
        getOperatorBounds(booleanFilter, matchingIndex, matchLength) {
          const matchingIndexEnd = matchingIndex + matchLength;
          let start2;
          let end2;
          if (matchingIndex > 4 && booleanFilter.slice(matchingIndex - 4, matchingIndex) === " or ") {
            start2 = matchingIndex - 4;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 4 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 4) === " or ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 4;
          } else if (matchingIndex > 5 && booleanFilter.slice(matchingIndex - 5, matchingIndex) === " and ") {
            start2 = matchingIndex - 5;
            end2 = matchingIndexEnd;
          } else if (matchingIndexEnd < booleanFilter.length - 5 && booleanFilter.slice(matchingIndexEnd, matchingIndexEnd + 5) === " and ") {
            start2 = matchingIndex;
            end2 = matchingIndexEnd + 5;
          } else {
            start2 = matchingIndex;
            end2 = matchingIndexEnd;
          }
          return { start: start2, end: end2 };
        }
      };
      const DeferredPromise = function() {
        this._promise = new Promise((resolve2, reject) => {
          this.resolve = resolve2;
          this.reject = reject;
        });
        this.then = this._promise.then.bind(this._promise);
        this.catch = this._promise.catch.bind(this._promise);
        this.finally = this._promise.finally.bind(this._promise);
        this[Symbol.toStringTag] = "Promise";
      };
      const Plan = {
        defaults: () => ({
          sobjectType: "sfsp__SalesPlan__c",
          Name: "",
          sfsp__SalesMetrics__r: [],
          sfsp__SalesAssignmentObjects__r: [],
          sfsp__SalesNodeMetrics__r: [],
          sfsp__ListViews__r: [],
          sfsp__SalesNodeBoundaries__r: [],
          sfsp__SalesPlanUsers__r: [],
          sfsp__SalesUserAccess__r: []
        })
      };
      const AssignmentObject = {
        getIcon(objName) {
          const icons = {
            Account: { category: "standard", name: "account", color: "#5867E8" },
            Lead: { category: "standard", name: "lead", color: "#FF5D2D" },
            Contact: { category: "standard", name: "contact", color: "#a094ed" },
            Opportunity: { category: "standard", name: "opportunity", color: "#fcb95b" },
            User: { category: "standard", name: "customers", color: "#06A59A" }
          };
          return icons[objName] || { category: "standard", name: "entity", color: "#f88962" };
        },
        getReferenceMetadata({ assignmentObject }) {
          return [
            ...assignmentObject.recordsDataset.dimensions.map((d) => ({ id: d.id, title: `Unique ${d.title}`, type: "unique" })),
            ...assignmentObject.recordsDataset.measures.reduce((arr, m) => [
              { id: m.id, title: `Sum of ${m.title}`, type: "sum" },
              { id: m.id, title: `Min ${m.title}`, type: "min" },
              { id: m.id, title: `Max ${m.title}`, type: "max" }
            ].concat(arr), [])
          ];
        },
        getFieldOptions({ assignmentObject, mode = "Record" }) {
          const aggregateIdPrefix = mode === "Record" ? "" : "sum__";
          const aggregateLabelPrefix = mode === "Record" ? "" : "Sum of ";
          const fields = assignmentObject.referenceFields.filter((f) => f.type === "Numeric" || mode === "Record").map(({ id: id2, label, type, isNameField }) => ({
            id: `${aggregateIdPrefix}${assignmentObject.id}__${id2}`,
            label: `${aggregateLabelPrefix}${label}`,
            type,
            isNameField
          }));
          if (mode === "Record") {
            SPM.$store.boundaryObjects.forEach((boundaryObject) => {
              var _a, _b;
              if ((_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name)) {
                fields.push({ id: `${assignmentObject.id}__${boundaryObject.name}`, label: boundaryObject.label, type: "Text" });
              }
            });
          }
          fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
          if (fields.find((f) => f.isNameField)) {
            fields.unshift(fields.splice(fields.findIndex((f) => f.isNameField), 1)[0]);
            if (mode === "Record") {
              fields.splice(
                1,
                0,
                { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
                { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
              );
            }
          } else if (mode === "Record") {
            fields.push(
              { id: "AssignedTo", label: "Assigned To", type: "Assignment" },
              { id: "AssignmentType", label: "Assignment Type", type: "Assignment" }
            );
          }
          return fields;
        },
        getDefaultColumns({ assignmentObject, mode = "Record" }) {
          const fields = AssignmentObject.getFieldOptions({ assignmentObject, mode });
          if (fields.find((f) => f.isNameField)) {
            return fields.filter((f) => f.id !== `${assignmentObject.id}__Id`).map(({ id: id2, type, isNameField }) => ({
              id: id2,
              summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique",
              isNameField
            }));
          }
          return fields.map(({ id: id2, type }) => ({
            id: id2,
            summaryFormat: type === "Numeric" ? "Sum" : type === "Assignment" ? "Assignment" : "Unique"
          }));
        },
        async getDatasetInfo({ alias }) {
          let response = {};
          let dataset = [];
          let metadata = {};
          if (!SPM.hasDataPipelinesAccess) {
            ({ datasets: response, metadata } = await SPM.Utils.Apex.invoke("GetDatasets", [alias]));
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
          } else {
            response = await SPM.Utils.Rest.invoke("GetDatasets", { alias });
            if (!(response == null ? void 0 : response.length))
              return false;
            dataset = response[0];
            metadata = await SPM.Utils.Rest.invoke("GetDatasetMetadata", { url: dataset.currentVersionUrl });
          }
          return { dataset, metadata };
        },
        async loadDatasets({ assignmentObjectId, planId }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Records` });
          if (!recordsDataset || !recordsMetadata)
            return false;
          const { dataset: assignmentsDataset, metadata: assignmentsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias: `${planId}_${assignmentObjectId}_Assignments` });
          if (!assignmentsDataset || !assignmentsDataset)
            return false;
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          Object.assign(assignmentsDataset, {
            measures: assignmentsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: assignmentsMetadata.measures,
            dimensions: assignmentsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          return { recordsDataset, assignmentsDataset };
        },
        async reassign({ objectId, reassignments }) {
          const recordAssignmentsMap = SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }).reduce((map2, node) => {
            if (node !== SPM.$store.rootNode) {
              node.assignments.forEach((a) => {
                if (a.sfsp__SalesAssignmentObject__c === objectId) {
                  map2[a.sfsp__RecordId__c] = map2[a.sfsp__RecordId__c] || [];
                  map2[a.sfsp__RecordId__c].push(a);
                }
              });
            }
            return map2;
          }, {});
          const assignmentsToDelete = [];
          const assignmentsToInsert = [];
          const impactedNodeIds = /* @__PURE__ */ new Set();
          reassignments.forEach(({ recordId, targetId }) => {
            const existingAssignments = recordAssignmentsMap[recordId];
            existingAssignments == null ? void 0 : existingAssignments.forEach((a) => {
              assignmentsToDelete.push(a);
              impactedNodeIds.add(a.sfsp__SalesNode__c);
            });
            let currentNode = SPM.$store.nodeMap[targetId];
            while (currentNode !== SPM.$store.rootNode) {
              impactedNodeIds.add(currentNode.id);
              assignmentsToInsert.push({
                sobjectType: "sfsp__SalesNodeAssignment__c",
                sfsp__SalesAssignmentObject__c: objectId,
                sfsp__RecordId__c: recordId,
                sfsp__AssignmentType__c: "Manual",
                sfsp__SalesNode__c: currentNode.id,
                sfsp__Status__c: "Active"
              });
              currentNode = SPM.$store.nodeMap[currentNode.parentId];
            }
          });
          await Promise.all([
            SPM.Utils.CRM.delete({ records: assignmentsToDelete }),
            SPM.Utils.CRM.upsert({ records: assignmentsToInsert })
          ]);
          impactedNodeIds.forEach((nodeId2) => {
            SPM.$store.nodeMap[nodeId2].assignments = SPM.$store.nodeMap[nodeId2].assignments.filter((a) => !assignmentsToDelete.includes(a));
            SPM.$store.nodeMap[nodeId2].assignments.push(...assignmentsToInsert.filter((a) => a.sfsp__SalesNode__c === nodeId2));
          });
        },
        async reassignBoundaries({ objectId, reassignments, isPreview, onProgress = () => {
        } }) {
          const boundaryObject = SPM.$store.boundaryObjects.find((o) => o.id === objectId);
          const rulesToDelete = [];
          const rulesToUpsert = [];
          SPM.$store.allNodes.forEach((node) => {
            if (node.id === "All Org")
              return;
            const nodeBoundaryMap = SPM.Utils.Node.getBoundaries({ node, boundaryObject, format: "map" });
            const considerSiblings = SPM.$store.rootNode.assignmentBehavior === "Exclusive";
            let isAffected = false;
            reassignments.forEach(({ boundary, targetId }) => {
              const targetNode = SPM.$store.nodeMap[targetId];
              const shouldHaveBoundary = node.id === targetNode.id || SPM.Utils.Node.isAncestor({ node: targetNode, ancestor: node, nodeMap: SPM.$store.nodeMap });
              if (shouldHaveBoundary && !nodeBoundaryMap[boundary]) {
                nodeBoundaryMap[boundary] = true;
                isAffected = true;
              } else if (considerSiblings && !shouldHaveBoundary && nodeBoundaryMap[boundary]) {
                delete nodeBoundaryMap[boundary];
                isAffected = true;
              }
            });
            if (isAffected) {
              if (isPreview) {
                const previewRules = [...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId)];
                rulesToDelete.push(...(node.previewRules || node.rules).filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = SPM.Utils.Rule.fromBoundaries({
                    boundaries: Object.keys(nodeBoundaryMap),
                    boundaryObject
                  });
                  previewRules.push(newBoundaryRule);
                }
                node.previewRules = previewRules;
              } else {
                rulesToDelete.push(...node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c === objectId));
                node.rules = node.rules.filter((r) => r.sfsp__SalesNodeBoundary__c !== objectId);
                if (Object.keys(nodeBoundaryMap).length) {
                  const newBoundaryRule = {
                    ...SPM.Utils.Rule.fromBoundaries({
                      boundaries: Object.keys(nodeBoundaryMap),
                      boundaryObject
                    }),
                    sfsp__SalesNode__c: node.id
                  };
                  node.rules.push(newBoundaryRule);
                  rulesToUpsert.push(newBoundaryRule);
                }
              }
            }
          });
          if (isPreview)
            return;
          await SPM.Utils.CRM.upsert({
            records: rulesToUpsert,
            onProgress: (percent) => onProgress(`Saving Rules...${percent}%`)
          });
          const ruleItemsToUpsert = [];
          rulesToUpsert.forEach((rule) => {
            rule.sfsp__SalesNodeRuleItems__r.forEach((item) => {
              item.sfsp__SalesNodeRule__c = rule.Id;
              ruleItemsToUpsert.push(item);
            });
          });
          await SPM.Utils.CRM.upsert({
            records: ruleItemsToUpsert,
            onProgress: (percent) => onProgress(`Saving Rule Items...${percent}%`)
          });
          await SPM.Utils.CRM.delete({
            records: rulesToDelete,
            onProgress: (percent) => onProgress(`Cleaning Up...${percent}%`)
          });
        },
        async getSalesAsyncJobs({ objectId, statuses = [] }) {
          const objectFilter = objectId ? ` AND sfsp__SalesAssignmentObject__c = '${objectId}'` : "";
          const statusFilter = statuses.length > 0 ? ` AND sfsp__Status__c IN ('${statuses.join("','")}')` : "";
          return await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Name,
                    CreatedDate,
                    sfsp__Details__c,
                    sfsp__Status__c,
                    sfsp__Type__c,
                    sfsp__Splunk__c,
                    sfsp__SalesAssignmentObject__c,
                    sfsp__SalesAssignmentObject__r.Name,
                    sfsp__SalesAssignmentObject__r.sfsp__Label__c,
                    sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c
                FROM sfsp__SalesAsyncJob__c
                WHERE sfsp__SalesAssignmentObject__r.sfsp__SalesPlan__c = '${SPM.$store.plan.Id}'${objectFilter}${statusFilter}
                ORDER BY CreatedDate DESC
            `]) || [];
        },
        async updateReferenceFields({ assignmentObject }) {
          const referenceFields = JSON.parse((SPM.$store.plan.sfsp__SalesAssignmentObjects__r.find((obj) => obj.Id === assignmentObject.id) || {}).sfsp__ReferenceFields__c);
          referenceFields.forEach((field) => field.lastModifiedDate = Date.now());
          const [updatedAssignmentObject] = await SPM.Utils.Apex.invoke("UpdateSObjects", [
            [{
              Id: assignmentObject.id,
              Name: assignmentObject.name,
              sfsp__Label__c: assignmentObject.label,
              sfsp__ReferenceFields__c: JSON.stringify(referenceFields)
            }],
            true
          ]);
          SPM.$store.$patch((state) => {
            const assignmentObjectIndex = state.plan.sfsp__SalesAssignmentObjects__r.findIndex((a) => a.Id === assignmentObject.id);
            state.plan.sfsp__SalesAssignmentObjects__r.splice(assignmentObjectIndex, 1, updatedAssignmentObject);
            state.hasChanged = true;
          });
        }
      };
      const BoundaryObject = {
        Defaults: {
          type: "boundary",
          icon: "location",
          styles: {
            visible: true,
            opacity: 0.3
          }
        },
        getFieldOptions({ boundaryObject }) {
          const fields = [
            { id: "Name", label: boundaryObject.label, type: "Text" },
            { id: "AssignedTo", label: "Assigned To", type: "Text" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            fields.push(
              { id: `unique__${assignmentObject.id}__Id`, label: assignmentObject.label, type: "Numeric" },
              ...assignmentObject.referenceFields.filter((f) => f.type === "Numeric").map(({ id: id2, label, type }) => ({
                id: `sum__${assignmentObject.id}__${id2}`,
                label,
                type
              }))
            );
          });
          Object.entries(boundaryObject.metadata).forEach(([key, { label, type, visible }]) => {
            if (visible)
              fields.push({ id: `BoundaryMetadata:${key}`, label, type: type === "float" ? "Numeric" : "Text" });
          });
          return fields.sort((a, b) => {
            if (a.label > b.label)
              return 1;
            if (a.label < b.label)
              return -1;
            return 0;
          });
        },
        getDefaultColumns({ boundaryObject }) {
          const defaultColumns = [
            { id: "Name", summaryFormat: "Unique" },
            { id: "AssignedTo", summaryFormat: "Unique" }
          ];
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a, _b;
            return (_b = (_a = o.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
          });
          objectsWithGeoField.forEach((assignmentObject) => {
            defaultColumns.push({ id: `unique__${assignmentObject.id}__Id`, summaryFormat: "Sum" });
          });
          return defaultColumns;
        }
      };
      const Node2 = {
        defaults: () => ({
          sobjectType: "sfsp__SalesNode__c",
          Name: "",
          sfsp__SalesNodes__r: [],
          sfsp__SalesNodeRules__r: [],
          sfsp__RuleLogics__c: "{}"
        }),
        buildRows({ parentRow, childNodes, lazy, includeBoundaries = true }) {
          const childRows = [];
          childNodes.forEach((node) => {
            const row = {
              id: node.id,
              name: node.name,
              data: [
                { id: "Name", format: "Name", type: "custom", node },
                ...SPM.$store.assignmentObjects.filter((obj) => obj.recordsDataset.dimensions).map((assignment) => ({
                  id: assignment.id,
                  format: "Assignment",
                  type: "custom",
                  state: "loading",
                  value: 0,
                  columnName: assignment.name
                })),
                ...((includeBoundaries ? SPM.$store.boundaryObjects : []) || []).map((boundary) => ({
                  id: boundary.id,
                  format: "Boundary",
                  type: "custom",
                  state: "loading",
                  value: 0
                })),
                ...node.metrics.map((metric) => {
                  const salesMetric = SPM.$store.plan.sfsp__SalesMetrics__r.find((m) => m.Id === metric.sfsp__SalesMetric__c);
                  const monthKeys = [...Object.keys(metric)].filter((name2) => name2.startsWith("sfsp__Target_Month"));
                  const metricDetails = {
                    id: metric.Id,
                    format: "Allocation",
                    type: "custom",
                    dataType: salesMetric.sfsp__Type__c,
                    value: monthKeys.reduce((agg, field) => agg + metric[field], 0),
                    columnName: salesMetric.Name
                  };
                  metricDetails.overrideAmount = salesMetric.sfsp__TargetOverrideEnabled__c ? metric.sfsp__TargetOverrideType__c === "Percentage" ? metric.sfsp__TargetOverrideAmount__c / 100 * metricDetails.value : metric.sfsp__TargetOverrideAmount__c : 0;
                  return metricDetails;
                })
              ],
              parent: parentRow,
              children: [],
              childCount: 0,
              expanded: !lazy,
              loaded: !lazy
            };
            if (SPM.$store.hasSalesPlanningTemplateApp && SPM.$store.isEditor)
              row.data.splice(1, 0, { id: "SharedWith", format: "Shared with", type: "custom", node });
            childRows.push(row);
            parentRow.children.push(row);
          });
          parentRow.loaded = true;
          parentRow.expanded = true;
          return childRows;
        },
        async importHierarchy({ hierarchy: hierarchy2, includeBoundaries = true }) {
          const rowMap = {};
          const traverse2 = (rows) => {
            rows.forEach((r) => {
              rowMap[r.id] = r;
              traverse2(r.children);
            });
          };
          traverse2(SPM.Components.Hierarchy.rows);
          let hierarchyNodes = [hierarchy2];
          while (hierarchyNodes.length) {
            const parentIds = hierarchyNodes.map((n) => n.id);
            hierarchyNodes = hierarchyNodes.reduce((arr, hierarchyNode) => arr.concat(
              hierarchyNode.children.map((hierarchyChild) => Object.assign(hierarchyChild, {
                parentNode: SPM.$store.nodeMap[hierarchyNode.id] || { id: hierarchyNode.id, childCount: 0 }
              }))
            ), []);
            const nodesToInsert = hierarchyNodes.map((hierarchyNode, i) => ({
              sobjectType: "sfsp__SalesNode__c",
              Name: hierarchyNode.name,
              sfsp__SalesPlan__c: SPM.$store.plan.Id,
              sfsp__Parent__c: hierarchyNode.parentNode.id.replace("All Org", ""),
              sfsp__Priority__c: hierarchyNode.parentNode.childCount + i + 1,
              sfsp__Color__c: SPM.Utils.Node.randomColor(),
              sfsp__AssignmentBehavior__c: "Exclusive"
            }));
            await SPM.Utils.CRM.upsert({ records: nodesToInsert });
            nodesToInsert.forEach((node, i) => {
              hierarchyNodes[i].id = node.Id;
              const parentId = node.sfsp__Parent__c || "All Org";
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              const newNode = {
                id: node.Id,
                name: node.Name,
                color: node.sfsp__Color__c,
                assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
                ownerId: "",
                ownerName: "",
                level: parentNode.level + 1,
                parentId,
                childCount: 0,
                children: [],
                metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => ({
                  ...SPM.Utils.NodeMetric.Defaults,
                  sfsp__SalesPlan__c: SPM.$store.plan.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  sfsp__SalesNode__c: node.Id
                })),
                users: [],
                accessRecords: [],
                rules: [],
                ruleLogics: {},
                previewRuleLogics: {},
                assignments: [],
                boundaries: [],
                referenceData: []
              };
              SPM.$store.nodeMap[newNode.id] = newNode;
              parentNode.children.push(newNode);
              rowMap[newNode.id] = this.buildRows({ parentRow: rowMap[parentNode.id], childNodes: [newNode], includeBoundaries })[0];
            });
            parentIds.forEach((parentId) => {
              const parentNode = SPM.$store.nodeMap[parentId];
              if (!(parentNode == null ? void 0 : parentNode.children))
                return;
              parentNode.childCount = parentNode.children.length;
              parentNode.children.forEach((childNode) => {
                childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
                childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
              });
            });
            SPM.$store.branch.descendantIds.push(...nodesToInsert.map((node) => node.Id));
          }
          this.calculateValues(SPM.Components.Hierarchy.rows);
        },
        getBoundaryValue({ cell, nodeId: nodeId2, boundaryObjectId }) {
          const count2 = SPM.Utils.Node.getBoundaries({ node: SPM.$store.nodeMap[nodeId2], boundaryObject: SPM.$store.boundaryObjects.find((o) => o.id === boundaryObjectId) }).length;
          cell.state = "loaded";
          cell.value = count2;
        },
        async getAssignmentValues({ nodeId: nodeId2, assignmentObjectId, referenceFields = [] }) {
          var _a;
          const assignmentObject = SPM.$store.assignmentObjects.find((o) => o.id === assignmentObjectId);
          if (!((_a = assignmentObject == null ? void 0 : assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions))
            return;
          const saql = SPM.Utils.Node.generateSaql({
            node: SPM.$store.nodeMap[nodeId2],
            assignmentObject,
            referenceFields,
            boundaryObjects: SPM.$store.boundaryObjects,
            nodeMap: SPM.$store.nodeMap,
            recordsDataset: assignmentObject.recordsDataset,
            assignmentsDataset: assignmentObject.assignmentsDataset,
            type: "cogroup"
          });
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          return ((results == null ? void 0 : results.records) || []).reduce((map2, rec) => {
            map2[rec.nodeId] = {};
            Object.entries(rec).forEach(([key, value]) => {
              if (key !== "nodeId")
                map2[rec.nodeId][key] = value;
            }, {});
            return map2;
          }, {});
        },
        calculateValues(rows) {
          const boundaryCalculations = [];
          const parentToObjectMap = {};
          const findValues = (parents) => {
            parents.forEach((row) => {
              var _a;
              const parentId = ((_a = row.parent) == null ? void 0 : _a.id) || "All Org";
              parentToObjectMap[parentId] = parentToObjectMap[parentId] || {};
              row.data.forEach((col) => {
                if (col.format === "Assignment" && col.state === "loading") {
                  parentToObjectMap[parentId][col.id] = parentToObjectMap[parentId][col.id] || {};
                  parentToObjectMap[parentId][col.id][row.id] = col;
                } else if (col.format === "Boundary" && col.state === "loading") {
                  boundaryCalculations.push({ cell: col, nodeId: row.id, boundaryObjectId: col.id });
                }
              });
              findValues(row.children);
            });
          };
          findValues(rows);
          SPM.Utils.Async.forEachParallel(boundaryCalculations, (boundaryToCalculate) => this.getBoundaryValue(boundaryToCalculate), 5);
          SPM.Utils.Async.forEach(Object.values(parentToObjectMap), async (assignmentObjectToCellMap) => {
            await SPM.Utils.Async.forEachParallel(Object.entries(assignmentObjectToCellMap), async ([assignmentObjectId, cellMap]) => {
              const nodeIds = Object.keys(cellMap);
              const lastSiblingId = nodeIds[nodeIds.length - 1];
              const assignmentValues = await this.getAssignmentValues({ nodeId: lastSiblingId, assignmentObjectId });
              nodeIds.forEach((nodeId2) => {
                var _a;
                const value = ((_a = assignmentValues[nodeId2]) == null ? void 0 : _a.count) || 0;
                cellMap[nodeId2].value = value;
                cellMap[nodeId2].state = "loaded";
              });
            }, 5);
          });
        },
        async getMaxLevel({ planId, nodeIds, currentLevel }) {
          if (nodeIds.includes(""))
            throw new Error("Blank node id is not supported");
          const fifthLevelChildNodes = await SPM.Utils.Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id IN ('${nodeIds.join("','")}')`]);
          if (fifthLevelChildNodes.length) {
            return Node2.getMaxLevel({ planId, nodeIds: fifthLevelChildNodes.map((n) => n.Id), currentLevel: currentLevel + 5 });
          }
          for (let i = 4; i > 0; i--) {
            const ancestorPath = Array(i).fill().map((item) => "sfsp__Parent__r").join(".");
            const nodes = await Apex.invoke("Query", [`SELECT Id FROM sfsp__SalesNode__c WHERE sfsp__SalesPlan__c = '${planId}' AND ${ancestorPath}.Id IN ('${nodeIds.join("','")}') LIMIT 1`]);
            if (nodes.length) {
              return currentLevel + i;
            }
          }
          return currentLevel;
        },
        async getNodeLevel({ nodeId: nodeId2 }) {
          var _a, _b, _c, _d, _e;
          let level = 1;
          while (nodeId2) {
            const node = (await Apex.invoke("Query", [`
                    SELECT Id,
                        sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                        sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                    FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
                `]))[0];
            let parentNode = node;
            while (parentNode = (_a = parentNode == null ? void 0 : parentNode.sfsp__Parent__r) == null ? void 0 : _a.Id)
              level++;
            nodeId2 = (_e = (_d = (_c = (_b = node == null ? void 0 : node.sfsp__Parent__r) == null ? void 0 : _b.sfsp__Parent__r) == null ? void 0 : _c.sfsp__Parent__r) == null ? void 0 : _d.sfsp__Parent__r) == null ? void 0 : _e.sfsp__Parent__r.Id;
          }
          return level;
        },
        async getDescendantIds({ planId, nodeIds }) {
          if (!nodeIds || nodeIds.length === 0)
            return [];
          const descendantIds = (await Apex.invoke("Query", [`
                SELECT Id, sfsp__SalesPlan__c, sfsp__Parent__r.Id FROM sfsp__SalesNode__c WHERE sfsp__Parent__r.Id IN ('${nodeIds.join("','")}') AND sfsp__SalesPlan__c = '${planId}'
            `])).map((node) => node.Id);
          return [
            ...descendantIds,
            ...await Node2.getDescendantIds({ planId, nodeIds: descendantIds })
          ];
        },
        async getAncestorIds({ nodeId: nodeId2 }) {
          if (!nodeId2 || nodeId2 === "All Org")
            return [];
          let node = (await Apex.invoke("Query", [`
                SELECT Id,
                    sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id,
                    sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.sfsp__Parent__r.Id
                FROM sfsp__SalesNode__c WHERE Id = '${nodeId2}'
            `]))[0];
          const ancestorIds = [];
          while (node = node.sfsp__Parent__r)
            ancestorIds.push(node.Id);
          return [
            ...ancestorIds,
            ...await Node2.getAncestorIds({ nodeId: ancestorIds[4] }),
            "All Org"
          ];
        },
        async loadScope({ planId, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false, rootNodeId, parentNodeIds = [] }) {
          if (rootNodeId && nodeMap[rootNodeId]) {
            parentNodeIds.push(rootNodeId);
            rootNodeId = null;
          }
          parentNodeIds = [...new Set(parentNodeIds)].filter((id2) => {
            var _a;
            return !((_a = nodeMap[id2 || "All Org"]) == null ? void 0 : _a.children);
          });
          const parentNodeBatches = rootNodeId ? [[]] : [];
          let parentNodeIndex = 0;
          while (parentNodeIndex < parentNodeIds.length) {
            parentNodeBatches.push(parentNodeIds.slice(parentNodeIndex, parentNodeIndex + 1e3));
            parentNodeIndex += 1e3;
          }
          const nodes = [];
          await Async.forEachParallel(parentNodeBatches, async (batchIds) => {
            const parentClause = rootNodeId ? `(Id = '${rootNodeId}' OR sfsp__Parent__c = '${rootNodeId}')` : `sfsp__Parent__c IN ('${batchIds.join("','")}')`;
            const batchNodes = await Apex.invoke(
              "Query",
              [`
                        SELECT
                            Id,
                            Name,
                            sfsp__Parent__c,
                            sfsp__Color__c,
                            sfsp__Owner__c,
                            sfsp__Owner__r.Name,
                            sfsp__AssignmentBehavior__c,
                            sfsp__RuleLogics__c,
                            sfsp__HierarchyReferenceData__c,
                            (
                                SELECT
                                    Id,
                                    sfsp__TargetOverrideAmount__c,
                                    sfsp__TargetOverrideType__c,
                                    ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")},
                                    sfsp__SalesMetric__c
                                FROM sfsp__SalesNodeMetrics__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c, sfsp__SalesAssignmentObject__c, sfsp__SalesNodeBoundary__c
                                FROM sfsp__SalesNodeRules__r
                            ),
                            (
                                SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c
                                FROM sfsp__SalesNodeBoundaries__r
                            ),
                            (
                                SELECT Id, sfsp__SalesNode__c, sfsp__User__c, sfsp__User__r.Name, sfsp__Role__c
                                FROM sfsp__SalesNodeUsers__r
                            ),
                            (
                                SELECT Id
                                FROM sfsp__SalesNodes__r
                            ),
                            (
                                SELECT Id, sfsp__User__r.Name, sfsp__AccessLevel__c, sfsp__SalesNode__r.Name FROM sfsp__SalesUserAccess__r 
                            )
                        FROM sfsp__SalesNode__c
                        WHERE sfsp__SalesPlan__c = '${planId}' AND ${parentClause}
                        ORDER BY sfsp__Priority__c ASC
                    `]
            );
            nodes.push(...batchNodes);
            if (loadRuleItems) {
              const batchRuleMap = batchNodes.reduce((map2, node) => {
                (node.sfsp__SalesNodeRules__r || []).forEach((rule) => {
                  rule.sfsp__SalesNodeRuleItems__r = [];
                  map2[rule.Id] = rule;
                });
                return map2;
              }, {});
              const batchRuleItems = Object.keys(batchRuleMap).length === 0 ? [] : await Apex.invoke(
                "Query",
                [`
                            SELECT Id, sfsp__SalesNodeRule__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                            FROM sfsp__SalesNodeRuleItem__c
                            WHERE sfsp__SalesNodeRule__c IN ('${Object.keys(batchRuleMap).join("','")}')
                        `]
              );
              batchRuleItems.forEach((item) => batchRuleMap[item.sfsp__SalesNodeRule__c].sfsp__SalesNodeRuleItems__r.push(item));
            }
            if (loadAssignments) {
              const batchNodeMap = batchNodes.reduce((map2, node) => {
                node.assignments = [];
                map2[node.Id] = node;
                return map2;
              }, {});
              const batchAssignments = Object.keys(batchNodeMap).length === 0 ? [] : await SPM.Utils.Rest.invoke(
                "Query",
                { query: `
                            SELECT sfsp__SalesNode__c, sfsp__SalesAssignmentObject__c, sfsp__AssignmentType__c, sfsp__RecordId__c, sfsp__Status__c
                            FROM sfsp__SalesNodeAssignment__c
                            WHERE sfsp__SalesNode__c IN ('${Object.keys(batchNodeMap).join("','")}') AND sfsp__Status__c != 'Deleted'
                        ` }
              );
              batchAssignments.forEach((assignment) => batchNodeMap[assignment.sfsp__SalesNode__c].assignments.push(assignment));
            }
          }, 5);
          let rootNodeLevel;
          if (rootNodeId) {
            rootNodeLevel = await Node2.getNodeLevel({ nodeId: rootNodeId });
            nodeMap[rootNodeId] = {
              level: rootNodeLevel,
              siblingIds: [],
              olderSiblingIds: [],
              users: [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: [],
              referenceData: []
            };
          }
          nodes.forEach((node) => {
            var _a, _b, _c;
            const nodeMetrics = node.sfsp__SalesNodeMetrics__r || [];
            const childNode = {
              ...nodeMap[node.Id],
              id: node.Id,
              name: node.Name,
              color: node.sfsp__Color__c,
              assignmentBehavior: node.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: node.sfsp__Owner__c || "",
              ownerName: ((_a = node == null ? void 0 : node.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: node.Id === rootNodeId ? rootNodeLevel : nodeMap[node.sfsp__Parent__c || "All Org"].level + 1,
              parentId: node.sfsp__Parent__c || "All Org",
              childCount: ((_b = node == null ? void 0 : node.sfsp__SalesNodes__r) == null ? void 0 : _b.length) || 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = nodeMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.Id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: node.sfsp__SalesNodeUsers__r || [],
              accessRecords: ((_c = node.sfsp__SalesUserAccess__r) == null ? void 0 : _c.map(({ sfsp__User__r, sfsp__User__c, sfsp__SalesNode__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: sfsp__SalesNode__c }))) || [],
              rules: node.sfsp__SalesNodeRules__r || [],
              ruleLogics: JSON.parse(node.sfsp__RuleLogics__c || "{}"),
              previewRuleLogics: {},
              assignments: node.assignments || [],
              boundaries: node.sfsp__SalesNodeBoundaries__r || [],
              referenceData: JSON.parse((node == null ? void 0 : node.sfsp__HierarchyReferenceData__c) || "[]")
            };
            nodeMap[node.Id] = childNode;
            const parentNode = nodeMap[node.sfsp__Parent__c || "All Org"];
            if (parentNode) {
              parentNode.children = parentNode.children || [];
              const childIndex = parentNode.children.findIndex((c) => c.id === childNode.id);
              if (childIndex === -1) {
                parentNode.children.push(childNode);
              } else {
                parentNode.children.splice(childIndex, 1, childNode);
              }
            }
          });
          const parentIdsToInit = rootNodeId ? [rootNodeId, ...parentNodeIds] : parentNodeIds;
          parentIdsToInit.forEach((parentId) => {
            const parentNode = nodeMap[parentId || "All Org"];
            parentNode.children = parentNode.children || [];
            parentNode.childCount = parentNode.children.length;
            parentNode.rules = parentNode.rules || [];
            parentNode.boundaries = parentNode.boundaries || [];
            parentNode.children.forEach((childNode) => {
              childNode.siblingIds = parentNode.children.filter((n) => n.id !== childNode.id).map((n) => n.id);
              childNode.olderSiblingIds = parentNode.children.slice(0, parentNode.children.indexOf(childNode)).map((n) => n.id);
            });
          });
        },
        async loadAncestors({ planId, nodeId: nodeId2, metrics = [], nodeMap = {}, loadRuleItems = false, loadAssignments = false }) {
          var _a;
          const ancestorIds = await Node2.getAncestorIds({ nodeId: nodeId2 });
          if (!ancestorIds.length)
            return;
          if (!nodeMap["All Org"]) {
            const allOrgMetrics = await SPM.Utils.Apex.invoke("Query", [`SELECT Id, sfsp__TargetOverrideAmount__c, sfsp__TargetOverrideType__c, ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")}, sfsp__SalesMetric__c FROM sfsp__SalesNodeMetric__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''`]);
            const planNodeBoundaries = await SPM.Utils.Rest.invoke("Query", { query: `SELECT Id, Name, sfsp__SalesNode__c, sfsp__ContainerSet__c, sfsp__Filter__c, sfsp__IncludePoints__c, sfsp__SalesBoundary__c, sfsp__SalesBoundary__r.Name, sfsp__SalesBoundary__r.sfsp__ContainerSet__c, sfsp__SalesBoundary__r.sfsp__IncludePoints__c, sfsp__SalesBoundary__r.sfsp__SalesPlan__c FROM sfsp__SalesNodeBoundary__c WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__SalesNode__c = ''` });
            nodeMap["All Org"] = {
              id: "All Org",
              name: "All Org",
              color: "#2C7ED0",
              assignmentBehavior: SPM.$store.plan.sfsp__AssignmentBehavior__c || "Exclusive",
              ownerId: SPM.$store.plan.sfsp__Owner__c || "",
              ownerName: ((_a = SPM.$store.plan.sfsp__Owner__r) == null ? void 0 : _a.Name) || "",
              level: 0,
              metrics: metrics.map((metric) => {
                const nodeMetric = allOrgMetrics.find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              }),
              users: SPM.$store.plan.sfsp__SalesPlanUsers__r || [],
              accessRecords: SPM.$store.plan.sfsp__SalesUserAccess__r.filter((ua) => !ua.sfsp__SalesNode__c && !SPM.$store.availableAdminIds.has(ua.sfsp__User__c) && !SPM.$store.availableManagerIds.has(ua.sfsp__User__c)).map(({ sfsp__User__r, sfsp__User__c }) => ({ name: sfsp__User__r.Name, userId: sfsp__User__c, nodeId: "All Org" })) || [],
              rules: [],
              ruleLogics: {},
              previewRuleLogics: {},
              assignments: [],
              boundaries: planNodeBoundaries,
              siblingIds: [],
              olderSiblingIds: []
            };
            await Node2.loadScope({ planId, metrics, nodeMap, loadRuleItems, loadAssignments, parentNodeIds: [""] });
          }
          let currentAncestor = nodeMap["All Org"].children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          while (currentAncestor.id !== nodeId2) {
            await Node2.loadScope({
              planId,
              metrics,
              nodeMap,
              loadRuleItems,
              loadAssignments,
              parentNodeIds: [currentAncestor.id]
            });
            currentAncestor = currentAncestor.children.find((c) => c.id === nodeId2 || ancestorIds.includes(c.id));
          }
        },
        getProjectionFields({ node, referenceFields }) {
          const fields = /* @__PURE__ */ new Set(["Id"]);
          referenceFields.forEach((f) => fields.add(f.name));
          const checkParent = (node2) => {
            if (node2.parentId) {
              const parentNode = SPM.$store.nodeMap[node2.parentId];
              const allRules = [...parentNode.rules, ...parentNode.previewRules || []];
              allRules.forEach((rule) => {
                (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                  fields.add(ruleItem.sfsp__Field__c);
                });
              });
              [...parentNode.olderSiblingIds].forEach((nodeId2) => {
                const levelNode = SPM.$store.nodeMap[nodeId2];
                const allRules2 = [...levelNode.rules, ...levelNode.previewRules || []];
                allRules2.forEach((rule) => {
                  (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                    fields.add(ruleItem.sfsp__Field__c);
                  });
                });
              });
              checkParent(parentNode);
            }
          };
          checkParent(node);
          [...node.olderSiblingIds, node.id].forEach((nodeId2) => {
            const levelNode = SPM.$store.nodeMap[nodeId2];
            const allRules = [...levelNode.rules, ...levelNode.previewRules || []];
            allRules.forEach((rule) => {
              (rule.sfsp__SalesNodeRuleItems__r || []).forEach((ruleItem) => {
                fields.add(ruleItem.sfsp__Field__c);
              });
            });
          });
          return fields;
        },
        generateSaql({ node, assignmentObject, boundaryObjects, projectionFields, referenceFields = [], nodeMap, recordIds, type, returnType = "count", descendantNodes = [], descendantSaql = "", prefix = "", skipLoad = false, isBurndown = false }) {
          const dimensions = [...assignmentObject.recordsDataset.dimensions].map((d) => d.id);
          const measures = [...assignmentObject.recordsDataset.measures].map((d) => d.id);
          const uniqueIdField = "Id";
          prefix = prefix ? `${prefix}_` : "";
          if (!projectionFields) {
            if (returnType === "count") {
              projectionFields = this.getProjectionFields({ node, referenceFields });
            } else {
              projectionFields = /* @__PURE__ */ new Set([...dimensions, ...measures]);
            }
          }
          const referenceProjections = referenceFields.reduce((str, field) => {
            const aggregatePrefix = field.type === "Text" ? "unique" : "sum";
            str += ` ${aggregatePrefix}('${field.name}') as ${field.name},`;
            return str;
          }, "");
          function projection(dataStream = "") {
            const streamPrefix = dataStream ? `${dataStream}.` : "";
            return [
              ...dimensions.filter((d) => projectionFields.has(d)).map((d) => `${streamPrefix}${d} as ${d}`),
              ...measures.filter((m) => projectionFields.has(m)).map((m) => `sum(${streamPrefix}${m}) as ${m}`)
            ].join(", ");
          }
          function grouping() {
            return `(${dimensions.filter((d) => projectionFields.has(d)).map((f) => f).join(", ")})`;
          }
          if (!node.parentId) {
            const filterNodes = isBurndown && node === SPM.$store.rootNode ? [node, ...descendantNodes] : descendantNodes;
            return `
                    ${skipLoad ? `` : `
                            -- load records
                            q = load "${assignmentObject.recordsDataset.id}/${assignmentObject.recordsDataset.currentVersionId}";
                        `}

                    ------------------------------------------------------------------
                    -- All Possible
                    ------------------------------------------------------------------
                    ${recordIds ? `
                            all_possible = filter q by ${uniqueIdField} in ${JSON.stringify(recordIds)};
                            all_possible = foreach all_possible generate ${projection()};
                        ` : `
                            all_possible = filter q by ${filterNodes.length ? `(${filterNodes.map((n) => this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)).join(") && (")})` : `${uniqueIdField} is not null`};
                            all_possible = foreach all_possible generate ${projection()};
                        `}
                    ${descendantSaql || (returnType === "count" ? `
                            -- All Org
                            ${prefix}all_possible = group all_possible by all;
                            ${prefix}all_possible = foreach all_possible generate "All Org" as nodeId,${referenceProjections} count() as count;
                        ` : `
                            -- all records
                            ${prefix}all_possible = filter all_possible by ${uniqueIdField} != "";
                        `)}
                `.replace(/^ */gm, "");
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          let saql = "";
          [...node.olderSiblingIds.map((id2) => nodeMap[id2]), node].forEach((n, i) => {
            const parentId = n.parentId.replace("All Org", "");
            saql += `
                    ------------------------------------------------------------------
                    -- ${n.name}${n.id !== node.id ? `(${node.name} sibling)` : ""}
                    ------------------------------------------------------------------
                `;
            saql += `
                    -- rules
                    ${n.id} = filter ${parentId || "all_possible"} by ${this.generateRules(n, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown && n === SPM.$store.rootNode)};
                `;
            if (considerSiblings) {
              if (i === 0) {
                saql += `
                            -- exclusions
                            exclusions = union ${n.id}, ${n.id};
                        `;
              } else {
                saql += type === "join" ? `
                                -- remove exclusions from older siblings
                                ${n.id} = join ${n.id} by ${uniqueIdField} anti, exclusions by ${uniqueIdField};
                            ` : `
                                -- remove exclusions from older siblings
                                ${n.id} = cogroup ${n.id} by ${grouping()} left, exclusions by ${grouping()};
                                ${n.id} = foreach ${n.id} generate ${projection(n.id)}, exclusions.${uniqueIdField} as UnexceptionId;
                                ${n.id} = filter ${n.id} by UnexceptionId is null;
                            `;
                saql += `
                            -- exclusions
                            exclusions = union exclusions, ${n.id};
                        `;
              }
            }
          });
          if (!descendantSaql) {
            saql += `
                    ------------------------------------------------------------------
                    -- Results
                    ------------------------------------------------------------------
                `;
            if (returnType === "count") {
              const resultStreams = [];
              [nodeMap[node.parentId], ...node.olderSiblingIds.map((id2) => nodeMap[id2]), node].forEach((n) => {
                const streamId = n.id === "All Org" ? "all_possible" : n.id;
                saql += `
                            -- ${n.name}
                            ${prefix}${streamId} = group ${streamId} by all;
                            ${prefix}${streamId} = foreach ${prefix}${streamId} generate "${n.id}" as nodeId,${referenceProjections} count() as count;
                        `;
                resultStreams.push(`${prefix}${streamId}`);
              });
              saql += `
                        -- union results for target node, parent node, older siblings
                        results = union ${resultStreams.join(", ")};
                    `;
            } else {
              saql += `
                        -- all records
                        ${prefix}${node.id} = filter ${node.id} by ${uniqueIdField} != "";
                    `;
            }
          }
          return this.generateSaql({
            node: nodeMap[node.parentId || "All Org"],
            assignmentObject,
            boundaryObjects,
            projectionFields,
            nodeMap,
            recordIds,
            type,
            descendantNodes: descendantSaql ? [node, ...descendantNodes] : descendantNodes,
            descendantSaql: saql + descendantSaql
          });
        },
        generateRules(node, nodeMap, assignmentObject, boundaryObjects, uniqueIdField, isBurndown) {
          var _a, _b;
          const matchingRules = (node.previewRules || node.rules).filter((r) => {
            const matchesAssignmentObject = r.sfsp__SalesAssignmentObject__c === assignmentObject.id && r.state !== "deleted";
            return matchesAssignmentObject;
          });
          const matchingBoundaryRules = (node.previewRules || node.rules).filter((r) => {
            var _a2, _b2, _c;
            const boundaryField = (_a2 = boundaryObjects == null ? void 0 : boundaryObjects.find((o) => o.id === r.sfsp__SalesNodeBoundary__c)) == null ? void 0 : _a2.name;
            const matchesBoundary = (_c = (_b2 = assignmentObject.recordsDataset) == null ? void 0 : _b2.dimensions) == null ? void 0 : _c.some((f) => f.id === boundaryField);
            return matchesBoundary;
          });
          const matchingAssignments = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted");
          const burndownNodes = isBurndown ? node.children : [];
          if (matchingRules.length === 0 && matchingBoundaryRules.length === 0 && matchingAssignments.length === 0 && burndownNodes.length === 0)
            return `${uniqueIdField} is null`;
          const ruleAndAssignmentSaqlParts = [];
          if (matchingRules.length) {
            const matchingRulesLogic = ((_a = node == null ? void 0 : node.previewRuleLogics) == null ? void 0 : _a[assignmentObject.id]) || ((_b = node == null ? void 0 : node.ruleLogics) == null ? void 0 : _b[assignmentObject.id]) || Array(matchingRules.length).fill().map((item, i) => i + 1).join(" or ");
            const matchingRulesFilterExpression = SPM.Utils.Filter.mergeBooleanFilter(
              matchingRulesLogic,
              matchingRules.map((r) => Rule.toSaql(r, assignmentObject))
            );
            ruleAndAssignmentSaqlParts.push(`(${matchingRulesFilterExpression})`);
          }
          if (matchingBoundaryRules.length) {
            ruleAndAssignmentSaqlParts.push(`(${matchingBoundaryRules.map((r) => Rule.toSaql(r, assignmentObject)).join(" || ")})`);
          }
          if (matchingAssignments.length) {
            ruleAndAssignmentSaqlParts.push(`${uniqueIdField} in ${JSON.stringify(matchingAssignments.map((a) => a.sfsp__RecordId__c))}`);
          }
          const saqlParts = [];
          if (ruleAndAssignmentSaqlParts.length) {
            saqlParts.push(`(${ruleAndAssignmentSaqlParts.join(" || ")})`);
          }
          const considerSiblings = nodeMap[node.parentId || "All Org"].assignmentBehavior === "Exclusive";
          if (considerSiblings) {
            const unexceptionIds = Node2.getUnexceptionIds(node, nodeMap, assignmentObject);
            if (unexceptionIds.length) {
              saqlParts.push(`${uniqueIdField} not in ${JSON.stringify(unexceptionIds)}`);
            }
          }
          if (burndownNodes.length) {
            const childSaqlParts = burndownNodes.map((childNode) => `(${Node2.generateRules(childNode, nodeMap, assignmentObject, boundaryObjects, uniqueIdField)})`);
            saqlParts.push(`!(${childSaqlParts.join(" || ")})`);
          }
          return saqlParts.join(" && ");
        },
        getUnexceptionIds(node, nodeMap, assignmentObject) {
          const nodeExceptionMap = (node.previewAssignments || node.assignments).filter((a) => a.sfsp__SalesAssignmentObject__c === assignmentObject.id && a.sfsp__Status__c !== "Deleted").reduce((map2, a) => {
            map2[a.sfsp__RecordId__c] = a;
            return map2;
          }, {});
          const unexceptionMap = [];
          node.siblingIds.forEach((siblingId) => {
            const siblingNode = nodeMap[siblingId];
            const siblingIsOlder = node.olderSiblingIds.includes(siblingId);
            (siblingNode.previewAssignments || siblingNode.assignments).forEach((siblingAssignment) => {
              if (siblingAssignment.sfsp__SalesAssignmentObject__c !== assignmentObject.id || siblingAssignment.sfsp__Status__c === "Deleted")
                return;
              if (siblingIsOlder || !nodeExceptionMap[siblingAssignment.sfsp__RecordId__c])
                unexceptionMap[siblingAssignment.sfsp__RecordId__c] = siblingAssignment;
            });
          });
          return Object.keys(unexceptionMap);
        },
        getDescendants({ nodes }) {
          if (nodes.length === 0)
            return [];
          const childNodes = nodes.reduce((arr, n) => arr.concat(n.children || []), []);
          return [
            ...nodes,
            ...Node2.getDescendants({ nodes: childNodes })
          ];
        },
        getAncestors({ node, nodeMap }) {
          const ancestors = [];
          while (node = nodeMap[node.parentId]) {
            ancestors.unshift(node);
          }
          return ancestors;
        },
        isAncestor({ node, ancestor, nodeMap }) {
          while (node = nodeMap[node.parentId]) {
            if (node === ancestor)
              return true;
          }
          return false;
        },
        async getChildren({ node }) {
          const children2 = [];
          const childrenResponse = await SPM.Utils.Apex.invoke(
            "Query",
            [`
                    SELECT
                        Id,
                        Name,
                        sfsp__Parent__c,
                        (
                            SELECT
                                Id,
                                sfsp__TargetOverrideAmount__c,
                                sfsp__TargetOverrideType__c,
                                ${Array(12).fill().map((v, i) => `sfsp__Target_Month${i + 1}__c`).join(", ")},
                                sfsp__SalesMetric__c
                            FROM sfsp__SalesNodeMetrics__r
                        ),
                        (
                            SELECT Id
                            FROM sfsp__SalesNodes__r
                        )
                    FROM sfsp__SalesNode__c
                    WHERE sfsp__SalesPlan__c = '${SPM.$store.plan.Id}' AND sfsp__Parent__c = '${node.id}'
                `]
          );
          childrenResponse.forEach((c) => {
            var _a;
            children2.push({
              id: c.Id,
              name: c.Name,
              parentId: c.sfsp__Parent__c || "All Org",
              childCount: ((_a = c.sfsp__SalesNodes__r) == null ? void 0 : _a.length) || 0,
              metrics: SPM.$store.plan.sfsp__SalesMetrics__r.map((metric) => {
                const nodeMetric = (c.sfsp__SalesNodeMetrics__r || []).find((m) => m.sfsp__SalesMetric__c === metric.Id);
                return {
                  ...NodeMetric.Defaults,
                  sfsp__SalesNode__c: node.id,
                  sfsp__SalesMetric__c: metric.Id,
                  ...nodeMetric || {}
                };
              })
            });
          });
          return children2;
        },
        isExclusiveBranch({ node }) {
          return Node2.getDescendants({ nodes: [node] }).every((n) => n.assignmentBehavior === "Exclusive");
        },
        getBoundaryObjects({ node, nodeMap, includeDescendants = false }) {
          return [...Node2.getAncestors({ node, nodeMap }), ...includeDescendants ? Node2.getDescendants({ nodes: [node] }) : [node]].reduce((arr, n) => {
            arr.push(...(n.boundaries || []).map((b) => {
              const salesBoundary = SPM.$store.salesBoundaries.find((s) => s.Id === b.sfsp__SalesBoundary__c);
              const containerSet = SPM.$store.containerSets[b.sfsp__ContainerSet__c];
              const includesPoints = (salesBoundary == null ? void 0 : salesBoundary.sfsp__IncludePoints__c) || b.sfsp__IncludePoints__c;
              const fieldName = salesBoundary ? `${n.id === "All Org" || b.sfsp__SalesBoundary__c ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}${includesPoints ? "_points" : ""}` : `${n.id === "All Org" ? SPM.$store.plan.Id : n.id}_${b.sfsp__ContainerSet__c}`;
              return {
                id: b.Id,
                containerSetId: (salesBoundary == null ? void 0 : salesBoundary.sfsp__ContainerSet__c) || b.sfsp__ContainerSet__c,
                salesBoundary: b == null ? void 0 : b.sfsp__SalesBoundary__c,
                rootNodeId: n.id,
                name: fieldName,
                includesPoints,
                label: containerSet.label,
                metadata: containerSet.metadata,
                assignmentCount: 0,
                totalCount: containerSet.size + (b.sfsp__IncludePoints__c ? Object.keys(containerSet.childContainers || {}).length : 0),
                progress: null,
                icon: { category: "standard", name: "address", color: "#3BA755" }
              };
            }));
            return arr;
          }, []);
        },
        getBoundaries({ node, boundaryObject, format: format2 = "array" }) {
          let containers2 = SPM.$store.containerSets[boundaryObject.containerSetId].containers;
          if (!boundaryObject.includesPoints) {
            containers2 = Object.keys(containers2).filter((key) => !containers2[key].parent).reduce((res, key) => (res[key] = containers2[key], res), {});
          }
          if (boundaryObject.rootNodeId === node.id) {
            return format2 === "map" ? Object.values(containers2).reduce((map2, boundary) => {
              map2[boundary.name] = true;
              return map2;
            }, {}) : Object.values(containers2).map((boundary) => boundary.name);
          }
          const boundaryRule = (node.previewRules || node.rules).find((r) => r.sfsp__SalesNodeBoundary__c === boundaryObject.id);
          const boundaryValueMap = ((boundaryRule == null ? void 0 : boundaryRule.sfsp__SalesNodeRuleItems__r) || []).reduce((map2, ruleItem) => {
            ruleItem.sfsp__Value__c.split(",").forEach((v) => map2[v] = true);
            return map2;
          }, {});
          const boundaryPrefixValues = Object.keys(boundaryValueMap);
          const expandedBoundaries = SPM.Utils.Rule.unsimplifyValues(Object.values(containers2).map((c) => c.name), boundaryPrefixValues);
          const boundaries = expandedBoundaries.map((boundary) => containers2[boundary]);
          return format2 === "map" ? boundaries.reduce((map2, boundary) => {
            map2[boundary.name] = true;
            return map2;
          }, {}) : boundaries.map((boundary) => boundary.name);
        },
        async getBoundaryData({ nodes, boundaryObject }) {
          var _a, _b;
          const boundaryNodeMap = {};
          Node2.getDescendants({ nodes }).forEach((descendant) => {
            if (descendant.level > SPM.$store.scope)
              return;
            SPM.Utils.Node.getBoundaries({ node: descendant, boundaryObject }).forEach((boundary) => {
              boundaryNodeMap[boundary] = boundaryNodeMap[boundary] || [];
              const newBoundaryNodes = [];
              let isAncestor = false;
              boundaryNodeMap[boundary].forEach((n) => {
                if (SPM.Utils.Node.isAncestor({ node: n, ancestor: descendant, nodeMap: SPM.$store.nodeMap })) {
                  isAncestor = true;
                  return;
                } else if (!SPM.Utils.Node.isAncestor({ node: descendant, ancestor: n, nodeMap: SPM.$store.nodeMap })) {
                  newBoundaryNodes.push(n);
                }
              });
              if (!isAncestor)
                newBoundaryNodes.push(descendant);
              boundaryNodeMap[boundary] = newBoundaryNodes;
            });
          });
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === boundaryObject.name);
          });
          const containerMap = SPM.$store.containerMap[boundaryObject.containerSetId];
          const recordMap = {};
          Object.keys(boundaryNodeMap).forEach((boundary) => {
            recordMap[boundary] = {
              id: boundary,
              label: containerMap[boundary].label,
              nodeId: boundaryNodeMap[boundary][0].id,
              // nodeId is only used in exclusive assignment where there will be a single value
              AssignedTo: boundaryNodeMap[boundary].map((n) => n.name).join(", ")
            };
            objectsWithGeoField.forEach((o) => recordMap[boundary][o.id] = 0);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            nodes.forEach((node) => {
              saql += SPM.Utils.Node.generateSaql({
                node,
                assignmentObject,
                boundaryObjects: SPM.$store.boundaryObjects,
                nodeMap: SPM.$store.nodeMap,
                type: "cogroup",
                returnType: "records",
                prefix: "boundary",
                skipLoad: !!saql
              });
            });
            let rootStream = "all_possible";
            if (nodes.length > 1) {
              saql += `
                        ------------------------------------------------------------------
                        -- Combine Filter Nodes
                        ------------------------------------------------------------------
                        all_possible = union ${nodes.map((n) => `boundary_${n.id}`).join(", ")};
                    `;
            } else {
              rootStream = `boundary_${nodes[0].id.replace("All Org", "all_possible")}`;
            }
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === boundaryObject.name);
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, count() as '${assignmentObject.id}';
                    boundaries = order boundaries by '${assignmentObject.id}' desc;
                `;
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            ((results == null ? void 0 : results.records) || []).forEach((record) => {
              const existingRecord = recordMap[record[geoField.id]];
              if (existingRecord) {
                existingRecord[assignmentObject.id] = record[assignmentObject.id];
              }
            });
          }
          return Object.values(recordMap);
        },
        async getAssignments({ recordIds, assignmentObject, nodes = SPM.$store.scopeChildNodes }) {
          const assignments = recordIds.reduce((map2, id2) => {
            map2[id2] = [];
            return map2;
          }, {});
          await Async.forEachParallel(nodes, async (node) => {
            const saql = Node2.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              recordIds,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            results.records.forEach((record) => {
              var _a, _b, _c;
              const currentLevel = ((_c = (_b = SPM.$store.nodeMap) == null ? void 0 : _b[(_a = assignments[record.Id]) == null ? void 0 : _a[0]]) == null ? void 0 : _c.level) || 0;
              if (node.level > currentLevel) {
                assignments[record.Id] = [node.id];
              } else if (node.level === currentLevel) {
                assignments[record.Id].push(node.id);
              }
            });
          });
          return assignments;
        },
        async getAssignmentData({ nodes, includeDescendants = false, filters = [], filterLogic, assignmentObject, type, isBurndown }) {
          let saql = "";
          nodes.forEach((node) => {
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "filter",
              skipLoad: !!saql,
              isBurndown
            });
          });
          let rootStream = "all_possible";
          if (nodes.length > 1) {
            saql += `
                    ------------------------------------------------------------------
                    -- Combine Nodes
                    ------------------------------------------------------------------
                    all_possible = union ${nodes.map((n) => `filter_${n.id.replace("All Org", "all_possible")}`).join(", ")};
                `;
          } else {
            rootStream = `filter_${nodes[0].id.replace("All Org", "all_possible")}`;
          }
          if (filters.length) {
            const recordFiltersExpression = SPM.Utils.Filter.mergeBooleanFilter(
              filterLogic || Array(filters.length).fill("").map((item, i) => i + 1).join(" and "),
              filters.map((f) => SPM.Utils.Filter.toSaql(f))
            );
            saql += `
                    ------------------------------------------------------------------
                    -- Record Filters
                    ------------------------------------------------------------------
                    q = filter ${rootStream} by ${recordFiltersExpression};
                `;
            rootStream = "q";
          }
          if (type === "aggregates") {
            const referenceMetadata = AssignmentObject.getReferenceMetadata({ assignmentObject });
            saql += `
                    ------------------------------------------------------------------
                    -- Measure Aggregation
                    ------------------------------------------------------------------
                    q = group ${rootStream} by all;
                    q = foreach q generate ${referenceMetadata.map(
              (m) => ["min", "max"].includes(m.type) ? `floor(${m.type}(${m.id})) as ${m.type}__${assignmentObject.id}__${m.id}` : `${m.type}(${m.id}) as ${m.type}__${assignmentObject.id}__${m.id}`
            ).join(", ")};
                `;
            const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            return referenceMetadata.reduce((map2, m) => {
              var _a, _b, _c, _d;
              map2[`${m.type}__${assignmentObject.id}__${m.id}`] = ["min", "max"].includes(m.type) ? (_b = (_a = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _a[0]) == null ? void 0 : _b[`${m.type}__${assignmentObject.id}__${m.id}`] : ((_d = (_c = aggregateResults == null ? void 0 : aggregateResults.records) == null ? void 0 : _c[0]) == null ? void 0 : _d[`${m.type}__${assignmentObject.id}__${m.id}`]) || 0;
              return map2;
            }, {});
          }
          if (type === "records") {
            saql += `
                    ------------------------------------------------------------------
                    -- Record Projections
                    ------------------------------------------------------------------
                    q = foreach ${rootStream} generate ${[
              ...assignmentObject.recordsDataset.dimensions.map((d) => d.id),
              ...assignmentObject.recordsDataset.measures.map((m) => m.id)
            ].map((f) => `${f} as ${assignmentObject.id}__${f}`).join(", ")};
                `;
            const { results: recordResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const records = Object.values(((recordResults == null ? void 0 : recordResults.records) || []).reduce((map2, record) => {
              const recordId = record[`${assignmentObject.id}__Id`];
              if (!map2[recordId])
                map2[recordId] = record;
              return map2;
            }, {}));
            const assignments = await SPM.Utils.Node.getAssignments({
              recordIds: records.map((r) => r[`${assignmentObject.id}__Id`]),
              assignmentObject,
              nodes: includeDescendants ? SPM.Utils.Node.getDescendants({ nodes: [SPM.$store.rootNode] }) : SPM.$store.scopeNodes
            });
            const cachedNodeAssignments = /* @__PURE__ */ new Map();
            records.forEach((record) => {
              var _a;
              const recordId = record[`${assignmentObject.id}__Id`];
              assignments[recordId].forEach((nodeId2) => {
                if (!cachedNodeAssignments.has(nodeId2)) {
                  cachedNodeAssignments.set(nodeId2, new Map(SPM.$store.nodeMap[nodeId2].assignments.map((a) => [`${a.sfsp__RecordId__c}:${a.sfsp__SalesAssignmentObject__c}`, a])));
                }
              });
              record.NodeId = ((_a = assignments[recordId]) == null ? void 0 : _a[0]) || "";
              record.AssignedTo = assignments[recordId].join(", ");
              record.AssignmentType = assignments[recordId].map((nodeId2) => cachedNodeAssignments.get(nodeId2).has(`${recordId}:${assignmentObject.id}`) ? "Manual" : "Rule").join(", ") || "Rule";
            });
            return records;
          }
          if (type === "saql") {
            return { saql, rootStream };
          }
        },
        Colors: [
          // standard; a11y
          "#FFFA00",
          "#FF6E00",
          "#FF7B96",
          "#D31A28",
          "#D053FF",
          "#6C2777",
          "#46E71B",
          "#6FB384",
          "#68FFD7",
          "#01BFBF",
          "#ADD4F3",
          "#2C7ED0",
          // expanded
          "#e3abec",
          "#c2dbf7",
          "#9fd6ff",
          "#9de7da",
          "#9df0c0",
          "#fff099",
          "#fed49a",
          "#d073e0",
          "#86baf3",
          "#5ebbff",
          "#44d8be",
          "#3be282",
          "#ffe654",
          "#ffb758",
          "#bd35bd",
          "#5779c1",
          "#05007a",
          "#00aea9",
          "#3cba4c",
          "#f5bc25",
          "#f99221",
          "#580d8c",
          "#001970",
          "#0a2399",
          "#0b7477",
          "#0b6b50",
          "#b67e11",
          "#b85d0d"
        ],
        randomColor() {
          return SPM.Utils.Node.Colors[Math.floor(Math.random() * SPM.Utils.Node.Colors.length)];
        }
      };
      const NodeMetric = {
        Defaults: {
          sobjectType: "sfsp__SalesNodeMetric__c",
          sfsp__TargetOverrideAmount__c: 0,
          sfsp__TargetOverrideType__c: null,
          ...[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].reduce((fieldMap, monthIndex) => {
            fieldMap[`sfsp__Target_Month${monthIndex}__c`] = 0;
            fieldMap[`previewValue${monthIndex}`] = void 0;
            return fieldMap;
          }, {})
        },
        changeTarget({ nodeMetric, period, index, target, isPreview, startingMonth, customPercentages }) {
          function targetFieldName(i) {
            return isPreview ? `previewValue${i}` : `sfsp__Target_Month${i}__c`;
          }
          if (customPercentages) {
            for (let i = 1; i < 13; i++) {
              const monthValue = customPercentages[i];
              nodeMetric[targetFieldName(i)] = monthValue;
            }
          } else if (period === "Year") {
            const monthValue = Math.floor(target / 12);
            for (let i = 1; i < 12; i++) {
              nodeMetric[targetFieldName(i)] = monthValue;
            }
            nodeMetric[targetFieldName(12)] = monthValue + (target - monthValue * 12);
          } else if (period === "Quarter") {
            const monthValue = Math.floor(target / 3);
            let month = startingMonth + (index - 1) * 3 <= 12 ? startingMonth + (index - 1) * 3 : (startingMonth + (index - 1) * 3) % 12;
            for (let i = 0; i < 2; i++) {
              nodeMetric[targetFieldName(month)] = monthValue;
              month = month + 1 <= 12 ? month + 1 : (month + 1) % 12;
            }
            nodeMetric[targetFieldName(month)] = monthValue + (target - monthValue * 3);
          } else {
            const month = index + startingMonth - 1 <= 12 ? index + startingMonth - 1 : (index + startingMonth - 1) % 12;
            nodeMetric[targetFieldName(month)] = target;
          }
        },
        getTarget({ nodeMetric, period = "Year", index = 0 }) {
          let startMonth;
          let endMonth;
          if (period === "Year") {
            startMonth = 1;
            endMonth = 12;
          } else if (period === "Quarter") {
            startMonth = (index - 1) * 3 + 1;
            endMonth = index * 3;
          } else {
            startMonth = index;
            endMonth = index;
          }
          let target = 0;
          for (let i = startMonth; i <= endMonth; i++) {
            target += typeof nodeMetric[`previewValue${i}`] === "undefined" ? nodeMetric[`sfsp__Target_Month${i}__c`] : nodeMetric[`previewValue${i}`];
          }
          return target;
        }
      };
      const Allocation = {
        generateAllocationDistributionTable() {
          const allocationTable = [];
          const quarterLength = SPM.FiscalPeriod.Quarter.length;
          const percentToAllocateEachQuarter = Math.round(100 / quarterLength * 10) / 10;
          for (let i = 0; i < quarterLength; i++) {
            const months2 = SPM.FiscalPeriod.Quarter[i];
            allocationTable[i] = allocationTable[i] || { months: [], percent: percentToAllocateEachQuarter, label: `Quarter ${i + 1}`, previewPercent: null };
            allocationTable[i].percent = percentToAllocateEachQuarter;
            const percentToAllocateEachMonth = Math.round(percentToAllocateEachQuarter / months2.length * 10) / 10;
            for (let m = 0; m < months2.length - 1; m++) {
              const id2 = months2[m];
              const monthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[id2] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, id2 - 1), { month: "long" });
              allocationTable[i].months.push({
                label: monthLabel,
                percent: percentToAllocateEachMonth,
                id: id2,
                previewPercent: null
              });
            }
            const lastMonthOfQuarter = months2[months2.length - 1];
            const lastMonthLabel = !SPM.$store.plan.fiscalPeriodLabel ? SPM.FiscalLabels.Month[lastMonthOfQuarter] : SPM.app.config.globalProperties.$F("DateTime", new Date(2023, lastMonthOfQuarter - 1), { month: "long" });
            allocationTable[i].months.push({
              label: lastMonthLabel,
              percent: Math.round((percentToAllocateEachMonth + (percentToAllocateEachQuarter - percentToAllocateEachMonth * months2.length)) * 10) / 10,
              id: lastMonthOfQuarter,
              previewPercent: null
            });
          }
          allocationTable[quarterLength - 1].percent = Math.round((percentToAllocateEachQuarter + (100 - percentToAllocateEachQuarter * quarterLength)) * 10) / 10;
          return allocationTable;
        },
        getPercentageChange(oldNumber, newNumber) {
          const decreaseValue = newNumber - oldNumber;
          const change = Math.floor(decreaseValue / oldNumber * 100);
          if (change === 0 || decreaseValue === 0) {
            return "0%";
          }
          if (change === Infinity) {
            return `+ ${newNumber}%`;
          }
          return change > 0 ? `+ ${change}%` : `- ${change * -1}%`;
        }
      };
      const ExternalData = {
        // https://developer.salesforce.com/docs/atlas.en-us.238.0.bi_dev_guide_ext_data.meta/bi_dev_guide_ext_data/bi_ext_data_overview.htm
        generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries }) {
          const fields = [];
          JSON.parse(assignmentObject.sfsp__ReferenceFields__c).forEach((f) => {
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${f.name}`,
              name: f.name,
              label: f.label,
              isUniqueId: f.unique,
              type: f.type,
              isSystemField: false,
              isMultiValue: false,
              description: ""
            };
            if (f.type === "Numeric") {
              field.precision = f.precision;
              field.scale = f.scale;
              field.defaultValue = 0;
            }
            if (["Latitude", "Longitude"].includes(f.type))
              field.type = "Text";
            fields.push(field);
          });
          const boundaryFields = [];
          geoBoundaries == null ? void 0 : geoBoundaries.forEach((boundary) => {
            const fieldName = `${boundary.sfsp__SalesNode__c || boundary.sfsp__SalesPlan__c}_${boundary.sfsp__ContainerSet__c}`;
            const field = {
              fullyQualifiedName: `${assignmentObject.Id}.${fieldName}`,
              name: fieldName,
              label: boundary.Name,
              isUniqueId: false,
              type: "Text",
              isMultiValue: false,
              description: ""
            };
            const existingField = boundaryFields.find((f) => f.name === field.name);
            if (existingField)
              Object.assign(existingField, field);
            else
              boundaryFields.push(field);
          });
          fields.push(...boundaryFields);
          if (datasetType === "Assignments") {
            fields.push(
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentNode`,
                label: "Assignment Node",
                name: "AssignmentNode",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              },
              {
                description: "",
                fullyQualifiedName: `${assignmentObject.Id}.AssignmentType`,
                label: "Assignment Type",
                name: "AssignmentType",
                isSystemField: false,
                isUniqueId: false,
                isMultiValue: false,
                type: "Text"
              }
            );
          }
          return {
            fileFormat: {
              charsetName: "UTF-8",
              fieldsDelimitedBy: ",",
              fieldsEnclosedBy: '"',
              fieldsEscapedBy: "",
              linesTerminatedBy: "\r\n",
              numberOfLinesToIgnore: 0
            },
            objects: [
              {
                connector: "SalesPlanningCSVConnector",
                fullyQualifiedName: assignmentObject.Id,
                label: `${planName} ${assignmentObject.sfsp__Label__c} ${datasetType}`,
                name: assignmentObject.Name,
                description: "",
                fields
              }
            ]
          };
        },
        async getDatasetRecords({ alias, assignmentObject }) {
          const { dataset: recordsDataset, metadata: recordsMetadata } = await SPM.Utils.AssignmentObject.getDatasetInfo({ alias });
          Object.assign(recordsDataset, {
            measures: recordsMetadata.measures.map((m) => ({
              type: "measure",
              id: m.field,
              title: m.label
            })),
            measuresMetadata: recordsMetadata.measures,
            dimensions: recordsMetadata.dimensions.map((d) => ({
              type: "dimension",
              id: d.field,
              title: d.label
            }))
          });
          const datasetRowMap = {};
          const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
          await async function getBatch(offset2, batchSize) {
            const saql = `
                    // total records
                    records_batch = load "${recordsDataset.id}/${recordsDataset.currentVersionId}";
                    records_batch = foreach records_batch generate ${recordsDataset.dimensions.concat(recordsDataset.measures).map((field) => `'${field.id}' as '${field.id}'`).join(", ")};
                    records_batch = order records_batch by '${uniqueIdField}';
                    records_batch = offset records_batch ${offset2};
                    records_batch = limit records_batch ${batchSize};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              datasetRowMap[record[uniqueIdField]] = record;
            });
            if (results.records.length === batchSize)
              await getBatch(offset2 + batchSize, batchSize);
          }(0, 1e4);
          return datasetRowMap;
        },
        async updateDataset({ planId, planName, datasetType, assignmentObject, geoBoundaries, rowsToUpdate }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject, geoBoundaries });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const datasetRowMap = await this.getDatasetRecords({ alias: `${planId}_${assignmentObject.Id}_Records`, assignmentObject });
            const uniqueIdField = JSON.parse(assignmentObject.sfsp__ReferenceFields__c).find((f) => f.unique).name;
            rowsToUpdate.forEach((row) => {
              const existingRow = datasetRowMap[row[uniqueIdField]];
              if (existingRow) {
                Object.keys(row).forEach((fieldName) => {
                  existingRow[fieldName] = row[fieldName];
                });
                datasetRowMap[row[uniqueIdField]] = existingRow;
              }
            });
            const recordBatches = [];
            const rowValues = Object.values(datasetRowMap);
            while (rowValues.length)
              recordBatches.push(rowValues.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => record[field.name] || (field.type === "Text" ? "" : 0))));
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa.unparse(batch);
              const chunkSize = 3e6;
              Papa.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        },
        async createManualDataset({ planId, planName, datasetType, assignmentObject, records }) {
          const csvMetadata = this.generateMetadata({ planName, datasetType, assignmentObject });
          const jobResponse = await SPM.Utils.Rest.invoke("CreateExternalDataJob", { metadata: Buffer2.from(JSON.stringify(csvMetadata, 0, 4)).toString("base64"), alias: `${planId}_${assignmentObject.Id}_${datasetType}`, operation: "Overwrite" });
          if (!jobResponse.success)
            throw jobResponse.errors[0] || "";
          const csvParts = [];
          if (datasetType === "Records") {
            const recordBatches = [];
            while (records.length) {
              recordBatches.push(records.splice(0, 1e6).map((record) => csvMetadata.objects[0].fields.map((field) => {
                return getValueFromRecord(field.name, record) || (field.type === "Text" ? "" : 0);
              })));
            }
            await Async.forEachParallel(recordBatches, async (batch) => {
              const csv = Papa.unparse(batch);
              const chunkSize = 3e6;
              Papa.parse(csv, {
                chunkSize,
                chunk(results, parser) {
                  csvParts.unshift(Papa.unparse(results.data));
                }
              });
            }, 5);
          } else if (datasetType === "Assignments") {
            const placeholderRow = csvMetadata.objects[0].fields.map((f) => f.type === "Text" ? "spm_placeholder" : 0);
            const csv = Papa.unparse([placeholderRow]);
            const chunkSize = 3e6;
            Papa.parse(csv, {
              chunkSize,
              chunk(results, parser) {
                csvParts.unshift(Papa.unparse(results.data));
              }
            });
          }
          let partNumber = 0;
          await SPM.Utils.Async.forEachParallel(csvParts, async (data) => {
            const base64String = Buffer2.from(partNumber === csvParts.length - 1 ? data : `${data}\r
`).toString("base64");
            const csvPart = base64String;
            partNumber += 1;
            const partResponse = await SPM.Utils.Rest.invoke("UploadCsvPart", { parentId: jobResponse.id, csvPart, partNumber });
            if (!partResponse.success)
              throw partResponse.errors[0] || "";
          }, 5);
          await SPM.Utils.Rest.invoke("StartExternalDataJob", { parentId: jobResponse.id });
        }
      };
      const AutoAssignment = {
        async buildAssignmentObjectScus({ balanceField, geoAssignment, selectedObject, selectedRecords, targetNodeIds }) {
          const rootNodeId = SPM.$store.rootNode.id === "All Org" ? SPM.$store.plan.Id : SPM.$store.rootNode.id;
          const containerSetIds = /* @__PURE__ */ new Set();
          SPM.$store.boundaryObjects.forEach((o) => containerSetIds.add(o.containerSetId));
          const scus = {};
          selectedRecords.forEach((unit) => {
            var _a, _b;
            const boundaryFields = Object.keys(unit).filter((fieldName) => fieldName.startsWith(`${selectedObject.id}__${rootNodeId}`));
            const boundaryKey = boundaryFields.find((f) => !!unit[f]);
            let boundary = unit[boundaryKey] || "";
            const record = {
              Id: unit[`${selectedObject.id}__Id`],
              Locked: false,
              Boundaries: boundary || "",
              Weight: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0,
              Volume: balanceField === "Unit" ? 1 : unit[`${selectedObject.id}__${balanceField}`] || 0
            };
            const latitudeField = (_a = selectedObject.latitude) == null ? void 0 : _a.name;
            const longitudeField = (_b = selectedObject.longitude) == null ? void 0 : _b.name;
            if (latitudeField && longitudeField) {
              record.Latitude = parseFloat(unit[`${selectedObject.id}__${latitudeField}`]);
              record.Longitude = parseFloat(unit[`${selectedObject.id}__${longitudeField}`]);
            }
            if (geoAssignment === "nonContiguous" && (!record.Latitude || !record.Longitude)) {
              const middleUSA = { latitude: 39.8283, longitude: 98.5795 };
              const radius = 944685;
              const randomPoint = randomLocation.randomCirclePoint(middleUSA, radius);
              record.Latitude = randomPoint.latitude;
              record.Longitude = randomPoint.longitude;
            }
            if (record.Latitude && record.Longitude)
              scus[record.Id] = record;
          });
          const assignmentNodes = targetNodeIds.map((id2) => SPM.$store.nodeMap[id2]);
          for (const assignmentNode of assignmentNodes) {
            const saql = SPM.Utils.Node.generateSaql({
              node: assignmentNode,
              assignmentObject: selectedObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records"
            });
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            const boundaryRollup = results.records.reduce((agg, rec) => {
              const boundaryFields = Object.keys(rec).filter((fieldName) => fieldName.startsWith(rootNodeId));
              boundaryFields.forEach((fieldName) => {
                let boundary = rec[fieldName] || "";
                if (agg.includes(boundary))
                  ;
                else if (agg.length === 0)
                  agg = boundary;
                else
                  agg = `${agg},${boundary}`;
              });
              return agg;
            }, "");
            const weightRollup = results.records.reduce((agg, rec) => {
              if (scus[rec.Id])
                return agg;
              return agg + (balanceField === "Unit" ? 1 : rec[balanceField] || 0);
            }, 0);
            scus[`${assignmentNode.id}-Rollup`] = {
              Id: `${assignmentNode.id}-Rollup`,
              Assignment: assignmentNode.id,
              Boundaries: boundaryRollup,
              Locked: true,
              Latitude: 39.8283,
              Longitude: 98.5795,
              Weight: weightRollup,
              Volume: weightRollup
            };
          }
          return { scus: [...Object.values(scus)], containerSetIds };
        },
        async buildBoundaryObjectScus({ balanceField, selectedObject, selectedBoundaries, node }) {
          var _a, _b;
          const weightMap = {};
          const objectsWithGeoField = SPM.$store.assignmentObjects.filter((o) => {
            var _a2, _b2;
            return (_b2 = (_a2 = o.recordsDataset) == null ? void 0 : _a2.dimensions) == null ? void 0 : _b2.find((f) => f.id === selectedObject.name);
          });
          for (const assignmentObject of objectsWithGeoField) {
            let saql = "";
            saql += SPM.Utils.Node.generateSaql({
              node,
              assignmentObject,
              boundaryObjects: SPM.$store.boundaryObjects,
              nodeMap: SPM.$store.nodeMap,
              type: "cogroup",
              returnType: "records",
              prefix: "drilldown",
              skipLoad: !!saql
            });
            const rootStream = `drilldown_${node.id.replace("All Org", "all_possible")}`;
            const geoField = (_b = (_a = assignmentObject.recordsDataset) == null ? void 0 : _a.dimensions) == null ? void 0 : _b.find((f) => f.id === selectedObject.name);
            const aggregateProjection = balanceField === "Unit" ? `count() as ${balanceField}` : `sum('${balanceField}') as '${balanceField}'`;
            saql += `
                    ------------------------------------------------------------------
                    -- Boundary Filter
                    ------------------------------------------------------------------
                    ${rootStream} = filter ${rootStream} by ${geoField.id} ${node.id === SPM.$store.rootNode.id ? "in" : "not in"} ${JSON.stringify(selectedBoundaries)};

                    ------------------------------------------------------------------
                    -- Boundary Aggregation
                    ------------------------------------------------------------------
                    boundaries = group ${rootStream} by ${`'${geoField.id}'`};
                    boundaries = foreach boundaries generate ${`'${geoField.id}' as '${geoField.id}'`}, ${aggregateProjection};
                `;
            const { query, results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") }) || { query: "", records: [] };
            results.records.forEach((record) => {
              const boundaryName = record[geoField.id];
              if (!weightMap[boundaryName])
                weightMap[boundaryName] = 0;
              weightMap[boundaryName] += record[balanceField];
            });
          }
          const scus = {};
          const boundaryMap = SPM.$store.containerMap[selectedObject.containerSetId];
          if (node.id !== SPM.$store.rootNode.id) {
            let boundaryRollup = "";
            let weightRollup = 0;
            let totalLat = 0;
            let totalLng = 0;
            Object.entries(weightMap).forEach(([boundary, weight]) => {
              if (boundaryRollup.length === 0)
                boundaryRollup = boundary;
              else
                boundaryRollup += `, ${boundary}`;
              totalLat += boundaryMap[boundary].metadata.lat;
              totalLng += boundaryMap[boundary].metadata.lng;
              weightRollup += weight;
            });
            const nodeId2 = node.id === "All Org" ? SPM.$store.plan.Id : node.id;
            scus[`${nodeId2}-Rollup`] = {
              Id: `${nodeId2}-Rollup`,
              Locked: true,
              Assignment: node.id,
              Boundaries: boundaryRollup,
              Weight: weightRollup,
              Volume: weightRollup,
              Latitude: totalLat / Object.keys(weightMap).length,
              Longitude: totalLng / Object.keys(weightMap).length
            };
          } else {
            selectedBoundaries.forEach((boundary) => {
              const weight = weightMap[boundary] || 0;
              scus[boundary] = {
                Id: boundary,
                Locked: false,
                Boundaries: boundary,
                Weight: weight,
                Volume: weight,
                Latitude: boundaryMap[boundary].metadata.lat,
                Longitude: boundaryMap[boundary].metadata.lng
              };
            });
          }
          return Object.values(scus);
        }
      };
      const Browser = {
        clearSelection() {
          var _a, _b, _c;
          (_a = window == null ? void 0 : window.getSelection()) == null ? void 0 : _a.empty();
          (_b = window == null ? void 0 : window.getSelection()) == null ? void 0 : _b.removeAllRanges();
          (_c = document == null ? void 0 : document.selection) == null ? void 0 : _c.empty();
        },
        getCursorPosition(input, selectionPoint, { top: top2, left: left2 } = {}) {
          const { offsetLeft: inputX, offsetTop: inputY } = input;
          const div = document.createElement("div");
          const copyStyle = getComputedStyle(input);
          for (const prop of copyStyle)
            div.style[prop] = copyStyle[prop];
          const inputValue = input.tagName === "INPUT" ? input.value.replace(/ /g, ".") : input.value;
          div.textContent = inputValue.substr(0, selectionPoint);
          if (input.tagName === "TEXTAREA")
            div.style.height = "auto";
          if (input.tagName === "INPUT")
            div.style.width = "auto";
          const span = document.createElement("span");
          span.textContent = inputValue.substr(selectionPoint) || ".";
          div.appendChild(span);
          document.body.appendChild(div);
          div.style.position = "absolute";
          div.style.top = "0px";
          div.style.left = "-1000px";
          const { offsetLeft: spanX, offsetTop: spanY } = span;
          document.body.removeChild(div);
          return {
            x: inputX + spanX + (left2 || 0),
            y: inputY + spanY - input.scrollTop + (top2 || 0)
          };
        },
        // sets search params by replacing existing state (i.e. popstate event is not fired)
        setSearchParams(params = {}) {
          const url = new URL(window.location);
          for (const [key, value] of Object.entries(params)) {
            url.searchParams.set(key, value);
          }
          window.history.replaceState({}, "", url);
        }
      };
      const Str = {
        htmlEncode(str) {
          str = this.htmlDecode(str);
          return String(str).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        htmlDecode(stringValue) {
          let returnText = stringValue;
          if (typeof stringValue === "string") {
            if (typeof document === "object") {
              const txt = document.createElement("textarea");
              txt.innerHTML = stringValue;
              returnText = txt.value;
            } else {
              returnText = String(stringValue).replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
            }
          }
          return returnText;
        },
        sanitizeHTML(str) {
          const temp = document.createElement("div");
          temp.textContent = str;
          return temp.innerHTML;
        },
        splitLines(str) {
          return str.split(/\r?\n|\r|\n/g).filter((line) => !!line).map((line) => line.trim());
        },
        truncate(str, { length = 80, ellipsis = true } = {}) {
          return ellipsis && str.length > length && length >= 3 ? `${str.slice(0, length - 3)}...` : str.slice(0, length);
        }
      };
      const Pendo = {
        track(event, payload) {
          if (pendo.visitorId)
            pendo.track(event, payload);
          else
            console.log("Pendo is unable to track this event");
        }
      };
      const Splunk = {
        showLogs(logName = "spm*") {
          const baseSplunkUrl = `https://splunk-web.log-analytics.monitoring.aws-esvc1-useast2.aws.sfdc.is/en-US/app/search/search?q=search `;
          const searchParams = encodeURIComponent(` index=${SPM.instanceName} organizationId=${SPM.orgId} logRecordType=jsLog logName=${logName}`);
          window.open(`${`${baseSplunkUrl}${searchParams}&display.page.search.mode=verbose&dispatch.sample_ratio=1&earliest=-24h%40h&latest=now`}`);
        },
        sendLog({ txnId = SPM.$store.txnId || getGUID(), logName = "spmLog", logPayload = {} }) {
          if (logName === "spmEPT" && SPM.$store.eptCaptured)
            return;
          else if (logName === "spmEPT") {
            SPM.$store.eptCaptured = true;
            logPayload.ept = window.performance.now();
          }
          const logLines = [{
            logName,
            logLevel: "INFO",
            logAttrs: {
              txnId,
              ...logPayload
            }
          }];
          const iframe = document.createElement("iframe");
          iframe.style.display = "none";
          iframe.name = `jslogger_${Date.now()}`;
          document.body.appendChild(iframe);
          const logLinesInput = document.createElement("input");
          logLinesInput.style.display = "none";
          logLinesInput.name = "logLines";
          logLinesInput.value = JSON.stringify(logLines);
          const form = document.createElement("form");
          form.style.display = "none";
          form.method = "POST";
          form.action = `${SPM.orgDomainUrl}/_ui/common/request/servlet/JsLoggingServlet`;
          form.target = iframe.name;
          form.appendChild(logLinesInput);
          document.body.appendChild(form);
          form.submit();
          setTimeout(() => {
            form.remove();
            iframe.remove();
          }, 5e3);
        }
      };
      const Version244 = {
        /**
         * Waiting status metadata was introduced in version 244.4 to the SalesAsyncJob object on the Status field (picklist)
         * Picklist field values do not ship new or removed metadata values in managed package upgrades.
         * The new metadata values are only available on new installs. In this case 244.4 or higher
         * This check will run on every page load to see if the picklist value "Waiting" is available on the SalesAsyncJob object -> Status field
         */
        async checkAsyncJobWaitingStatus() {
          let toastMessage = "";
          try {
            const sObject = "sfsp__SalesAsyncJob__c";
            const statusField = "sfsp__Status__c";
            const sObjectDescribe = await SPM.Utils.Rest.invoke("SObject", { sObject });
            const field = sObjectDescribe.fields.find((f) => f.name === statusField);
            const waitingPicklistValue = field.picklistValues.find((f) => f.value === "Waiting");
            if (!waitingPicklistValue) {
              toastMessage = `Missing status "Waiting" on the ${statusField} field for the sobject ${sObject}`;
              const entityDefQuery = `SELECT DurableId, QualifiedApiName FROM EntityDefinition WHERE QualifiedApiName = '${sObject}'`;
              const entityRecords = await SPM.Utils.Rest.invoke("ToolingQuery", entityDefQuery);
              const entityRecord = entityRecords.records.length ? entityRecords.records[0] : null;
              if (entityRecord) {
                const sObjectToolingDescribe = await SPM.Utils.Rest.invoke("ToolingSObject", { sObject: "CustomField" });
                const toolingFieldsToQuery = sObjectToolingDescribe.fields.map((a) => a.name);
                const metadataCustomFieldQuery = `SELECT ${toolingFieldsToQuery.join(", ")} FROM CustomField WHERE DeveloperName = 'Status' AND EntityDefinitionId = '${entityRecord.DurableId}' AND NamespacePrefix = 'sfsp' LIMIT 1`;
                const customFieldRecords = await SPM.Utils.Rest.invoke("ToolingQuery", metadataCustomFieldQuery);
                if (!customFieldRecords.records.length) {
                  toastMessage = `Could not find ${statusField} field for the sobject ${sObject}`;
                  throw new Error(toastMessage);
                }
                const salesAsyncJobField = customFieldRecords.records.find((f) => f.FullName === `${sObject}.${statusField}`);
                if (!salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.find((f) => f.valueName === "Waiting")) {
                  salesAsyncJobField.Metadata.valueSet.valueSetDefinition.value.push({
                    color: null,
                    default: false,
                    description: null,
                    isActive: null,
                    label: "Waiting",
                    urls: null,
                    valueName: "Waiting"
                  });
                  salesAsyncJobField.Metadata.valueSet.valueSettings = [];
                  const metadata = { Metadata: salesAsyncJobField.Metadata, FullName: salesAsyncJobField.FullName };
                  const url = salesAsyncJobField.attributes.url;
                  try {
                    await SPM.Utils.Rest.invoke("ToolingSObjectPatch", { url, metadata });
                  } catch (ex) {
                    toastMessage = `Error updating ${statusField} field with picklist value "Waiting" for the sobject ${sObject}`;
                    throw new Error(ex);
                  }
                }
              } else {
                toastMessage = `Unable to find the sobject ${sObject}. Missing status "Waiting" on the ${statusField} field.`;
              }
              toastMessage = "";
            }
          } catch (e) {
            if (toastMessage !== "")
              SPM.$store.toast({ state: "error", message: `${toastMessage}.`, subMessage: "Please contact your admin to ensure Sales Planning is properly configured.", duration: null });
            console.log("checkAsyncJobWaitingStatus", e);
          }
        }
      };
      const Segment = SegClient({ Buffer: Buffer2, Papa });
      const Area = {
        getFieldValue(store, area, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = area.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getAreaValue(area);
          } else if (fieldType === "Metadata") {
            fieldValue = area.metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = area[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, area, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Area.getFieldValue(store, area, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Area.getFieldValue(store, area, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Area.getFieldValue(store, area, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Area.getFieldValue(store, area, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Container = {
        getFieldValue(store, containerUnit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = containerUnit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(containerUnit);
          } else if (fieldType === "Metadata") {
            fieldValue = containerUnit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "ContainerMetadata") {
            fieldValue = store.state.containerSets.find((cs) => cs.id === containerUnit.ContainerSetId).containers[containerUnit.ContainerId].metadata[fieldId.replace(/^ContainerMetadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = containerUnit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, containerUnit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Container.getFieldValue(store, containerUnit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Container.getFieldValue(store, containerUnit, overlay.altLabelFieldId);
          }
          return label;
        }
      };
      const Unit = {
        getFieldValue(store, unit, fieldId, percentFocusTarget) {
          const fieldType = fieldId.split(":")[0];
          let fieldValue = unit.CalculatedMetadata[fieldId];
          if (fieldType === "Special") {
            const specialColumn = store.getters.getSpecialFields.find((sc) => sc.id === fieldId.replace(/^Special:/, ""));
            fieldValue = specialColumn.getUnitValue(unit);
          } else if (fieldType === "Metadata") {
            fieldValue = unit.Metadata[fieldId.replace(/^Metadata:/, "")];
          } else if (fieldType === "Property") {
            fieldValue = unit[fieldId.replace(/^Property:/, "")];
          }
          return percentFocusTarget ? fieldValue / percentFocusTarget : fieldValue;
        },
        getLabelValue(store, unit, overlay, focusValues) {
          if (overlay.labelPriorityFieldId && overlay.screenLabels) {
            const screenValue = focusValues[overlay.labelPriorityFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.labelPriorityFieldId, focusValues[overlay.labelPriorityFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.labelPriorityFieldId);
            if (overlay.screenValue > screenValue)
              return "";
          }
          let label = focusValues[overlay.labelFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.labelFieldId, focusValues[overlay.labelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.labelFieldId);
          if (overlay.altLabelFieldId) {
            label += overlay.altLabelSeparator;
            label += focusValues[overlay.altLabelFieldId] ? numeral(Unit.getFieldValue(store, unit, overlay.altLabelFieldId, focusValues[overlay.altLabelFieldId] / focusValues.FocusCount)).format("0.0%") : Unit.getFieldValue(store, unit, overlay.altLabelFieldId);
          }
          return label;
        },
        get18CharacterId(store, unit) {
          let id2 = unit.UnitId || "";
          if (id2.length !== 15)
            return null;
          for (let i = 0; i < 3; i++) {
            let flags = 0;
            for (let j = 0; j < 5; j++) {
              const c = id2.charAt(i * 5 + j);
              if (c >= "A" && c <= "Z")
                flags += 1 << j;
            }
            id2 += "ABCDEFGHIJKLMNOPQRSTUVWXYZ012345".charAt(flags);
          }
          return id2;
        }
      };
      const PkChunking = {
        encode(int, charset) {
          let byCode = charset.byCode;
          if (int === 0) {
            return byCode[0];
          }
          var res = "", max2 = charset.length;
          while (int > 0) {
            res = byCode[int % max2] + res;
            int = Math.floor(int / max2);
          }
          return res;
        },
        decode(str, charset) {
          var byChar = charset.byChar, res = 0, length = str.length, max2 = charset.length, i, char;
          for (i = 0; i < length; i++) {
            char = str[i];
            res += byChar[char] * Math.pow(max2, length - i - 1);
          }
          return res;
        },
        // NB: does not validate input
        indexCharset(str) {
          var byCode = {}, byChar = {}, length = str.length, i, char;
          for (i = 0; i < length; i++) {
            char = str[i];
            byCode[i] = char;
            byChar[char] = i;
          }
          return { byCode, byChar, length };
        },
        /* strip the 6 digit id prefix, and last 3 digits (CRC check) if any
        * then base62 decode to convert to long
        */
        convertSalesforceIdToLong(salesforceId) {
          const salesforceIdStripped = salesforceId.substring(6, 15);
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          return this.decode(salesforceIdStripped, charset);
        },
        // base62 encode them, and add the id prefix back in
        convertLongToSalesforceId(idPrefix, longId) {
          const baseDigits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          const charset = this.indexCharset(baseDigits);
          const sfNumId = Number(longId);
          const idStringB62 = this.encode(sfNumId, charset).padStart(9, 0);
          return idPrefix + idStringB62;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and break it into chunk ranges of specified size
        * Only works if all the IDs have the same pod identifier
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        chunkIdRange(startId, endId2, chunkSize) {
          const idPrefix = startId.substring(0, 6);
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const numberChunkList = this.chunkRange(startNum, endNum, 9, chunkSize);
          return numberChunkList.map((chunk) => {
            const first = this.convertLongToSalesforceId(idPrefix, chunk.first);
            const last = this.convertLongToSalesforceId(idPrefix, chunk.last);
            return { first, last };
          });
        },
        /*
        * This method is used to chunk up a large range of Long Integers into a list of smaller ranges.
        * start number, end number, and size of the chunks is passed in
        */
        chunkRange(firstNum, lastNum, totalLength, chunkSize) {
          const range = lastNum - firstNum;
          const numChunkList = [];
          if (range < chunkSize) {
            numChunkList.push({ first: firstNum, last: lastNum });
          } else {
            const numChunks = Math.trunc(range / chunkSize);
            let firstNumChunk = firstNum;
            let lastNumChunk = firstNum + chunkSize - 1;
            numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            for (let i = 1; i < numChunks; i++) {
              firstNumChunk = lastNumChunk + 1;
              lastNumChunk = firstNumChunk + chunkSize - 1;
              numChunkList.push({ first: firstNumChunk, last: lastNumChunk });
            }
            const lastlastNumChunk = numChunkList[numChunkList.length - 1].last;
            if (lastlastNumChunk < lastNum) {
              numChunkList.push({ first: lastlastNumChunk + 1, last: lastNum });
            }
          }
          const numChunkListZeroPadded = numChunkList.map((numChunk) => ({
            first: (numChunk.first || "").toString().padStart(totalLength, 0),
            last: (numChunk.last || "").toString().padStart(totalLength, 0)
          }));
          return numChunkListZeroPadded;
        },
        /*
        * Take a 15 or 18 digit start and ending salesforce Id and calculate the number of ids between the two
        * Use the unit count to calculate fragementation between the range we require and the actual ids present
        * Only works if all the IDs have the same pod identider
        * Be careful of pod splits, sandbox / production data in a sandbox, etc.
        */
        calculateFragmentation(startId, endId2, unitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          return totalRange / unitCount;
        },
        // split the range into the number of chunks specified by splitCount
        splitIdChunk(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return this.chunkIdRange(startId, endId2, chunkSize);
        },
        // Calculate the size of a chunk to split the input range into the number of splits specified
        // For example a range of 30002 with a split of 3 would result in a chunk size of 10001
        calculateChunkSizeToSplitRange(startId, endId2, splitCount) {
          const startNum = this.convertSalesforceIdToLong(startId);
          const endNum = this.convertSalesforceIdToLong(endId2);
          const totalRange = endNum - startNum;
          const chunkSize = Math.ceil(totalRange / splitCount) + 1;
          return chunkSize;
        }
      };
      return {
        Debug: false,
        Apex,
        Rest,
        Pendo,
        Splunk,
        HTTP,
        CRM,
        CRMA,
        ExternalData,
        Async,
        Store,
        Obj,
        Arr,
        Tree: Tree2,
        Rule,
        Filter,
        DeferredPromise,
        AutoAssignment,
        Plan,
        AssignmentObject,
        BoundaryObject,
        Node: Node2,
        NodeMetric,
        Browser,
        Str,
        Map: MapUtil,
        Segment,
        Allocation,
        Area,
        Container,
        Unit,
        PkChunking,
        Version244
      };
    }
    const ClickOutside = {
      mounted(el, binding) {
        setTimeout(() => {
          el.clickOutsideEvent = function(event) {
            if (!(el === event.target || el.contains(event.target))) {
              binding.value(event);
            }
          };
          document.addEventListener("click", el.clickOutsideEvent);
        });
      },
      unmounted(el) {
        document.removeEventListener("click", el.clickOutsideEvent);
      }
    };
    const fetch = (url) => new Promise((resolve2, reject) => {
      console.log(url);
      const request = new XMLHttpRequest();
      request.onload = () => {
        if (request.status >= 200 && request.status < 400) {
          resolve2(request.responseText);
        } else {
          reject(request);
        }
      };
      request.onerror = () => console.error("Could not load the SVG.");
      request.open("GET", url, true);
      request.send();
    });
    const Icon = {
      name: "Icon",
      props: {
        assistiveText: String,
        button: Boolean,
        category: {
          type: String,
          default: "standard",
          validator(category) {
            if (!["action", "custom", "doctype", "standard", "utility"].includes(category)) {
              console.error("Invalid category. Please see documentation for valid categories.");
              return false;
            }
            return true;
          }
        },
        iconClass: {
          type: [Array, String]
        },
        inheritFillFromParent: Boolean,
        name: {
          type: String,
          default: ""
        },
        size: {
          type: String,
          default: "",
          validator(size2) {
            if (size2 && !["xx-small", "x-small", "small", "large"].includes(size2)) {
              console.error("Invalid size. Please see documentation for valid sizes.");
              return false;
            }
            return true;
          }
        },
        src: String,
        svg: {
          type: [Object, String],
          validator(value) {
            const isString2 = typeof value === "string";
            const isESModule = typeof value === "object" && value.__esModule === true;
            return isString2 || isESModule;
          }
        },
        title: {
          type: String,
          default: ""
        },
        variant: {
          type: String,
          default: "default",
          validator(variant) {
            if (variant && !["inverse", "success", "warning", "error", "default", "none"].includes(variant)) {
              console.error("Invalid variant. Please see documentation for valid variants.");
              return false;
            }
            return true;
          }
        }
      },
      render() {
        const classes = [];
        if (!this.$props.button) {
          classes.push("slds-icon_container");
          if (this.hasFQIcon) {
            classes.push(`slds-icon-${this.$props.category}-${this.$props.name.replace(/_/g, "-")}`);
          }
        }
        const svgVNode = this.buildSVGVNode();
        const children2 = [svgVNode];
        if (this.$props.assistiveText) {
          children2.push(
            h(
              "span",
              {
                class: "slds-assistive-text"
              },
              [this.$props.assistiveText]
            )
          );
        }
        if (this.$props.button) {
          return [children2];
        }
        return h(
          "div",
          {
            class: classes,
            title: this.$props.title
          },
          [children2]
        );
      },
      data() {
        return {
          processing: false,
          inlineData: null
        };
      },
      computed: {
        hasFQIcon() {
          return this.$props.category && this.$props.name;
        },
        computedFill() {
          return this.$props.button || this.hasFQIcon && this.$props.category === "utility" ? "inherit" : this.$props.fill;
        }
      },
      watch: {
        $props: {
          handler() {
            this.process();
          },
          deep: true,
          immediate: true
        }
      },
      inject: ["$__getIconSettings"],
      methods: {
        validateSources() {
          let numSources = 0;
          if (this.$props.src)
            numSources++;
          if (this.$props.svg)
            numSources++;
          if (this.hasFQIcon)
            numSources++;
          if (numSources === 0 || numSources > 1) {
            throw new Error("You must provide exactly one icon source.");
          }
        },
        async process() {
          if (this.processing)
            return;
          this.validateSources();
          try {
            this.processing = true;
            if (this.$props.src) {
              this.inlineData = await fetch(this.$props.src);
            } else if (this.$props.svg) {
              this.inlineData = this.$props.svg;
            }
          } finally {
            this.processing = false;
          }
        },
        buildSVGVNode() {
          const iconClasses = this.getIconClasses();
          const baseAttrs = {
            "aria-hidden": true,
            focusable: false,
            "data-key": this.$props.name
          };
          if (this.inlineData) {
            const fragment = document.createRange().createContextualFragment(this.inlineData);
            const svg = Array.from(fragment.childNodes).find((child) => child.nodeName === "svg");
            svg.classList.add(...iconClasses);
            if (this.$props.inheritFillFromParent) {
              svg.querySelectorAll("g, path").forEach((el) => {
                el.style.fill = "inherit";
              });
            }
            const attrs = Object.values(svg.attributes).reduce((result, attr) => {
              result[attr.name] = attr.value;
              return result;
            }, baseAttrs);
            return h(
              "svg",
              {
                ...attrs,
                class: iconClasses,
                innerHTML: svg.innerHTML
              }
            );
          }
          return h(
            "svg",
            {
              ...baseAttrs,
              class: iconClasses
            },
            [
              h(
                "use",
                {
                  href: this.getAssetURL()
                }
              )
            ]
          );
        },
        getAssetURL() {
          const {
            iconPath,
            actionSpritePath,
            customSpritePath,
            doctypeSpritePath,
            standardSpritePath,
            utilitySpritePath
          } = this.$__getIconSettings();
          if (iconPath) {
            return `${iconPath}/${this.$props.category}-sprite/svg/symbols.svg#${this.$props.name}`;
          }
          switch (this.$props.category) {
            case "action":
              return `${actionSpritePath}/symbols.svg#${this.$props.name}`;
            case "custom":
              return `${customSpritePath}/symbols.svg#${this.$props.name}`;
            case "doctype":
              return `${doctypeSpritePath}/symbols.svg#${this.$props.name}`;
            case "standard":
              return `${standardSpritePath}/symbols.svg#${this.$props.name}`;
            case "utility":
              return `${utilitySpritePath}/symbols.svg#${this.$props.name}`;
            default:
              throw new Error("Invalid path");
          }
        },
        getIconClasses() {
          const iconClasses = [];
          if (this.$props.category === "utility" && this.$props.variant !== "none") {
            iconClasses.push(`slds-icon-text-${this.$props.variant}`);
          }
          if (Array.isArray(this.iconClass)) {
            this.iconClass.forEach((cssClass) => iconClasses.push(cssClass));
          } else if (this.iconClass) {
            iconClasses.push(this.iconClass);
          }
          if (!this.$props.button && this.hasFQIcon) {
            iconClasses.push("slds-icon");
            if (this.$props.size) {
              iconClasses.push(`slds-icon_${this.$props.size}`);
            }
          }
          return iconClasses;
        }
      }
    };
    const ButtonIcon = {
      name: "Button",
      components: { Icon },
      props: {
        assistiveText: {
          type: String,
          required: true
        },
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        iconClass: {
          type: [Array, String],
          default: () => []
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Icon size.
         */
        iconSize: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid iconSize prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        more: Boolean,
        /**
         * Contained variants can be displayed in three smaller sizes—small, x-small, xx-small—by adding a sizing class on the <button>.
         */
        size: {
          type: String,
          default: "",
          validator: (value) => {
            const sizes = [
              "large",
              "small",
              "x-small",
              "xx-small"
            ];
            const isValid2 = !value || sizes.includes(value);
            if (!isValid2)
              console.error(`Valid button icon prop values are ${sizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, container,
         * brand, border, border-filled, base-inverse, border-inverse.
         */
        variant: {
          type: String,
          default: "bare",
          validator: (value) => {
            const variants = [
              "bare",
              "container",
              "brand",
              "border",
              "border-filled",
              "bare-inverse",
              "inverse",
              "border-inverse"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Displays browser-based tooltip text when the mouse moves over the element.
         */
        title: {
          type: String,
          required: true
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = Array.isArray(this.$props.iconClass) ? this.$props.iconClass : [this.$props.iconClass];
          iconClass.push("slds-button__icon");
          const props = {
            assistiveText: this.$props.assistiveText,
            category: this.$props.iconCategory,
            name: this.$props.iconName,
            iconClass,
            variant: "none",
            button: true
          };
          if (this.$props.iconSize) {
            iconClass.push(`slds-button__icon_${this.$props.iconSize}`);
            props.size = this.$props.iconSize;
          }
          iconVNode = h(Icon, props);
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children2 = [_default || iconVNode];
        if (this.$props.more) {
          const moreIconVNode = h(
            Icon,
            {
              assistiveText: iconVNode ? null : this.$props.assistiveText,
              category: "utility",
              name: "down",
              iconClass: ["slds-button__icon", "slds-button__icon_x-small"],
              variant: "none",
              button: true
            }
          );
          children2.push(moreIconVNode);
        }
        const classes = ["slds-button", "slds-button_icon"];
        if (this.$props.more) {
          if (this.$props.variant === "border-filled") {
            classes.push("slds-button_icon-more");
          } else {
            classes.push("slds-button_icon-container-more");
          }
        }
        classes.push(`slds-button_icon-${this.$props.variant}`);
        if (this.$props.size)
          classes.push(`slds-button_icon-${this.$props.size}`);
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        return h(
          "button",
          {
            class: classes,
            title: this.$props.title,
            disabled: this.$props.disabled
          },
          children2
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    const callbackMap = /* @__PURE__ */ new Map();
    function bind(el, handler, instance) {
      const callback = function(e) {
        if (instance.$.isUnmounted) {
          document.removeEventListener("click", callback);
          return;
        }
        if (!el.contains(e.target) && el !== e.target) {
          handler(e);
        }
      };
      callbackMap.set(el, callback);
      setTimeout(() => document.addEventListener("click", callback), 0);
    }
    function unbind(el) {
      const callback = callbackMap.get(el);
      document.removeEventListener("click", callback);
      callbackMap.delete(el);
    }
    const clickOutside = {
      created(el, { arg: { active, handler }, instance }) {
        if (typeof handler !== "function") {
          throw new Error("v-click-outside: missing required handler argument.");
        }
        if (active === true) {
          bind(el, handler, instance);
        }
      },
      updated(el, { arg: { active, handler } }, vNode) {
        if (active && !callbackMap.has(el)) {
          bind(el, handler, vNode);
        } else if (!active && callbackMap.has(el)) {
          unbind(el);
        }
      },
      unmounted(el) {
        unbind(el);
      }
    };
    const containers = /* @__PURE__ */ new Map();
    const createContainer = (el, context) => {
      const container = document.createElement("div");
      container.className = "slds-scope";
      container.appendChild(el);
      document.body.appendChild(container);
      context.$emit("detached", container);
      return container;
    };
    const alignToAnchor = (el, vnode, {
      anchorRef,
      resizeToAnchor,
      resizeToFitContent,
      alignment
    }) => {
      el.style.position = "fixed";
      const anchorRect = anchorRef.getBoundingClientRect();
      el.style.top = `${anchorRect.top + anchorRef.offsetHeight}px`;
      if (alignment === "left" || resizeToAnchor) {
        el.style.right = "auto";
        el.style.left = `${anchorRect.left}px`;
      } else if (alignment === "right") {
        el.style.left = "auto";
        el.style.right = `${document.documentElement.clientWidth - anchorRect.right}px`;
      }
      const anchorOffsetWidth = anchorRef.offsetWidth;
      if (resizeToAnchor) {
        el.style.width = `${anchorOffsetWidth}px`;
      } else if (resizeToFitContent) {
        el.style.minWidth = `${anchorOffsetWidth}px`;
        el.style.width = "auto";
      }
    };
    const getScrollbarWidth = () => {
      const scrollDiv = document.createElement("div");
      scrollDiv.style.width = "100px";
      scrollDiv.style.height = "100px";
      scrollDiv.style.overflow = "scroll";
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      scrollDiv.remove();
      return scrollbarWidth;
    };
    const adjustForViewPortOverflow = (el, options) => {
      const dropdownRect = el.getBoundingClientRect();
      const documentClientHeight = document.documentElement.clientHeight;
      const documentClientWidth = document.documentElement.clientWidth;
      const windowDocumentVerticalDiff = documentClientHeight - window.innerHeight;
      let viewportHeight;
      if (windowDocumentVerticalDiff <= 0) {
        viewportHeight = documentClientHeight;
      } else {
        viewportHeight = window.innerHeight - getScrollbarWidth();
      }
      if (dropdownRect.x < 0) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "left"
              }
            }
          );
        } else {
          el.style.left = `${el.offsetLeft + Math.abs(dropdownRect.x)}px`;
        }
      } else if (dropdownRect.left + dropdownRect.width > documentClientWidth) {
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(
            el,
            null,
            {
              ...options,
              ...{
                alignment: "right"
              }
            }
          );
        } else {
          const overflowXDiff = dropdownRect.left + dropdownRect.width - documentClientWidth - window.pageXOffset;
          el.style.left = `${dropdownRect.left - overflowXDiff}px`;
        }
      }
      let dropdownHeight = el.offsetHeight;
      let adjustedVerticalPosition;
      if (options.anchorRef && options.anchorTopOnVerticalOverflow) {
        const anchor = options.anchorRef.getBoundingClientRect();
        let anchorY = anchor.bottom;
        const boxShadow = window.getComputedStyle(el)["box-shadow"];
        if (boxShadow && boxShadow !== "none") {
          dropdownHeight += parseInt(/(?:\dpx ){2}(\d)/.exec(boxShadow)[1], 10);
        }
        if (anchorY + dropdownHeight > viewportHeight) {
          anchorY = anchor.top - dropdownHeight;
        }
        adjustedVerticalPosition = anchorY;
      } else if (dropdownRect.top + dropdownHeight > viewportHeight) {
        adjustedVerticalPosition = dropdownRect.top - (dropdownRect.top + dropdownHeight - viewportHeight);
      }
      if (adjustedVerticalPosition) {
        el.style.top = `${adjustedVerticalPosition}px`;
      }
    };
    const removeContainer = (el) => {
      let container = containers.get(el);
      if (!container)
        return;
      container.remove();
      container = null;
      containers.delete(el);
    };
    let scrollHandlerFn;
    const scrollHandler = (el, _scrollHandler, e) => {
      if (e && e.type === "scroll" && el && el.contains(e.target))
        return;
      if (typeof _scrollHandler === "function") {
        _scrollHandler(el, e);
      } else {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const detach = {
      created(el, binding, vnode) {
        if (binding.value.disabled)
          return;
        binding.instance.$nextTick(() => {
          const options = binding.value;
          const container = createContainer(el, binding.instance);
          vnode.container = container;
          containers.set(el, container);
          if (typeof options.customDisplayMethod === "function") {
            options.customDisplayMethod();
          }
          if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
            alignToAnchor(el, vnode, options);
          }
          if (options.viewPortOverflow) {
            binding.instance.$nextTick(() => {
              if (typeof options.onRender === "function") {
                options.onRender();
                binding.instance.$nextTick(adjustForViewPortOverflow.bind(this, el, options));
              } else {
                adjustForViewPortOverflow(el, options);
              }
            });
          }
          scrollHandlerFn = scrollHandler.bind(null, el, options.scrollHandler);
          window.addEventListener("scroll", scrollHandlerFn, true);
        });
      },
      updated(el, { value: options, instance }, vnode) {
        if (options.disabled)
          return;
        if (options.anchorRef && options.anchorRef instanceof HTMLElement) {
          alignToAnchor(el, vnode, options);
        }
        if (options.viewPortOverflow) {
          instance.$nextTick(() => {
            if (typeof options.onUpdate === "function") {
              options.onUpdate();
            }
            adjustForViewPortOverflow(el, options);
          });
        }
      },
      unmounted(el) {
        removeContainer(el);
        window.removeEventListener("scroll", scrollHandlerFn, true);
        scrollHandlerFn = null;
      }
    };
    const _export_sfc = (sfc, props) => {
      const target = sfc.__vccOpts || sfc;
      for (const [key, val] of props) {
        target[key] = val;
      }
      return target;
    };
    const _sfc_main$F = {
      name: "ActionMenu",
      components: { ButtonIcon },
      directives: {
        "click-outside": clickOutside,
        "detach-element": detach
      },
      props: {
        /**
         * Determines which side of the anchor the dropdown should align to
         */
        alignment: {
          type: String,
          default: "left",
          validator(alignment) {
            if (!["left", "right"].includes(alignment)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return false;
            }
            return true;
          }
        },
        // TODO - Setup a watcher on bindTo. If changed, remove existing event listener and register a new one.
        /**
         * Bind to an HTML Element. Should be focusable.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to custom coordinates.
         * An object in the following format:
         * `{
                x: 50,
                y: 50
            }`
         */
        bindToCoords: {
          type: Object,
          default: null,
          validator: (value) => value.x && value.y
        },
        /**
         * Bind to current mouse position.
         */
        bindToMousePosition: {
          type: Boolean,
          default: false
        },
        buttonIconSize: {
          type: String,
          default: ""
        },
        /**
         * Disables entire action menu.
         */
        disabled: Boolean,
        /**
         * The sync-supported visibility state prop.
         */
        doShowSync: Boolean,
        /**
         * Hide on mouse leave.
         */
        hideOnMouseout: Boolean,
        /**
         * Name of the icon category.
         */
        iconCategory: {
          type: String,
          default: "utility"
        },
        /**
         * Name of the icon.
         */
        iconName: {
          type: String,
          default: "down"
        },
        /**
         * Determines the size of the icon.
         */
        iconSize: {
          type: String,
          default: ""
        },
        /**
         * Title property for the button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Action menu variant. Shows menu items with link styling.
         */
        isActionMenu: {
          type: Boolean,
          default: true
        },
        /**
         * If defined, this will get called before toggling the action menu and be passed the following:
         * 1. JS click event
         * 2. Current visibility state of the action menu
         *
         * If the function returns a boolean value of true then the action menu will be toggled, otherwise, nothing will occur
         */
        onToggleRequest: {
          type: Function,
          default: null
        },
        /**
         * Adjust menu width to be equal to the anchor's width
         */
        resizeToAnchor: Boolean,
        /**
         * Label for button title and icon assistive text.
         */
        showMoreLabel: {
          type: String,
          default: "Show More"
        }
      },
      data() {
        return {
          doShow: this.doShowSync,
          isDirty: false,
          adjustedAlignment: null,
          container: null,
          focusedMenuItemIndex: null,
          focusableMenuItems: []
        };
      },
      computed: {
        doShowAnchor() {
          return !(this.bindTo || this.bindToMousePosition || this.bindToCoords);
        },
        clickOutsideOptions() {
          return {
            active: this.doShow,
            handler: this.doHide
          };
        },
        computedShowMoreIconTitle() {
          return this.$props.iconTitle || this.$props.showMoreLabel;
        },
        dropdownClasses() {
          const classes = ["slds-dropdown"];
          if (this.$props.isActionMenu)
            classes.push("slds-dropdown_actions");
          return classes;
        }
      },
      watch: {
        "$props.alignment": {
          handler(value) {
            if (!["left", "right"].includes(value)) {
              console.error("Invalid alignment. Please see documentation for valid alignments.");
              return;
            }
            this.adjustedAlignment = value;
          },
          immediate: true
        },
        doShow(value) {
          this.$emit("update:doShowSync", value);
        },
        doShowSync(value) {
          if (value === this.doShow)
            return;
          this.toggleMenu();
        }
      },
      created() {
        if (this.bindTo)
          this.bindTo.addEventListener("click", this.toggleMenu);
      },
      beforeUnmount() {
        if (this.bindTo)
          this.bindTo.removeEventListener("click", this.toggleMenu);
        this.destroy();
      },
      methods: {
        toggleMenu(e) {
          if (this.disabled || e && this.onToggleRequest && !this.onToggleRequest(e, this.doShow) || e && this.$refs.menu && (this.$refs.menu === e.target || this.$refs.menu.contains(e.target)))
            return;
          this.doShow = !this.doShow;
          if (this.doShow && !this.isKeyboardCallback) {
            window.addEventListener("scroll", this.doHide, true);
            window.addEventListener("resize", this.doHide);
            this.$nextTick(this.showMenu.bind(this, e));
            this.$emit("bindToClick", e);
          } else {
            this.destroy();
          }
        },
        showMenu() {
          this.$nextTick(() => {
            this.getFocusableMenuItems();
            if (this.focusableMenuItems.length) {
              this.focusedMenuItemIndex = 0;
              this.setMenuItemFocus();
            }
          });
        },
        onDetachRender() {
          this.$emit("detached", this.$refs.menu);
        },
        adjustAlignment(position) {
          this.adjustedAlignment = position;
        },
        destroy() {
          this.focusableMenuItems = [];
          this.doShow = false;
          window.removeEventListener("scroll", this.doHide, true);
          window.removeEventListener("resize", this.doHide);
          if (this.container) {
            this.container.remove();
            this.container = null;
          }
          if (this.doShowAnchor)
            this.$refs.anchor.firstElementChild.focus();
          this.$emit("hide");
        },
        doHide() {
          this.destroy();
        },
        mouseover(e) {
          this.$emit("mouseover", e);
        },
        mouseout(e) {
          if (this.hideOnMouseout && e.type === "mouseout" && !this.$refs.menu.contains(e.toElement || e.relatedTarget)) {
            this.destroy();
            return;
          }
          this.$emit("mouseout", e);
        },
        getFocusableMenuItems() {
          this.focusableMenuItems = [];
          this.$refs.menu.querySelectorAll(".slds-dropdown__item").forEach((item) => {
            this.focusableMenuItems.push(item.querySelector("a"));
          });
        },
        down() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex < this.focusableMenuItems.length - 1) {
              this.focusedMenuItemIndex++;
            } else {
              this.focusedMenuItemIndex = 0;
            }
            this.setMenuItemFocus();
          }
        },
        up() {
          if (!this.doShow) {
            this.toggleMenu();
          } else {
            this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = -1;
            if (this.focusedMenuItemIndex > 0) {
              this.focusedMenuItemIndex--;
            } else {
              this.focusedMenuItemIndex = this.focusableMenuItems.length - 1;
            }
            this.setMenuItemFocus();
          }
        },
        setMenuItemFocus() {
          this.focusableMenuItems[this.focusedMenuItemIndex].tabIndex = 0;
          this.focusableMenuItems[this.focusedMenuItemIndex].focus();
        }
      }
    };
    const _hoisted_1$z = {
      key: 0,
      ref: "anchor"
    };
    const _hoisted_2$y = ["aria-label"];
    function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: "slds-dropdown-trigger slds-dropdown-trigger_click slds-is-open slds-show",
        onClick: _cache[6] || (_cache[6] = (...args) => $options.toggleMenu && $options.toggleMenu(...args)),
        onKeydown: [
          _cache[7] || (_cache[7] = withKeys((...args) => $options.toggleMenu && $options.toggleMenu(...args), ["enter"])),
          _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
          _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
          _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"]))
        ]
      }, [
        $options.doShowAnchor ? (openBlock(), createElementBlock("div", _hoisted_1$z, [
          renderSlot(_ctx.$slots, "button", {}, () => [
            createVNode(_component_ButtonIcon, {
              "aria-haspopup": "",
              variant: "border-filled",
              disabled: _ctx.$props.disabled,
              iconSize: _ctx.$props.iconSize,
              iconCategory: _ctx.$props.iconCategory,
              iconName: _ctx.$props.iconName,
              title: $options.computedShowMoreIconTitle,
              assistiveText: $props.showMoreLabel,
              "aria-expanded": $data.doShow,
              size: _ctx.$props.buttonIconSize
            }, null, 8, ["disabled", "iconSize", "iconCategory", "iconName", "title", "assistiveText", "aria-expanded", "size"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        $data.doShow ? withDirectives((openBlock(), createElementBlock("div", {
          key: 1,
          ref: "menu",
          class: normalizeClass([$options.dropdownClasses, "translateX"]),
          onMouseover: _cache[0] || (_cache[0] = (...args) => $options.mouseover && $options.mouseover(...args)),
          onMouseout: _cache[1] || (_cache[1] = (...args) => $options.mouseout && $options.mouseout(...args)),
          onKeydown: [
            _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["stop"]), ["down"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["stop"]), ["up"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.destroy && $options.destroy(...args), ["stop"]), ["esc"])),
            _cache[5] || (_cache[5] = withKeys((...args) => $options.destroy && $options.destroy(...args), ["tab"]))
          ]
        }, [
          createBaseVNode("ul", {
            class: "slds-dropdown__list",
            role: "menu",
            "aria-label": $props.showMoreLabel
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode("--- menu items go here ---")
            ], true)
          ], 8, _hoisted_2$y)
        ], 34)), [
          [_directive_click_outside, void 0, $options.clickOutsideOptions],
          [_directive_detach_element, {
            anchorRef: _ctx.$refs.anchor,
            viewPortOverflow: true,
            anchorTopOnVerticalOverflow: true,
            onRender: $options.onDetachRender,
            onOverflowAdjustment: $options.adjustAlignment,
            resizeToAnchor: _ctx.$props.resizeToAnchor,
            scrollHandler: $options.doHide,
            alignment: _ctx.$props.alignment
          }]
        ]) : createCommentVNode("", true)
      ], 32);
    }
    const ActionMenu = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$D], ["__scopeId", "data-v-413e8c13"]]);
    const decodeHtml = {
      methods: {
        decodeHtml(html) {
          const txt = document.createElement("textarea");
          txt.innerHTML = html;
          return txt.value;
        }
      }
    };
    const _sfc_main$E = {
      name: "ActionMenuItem",
      components: {
        Icon
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Label for the menu item.
         */
        label: {
          type: String,
          required: true
        },
        /**
         * Disable action menu item.
         */
        disabled: Boolean,
        /**
         * Determines if this item is a read-only header.
         */
        header: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Role for menu item. Selectable items need the role "menuitemcheckbox" or "menuitemradio"
         * Options: `menuitem` | `menuitemcheckbox` | `menuitemradio`
         */
        role: {
          type: String,
          default: "menuitem",
          validator: (value) => {
            const validRoles = [
              "menuitem",
              "menuitemcheckbox",
              "menuitemradio"
            ];
            const isValid2 = !value || validRoles.includes(value);
            if (!isValid2)
              console.error(`Valid role values are ${validRoles.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * If true we add aria-checked="true" to the anchor tag
         */
        selected: Boolean
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      methods: {
        onEnter(e) {
          this.$attrs.onClick(e);
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        },
        onClick() {
          if (!this.$props.disabled) {
            this.$parent.destroy();
          }
        }
      }
    };
    const _hoisted_1$y = {
      key: 0,
      role: "presentation",
      class: "slds-dropdown__header slds-text-heading--label"
    };
    const _hoisted_2$x = { role: "presentation" };
    const _hoisted_3$u = ["aria-disabled"];
    const _hoisted_4$s = ["role", "aria-checked"];
    const _hoisted_5$q = ["title"];
    function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return _ctx.$props.header ? (openBlock(), createElementBlock("li", _hoisted_1$y, [
        createBaseVNode("div", _hoisted_2$x, toDisplayString(_ctx.$props.label), 1)
      ])) : (openBlock(), createElementBlock("li", mergeProps({
        key: 1,
        class: ["slds-dropdown__item", { "slds-is-selected": _ctx.$props.selected }],
        "aria-disabled": $props.disabled,
        role: "presentation"
      }, toHandlers(_ctx.$attrs, true), {
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $options.onClick && $options.onClick(...args), ["stop", "prevent"])),
        onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.onEnter && $options.onEnter(...args), ["stop", "prevent"]), ["enter"]))
      }), [
        createBaseVNode("a", {
          role: $props.role,
          tabindex: "-1",
          "aria-checked": _ctx.$props.selected,
          class: normalizeClass({ "disabled": $props.disabled })
        }, [
          createBaseVNode("span", {
            title: $props.label,
            class: normalizeClass([{ "slds-text-color_inverse-weak": $props.disabled, "disabled": $props.disabled }, "slds-truncate"])
          }, [
            $options.hasFQIcon ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              category: _ctx.$props.iconCategory,
              name: _ctx.$props.iconName,
              size: "x-small",
              class: "slds-m-right_x-small"
            }, null, 8, ["category", "name"])) : createCommentVNode("", true),
            !_ctx.$parent.$props.isActionMenu ? (openBlock(), createBlock(_component_Icon, {
              key: 1,
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-m-right_x-small",
              iconClass: "slds-icon_selected"
            })) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($props.label)), 1)
            ], true)
          ], 10, _hoisted_5$q)
        ], 10, _hoisted_4$s)
      ], 16, _hoisted_3$u));
    }
    const ActionMenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$C], ["__scopeId", "data-v-ffe335c1"]]);
    const _sfc_main$D = {
      name: "Badge",
      props: {
        /**
         * Content to be placed inside the badge component.
         */
        content: {
          type: [String, Number],
          default: ""
        },
        /**
         * Icon alignment for the badge component.
         */
        iconAlignment: {
          type: String,
          default: "left"
        },
        /**
         * Color variant for the badge component
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "inverse",
              "lightest",
              "success",
              "warning",
              "error"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        iconOnly() {
          return this.$slots.icon && !this.content;
        },
        themeClasses() {
          const contrastClasses = ["inverse", "lightest"];
          const themeClasses = ["success", "warning", "error"];
          let themeClass = "";
          if (contrastClasses.includes(this.theme))
            themeClass = `slds-badge_${this.theme}`;
          if (themeClasses.includes(this.theme))
            themeClass = `slds-theme_${this.theme}`;
          return themeClass;
        },
        badgeIconClasses() {
          const classes = ["slds-badge__icon"];
          if (this.theme === "inverse")
            classes.push("slds-badge__icon_inverse");
          if (this.iconAlignment && !this.iconOnly)
            classes.push(`slds-badge__icon_${this.iconAlignment}`);
          return classes;
        }
      }
    };
    function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(["slds-badge", $options.themeClasses])
      }, [
        _ctx.$slots["icon"] && $props.iconAlignment === "left" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2),
          createTextVNode(" " + toDisplayString($props.content), 1)
        ], 64)) : _ctx.$slots["icon"] && $props.iconAlignment === "right" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString($props.content) + " ", 1),
          createBaseVNode("span", {
            class: normalizeClass($options.badgeIconClasses)
          }, [
            renderSlot(_ctx.$slots, "icon")
          ], 2)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString($props.content), 1)
        ], 64))
      ], 2);
    }
    const Badge = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$B]]);
    const Button = {
      name: "Button",
      components: { Icon },
      props: {
        /**
         * Disables the button and adds disabled styling.
         */
        disabled: Boolean,
        /**
         * Icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Icon class(es)
         */
        iconClass: {
          type: [Array, String]
        },
        /**
         * Icon name.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Describes the position of the icon with respect to body. Options include left and right.
         * This value defaults to left.
         */
        iconPosition: {
          type: String,
          default: "left"
        },
        iconVariant: {
          type: String,
          default: "none"
        },
        /**
         * The text to be displayed inside the button.
         */
        label: {
          type: String,
          default: "Button"
        },
        /**
         * Stretches the button to full width.
         */
        stretched: Boolean,
        /**
         * The variant changes the appearance of the button. Accepted variants include base, neutral,
         * brand, outline-brand, destructive, text-destructive, inverse, and success. This value defaults to neutral.
         */
        variant: {
          type: String,
          default: "neutral",
          validator: (value) => {
            const variants = [
              "base",
              "neutral",
              "brand",
              "inverse",
              "destructive",
              "success",
              "outline-brand",
              "text-destructive"
            ];
            const isValid2 = !value || variants.includes(value);
            if (!isValid2)
              console.error(`Valid variant prop values are ${variants.join(", ")}`);
            return isValid2;
          }
        }
      },
      computed: {
        hasFQIcon() {
          return this.$props.iconCategory && this.$props.iconName;
        }
      },
      render() {
        let iconVNode;
        if (this.hasFQIcon) {
          const iconClass = ["slds-button__icon"];
          if (this.$props.iconPosition) {
            iconClass.push(`slds-button__icon_${this.$props.iconPosition}`);
          }
          if (this.$props.iconClass) {
            if (Array.isArray(this.$props.iconClass)) {
              iconClass.push(...this.$props.iconClass);
            } else {
              iconClass.push(this.$props.iconClass);
            }
          }
          iconVNode = h(
            Icon,
            {
              button: true,
              category: this.$props.iconCategory,
              iconClass,
              name: this.$props.iconName,
              variant: this.$props.iconVariant
            }
          );
        }
        const _default = this.$slots.default ? this.$slots.default() : null;
        const children2 = [_default || this.$props.label];
        if (iconVNode) {
          if (this.$props.iconPosition === "right") {
            children2.push(iconVNode);
          } else {
            children2.unshift(iconVNode);
          }
        }
        const classes = ["slds-button"];
        if (this.$props.stretched) {
          classes.push("slds-button_stretch");
        }
        if (this.$props.variant !== "base") {
          classes.push(`slds-button_${this.variant}`);
        }
        return h(
          "button",
          {
            // on: this.$listeners,
            class: classes,
            disabled: this.$props.disabled
          },
          children2
        );
      },
      methods: {
        focus() {
          this.$el.focus();
        }
      }
    };
    var top = "top";
    var bottom = "bottom";
    var right = "right";
    var left = "left";
    var auto = "auto";
    var basePlacements = [top, bottom, right, left];
    var start$1 = "start";
    var end = "end";
    var clippingParents = "clippingParents";
    var viewport = "viewport";
    var popper = "popper";
    var reference = "reference";
    var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
      return acc.concat([placement + "-" + start$1, placement + "-" + end]);
    }, []);
    var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
      return acc.concat([placement, placement + "-" + start$1, placement + "-" + end]);
    }, []);
    var beforeRead = "beforeRead";
    var read = "read";
    var afterRead = "afterRead";
    var beforeMain = "beforeMain";
    var main$1 = "main";
    var afterMain = "afterMain";
    var beforeWrite = "beforeWrite";
    var write = "write";
    var afterWrite = "afterWrite";
    var modifierPhases = [beforeRead, read, afterRead, beforeMain, main$1, afterMain, beforeWrite, write, afterWrite];
    function getNodeName(element) {
      return element ? (element.nodeName || "").toLowerCase() : null;
    }
    function getWindow(node) {
      if (node == null) {
        return window;
      }
      if (node.toString() !== "[object Window]") {
        var ownerDocument = node.ownerDocument;
        return ownerDocument ? ownerDocument.defaultView || window : window;
      }
      return node;
    }
    function isElement(node) {
      var OwnElement = getWindow(node).Element;
      return node instanceof OwnElement || node instanceof Element;
    }
    function isHTMLElement(node) {
      var OwnElement = getWindow(node).HTMLElement;
      return node instanceof OwnElement || node instanceof HTMLElement;
    }
    function isShadowRoot(node) {
      if (typeof ShadowRoot === "undefined") {
        return false;
      }
      var OwnElement = getWindow(node).ShadowRoot;
      return node instanceof OwnElement || node instanceof ShadowRoot;
    }
    function applyStyles(_ref) {
      var state = _ref.state;
      Object.keys(state.elements).forEach(function(name2) {
        var style = state.styles[name2] || {};
        var attributes = state.attributes[name2] || {};
        var element = state.elements[name2];
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(name3) {
          var value = attributes[name3];
          if (value === false) {
            element.removeAttribute(name3);
          } else {
            element.setAttribute(name3, value === true ? "" : value);
          }
        });
      });
    }
    function effect$2(_ref2) {
      var state = _ref2.state;
      var initialStyles = {
        popper: {
          position: state.options.strategy,
          left: "0",
          top: "0",
          margin: "0"
        },
        arrow: {
          position: "absolute"
        },
        reference: {}
      };
      Object.assign(state.elements.popper.style, initialStyles.popper);
      state.styles = initialStyles;
      if (state.elements.arrow) {
        Object.assign(state.elements.arrow.style, initialStyles.arrow);
      }
      return function() {
        Object.keys(state.elements).forEach(function(name2) {
          var element = state.elements[name2];
          var attributes = state.attributes[name2] || {};
          var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
          var style = styleProperties.reduce(function(style2, property) {
            style2[property] = "";
            return style2;
          }, {});
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style);
          Object.keys(attributes).forEach(function(attribute) {
            element.removeAttribute(attribute);
          });
        });
      };
    }
    const applyStyles$1 = {
      name: "applyStyles",
      enabled: true,
      phase: "write",
      fn: applyStyles,
      effect: effect$2,
      requires: ["computeStyles"]
    };
    function getBasePlacement(placement) {
      return placement.split("-")[0];
    }
    var max$2 = Math.max;
    var min$2 = Math.min;
    var round$1 = Math.round;
    function getUAString() {
      var uaData = navigator.userAgentData;
      if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
        return uaData.brands.map(function(item) {
          return item.brand + "/" + item.version;
        }).join(" ");
      }
      return navigator.userAgent;
    }
    function isLayoutViewport() {
      return !/^((?!chrome|android).)*safari/i.test(getUAString());
    }
    function getBoundingClientRect(element, includeScale, isFixedStrategy) {
      if (includeScale === void 0) {
        includeScale = false;
      }
      if (isFixedStrategy === void 0) {
        isFixedStrategy = false;
      }
      var clientRect = element.getBoundingClientRect();
      var scaleX = 1;
      var scaleY = 1;
      if (includeScale && isHTMLElement(element)) {
        scaleX = element.offsetWidth > 0 ? round$1(clientRect.width) / element.offsetWidth || 1 : 1;
        scaleY = element.offsetHeight > 0 ? round$1(clientRect.height) / element.offsetHeight || 1 : 1;
      }
      var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
      var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
      var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
      var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
      var width = clientRect.width / scaleX;
      var height = clientRect.height / scaleY;
      return {
        width,
        height,
        top: y2,
        right: x2 + width,
        bottom: y2 + height,
        left: x2,
        x: x2,
        y: y2
      };
    }
    function getLayoutRect(element) {
      var clientRect = getBoundingClientRect(element);
      var width = element.offsetWidth;
      var height = element.offsetHeight;
      if (Math.abs(clientRect.width - width) <= 1) {
        width = clientRect.width;
      }
      if (Math.abs(clientRect.height - height) <= 1) {
        height = clientRect.height;
      }
      return {
        x: element.offsetLeft,
        y: element.offsetTop,
        width,
        height
      };
    }
    function contains(parent, child) {
      var rootNode = child.getRootNode && child.getRootNode();
      if (parent.contains(child)) {
        return true;
      } else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;
        do {
          if (next && parent.isSameNode(next)) {
            return true;
          }
          next = next.parentNode || next.host;
        } while (next);
      }
      return false;
    }
    function getComputedStyle$2(element) {
      return getWindow(element).getComputedStyle(element);
    }
    function isTableElement(element) {
      return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
    }
    function getDocumentElement(element) {
      return ((isElement(element) ? element.ownerDocument : (
        // $FlowFixMe[prop-missing]
        element.document
      )) || window.document).documentElement;
    }
    function getParentNode(element) {
      if (getNodeName(element) === "html") {
        return element;
      }
      return (
        // this is a quicker (but less type safe) way to save quite some bytes from the bundle
        // $FlowFixMe[incompatible-return]
        // $FlowFixMe[prop-missing]
        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
        element.parentNode || // DOM Element detected
        (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
        // $FlowFixMe[incompatible-call]: HTMLElement is a Node
        getDocumentElement(element)
      );
    }
    function getTrueOffsetParent(element) {
      if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
      getComputedStyle$2(element).position === "fixed") {
        return null;
      }
      return element.offsetParent;
    }
    function getContainingBlock(element) {
      var isFirefox = /firefox/i.test(getUAString());
      var isIE = /Trident/i.test(getUAString());
      if (isIE && isHTMLElement(element)) {
        var elementCss = getComputedStyle$2(element);
        if (elementCss.position === "fixed") {
          return null;
        }
      }
      var currentNode = getParentNode(element);
      if (isShadowRoot(currentNode)) {
        currentNode = currentNode.host;
      }
      while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
        var css = getComputedStyle$2(currentNode);
        if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
          return currentNode;
        } else {
          currentNode = currentNode.parentNode;
        }
      }
      return null;
    }
    function getOffsetParent(element) {
      var window2 = getWindow(element);
      var offsetParent = getTrueOffsetParent(element);
      while (offsetParent && isTableElement(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
        offsetParent = getTrueOffsetParent(offsetParent);
      }
      if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
        return window2;
      }
      return offsetParent || getContainingBlock(element) || window2;
    }
    function getMainAxisFromPlacement(placement) {
      return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }
    function within(min2, value, max2) {
      return max$2(min2, min$2(value, max2));
    }
    function withinMaxClamp(min2, value, max2) {
      var v = within(min2, value, max2);
      return v > max2 ? max2 : v;
    }
    function getFreshSideObject() {
      return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
    }
    function mergePaddingObject(paddingObject) {
      return Object.assign({}, getFreshSideObject(), paddingObject);
    }
    function expandToHashMap(value, keys2) {
      return keys2.reduce(function(hashMap, key) {
        hashMap[key] = value;
        return hashMap;
      }, {});
    }
    var toPaddingObject = function toPaddingObject2(padding, state) {
      padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
        placement: state.placement
      })) : padding;
      return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
    };
    function arrow(_ref) {
      var _state$modifiersData$;
      var state = _ref.state, name2 = _ref.name, options = _ref.options;
      var arrowElement = state.elements.arrow;
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var basePlacement = getBasePlacement(state.placement);
      var axis = getMainAxisFromPlacement(basePlacement);
      var isVertical = [left, right].indexOf(basePlacement) >= 0;
      var len = isVertical ? "height" : "width";
      if (!arrowElement || !popperOffsets2) {
        return;
      }
      var paddingObject = toPaddingObject(options.padding, state);
      var arrowRect = getLayoutRect(arrowElement);
      var minProp = axis === "y" ? top : left;
      var maxProp = axis === "y" ? bottom : right;
      var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
      var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
      var arrowOffsetParent = getOffsetParent(arrowElement);
      var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
      var centerToReference = endDiff / 2 - startDiff / 2;
      var min2 = paddingObject[minProp];
      var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
      var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
      var offset2 = within(min2, center, max2);
      var axisProp = axis;
      state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
    }
    function effect$1(_ref2) {
      var state = _ref2.state, options = _ref2.options;
      var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
      if (arrowElement == null) {
        return;
      }
      if (typeof arrowElement === "string") {
        arrowElement = state.elements.popper.querySelector(arrowElement);
        if (!arrowElement) {
          return;
        }
      }
      if (!contains(state.elements.popper, arrowElement)) {
        return;
      }
      state.elements.arrow = arrowElement;
    }
    const arrow$1 = {
      name: "arrow",
      enabled: true,
      phase: "main",
      fn: arrow,
      effect: effect$1,
      requires: ["popperOffsets"],
      requiresIfExists: ["preventOverflow"]
    };
    function getVariation(placement) {
      return placement.split("-")[1];
    }
    var unsetSides = {
      top: "auto",
      right: "auto",
      bottom: "auto",
      left: "auto"
    };
    function roundOffsetsByDPR(_ref, win) {
      var x2 = _ref.x, y2 = _ref.y;
      var dpr = win.devicePixelRatio || 1;
      return {
        x: round$1(x2 * dpr) / dpr || 0,
        y: round$1(y2 * dpr) / dpr || 0
      };
    }
    function mapToStyles(_ref2) {
      var _Object$assign2;
      var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
      var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
      var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
        x: x2,
        y: y2
      }) : {
        x: x2,
        y: y2
      };
      x2 = _ref3.x;
      y2 = _ref3.y;
      var hasX = offsets.hasOwnProperty("x");
      var hasY = offsets.hasOwnProperty("y");
      var sideX = left;
      var sideY = top;
      var win = window;
      if (adaptive) {
        var offsetParent = getOffsetParent(popper2);
        var heightProp = "clientHeight";
        var widthProp = "clientWidth";
        if (offsetParent === getWindow(popper2)) {
          offsetParent = getDocumentElement(popper2);
          if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
            heightProp = "scrollHeight";
            widthProp = "scrollWidth";
          }
        }
        offsetParent = offsetParent;
        if (placement === top || (placement === left || placement === right) && variation === end) {
          sideY = bottom;
          var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
            // $FlowFixMe[prop-missing]
            offsetParent[heightProp]
          );
          y2 -= offsetY - popperRect.height;
          y2 *= gpuAcceleration ? 1 : -1;
        }
        if (placement === left || (placement === top || placement === bottom) && variation === end) {
          sideX = right;
          var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
            // $FlowFixMe[prop-missing]
            offsetParent[widthProp]
          );
          x2 -= offsetX - popperRect.width;
          x2 *= gpuAcceleration ? 1 : -1;
        }
      }
      var commonStyles = Object.assign({
        position
      }, adaptive && unsetSides);
      var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
        x: x2,
        y: y2
      }, getWindow(popper2)) : {
        x: x2,
        y: y2
      };
      x2 = _ref4.x;
      y2 = _ref4.y;
      if (gpuAcceleration) {
        var _Object$assign;
        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
      }
      return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
    }
    function computeStyles(_ref5) {
      var state = _ref5.state, options = _ref5.options;
      var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
      var commonStyles = {
        placement: getBasePlacement(state.placement),
        variation: getVariation(state.placement),
        popper: state.elements.popper,
        popperRect: state.rects.popper,
        gpuAcceleration,
        isFixed: state.options.strategy === "fixed"
      };
      if (state.modifiersData.popperOffsets != null) {
        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.popperOffsets,
          position: state.options.strategy,
          adaptive,
          roundOffsets
        })));
      }
      if (state.modifiersData.arrow != null) {
        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
          offsets: state.modifiersData.arrow,
          position: "absolute",
          adaptive: false,
          roundOffsets
        })));
      }
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-placement": state.placement
      });
    }
    const computeStyles$1 = {
      name: "computeStyles",
      enabled: true,
      phase: "beforeWrite",
      fn: computeStyles,
      data: {}
    };
    var passive = {
      passive: true
    };
    function effect(_ref) {
      var state = _ref.state, instance = _ref.instance, options = _ref.options;
      var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
      var window2 = getWindow(state.elements.popper);
      var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.addEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.addEventListener("resize", instance.update, passive);
      }
      return function() {
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.removeEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.removeEventListener("resize", instance.update, passive);
        }
      };
    }
    const eventListeners = {
      name: "eventListeners",
      enabled: true,
      phase: "write",
      fn: function fn() {
      },
      effect,
      data: {}
    };
    var hash$1 = {
      left: "right",
      right: "left",
      bottom: "top",
      top: "bottom"
    };
    function getOppositePlacement(placement) {
      return placement.replace(/left|right|bottom|top/g, function(matched) {
        return hash$1[matched];
      });
    }
    var hash = {
      start: "end",
      end: "start"
    };
    function getOppositeVariationPlacement(placement) {
      return placement.replace(/start|end/g, function(matched) {
        return hash[matched];
      });
    }
    function getWindowScroll(node) {
      var win = getWindow(node);
      var scrollLeft = win.pageXOffset;
      var scrollTop = win.pageYOffset;
      return {
        scrollLeft,
        scrollTop
      };
    }
    function getWindowScrollBarX(element) {
      return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
    }
    function getViewportRect(element, strategy) {
      var win = getWindow(element);
      var html = getDocumentElement(element);
      var visualViewport = win.visualViewport;
      var width = html.clientWidth;
      var height = html.clientHeight;
      var x2 = 0;
      var y2 = 0;
      if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        var layoutViewport = isLayoutViewport();
        if (layoutViewport || !layoutViewport && strategy === "fixed") {
          x2 = visualViewport.offsetLeft;
          y2 = visualViewport.offsetTop;
        }
      }
      return {
        width,
        height,
        x: x2 + getWindowScrollBarX(element),
        y: y2
      };
    }
    function getDocumentRect(element) {
      var _element$ownerDocumen;
      var html = getDocumentElement(element);
      var winScroll = getWindowScroll(element);
      var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
      var width = max$2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
      var height = max$2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
      var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
      var y2 = -winScroll.scrollTop;
      if (getComputedStyle$2(body || html).direction === "rtl") {
        x2 += max$2(html.clientWidth, body ? body.clientWidth : 0) - width;
      }
      return {
        width,
        height,
        x: x2,
        y: y2
      };
    }
    function isScrollParent(element) {
      var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
      return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
    }
    function getScrollParent(node) {
      if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
        return node.ownerDocument.body;
      }
      if (isHTMLElement(node) && isScrollParent(node)) {
        return node;
      }
      return getScrollParent(getParentNode(node));
    }
    function listScrollParents(element, list) {
      var _element$ownerDocumen;
      if (list === void 0) {
        list = [];
      }
      var scrollParent = getScrollParent(element);
      var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
      var win = getWindow(scrollParent);
      var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
      var updatedList = list.concat(target);
      return isBody ? updatedList : (
        // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
        updatedList.concat(listScrollParents(getParentNode(target)))
      );
    }
    function rectToClientRect(rect) {
      return Object.assign({}, rect, {
        left: rect.x,
        top: rect.y,
        right: rect.x + rect.width,
        bottom: rect.y + rect.height
      });
    }
    function getInnerBoundingClientRect(element, strategy) {
      var rect = getBoundingClientRect(element, false, strategy === "fixed");
      rect.top = rect.top + element.clientTop;
      rect.left = rect.left + element.clientLeft;
      rect.bottom = rect.top + element.clientHeight;
      rect.right = rect.left + element.clientWidth;
      rect.width = element.clientWidth;
      rect.height = element.clientHeight;
      rect.x = rect.left;
      rect.y = rect.top;
      return rect;
    }
    function getClientRectFromMixedType(element, clippingParent, strategy) {
      return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
    }
    function getClippingParents(element) {
      var clippingParents2 = listScrollParents(getParentNode(element));
      var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
      var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
      if (!isElement(clipperElement)) {
        return [];
      }
      return clippingParents2.filter(function(clippingParent) {
        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
      });
    }
    function getClippingRect(element, boundary, rootBoundary, strategy) {
      var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
      var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
      var firstClippingParent = clippingParents2[0];
      var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
        var rect = getClientRectFromMixedType(element, clippingParent, strategy);
        accRect.top = max$2(rect.top, accRect.top);
        accRect.right = min$2(rect.right, accRect.right);
        accRect.bottom = min$2(rect.bottom, accRect.bottom);
        accRect.left = max$2(rect.left, accRect.left);
        return accRect;
      }, getClientRectFromMixedType(element, firstClippingParent, strategy));
      clippingRect.width = clippingRect.right - clippingRect.left;
      clippingRect.height = clippingRect.bottom - clippingRect.top;
      clippingRect.x = clippingRect.left;
      clippingRect.y = clippingRect.top;
      return clippingRect;
    }
    function computeOffsets(_ref) {
      var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
      var basePlacement = placement ? getBasePlacement(placement) : null;
      var variation = placement ? getVariation(placement) : null;
      var commonX = reference2.x + reference2.width / 2 - element.width / 2;
      var commonY = reference2.y + reference2.height / 2 - element.height / 2;
      var offsets;
      switch (basePlacement) {
        case top:
          offsets = {
            x: commonX,
            y: reference2.y - element.height
          };
          break;
        case bottom:
          offsets = {
            x: commonX,
            y: reference2.y + reference2.height
          };
          break;
        case right:
          offsets = {
            x: reference2.x + reference2.width,
            y: commonY
          };
          break;
        case left:
          offsets = {
            x: reference2.x - element.width,
            y: commonY
          };
          break;
        default:
          offsets = {
            x: reference2.x,
            y: reference2.y
          };
      }
      var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
      if (mainAxis != null) {
        var len = mainAxis === "y" ? "height" : "width";
        switch (variation) {
          case start$1:
            offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
            break;
          case end:
            offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
            break;
        }
      }
      return offsets;
    }
    function detectOverflow(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
      var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      var altContext = elementContext === popper ? reference : popper;
      var popperRect = state.rects.popper;
      var element = state.elements[altBoundary ? altContext : elementContext];
      var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
      var referenceClientRect = getBoundingClientRect(state.elements.reference);
      var popperOffsets2 = computeOffsets({
        reference: referenceClientRect,
        element: popperRect,
        strategy: "absolute",
        placement
      });
      var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
      var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
      var overflowOffsets = {
        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
        right: elementClientRect.right - clippingClientRect.right + paddingObject.right
      };
      var offsetData = state.modifiersData.offset;
      if (elementContext === popper && offsetData) {
        var offset2 = offsetData[placement];
        Object.keys(overflowOffsets).forEach(function(key) {
          var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
          var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
          overflowOffsets[key] += offset2[axis] * multiply;
        });
      }
      return overflowOffsets;
    }
    function computeAutoPlacement(state, options) {
      if (options === void 0) {
        options = {};
      }
      var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
      var variation = getVariation(placement);
      var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
        return getVariation(placement2) === variation;
      }) : basePlacements;
      var allowedPlacements = placements$1.filter(function(placement2) {
        return allowedAutoPlacements.indexOf(placement2) >= 0;
      });
      if (allowedPlacements.length === 0) {
        allowedPlacements = placements$1;
      }
      var overflows = allowedPlacements.reduce(function(acc, placement2) {
        acc[placement2] = detectOverflow(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding
        })[getBasePlacement(placement2)];
        return acc;
      }, {});
      return Object.keys(overflows).sort(function(a, b) {
        return overflows[a] - overflows[b];
      });
    }
    function getExpandedFallbackPlacements(placement) {
      if (getBasePlacement(placement) === auto) {
        return [];
      }
      var oppositePlacement = getOppositePlacement(placement);
      return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
    }
    function flip(_ref) {
      var state = _ref.state, options = _ref.options, name2 = _ref.name;
      if (state.modifiersData[name2]._skip) {
        return;
      }
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
      var preferredPlacement = state.options.placement;
      var basePlacement = getBasePlacement(preferredPlacement);
      var isBasePlacement = basePlacement === preferredPlacement;
      var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
      var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
        return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
          placement: placement2,
          boundary,
          rootBoundary,
          padding,
          flipVariations,
          allowedAutoPlacements
        }) : placement2);
      }, []);
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var checksMap = /* @__PURE__ */ new Map();
      var makeFallbackChecks = true;
      var firstFittingPlacement = placements2[0];
      for (var i = 0; i < placements2.length; i++) {
        var placement = placements2[i];
        var _basePlacement = getBasePlacement(placement);
        var isStartVariation = getVariation(placement) === start$1;
        var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
        var len = isVertical ? "width" : "height";
        var overflow = detectOverflow(state, {
          placement,
          boundary,
          rootBoundary,
          altBoundary,
          padding
        });
        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
        if (referenceRect[len] > popperRect[len]) {
          mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        var altVariationSide = getOppositePlacement(mainVariationSide);
        var checks = [];
        if (checkMainAxis) {
          checks.push(overflow[_basePlacement] <= 0);
        }
        if (checkAltAxis) {
          checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
        }
        if (checks.every(function(check) {
          return check;
        })) {
          firstFittingPlacement = placement;
          makeFallbackChecks = false;
          break;
        }
        checksMap.set(placement, checks);
      }
      if (makeFallbackChecks) {
        var numberOfChecks = flipVariations ? 3 : 1;
        var _loop = function _loop2(_i2) {
          var fittingPlacement = placements2.find(function(placement2) {
            var checks2 = checksMap.get(placement2);
            if (checks2) {
              return checks2.slice(0, _i2).every(function(check) {
                return check;
              });
            }
          });
          if (fittingPlacement) {
            firstFittingPlacement = fittingPlacement;
            return "break";
          }
        };
        for (var _i = numberOfChecks; _i > 0; _i--) {
          var _ret = _loop(_i);
          if (_ret === "break")
            break;
        }
      }
      if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name2]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
      }
    }
    const flip$1 = {
      name: "flip",
      enabled: true,
      phase: "main",
      fn: flip,
      requiresIfExists: ["offset"],
      data: {
        _skip: false
      }
    };
    function getSideOffsets(overflow, rect, preventedOffsets) {
      if (preventedOffsets === void 0) {
        preventedOffsets = {
          x: 0,
          y: 0
        };
      }
      return {
        top: overflow.top - rect.height - preventedOffsets.y,
        right: overflow.right - rect.width + preventedOffsets.x,
        bottom: overflow.bottom - rect.height + preventedOffsets.y,
        left: overflow.left - rect.width - preventedOffsets.x
      };
    }
    function isAnySideFullyClipped(overflow) {
      return [top, right, bottom, left].some(function(side) {
        return overflow[side] >= 0;
      });
    }
    function hide(_ref) {
      var state = _ref.state, name2 = _ref.name;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var preventedOffsets = state.modifiersData.preventOverflow;
      var referenceOverflow = detectOverflow(state, {
        elementContext: "reference"
      });
      var popperAltOverflow = detectOverflow(state, {
        altBoundary: true
      });
      var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
      var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
      var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
      var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
      state.modifiersData[name2] = {
        referenceClippingOffsets,
        popperEscapeOffsets,
        isReferenceHidden,
        hasPopperEscaped
      };
      state.attributes.popper = Object.assign({}, state.attributes.popper, {
        "data-popper-reference-hidden": isReferenceHidden,
        "data-popper-escaped": hasPopperEscaped
      });
    }
    const hide$1 = {
      name: "hide",
      enabled: true,
      phase: "main",
      requiresIfExists: ["preventOverflow"],
      fn: hide
    };
    function distanceAndSkiddingToXY(placement, rects, offset2) {
      var basePlacement = getBasePlacement(placement);
      var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
      var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
        placement
      })) : offset2, skidding = _ref[0], distance = _ref[1];
      skidding = skidding || 0;
      distance = (distance || 0) * invertDistance;
      return [left, right].indexOf(basePlacement) >= 0 ? {
        x: distance,
        y: skidding
      } : {
        x: skidding,
        y: distance
      };
    }
    function offset$1(_ref2) {
      var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
      var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
      var data = placements.reduce(function(acc, placement) {
        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
        return acc;
      }, {});
      var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
      if (state.modifiersData.popperOffsets != null) {
        state.modifiersData.popperOffsets.x += x2;
        state.modifiersData.popperOffsets.y += y2;
      }
      state.modifiersData[name2] = data;
    }
    const offset$2 = {
      name: "offset",
      enabled: true,
      phase: "main",
      requires: ["popperOffsets"],
      fn: offset$1
    };
    function popperOffsets(_ref) {
      var state = _ref.state, name2 = _ref.name;
      state.modifiersData[name2] = computeOffsets({
        reference: state.rects.reference,
        element: state.rects.popper,
        strategy: "absolute",
        placement: state.placement
      });
    }
    const popperOffsets$1 = {
      name: "popperOffsets",
      enabled: true,
      phase: "read",
      fn: popperOffsets,
      data: {}
    };
    function getAltAxis(axis) {
      return axis === "x" ? "y" : "x";
    }
    function preventOverflow(_ref) {
      var state = _ref.state, options = _ref.options, name2 = _ref.name;
      var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
      var overflow = detectOverflow(state, {
        boundary,
        rootBoundary,
        padding,
        altBoundary
      });
      var basePlacement = getBasePlacement(state.placement);
      var variation = getVariation(state.placement);
      var isBasePlacement = !variation;
      var mainAxis = getMainAxisFromPlacement(basePlacement);
      var altAxis = getAltAxis(mainAxis);
      var popperOffsets2 = state.modifiersData.popperOffsets;
      var referenceRect = state.rects.reference;
      var popperRect = state.rects.popper;
      var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
        placement: state.placement
      })) : tetherOffset;
      var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
        mainAxis: tetherOffsetValue,
        altAxis: tetherOffsetValue
      } : Object.assign({
        mainAxis: 0,
        altAxis: 0
      }, tetherOffsetValue);
      var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
      var data = {
        x: 0,
        y: 0
      };
      if (!popperOffsets2) {
        return;
      }
      if (checkMainAxis) {
        var _offsetModifierState$;
        var mainSide = mainAxis === "y" ? top : left;
        var altSide = mainAxis === "y" ? bottom : right;
        var len = mainAxis === "y" ? "height" : "width";
        var offset2 = popperOffsets2[mainAxis];
        var min2 = offset2 + overflow[mainSide];
        var max2 = offset2 - overflow[altSide];
        var additive = tether ? -popperRect[len] / 2 : 0;
        var minLen = variation === start$1 ? referenceRect[len] : popperRect[len];
        var maxLen = variation === start$1 ? -popperRect[len] : -referenceRect[len];
        var arrowElement = state.elements.arrow;
        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
          width: 0,
          height: 0
        };
        var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
        var arrowPaddingMin = arrowPaddingObject[mainSide];
        var arrowPaddingMax = arrowPaddingObject[altSide];
        var arrowLen = within(0, referenceRect[len], arrowRect[len]);
        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
        var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
        var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
        var tetherMax = offset2 + maxOffset - offsetModifierValue;
        var preventedOffset = within(tether ? min$2(min2, tetherMin) : min2, offset2, tether ? max$2(max2, tetherMax) : max2);
        popperOffsets2[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset2;
      }
      if (checkAltAxis) {
        var _offsetModifierState$2;
        var _mainSide = mainAxis === "x" ? top : left;
        var _altSide = mainAxis === "x" ? bottom : right;
        var _offset = popperOffsets2[altAxis];
        var _len = altAxis === "y" ? "height" : "width";
        var _min = _offset + overflow[_mainSide];
        var _max = _offset - overflow[_altSide];
        var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
        popperOffsets2[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
      state.modifiersData[name2] = data;
    }
    const preventOverflow$1 = {
      name: "preventOverflow",
      enabled: true,
      phase: "main",
      fn: preventOverflow,
      requiresIfExists: ["offset"]
    };
    function getHTMLElementScroll(element) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    function getNodeScroll(node) {
      if (node === getWindow(node) || !isHTMLElement(node)) {
        return getWindowScroll(node);
      } else {
        return getHTMLElementScroll(node);
      }
    }
    function isElementScaled(element) {
      var rect = element.getBoundingClientRect();
      var scaleX = round$1(rect.width) / element.offsetWidth || 1;
      var scaleY = round$1(rect.height) / element.offsetHeight || 1;
      return scaleX !== 1 || scaleY !== 1;
    }
    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
      if (isFixed === void 0) {
        isFixed = false;
      }
      var isOffsetParentAnElement = isHTMLElement(offsetParent);
      var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
      var documentElement = getDocumentElement(offsetParent);
      var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
      var scroll = {
        scrollLeft: 0,
        scrollTop: 0
      };
      var offsets = {
        x: 0,
        y: 0
      };
      if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
        if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
        isScrollParent(documentElement)) {
          scroll = getNodeScroll(offsetParent);
        }
        if (isHTMLElement(offsetParent)) {
          offsets = getBoundingClientRect(offsetParent, true);
          offsets.x += offsetParent.clientLeft;
          offsets.y += offsetParent.clientTop;
        } else if (documentElement) {
          offsets.x = getWindowScrollBarX(documentElement);
        }
      }
      return {
        x: rect.left + scroll.scrollLeft - offsets.x,
        y: rect.top + scroll.scrollTop - offsets.y,
        width: rect.width,
        height: rect.height
      };
    }
    function order(modifiers) {
      var map2 = /* @__PURE__ */ new Map();
      var visited = /* @__PURE__ */ new Set();
      var result = [];
      modifiers.forEach(function(modifier) {
        map2.set(modifier.name, modifier);
      });
      function sort(modifier) {
        visited.add(modifier.name);
        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
        requires.forEach(function(dep) {
          if (!visited.has(dep)) {
            var depModifier = map2.get(dep);
            if (depModifier) {
              sort(depModifier);
            }
          }
        });
        result.push(modifier);
      }
      modifiers.forEach(function(modifier) {
        if (!visited.has(modifier.name)) {
          sort(modifier);
        }
      });
      return result;
    }
    function orderModifiers(modifiers) {
      var orderedModifiers = order(modifiers);
      return modifierPhases.reduce(function(acc, phase) {
        return acc.concat(orderedModifiers.filter(function(modifier) {
          return modifier.phase === phase;
        }));
      }, []);
    }
    function debounce$1(fn) {
      var pending;
      return function() {
        if (!pending) {
          pending = new Promise(function(resolve2) {
            Promise.resolve().then(function() {
              pending = void 0;
              resolve2(fn());
            });
          });
        }
        return pending;
      };
    }
    function mergeByName(modifiers) {
      var merged = modifiers.reduce(function(merged2, current) {
        var existing = merged2[current.name];
        merged2[current.name] = existing ? Object.assign({}, existing, current, {
          options: Object.assign({}, existing.options, current.options),
          data: Object.assign({}, existing.data, current.data)
        }) : current;
        return merged2;
      }, {});
      return Object.keys(merged).map(function(key) {
        return merged[key];
      });
    }
    var DEFAULT_OPTIONS = {
      placement: "bottom",
      modifiers: [],
      strategy: "absolute"
    };
    function areValidElements() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return !args.some(function(element) {
        return !(element && typeof element.getBoundingClientRect === "function");
      });
    }
    function popperGenerator(generatorOptions) {
      if (generatorOptions === void 0) {
        generatorOptions = {};
      }
      var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
      return function createPopper2(reference2, popper2, options) {
        if (options === void 0) {
          options = defaultOptions;
        }
        var state = {
          placement: "bottom",
          orderedModifiers: [],
          options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
          modifiersData: {},
          elements: {
            reference: reference2,
            popper: popper2
          },
          attributes: {},
          styles: {}
        };
        var effectCleanupFns = [];
        var isDestroyed = false;
        var instance = {
          state,
          setOptions: function setOptions(setOptionsAction) {
            var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
            cleanupModifierEffects();
            state.options = Object.assign({}, defaultOptions, state.options, options2);
            state.scrollParents = {
              reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
              popper: listScrollParents(popper2)
            };
            var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
            state.orderedModifiers = orderedModifiers.filter(function(m) {
              return m.enabled;
            });
            runModifierEffects();
            return instance.update();
          },
          // Sync update – it will always be executed, even if not necessary. This
          // is useful for low frequency updates where sync behavior simplifies the
          // logic.
          // For high frequency updates (e.g. `resize` and `scroll` events), always
          // prefer the async Popper#update method
          forceUpdate: function forceUpdate() {
            if (isDestroyed) {
              return;
            }
            var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
            if (!areValidElements(reference3, popper3)) {
              return;
            }
            state.rects = {
              reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
              popper: getLayoutRect(popper3)
            };
            state.reset = false;
            state.placement = state.options.placement;
            state.orderedModifiers.forEach(function(modifier) {
              return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
            });
            for (var index = 0; index < state.orderedModifiers.length; index++) {
              if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
              }
              var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
              if (typeof fn === "function") {
                state = fn({
                  state,
                  options: _options,
                  name: name2,
                  instance
                }) || state;
              }
            }
          },
          // Async and optimistically optimized update – it will not be executed if
          // not necessary (debounced to run at most once-per-tick)
          update: debounce$1(function() {
            return new Promise(function(resolve2) {
              instance.forceUpdate();
              resolve2(state);
            });
          }),
          destroy: function destroy() {
            cleanupModifierEffects();
            isDestroyed = true;
          }
        };
        if (!areValidElements(reference2, popper2)) {
          return instance;
        }
        instance.setOptions(options).then(function(state2) {
          if (!isDestroyed && options.onFirstUpdate) {
            options.onFirstUpdate(state2);
          }
        });
        function runModifierEffects() {
          state.orderedModifiers.forEach(function(_ref) {
            var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
            if (typeof effect2 === "function") {
              var cleanupFn = effect2({
                state,
                name: name2,
                instance,
                options: options2
              });
              var noopFn = function noopFn2() {
              };
              effectCleanupFns.push(cleanupFn || noopFn);
            }
          });
        }
        function cleanupModifierEffects() {
          effectCleanupFns.forEach(function(fn) {
            return fn();
          });
          effectCleanupFns = [];
        }
        return instance;
      };
    }
    var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$2, flip$1, preventOverflow$1, arrow$1, hide$1];
    var createPopper = /* @__PURE__ */ popperGenerator({
      defaultModifiers
    });
    const alignmentPositions$1 = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const isAlignmentValid$1 = (alignment) => Object.keys(alignmentPositions$1).find((value) => value === alignment);
    const _sfc_main$C = {
      name: "Tooltip",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Alignment of the Tooltip relative to the element that triggers it.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid$1(alignment);
          }
        },
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: String,
          default: "Help"
        },
        /**
         * Title prop for button icon
         */
        iconTitle: {
          type: String,
          default: ""
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for popover body.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Trigger element or function. If provided, the source slot will not be rendered.
         */
        source: {
          type: [HTMLElement, Function],
          default: null
        },
        /**
         * Content inside Tooltip.
         */
        text: {
          type: String,
          default: ""
        }
      },
      data() {
        return {
          localSource: null,
          isOpen: false,
          tooltipId: getGUID(),
          popperInstance: null
        };
      },
      computed: {
        computedText() {
          return this.$props.text.replaceAll(/(<br>|<br \/>)/gm, "\n").replaceAll("<br />", "\n").replaceAll("&lt;br /&gt;", "\n").replaceAll(/(\\r\\n|\\n|\\r)/gm, "\n");
        },
        computedIconTitle() {
          return this.$props.iconTitle || this.$props.assistiveText;
        }
      },
      watch: {
        "$props.source": {
          handler() {
            if (!this.$props.source)
              return;
            if (this.$slots.source) {
              throw new Error("Cannot set source prop and provide a default source");
            }
            this.processSource(this.$props.source);
          },
          immediate: true
        },
        alignment() {
          if (isAlignmentValid$1(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions$1[this.$props.alignment]
            });
          }
        }
      },
      mounted() {
        if (this.$props.source)
          return;
        let source;
        if (this.$slots.source) {
          source = this.$refs.source;
        } else {
          source = this.$refs.defaultSource.$el;
        }
        this.processSource(source);
      },
      beforeUnmount() {
        this.removeListeners();
      },
      methods: {
        async processSource(source) {
          this.removeListeners();
          this.localSource = typeof source === "function" ? await source() : source;
          this.localSource.setAttribute("aria-describedby", this.tooltipId);
          this.addListeners();
          if (this.popperInstance) {
            this.popperInstance.state.elements.reference = this.localSource;
          } else {
            this.$nextTick(this.setPopperInstance);
          }
        },
        setPopperInstance() {
          this.popperInstance = createPopper(this.localSource, this.$refs.tooltip, {
            strategy: this.$props.position,
            placement: alignmentPositions$1[this.$props.alignment],
            modifiers: [
              {
                name: "offset",
                options: {
                  offset: ({ placement }) => {
                    if (placement.includes("end")) {
                      return [16, 14];
                    }
                    if (placement.includes("start")) {
                      return [-16, 14];
                    }
                    return [0, 14];
                  }
                }
              },
              {
                name: "preventOverflow",
                options: {
                  padding: this.$props.overflowPadding
                }
              }
            ]
          });
          this.$nextTick(() => {
            if (document.activeElement === this.localSource)
              this.enter();
          });
        },
        addListeners() {
          const showEvents = ["mouseenter", "focus"];
          const hideEvents = ["mouseleave", "blur"];
          showEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.enter);
          });
          hideEvents.forEach((event) => {
            this.localSource.addEventListener(event, this.leave);
          });
        },
        removeListeners() {
          if (!this.localSource)
            return;
          this.localSource.removeEventListener("focus", this.enter);
          this.localSource.removeEventListener("mouseenter", this.enter);
          this.localSource.removeEventListener("blur", this.leave);
          this.localSource.removeEventListener("mouseleave", this.leave);
        },
        enter() {
          this.isOpen = true;
          this.popperInstance.update();
        },
        leave() {
          if (document.activeElement === this.localSource)
            return;
          this.isOpen = false;
        }
      }
    };
    const _withScopeId$9 = (n) => (pushScopeId("data-v-0233e977"), n = n(), popScopeId(), n);
    const _hoisted_1$x = {
      key: 0,
      ref: "source"
    };
    const _hoisted_2$w = ["id"];
    const _hoisted_3$t = { class: "slds-popover__body" };
    const _hoisted_4$r = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        !_ctx.$props.source ? (openBlock(), createElementBlock("span", _hoisted_1$x, [
          renderSlot(_ctx.$slots, "source", {}, () => [
            createVNode(_component_ButtonIcon, {
              ref: "defaultSource",
              "aria-describedby": $data.tooltipId,
              "aria-disabled": "true",
              iconCategory: "utility",
              iconName: "info",
              iconSize: "xx-small",
              assistiveText: _ctx.$props.assistiveText,
              title: $options.computedIconTitle
            }, null, 8, ["aria-describedby", "assistiveText", "title"])
          ], true)
        ], 512)) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", {
          id: $data.tooltipId,
          ref: "tooltip",
          class: "slds-popover slds-popover_tooltip",
          role: "tooltip"
        }, [
          createBaseVNode("div", _hoisted_3$t, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedText)), 1)
            ], true)
          ]),
          _hoisted_4$r
        ], 8, _hoisted_2$w), [
          [vShow, $data.isOpen]
        ])
      ]);
    }
    const Tooltip = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$A], ["__scopeId", "data-v-0233e977"]]);
    const defaultLabels$5 = () => ({
      name: "Default Label",
      stateOn: "Enabled",
      stateOff: "Disabled",
      required: "required"
    });
    const _sfc_main$B = {
      name: "Checkbox",
      components: {
        Icon,
        Tooltip
      },
      mixins: [decodeHtml],
      props: {
        /**
         * The aria-labelledby attribute establishes relationships between objects and their label(s), and its value should be one or more element IDs, which refer to elements that have the text needed for labeling. List multiple element IDs in a space delimited fashion.
         */
        ariaLabeledBy: {
          type: String,
          default: ""
        },
        /**
         * Disables the Checkbox and prevents clicking it.
         */
        disabled: Boolean,
        /**
         * An array of errors used for checkbox validation.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Content for Tooltip component that is displayed next to the label. Only for use with form element variant.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Adds assistive text class to visually hide checkbox label.
         */
        hideLabel: Boolean,
        /**
         * Adds a tertiary state to no-slide checkboxes.
         */
        indeterminate: Boolean,
        /**
         * Shows label as a block element.
         */
        isFormElement: Boolean,
        /**
         * Labels object for the checkbox
         */
        labels: {
          type: Object,
          default: () => {
          },
          validator: (value) => {
            if (!value || !value.name) {
              console.error('You must provide a "name" label, because it is the minimum requirement for accessibility. If you do not want to render the label than set hideLabel to true and the "name" label will be used as assistive text.');
              return false;
            }
            return true;
          }
        },
        /**
         * v-model binding.
         */
        modelValue: Boolean,
        /**
         * Displays the value of the input, but does not allow changes.
         */
        readonly: Boolean,
        /**
         * Highlights the Checkbox as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * Shows state labels for toggle variant.
         */
        showStateLabels: Boolean,
        /**
         * Checkbox Toggle variant.
         */
        slide: Boolean,
        // TODO - Change to 'toggle' in next major release to align with SLDS terminology
        toggleBuffer: {
          type: Number,
          default: 0
        }
      },
      data() {
        return {
          checkboxId: getGUID(),
          errorId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().checkbox || {} : {};
          return {
            ...defaultLabels$5(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length && !this.$props.slide;
        },
        checkboxClass() {
          return !this.slide ? "slds-form-element__control" : "slds-checkbox_toggle slds-grid";
        }
      },
      watch: {
        modelValue(checked) {
          if (this.$refs.checkbox) {
            this.$refs.checkbox.checked = checked;
          }
          if (checked) {
            this.$emit("update:indeterminate", false);
          }
        },
        indeterminate: {
          handler(state) {
            if (!this.$props.slide) {
              this.$nextTick(() => {
                this.$refs.checkbox.indeterminate = state;
                if (state) {
                  this.$emit("update:modelValue", false);
                }
              });
            }
          },
          immediate: true
        }
      },
      mounted() {
        if (this.$refs.checkbox) {
          this.$refs.checkbox.checked = this.$props.modelValue;
        }
      },
      methods: {
        onClick(e) {
          if (!e.clientX && !e.clientY)
            return;
          if (e.currentTarget.checked && this.toggleBuffer) {
            this.$refs.checkbox.disabled = true;
            setTimeout(() => {
              this.$refs.checkbox.disabled = false;
            }, this.toggleBuffer);
          }
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.checked);
        }
      }
    };
    const _withScopeId$8 = (n) => (pushScopeId("data-v-6891711e"), n = n(), popScopeId(), n);
    const _hoisted_1$w = ["title"];
    const _hoisted_2$v = ["checked", "disabled", "aria-describedby"];
    const _hoisted_3$s = ["id"];
    const _hoisted_4$q = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_5$p = {
      key: 0,
      class: "slds-checkbox_on"
    };
    const _hoisted_6$m = {
      key: 1,
      class: "slds-checkbox_off"
    };
    const _hoisted_7$j = ["for"];
    const _hoisted_8$g = ["title"];
    const _hoisted_9$e = { class: "slds-form-element__control" };
    const _hoisted_10$c = {
      key: 0,
      class: "slds-checkbox slds-checkbox_standalone"
    };
    const _hoisted_11$b = ["id", "aria-describedby", "checked", "disabled"];
    const _hoisted_12$9 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_13$a = {
      key: 2,
      class: "slds-form-element__control"
    };
    const _hoisted_14$8 = {
      key: 0,
      class: "slds-checkbox"
    };
    const _hoisted_15$6 = ["title"];
    const _hoisted_16$6 = ["id", "checked", "disabled", "aria-describedby", "aria-labelledby"];
    const _hoisted_17$5 = ["id", "for"];
    const _hoisted_18$4 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createBaseVNode("span", { class: "slds-checkbox_faux" }, null, -1));
    const _hoisted_19$4 = { class: "slds-form-element__label slds-m-left_x-small" };
    const _hoisted_20$4 = ["id"];
    function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $props.slide ? (openBlock(), createElementBlock("label", {
          key: 0,
          class: normalizeClass($options.checkboxClass)
        }, [
          !$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_1$w)) : createCommentVNode("", true),
            createBaseVNode("span", {
              class: normalizeClass(["slds-form-element__label slds-m-bottom_none", { "slds-assistive-text": _ctx.$props.hideLabel }])
            }, [
              createBaseVNode("span", null, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
            ], 2),
            createBaseVNode("input", mergeProps({
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": $data.labelId,
              type: "checkbox",
              onClick: _cache[0] || (_cache[0] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_2$v),
            createBaseVNode("span", {
              id: $data.labelId,
              class: "slds-checkbox_faux_container",
              "aria-live": "assertive"
            }, [
              _hoisted_4$q,
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_5$p, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOn)), 1)) : createCommentVNode("", true),
              $props.showStateLabels ? (openBlock(), createElementBlock("span", _hoisted_6$m, toDisplayString(_ctx.decodeHtml($options.computedLabels.stateOff)), 1)) : createCommentVNode("", true)
            ], 8, _hoisted_3$s)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ])
          ], 64))
        ], 2)) : $props.isFormElement ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createBaseVNode("label", {
            class: "slds-form-element__label",
            for: $data.checkboxId
          }, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_8$g)) : createCommentVNode("", true),
            createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 8, _hoisted_7$j),
          _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
            key: 0,
            class: "slds-form-element__icon",
            alignment: "top right",
            text: _ctx.$props.helpText
          }, null, 8, ["text"])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_9$e, [
            !$props.readonly ? (openBlock(), createElementBlock("span", _hoisted_10$c, [
              createBaseVNode("input", mergeProps({
                id: $data.checkboxId,
                ref: "checkbox",
                "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                checked: _ctx.$props.modelValue || false,
                disabled: $props.disabled,
                type: "checkbox",
                onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                onInput: _cache[3] || (_cache[3] = (...args) => $options.onInput && $options.onInput(...args))
              }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_11$b),
              _hoisted_12$9
            ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "check",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, _ctx.$props.modelValue]
              ]),
              withDirectives(createVNode(_component_Icon, {
                category: "utility",
                name: "steps",
                size: "x-small",
                class: "slds-current-color"
              }, null, 512), [
                [vShow, !_ctx.$props.modelValue]
              ])
            ], 64))
          ])
        ], 64)) : (openBlock(), createElementBlock("div", _hoisted_13$a, [
          !$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_14$8, [
            $props.required ? (openBlock(), createElementBlock("abbr", {
              key: 0,
              class: "slds-required",
              title: $options.computedLabels.required
            }, "*", 8, _hoisted_15$6)) : createCommentVNode("", true),
            createBaseVNode("input", mergeProps({
              id: $data.checkboxId,
              ref: "checkbox",
              checked: _ctx.$props.modelValue || false,
              disabled: $props.disabled,
              "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
              "aria-labelledby": `${$data.labelId} ${_ctx.$props.ariaLabeledBy}`,
              type: "checkbox",
              onClick: _cache[4] || (_cache[4] = (...args) => $options.onClick && $options.onClick(...args)),
              onInput: _cache[5] || (_cache[5] = (...args) => $options.onInput && $options.onInput(...args))
            }, toHandlers(_ctx.$attrs, true)), null, 16, _hoisted_16$6),
            createBaseVNode("label", {
              id: $data.labelId,
              for: $data.checkboxId,
              class: "slds-checkbox__label"
            }, [
              _hoisted_18$4,
              createBaseVNode("span", {
                class: normalizeClass(["slds-form-element__label", { "slds-assistive-text": _ctx.$props.hideLabel }])
              }, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 3)
            ], 8, _hoisted_17$5)
          ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "check",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, _ctx.$props.modelValue]
            ]),
            withDirectives(createVNode(_component_Icon, {
              category: "utility",
              name: "steps",
              size: "x-small",
              class: "slds-current-color"
            }, null, 512), [
              [vShow, !_ctx.$props.modelValue]
            ]),
            createBaseVNode("span", _hoisted_19$4, toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
          ], 64))
        ])),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 3,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_20$4)) : createCommentVNode("", true)
      ], 2);
    }
    const Checkbox = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$z], ["__scopeId", "data-v-6891711e"]]);
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var colorName = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
    const cssKeywords = colorName;
    const reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    const convert$1 = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    var conversions$2 = convert$1;
    for (const model of Object.keys(convert$1)) {
      if (!("channels" in convert$1[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert$1[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert$1[model].labels.length !== convert$1[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert$1[model];
      delete convert$1[model].channels;
      delete convert$1[model].labels;
      Object.defineProperty(convert$1[model], "channels", { value: channels });
      Object.defineProperty(convert$1[model], "labels", { value: labels });
    }
    convert$1.rgb.hsl = function(rgb2) {
      const r = rgb2[0] / 255;
      const g = rgb2[1] / 255;
      const b = rgb2[2] / 255;
      const min2 = Math.min(r, g, b);
      const max2 = Math.max(r, g, b);
      const delta = max2 - min2;
      let h2;
      let s;
      if (max2 === min2) {
        h2 = 0;
      } else if (r === max2) {
        h2 = (g - b) / delta;
      } else if (g === max2) {
        h2 = 2 + (b - r) / delta;
      } else if (b === max2) {
        h2 = 4 + (r - g) / delta;
      }
      h2 = Math.min(h2 * 60, 360);
      if (h2 < 0) {
        h2 += 360;
      }
      const l = (min2 + max2) / 2;
      if (max2 === min2) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max2 + min2);
      } else {
        s = delta / (2 - max2 - min2);
      }
      return [h2, s * 100, l * 100];
    };
    convert$1.rgb.hsv = function(rgb2) {
      let rdif;
      let gdif;
      let bdif;
      let h2;
      let s;
      const r = rgb2[0] / 255;
      const g = rgb2[1] / 255;
      const b = rgb2[2] / 255;
      const v = Math.max(r, g, b);
      const diff2 = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff2 + 1 / 2;
      };
      if (diff2 === 0) {
        h2 = 0;
        s = 0;
      } else {
        s = diff2 / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h2 = bdif - gdif;
        } else if (g === v) {
          h2 = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h2 = 2 / 3 + gdif - rdif;
        }
        if (h2 < 0) {
          h2 += 1;
        } else if (h2 > 1) {
          h2 -= 1;
        }
      }
      return [
        h2 * 360,
        s * 100,
        v * 100
      ];
    };
    convert$1.rgb.hwb = function(rgb2) {
      const r = rgb2[0];
      const g = rgb2[1];
      let b = rgb2[2];
      const h2 = convert$1.rgb.hsl(rgb2)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h2, w * 100, b * 100];
    };
    convert$1.rgb.cmyk = function(rgb2) {
      const r = rgb2[0] / 255;
      const g = rgb2[1] / 255;
      const b = rgb2[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y2 = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y2 * 100, k * 100];
    };
    function comparativeDistance(x2, y2) {
      return (x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2 + (x2[2] - y2[2]) ** 2;
    }
    convert$1.rgb.keyword = function(rgb2) {
      const reversed = reverseKeywords[rgb2];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb2, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert$1.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert$1.rgb.xyz = function(rgb2) {
      let r = rgb2[0] / 255;
      let g = rgb2[1] / 255;
      let b = rgb2[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x2 = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y2 = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x2 * 100, y2 * 100, z * 100];
    };
    convert$1.rgb.lab = function(rgb2) {
      const xyz = convert$1.rgb.xyz(rgb2);
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y2 - 16;
      const a = 500 * (x2 - y2);
      const b = 200 * (y2 - z);
      return [l, a, b];
    };
    convert$1.hsl.rgb = function(hsl2) {
      const h2 = hsl2[0] / 360;
      const s = hsl2[1] / 100;
      const l = hsl2[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb2 = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h2 + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb2[i] = val * 255;
      }
      return rgb2;
    };
    convert$1.hsl.hsv = function(hsl2) {
      const h2 = hsl2[0];
      let s = hsl2[1] / 100;
      let l = hsl2[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h2, sv * 100, v * 100];
    };
    convert$1.hsv.rgb = function(hsv) {
      const h2 = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h2) % 6;
      const f = h2 - Math.floor(h2);
      const p2 = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p2];
        case 1:
          return [q, v, p2];
        case 2:
          return [p2, v, t];
        case 3:
          return [p2, q, v];
        case 4:
          return [t, p2, v];
        case 5:
          return [v, p2, q];
      }
    };
    convert$1.hsv.hsl = function(hsv) {
      const h2 = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h2, sl * 100, l * 100];
    };
    convert$1.hwb.rgb = function(hwb) {
      const h2 = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h2);
      const v = 1 - bl;
      f = 6 * h2 - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert$1.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y2 = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y2 * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.rgb = function(xyz) {
      const x2 = xyz[0] / 100;
      const y2 = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x2 * 3.2406 + y2 * -1.5372 + z * -0.4986;
      g = x2 * -0.9689 + y2 * 1.8758 + z * 0.0415;
      b = x2 * 0.0557 + y2 * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert$1.xyz.lab = function(xyz) {
      let x2 = xyz[0];
      let y2 = xyz[1];
      let z = xyz[2];
      x2 /= 95.047;
      y2 /= 100;
      z /= 108.883;
      x2 = x2 > 8856e-6 ? x2 ** (1 / 3) : 7.787 * x2 + 16 / 116;
      y2 = y2 > 8856e-6 ? y2 ** (1 / 3) : 7.787 * y2 + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y2 - 16;
      const a = 500 * (x2 - y2);
      const b = 200 * (y2 - z);
      return [l, a, b];
    };
    convert$1.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x2;
      let y2;
      let z;
      y2 = (l + 16) / 116;
      x2 = a / 500 + y2;
      z = y2 - b / 200;
      const y22 = y2 ** 3;
      const x22 = x2 ** 3;
      const z2 = z ** 3;
      y2 = y22 > 8856e-6 ? y22 : (y2 - 16 / 116) / 7.787;
      x2 = x22 > 8856e-6 ? x22 : (x2 - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x2 *= 95.047;
      y2 *= 100;
      z *= 108.883;
      return [x2, y2, z];
    };
    convert$1.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h2;
      const hr = Math.atan2(b, a);
      h2 = hr * 360 / 2 / Math.PI;
      if (h2 < 0) {
        h2 += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h2];
    };
    convert$1.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h2 = lch[2];
      const hr = h2 / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert$1.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert$1.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert$1.hsv.ansi16 = function(args) {
      return convert$1.rgb.ansi16(convert$1.hsv.rgb(args), args[2]);
    };
    convert$1.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert$1.ansi16.rgb = function(args) {
      let color2 = args % 10;
      if (color2 === 0 || color2 === 7) {
        if (args > 50) {
          color2 += 3.5;
        }
        color2 = color2 / 10.5 * 255;
        return [color2, color2, color2];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color2 & 1) * mult * 255;
      const g = (color2 >> 1 & 1) * mult * 255;
      const b = (color2 >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert$1.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert$1.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert$1.rgb.hcg = function(rgb2) {
      const r = rgb2[0] / 255;
      const g = rgb2[1] / 255;
      const b = rgb2[2] / 255;
      const max2 = Math.max(Math.max(r, g), b);
      const min2 = Math.min(Math.min(r, g), b);
      const chroma = max2 - min2;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min2 / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max2 === r) {
        hue = (g - b) / chroma % 6;
      } else if (max2 === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert$1.hsl.hcg = function(hsl2) {
      const s = hsl2[1] / 100;
      const l = hsl2[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl2[0], c * 100, f * 100];
    };
    convert$1.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert$1.hcg.rgb = function(hcg) {
      const h2 = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h2 % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert$1.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert$1.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert$1.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert$1.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert$1.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert$1.rgb.apple = function(rgb2) {
      return [rgb2[0] / 255 * 65535, rgb2[1] / 255 * 65535, rgb2[2] / 255 * 65535];
    };
    convert$1.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert$1.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert$1.gray.hsv = convert$1.gray.hsl;
    convert$1.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert$1.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert$1.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert$1.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert$1.rgb.gray = function(rgb2) {
      const val = (rgb2[0] + rgb2[1] + rgb2[2]) / 3;
      return [val / 255 * 100];
    };
    const conversions$1 = conversions$2;
    function buildGraph() {
      const graph = {};
      const models2 = Object.keys(conversions$1);
      for (let len = models2.length, i = 0; i < len; i++) {
        graph[models2[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue2 = [fromModel];
      graph[fromModel].distance = 0;
      while (queue2.length) {
        const current = queue2.pop();
        const adjacents = Object.keys(conversions$1[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue2.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link$1(from2, to2) {
      return function(args) {
        return to2(from2(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions$1[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link$1(conversions$1[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    var route$1 = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models2 = Object.keys(graph);
      for (let len = models2.length, i = 0; i < len; i++) {
        const toModel = models2[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
    const conversions = conversions$2;
    const route = route$1;
    const convert = {};
    const models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    const _sfc_main$A = {
      name: "Tabs",
      components: { Icon },
      mixins: [decodeHtml],
      provide() {
        return {
          addTab: (tab) => this.tabs.push(tab),
          updateTab: (tab) => {
            const tabIndex = this.tabs.findIndex((t) => t.id === tab.id);
            this.tabs[tabIndex] = tab;
          }
        };
      },
      props: {
        /**
         * Represents active tab id. If not specified, the first tab is set as active.
         */
        modelValue: String | Number,
        /**
         * Vertical Navigation variant represents a list of links that either take the user to another page or parts of the page the user is in. `vertical` prop must be set to true.
         */
        navigation: {
          type: Boolean,
          default: false,
          validation: () => (void 0).vertical
        },
        /**
         * Scoped tab variant. Mainly used for nested tabs.
         */
        scoped: {
          type: Boolean,
          default: false,
          validation: () => !(void 0).vertical
        },
        /**
         * Vertical tab variant.
         */
        vertical: {
          type: Boolean,
          default: false,
          validation: () => !(void 0).scoped
        },
        /**
         * Invoked when a tab change is requested. If the callback returns true the tab change occurs.
         * If the callback returns false the tab change request is rejected.
         *
         * <strong>Callback Arguments</strong><br>
         * requestedTabId - id of the requested tab<br>
         * currentTabId - id of the current tab
         */
        onRequestTabChange: {
          type: Function,
          default: null
        }
      },
      data() {
        return {
          tabs: [],
          localActiveTabId: null
        };
      },
      computed: {
        tabClass() {
          let result = "slds-tabs_default";
          if (this.$props.scoped) {
            result = "slds-tabs_scoped";
          } else if (this.$props.vertical) {
            result = "slds-vertical-tabs";
          }
          return result;
        },
        selectedTabIndex() {
          return this.tabs.findIndex((tab) => tab.id === this.localActiveTabId);
        }
      },
      watch: {
        modelValue() {
          this.setActiveTab();
        }
      },
      mounted() {
        this.setActiveTab();
      },
      methods: {
        setActiveTab() {
          this.selectTab(this.$props.modelValue || this.tabs[0].id);
        },
        allowTabChange(tabId) {
          if (typeof this.$props.onRequestTabChange === "function") {
            return this.$props.onRequestTabChange(tabId, this.activeTabId);
          }
          return true;
        },
        getListItemCSSClasses(tab) {
          if (tab.sectionHeader)
            return [];
          const classes = [];
          if (!this.$props.navigation && this.$props.vertical) {
            classes.push(`${this.tabClass}__nav-item`);
          } else if (this.$props.navigation && this.$props.vertical) {
            classes.push("slds-nav-vertical__item");
          } else {
            classes.push(`${this.tabClass}__item`);
          }
          if (tab.active)
            classes.push("slds-is-active");
          if (tab.invalid)
            classes.push("slds-has-error");
          if (tab.anchorFocused)
            classes.push("slds-has-focus");
          if (tab.disabled)
            classes.push("section-disabled");
          return classes;
        },
        onClick(event, tab) {
          if (tab.link) {
            if (typeof tab.link === "function") {
              tab.link();
            } else {
              window.open(tab.link, "self");
            }
          } else {
            this.selectTab(tab.id, event);
          }
        },
        async selectTab(tabId, event) {
          if (this.localActiveTabId === tabId) {
            if (event) {
              event.preventDefault();
            }
            return;
          }
          const selectedTab = this.tabs.find((tab) => tab.id === tabId);
          if (!selectedTab || selectedTab.disabled)
            return;
          if (!await this.allowTabChange(tabId))
            return;
          this.tabs.forEach((tab) => {
            const selected = tab.id === selectedTab.id;
            tab.active = selected;
            tab.setActive(selected);
            if (selected)
              this.focusOnTablistItem(tab);
          });
          this.localActiveTabId = tabId;
          this.$emit("changed", selectedTab.id);
          this.$emit("update:modelValue", tabId);
        },
        nextTab() {
          let i = this.selectedTabIndex === this.tabs.length - 1 ? 0 : this.selectedTabIndex + 1;
          while (this.tabs[i].disabled || this.tabs[i].sectionHeader) {
            if (i < this.tabs.length - 1) {
              i++;
            } else {
              i = 0;
            }
          }
          this.selectTab(this.tabs[i].id);
        },
        previousTab() {
          let i = this.selectedTabIndex === 0 ? this.tabs.length - 1 : this.selectedTabIndex - 1;
          while (this.tabs[i].disabled || this.tabs[i].sectionHeader) {
            if (i > 0) {
              i--;
            } else {
              i = this.tabs.length - 1;
            }
          }
          this.selectTab(this.tabs[i].id);
        },
        focusOnTablistItem(tab) {
          this.$refs.tablist.querySelector(`[aria-controls="${tab.id}"]`).focus();
        },
        doRenderIcon(tab) {
          return this.$props.navigation && tab.iconCategory && tab.iconName && tab.iconAssistiveText;
        }
      }
    };
    const _hoisted_1$v = ["title", "tabId", "onClick"];
    const _hoisted_2$u = ["id", "aria-selected", "aria-controls", "tabindex", "onFocus", "onBlur", "onClick"];
    function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([$options.tabClass])
      }, [
        createBaseVNode("ul", {
          ref: "tablist",
          class: normalizeClass([!_ctx.$props.navigation ? `${$options.tabClass}__nav` : "navigation-list"]),
          role: "tablist",
          onKeydown: [
            _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.nextTab && $options.nextTab(...args), ["prevent"]), ["right"])),
            _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.nextTab && $options.nextTab(...args), ["prevent"]), ["down"])),
            _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.previousTab && $options.previousTab(...args), ["prevent"]), ["left"])),
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.previousTab && $options.previousTab(...args), ["prevent"]), ["up"]))
          ]
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.tabs, (tab, index) => {
            return openBlock(), createElementBlock("li", mergeProps({
              key: index,
              class: $options.getListItemCSSClasses(tab),
              title: tab.title,
              role: "presentation",
              tabId: tab.id,
              onClick: ($event) => _ctx.$emit("tab-click", tab.id, $event)
            }, toHandlers(_ctx.$attrs, true)), [
              !tab.sectionHeader ? (openBlock(), createElementBlock("a", {
                key: 0,
                id: `${tab.id}__item`,
                class: normalizeClass([!_ctx.$props.navigation ? `${$options.tabClass}__link` : "slds-nav-vertical__action"]),
                "aria-selected": tab.id === $data.localActiveTabId,
                "aria-controls": tab.id,
                tabindex: tab.id === $data.localActiveTabId ? 0 : -1,
                href: "javascript:void(0);",
                role: "tab",
                onFocus: ($event) => tab.anchorFocused = true,
                onBlur: ($event) => tab.anchorFocused = false,
                onClick: ($event) => $options.onClick($event, tab)
              }, [
                $options.doRenderIcon(tab) ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  category: tab.iconCategory,
                  name: tab.iconName,
                  size: "x-small",
                  assistiveText: tab.iconAssistiveText,
                  class: "slds-m-right_x-small slds-line-height_reset"
                }, null, 8, ["category", "name", "assistiveText"])) : createCommentVNode("", true),
                createTextVNode(" " + toDisplayString(_ctx.decodeHtml(tab.title)) + " ", 1),
                tab.invalid ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass([_ctx.$props.vertical ? "slds-vertical-tabs__right-icon" : "slds-tabs__right-icon"])
                }, [
                  createVNode(_component_Icon, {
                    category: "utility",
                    name: "error",
                    size: "x-small",
                    variant: "error",
                    assistiveText: "This item has an error"
                  })
                ], 2)) : createCommentVNode("", true)
              ], 42, _hoisted_2$u)) : (openBlock(), createElementBlock("h2", {
                key: 1,
                class: normalizeClass([{ "section-disabled": tab.disabled }, "slds-nav-vertical__title"])
              }, toDisplayString(_ctx.decodeHtml(tab.title)), 3))
            ], 16, _hoisted_1$v);
          }), 128)),
          renderSlot(_ctx.$slots, "content", {}, void 0, true)
        ], 34),
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    }
    const Tabs = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$y], ["__scopeId", "data-v-87fbdef9"]]);
    const _sfc_main$z = {
      name: "Tab",
      inject: ["addTab", "updateTab"],
      props: {
        /**
         * Disables tab.
         */
        disabled: Boolean,
        /**
         * Forces reload of tab content.
         */
        forceReloadWhenActivated: Boolean,
        /**
         * Name of the icon category.
         */
        iconCategory: {
          type: String,
          default: null
        },
        /**
         * Name of the icon.
         */
        iconName: {
          type: String,
          default: null
        },
        /**
         * Assistive text for tab icon
         */
        iconAssistiveText: {
          type: String,
          default: ""
        },
        /**
         * HTML id attribute.
         */
        id: {
          type: String,
          required: true
        },
        /**
         * Styles tab as section header.
         */
        isSectionHeader: Boolean,
        /**
         * Sets tab status as valid.
         */
        invalid: Boolean,
        /**
         * Either a string containing a link, or a function.
         */
        link: {
          type: [String, Function],
          default: ""
        },
        /**
         * Renders tab content immediately.
         */
        renderImmediately: Boolean,
        /**
         * Required title of the tab.
         */
        title: {
          type: String,
          required: true
        }
      },
      data() {
        return {
          active: false,
          vertical: false,
          loaded: false,
          anchorFocused: false
        };
      },
      watch: {
        $props() {
          this.updateTab({
            ...this.$props,
            ...this.$data,
            setActive: (state) => {
              this.active = state;
            }
          });
        },
        active() {
          if (this.loaded || this.forceReloadWhenActivated)
            return;
          this.loaded = true;
        }
      },
      created() {
        this.addTab({
          ...this.$props,
          ...this.$data,
          setActive: (state) => {
            this.active = state;
          }
        });
      },
      methods: {
        getCSSClasses() {
          const classes = [this.active ? "slds-show" : "slds-hide"];
          classes.push(`${this.$parent.$props.vertical ? "slds-vertical-tabs" : "slds-tabs_default"}__content`);
          return classes;
        }
      }
    };
    const _hoisted_1$u = ["id", "aria-labelledby"];
    function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
      return $props.renderImmediately || $data.active || $data.loaded ? (openBlock(), createElementBlock("div", {
        key: 0,
        id: $props.id,
        class: normalizeClass($options.getCSSClasses()),
        "aria-labelledby": `${$props.id}__item`,
        role: "tabpanel"
      }, [
        renderSlot(_ctx.$slots, "default", {
          state: { active: $data.active, loaded: $data.loaded }
        })
      ], 10, _hoisted_1$u)) : createCommentVNode("", true);
    }
    const Tab = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$x]]);
    const ConditionalWrapper = {
      name: "ConditionalWrapper",
      functional: true,
      inheritAttrs: false,
      props: {
        element: {
          type: String,
          required: true
        },
        active: Boolean
      },
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        if (this.$props.active) {
          return h(
            this.$props.element,
            {
              ...this.$attrs
            },
            _default
          );
        }
        return _default;
      }
    };
    function debounce(func, wait, immediate) {
      var timeout2, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout2 = setTimeout(later, wait - last);
        } else {
          timeout2 = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout2;
        if (!timeout2)
          timeout2 = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      debounced.flush = function() {
        if (timeout2) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout2);
          timeout2 = null;
        }
      };
      return debounced;
    }
    debounce.debounce = debounce;
    var debounce_1 = debounce;
    const _debounce = /* @__PURE__ */ getDefaultExportFromCjs(debounce_1);
    var vClickOutside_umd = { exports: {} };
    (function(module2, exports2) {
      !function(e, n) {
        module2.exports = n();
      }(commonjsGlobal, function() {
        var e = "__v-click-outside", n = "undefined" != typeof window, t = "undefined" != typeof navigator, r = n && ("ontouchstart" in window || t && navigator.msMaxTouchPoints > 0) ? ["touchstart"] : ["click"], i = function(e2) {
          var n2 = e2.event, t2 = e2.handler;
          (0, e2.middleware)(n2) && t2(n2);
        }, a = function(n2, t2) {
          var a2 = function(e2) {
            var n3 = "function" == typeof e2;
            if (!n3 && "object" != typeof e2)
              throw new Error("v-click-outside: Binding value must be a function or an object");
            return { handler: n3 ? e2 : e2.handler, middleware: e2.middleware || function(e3) {
              return e3;
            }, events: e2.events || r, isActive: !(false === e2.isActive), detectIframe: !(false === e2.detectIframe), capture: Boolean(e2.capture) };
          }(t2.value), o2 = a2.handler, d2 = a2.middleware, c = a2.detectIframe, u = a2.capture;
          if (a2.isActive) {
            if (n2[e] = a2.events.map(function(e2) {
              return { event: e2, srcTarget: document.documentElement, handler: function(e3) {
                return function(e4) {
                  var n3 = e4.el, t3 = e4.event, r2 = e4.handler, a3 = e4.middleware, o3 = t3.path || t3.composedPath && t3.composedPath();
                  (o3 ? o3.indexOf(n3) < 0 : !n3.contains(t3.target)) && i({ event: t3, handler: r2, middleware: a3 });
                }({ el: n2, event: e3, handler: o2, middleware: d2 });
              }, capture: u };
            }), c) {
              var l = { event: "blur", srcTarget: window, handler: function(e2) {
                return function(e3) {
                  var n3 = e3.el, t3 = e3.event, r2 = e3.handler, a3 = e3.middleware;
                  setTimeout(function() {
                    var e4 = document.activeElement;
                    e4 && "IFRAME" === e4.tagName && !n3.contains(e4) && i({ event: t3, handler: r2, middleware: a3 });
                  }, 0);
                }({ el: n2, event: e2, handler: o2, middleware: d2 });
              }, capture: u };
              n2[e] = [].concat(n2[e], [l]);
            }
            n2[e].forEach(function(t3) {
              var r2 = t3.event, i2 = t3.srcTarget, a3 = t3.handler;
              return setTimeout(function() {
                n2[e] && i2.addEventListener(r2, a3, u);
              }, 0);
            });
          }
        }, o = function(n2) {
          (n2[e] || []).forEach(function(e2) {
            return e2.srcTarget.removeEventListener(e2.event, e2.handler, e2.capture);
          }), delete n2[e];
        }, d = n ? { beforeMount: a, updated: function(e2, n2) {
          var t2 = n2.value, r2 = n2.oldValue;
          JSON.stringify(t2) !== JSON.stringify(r2) && (o(e2), a(e2, { value: t2 }));
        }, unmounted: o } : {};
        return { install: function(e2) {
          e2.directive("click-outside", d);
        }, directive: d };
      });
    })(vClickOutside_umd);
    var vClickOutside_umdExports = vClickOutside_umd.exports;
    const vClickOutside = /* @__PURE__ */ getDefaultExportFromCjs(vClickOutside_umdExports);
    function groupBuilder() {
      const groups = {
        0: {
          options: [],
          filtered: []
        }
      };
      let numAsyncGroups = 0;
      let hasStaticOptions = false;
      let groupIndex = 1;
      const optionsLength = this.options.length;
      for (let i = 0; i < optionsLength; i++) {
        const option = this.options[i];
        const isGroup = option.options;
        if (isGroup) {
          const isTitledGroup = option.title;
          if (Array.isArray(option.options)) {
            const { title, options } = option;
            if (isTitledGroup) {
              groups[groupIndex++] = {
                title,
                options,
                // static data
                filtered: [],
                static: true
              };
            } else {
              groups[0].options = groups[0].options.concat(options);
            }
            hasStaticOptions = true;
          } else if (typeof option.options === "function") {
            const groupId = isTitledGroup ? groupIndex++ : 0;
            const optionsFunction = (term) => this.invokeOptionsFunction(option.options, groupId, term);
            const debounce2 = _debounce(optionsFunction, this.asyncDelay, option.lazy);
            const asyncOptions = {
              searchIndex: 0,
              cached: false,
              options: [],
              doCancelAsync: false,
              loading: false,
              async: true,
              lazy: option.lazy,
              optionsFunction,
              debounce: debounce2
            };
            if (isTitledGroup) {
              groups[groupId] = {
                title: option.title,
                filtered: [],
                ...asyncOptions
              };
            } else {
              groups[0] = {
                ...groups[0],
                ...asyncOptions
              };
            }
            numAsyncGroups++;
          }
        } else {
          groups[0].static = true;
          hasStaticOptions = true;
          if (typeof option === "object") {
            groups[0].options.push({ $__guid: getGUID(), ...option });
          } else if (["string", "number", "symbol"].includes(typeof option)) {
            const title = typeof option === "symbol" ? option.description : option.toString();
            groups[0].options.push({
              $__guid: getGUID(),
              [this.idKey]: option,
              [this.titleKey]: title
            });
          }
        }
      }
      return { groups, numAsyncGroups, hasStaticOptions };
    }
    const _sfc_main$y = {
      name: "Spinner",
      props: {
        /**
         * This centers the spinner indicator within the viewport. This is used for when the spinner's container overflows the viewport and the indicator may be hidden.
         */
        adjustForOverflow: Boolean,
        /**
         * Adds delay of 300ms to the spinner.
         */
        delayed: Boolean,
        /**
         * Sets the spinner container position attribute to `fixed`.
         */
        fixed: Boolean,
        /**
         * Starts animation immediately.
         */
        immediate: Boolean,
        /**
         * Add styling to support an inline spinner inside of the document flow.
         */
        inline: Boolean,
        /**
         * Assistive text label for the spinner.
         */
        loadingLabel: {
          type: String,
          default: "Loading"
        },
        /**
         * Determines the size of the spinner.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = ["xx-small", "x-small", "small", "medium", "large"];
            const isValid2 = validSizes.includes(value);
            if (!isValid2)
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Determines the color of the spinner: `base` is gray, `brand` is blue, and `inverse` is white.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = ["base", "brand", "inverse"];
            const isValid2 = validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Render the spinner without a container.
         */
        withoutContainer: Boolean
      },
      data() {
        return {
          observer: null
        };
      },
      computed: {
        spinnerClasses() {
          const classes = [];
          if (this.$props.immediate)
            classes.push("spm-spinner_immediate");
          if (this.$props.theme)
            classes.push(`slds-spinner_${this.$props.theme}`);
          if (this.$props.delayed)
            classes.push("slds-spinner_delayed");
          if (this.$props.size)
            classes.push(`slds-spinner_${this.$props.size}`);
          if (this.$props.inline)
            classes.push("slds-spinner_inline");
          return classes;
        },
        containerClasses() {
          const classes = [];
          if (!this.$props.withoutContainer || this.$slots.description)
            classes.push("slds-spinner_container");
          if (this.$props.fixed)
            classes.push("slds-is-fixed");
          return classes;
        }
      },
      created() {
        if (this.$props.adjustForOverflow) {
          window.addEventListener("scroll", this.updateContainerSize);
        }
      },
      mounted() {
        if (this.$props.adjustForOverflow) {
          this.updateContainerSize();
          this.observer = new MutationObserver(this.updateContainerSize);
          this.observer.observe(this.$refs.container, { attributes: true });
        }
      },
      beforeUnmount() {
        if (this.$props.adjustForOverflow) {
          window.removeEventListener("scroll", this.updateContainerSize);
          this.observer.disconnect();
          this.observer = null;
        }
      },
      methods: {
        updateContainerSize() {
          const spinnerContainer = this.$refs.container;
          const { parentNode } = spinnerContainer.parentNode;
          const parentRect = parentNode.getBoundingClientRect();
          const windowHeight = window.innerHeight;
          if (parentRect.height < windowHeight)
            return;
          if (parentRect.top < 0) {
            spinnerContainer.style.top = `${Math.abs(parentRect.top)}px`;
          } else {
            spinnerContainer.style.top = 0;
          }
          if (parentRect.bottom > windowHeight) {
            spinnerContainer.style.bottom = `${parentRect.bottom - windowHeight}px`;
          } else {
            spinnerContainer.style.bottom = 0;
          }
        }
      }
    };
    const _withScopeId$7 = (n) => (pushScopeId("data-v-21b087de"), n = n(), popScopeId(), n);
    const _hoisted_1$t = { class: "slds-assistive-text" };
    const _hoisted_2$t = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-a" }, null, -1));
    const _hoisted_3$r = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-spinner__dot-b" }, null, -1));
    const _hoisted_4$p = {
      key: 0,
      class: "description"
    };
    const _hoisted_5$o = {
      "aria-live": "assertive",
      class: "slds-grid slds-grid_vertical slds-p-top_xx-large slds-text-align_center"
    };
    function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass($options.containerClasses)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([$options.spinnerClasses, "slds-spinner"]),
          "aria-hidden": "false",
          role: "status"
        }, [
          createBaseVNode("span", _hoisted_1$t, toDisplayString(_ctx.$props.loadingLabel), 1),
          _hoisted_2$t,
          _hoisted_3$r
        ], 2),
        _ctx.$slots["description"] ? (openBlock(), createElementBlock("div", _hoisted_4$p, [
          createBaseVNode("div", _hoisted_5$o, [
            renderSlot(_ctx.$slots, "description", {}, void 0, true)
          ])
        ])) : createCommentVNode("", true)
      ], 2);
    }
    const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$w], ["__scopeId", "data-v-21b087de"]]);
    const {
      parseInt: parseInt$1,
      getComputedStyle: getComputedStyle$1
    } = window;
    const _sfc_main$x = {
      name: "PicklistDropdown",
      components: {
        Icon,
        Spinner
      },
      mixins: [decodeHtml],
      data() {
        return {
          focusedOption: null,
          paddingBuffer: 0,
          currentOptionsLength: this.getDefaultOptionsLength()
        };
      },
      computed: {
        focusedOptionId() {
          let result = null;
          if (this.focusedOption) {
            result = this.focusedOption.dataset.id;
            if (this.focusedOption.dataset.type === "number") {
              result = parseInt$1(result);
            }
            if (this.focusedOption.dataset.type === "symbol") {
              result = Symbol.for(result);
            }
          }
          return result;
        },
        computedOptionGroups() {
          const result = {};
          let remaining = this.currentOptionsLength;
          Object.entries(this.$parent.groupData.groups).forEach(([key, group]) => {
            if (group.async || group.filtered.length) {
              if (remaining === 0)
                return;
              let renderLength;
              if (group.filtered.length >= remaining) {
                renderLength = remaining;
                remaining = 0;
              } else {
                renderLength = group.filtered.length;
                remaining -= group.filtered.length;
              }
              result[key] = {
                renderLength,
                ...group
              };
            }
          });
          return result;
        },
        doRenderGlobalNoSearchResults() {
          return this.$parent.groupData.hasStaticOptions && !Object.values(this.$parent.groupData.groups).some((group) => group.async || group.filtered.length);
        }
      },
      watch: {
        focusedOption() {
          this.$parent.focusedOptionId = this.focusedOptionId;
        },
        "$parent.groupData.groups": {
          handler() {
            if (this.$parent.computedDoRenderDropdown) {
              this.currentOptionsLength = this.getDefaultOptionsLength();
              this.$nextTick(this.setDropdownHeight);
            }
          },
          deep: true,
          immediate: true
        },
        "$parent.comboboxInputOption": {
          handler(value) {
            this.$nextTick(() => {
              this.focusedOption = value ? this.$refs.comboboxInputOption : this.getFirstAvailableOptionEl();
              this.$el.scrollTop = 0;
            });
          }
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.paddingBuffer = parseInt$1(getComputedStyle$1(this.$el).paddingTop || 0);
        });
      },
      methods: {
        getDefaultOptionsLength() {
          if (this.$parent.$props.pageSize <= 0) {
            return Infinity;
          }
          return Math.max(this.$parent.$props.pageSize, this.$parent.$props.heightInNumOptions + 1);
        },
        getListRole(groupId) {
          return !groupId ? "presentation" : "group";
        },
        setDropdownHeight() {
          var _a, _b, _c;
          const dropdown = this.$el;
          let dropdownHeight = 0;
          let numResultNodes = 0;
          let numTitleNodes = 0;
          const options = Array.from(this.$el.querySelectorAll("li.slds-listbox__item"));
          for (let i = 0; i < options.length; i++) {
            const option = options[i];
            dropdownHeight += option.clientHeight;
            if (Object.prototype.hasOwnProperty.call(option.dataset, "header")) {
              numTitleNodes++;
            } else {
              numResultNodes++;
            }
            if (numResultNodes === this.$parent.$props.heightInNumOptions)
              break;
          }
          if (options.length <= numResultNodes + numTitleNodes) {
            dropdown.style.height = "auto";
          } else {
            const { borderTopWidth, paddingTop } = getComputedStyle$1(dropdown);
            const dropdownHeightAdjustment = (parseInt$1(borderTopWidth, 10) + parseInt$1(paddingTop, 10)) * 2;
            let dropdownHeaderHeightAdjustment = (_a = this.$refs.dropdownHeader) == null ? void 0 : _a.clientHeight;
            if (dropdownHeaderHeightAdjustment) {
              const { marginTop, marginBottom } = getComputedStyle$1((_c = (_b = this.$refs.dropdownHeader) == null ? void 0 : _b.children) == null ? void 0 : _c[0]);
              dropdownHeaderHeightAdjustment += parseInt$1(marginTop, 10);
              dropdownHeaderHeightAdjustment += parseInt$1(marginBottom, 10);
            }
            dropdown.style.height = `${dropdownHeight + dropdownHeightAdjustment + dropdownHeaderHeightAdjustment}px`;
          }
          this.focusOption();
        },
        focusOption() {
          if (Array.isArray(this.$parent.modelValue)) {
            if (this.$parent.modelValue.length) {
              const [firstId] = this.$parent.modelValue;
              this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(firstId)}"][data-type="${typeof firstId}"]`) || this.getFirstAvailableOptionEl();
              this.scrollToFocusedOption();
            } else {
              this.focusedOption = this.getFirstAvailableOptionEl();
            }
          } else if (this.$parent.modelValue !== null && this.$parent.modelValue !== "" && this.$parent.comboboxInputOption === null) {
            this.focusedOption = this.$el.querySelector(`li[data-id="${this.$parent.getIdAsString(this.$parent.modelValue)}"][data-type="${typeof this.$parent.modelValue}"]`) || this.getFirstAvailableOptionEl();
            this.scrollToFocusedOption();
          } else {
            this.focusedOption = this.getFirstAvailableOptionEl();
          }
        },
        getFirstAvailableOptionEl() {
          return this.$el.querySelector("li[data-option]");
        },
        scrollToFocusedOption() {
          const focusedOptionAbsoluteOffsetTop = this.focusedOption.offsetTop + this.paddingBuffer;
          const dropdownHeight = this.$el.clientHeight;
          if (focusedOptionAbsoluteOffsetTop >= this.$el.scrollTop + dropdownHeight - this.paddingBuffer) {
            this.$el.scrollTop = focusedOptionAbsoluteOffsetTop + this.focusedOption.clientHeight - dropdownHeight;
          }
        },
        enter(e) {
          if (this.focusedOption === this.$refs.comboboxInputOption) {
            this.$parent.select(this.$parent.comboboxInputOption, e);
          } else {
            const option = this.$parent.getOptionById(this.focusedOptionId);
            this.$parent.select(option, e);
          }
        },
        down() {
          if (!this.focusedOption)
            return;
          const {
            nextElementSibling,
            parentElement: {
              nextElementSibling: parentsNextElementSibling
            }
          } = this.focusedOption;
          if (nextElementSibling) {
            this.focusedOption = nextElementSibling;
          } else if (parentsNextElementSibling) {
            const getNextDataOption = function getNextDataOption2(_parentsNextElementSibling) {
              if (_parentsNextElementSibling === null)
                return null;
              return _parentsNextElementSibling.querySelector("li[data-option]") || getNextDataOption2(parentsNextElementSibling.nextElementSibling);
            };
            const li = getNextDataOption(parentsNextElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption) {
            this.scrollToFocusedOption();
          }
          this.onScroll();
        },
        up() {
          if (!this.focusedOption)
            return;
          const {
            previousElementSibling,
            parentElement: {
              previousElementSibling: parentsPreviousElementSibling
            }
          } = this.focusedOption;
          const hasPreviousDataOptionSibling = previousElementSibling && Object.hasOwnProperty.call(previousElementSibling.dataset, "option");
          if (hasPreviousDataOptionSibling) {
            this.focusedOption = previousElementSibling;
          } else if (parentsPreviousElementSibling) {
            const getPreviousDataOption = function getPreviousDataOption2(_parentsPreviousElementSibling) {
              if (_parentsPreviousElementSibling === null)
                return null;
              return _parentsPreviousElementSibling.querySelector("li[data-option]:last-child") || getPreviousDataOption2(parentsPreviousElementSibling.previousElementSibling);
            };
            const li = getPreviousDataOption(parentsPreviousElementSibling);
            if (li) {
              this.focusedOption = li;
            }
          }
          if (this.focusedOption.offsetTop <= this.$el.scrollTop) {
            this.$el.scrollTop = this.focusedOption.offsetTop - this.paddingBuffer;
          }
        },
        onScroll({ target = this.$el } = {}) {
          const { scrollTop, scrollHeight, clientHeight } = target || this.$el;
          if (this.lastScrollTop > scrollTop)
            return;
          if (scrollTop + clientHeight >= scrollHeight - 5) {
            this.currentOptionsLength += this.$parent.$props.pageSize;
            target.scrollTop = scrollTop;
            this.lastScrollTop = scrollTop;
          }
        }
      }
    };
    const _hoisted_1$s = ["id"];
    const _hoisted_2$s = { ref: "dropdownHeader" };
    const _hoisted_3$q = {
      key: 0,
      class: "slds-listbox slds-listbox_vertical",
      role: "presentation"
    };
    const _hoisted_4$o = ["data-id"];
    const _hoisted_5$n = ["aria-selected"];
    const _hoisted_6$l = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_7$i = { class: "slds-media__body" };
    const _hoisted_8$f = { class: "slds-listbox__option-text slds-listbox__option-text_entity" };
    const _hoisted_9$d = { key: 1 };
    const _hoisted_10$b = {
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_11$a = ["title"];
    const _hoisted_12$8 = ["role"];
    const _hoisted_13$9 = {
      key: 0,
      role: "presentation",
      class: "slds-listbox__item",
      "data-header": ""
    };
    const _hoisted_14$7 = {
      class: "slds-media slds-listbox__option slds-listbox__option_plain slds-media_small",
      role: "presentation"
    };
    const _hoisted_15$5 = {
      class: "slds-listbox__option-header",
      role: "presentation"
    };
    const _hoisted_16$5 = {
      key: 1,
      class: "slds-listbox__item slds-listbox__status slds-p-vertical_x-small",
      role: "status",
      "aria-live": "polite"
    };
    const _hoisted_17$4 = ["title"];
    const _hoisted_18$3 = ["data-id", "data-type", "onMousedown"];
    const _hoisted_19$3 = ["aria-selected"];
    const _hoisted_20$3 = { class: "slds-media__figure slds-listbox__option-icon" };
    const _hoisted_21$3 = { class: "slds-media__body" };
    const _hoisted_22$2 = ["title"];
    const _hoisted_23$2 = { key: 2 };
    const _hoisted_24$2 = { class: "slds-align_absolute-center slds-p-top_medium" };
    function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      return openBlock(), createElementBlock("div", mergeProps({
        id: _ctx.$parent.dropdownId,
        class: "slds-dropdown slds-dropdown_fluid",
        role: "listbox"
      }, toHandlers(_ctx.$parent.$props.pageSize > 0 ? { scroll: $options.onScroll } : {}, true)), [
        createBaseVNode("div", _hoisted_2$s, [
          renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
        ], 512),
        _ctx.$parent.comboboxInputOption ? (openBlock(), createElementBlock("ul", _hoisted_3$q, [
          createBaseVNode("li", {
            ref: "comboboxInputOption",
            role: "presentation",
            class: "slds-listbox__item",
            "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(_ctx.$parent.comboboxInputOption)),
            "data-option": "",
            onMousedown: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.$parent.select(_ctx.$parent.comboboxInputOption, $event), ["prevent"]))
          }, [
            createBaseVNode("div", {
              "aria-selected": $data.focusedOption === _ctx.$refs.comboboxInputOption,
              class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_entity slds-listbox__option_term", { "slds-has-focus": $data.focusedOption === _ctx.$refs.comboboxInputOption }]),
              role: "option"
            }, [
              createBaseVNode("span", _hoisted_6$l, [
                createVNode(_component_Icon, {
                  assistiveText: _ctx.$parent.computedLabels.comboboxAdd,
                  title: _ctx.$parent.computedLabels.comboboxAdd,
                  category: "utility",
                  name: "add",
                  size: "x-small"
                }, null, 8, ["assistiveText", "title"])
              ]),
              createBaseVNode("span", _hoisted_7$i, [
                createBaseVNode("span", _hoisted_8$f, toDisplayString(_ctx.$parent.comboboxInputOption[_ctx.$parent.$props.titleKey]), 1)
              ])
            ], 10, _hoisted_5$n)
          ], 40, _hoisted_4$o)
        ])) : createCommentVNode("", true),
        $options.doRenderGlobalNoSearchResults ? (openBlock(), createElementBlock("ul", _hoisted_9$d, [
          createBaseVNode("li", _hoisted_10$b, [
            createBaseVNode("span", {
              class: "slds-m-left_x-large",
              title: _ctx.$parent.computedLabels.noSearchResults
            }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_11$a)
          ])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.computedOptionGroups, (group, name2, index) => {
          return openBlock(), createElementBlock("ul", {
            key: index,
            class: "slds-listbox slds-listbox_vertical",
            role: $options.getListRole(group)
          }, [
            group.title != null && (group.filtered.length || group.async) ? (openBlock(), createElementBlock("li", _hoisted_13$9, [
              createBaseVNode("div", _hoisted_14$7, [
                createBaseVNode("h3", _hoisted_15$5, toDisplayString(_ctx.decodeHtml(group.title)), 1)
              ])
            ])) : createCommentVNode("", true),
            group.async && !group.filtered.length && !group.loading ? (openBlock(), createElementBlock("li", _hoisted_16$5, [
              createBaseVNode("span", {
                class: "slds-m-left_x-large",
                title: _ctx.$parent.computedLabels.noSearchResults
              }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.noSearchResults)), 9, _hoisted_17$4)
            ])) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(group.renderLength, (n) => {
              return openBlock(), createElementBlock("li", {
                key: group.filtered[n - 1].$__guid,
                "data-id": _ctx.$parent.getIdAsString(_ctx.$parent.getId(group.filtered[n - 1])),
                "data-type": _ctx.$parent.getIdType(group.filtered[n - 1]),
                "data-option": "",
                role: "presentation",
                class: "slds-listbox__item",
                onMousedown: withModifiers(($event) => _ctx.$parent.select(group.filtered[n - 1], $event), ["prevent"])
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["slds-media slds-listbox__option slds-listbox__option_plain slds-media_small", { "slds-has-focus": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId, "slds-is-selected": _ctx.$parent.isOptionSelected(group.filtered[n - 1]) }]),
                  "aria-selected": _ctx.$parent.getId(group.filtered[n - 1]) === $options.focusedOptionId,
                  role: "option"
                }, [
                  renderSlot(_ctx.$slots, "option", {
                    option: group.filtered[n - 1],
                    index: n
                  }, () => [
                    createBaseVNode("span", _hoisted_20$3, [
                      _ctx.$parent.isOptionSelected(group.filtered[n - 1]) ? (openBlock(), createBlock(_component_Icon, {
                        key: 0,
                        class: "slds-current-color",
                        category: "utility",
                        name: "check",
                        size: "x-small"
                      })) : createCommentVNode("", true)
                    ]),
                    createBaseVNode("span", _hoisted_21$3, [
                      createBaseVNode("span", {
                        class: "slds-truncate",
                        title: _ctx.$parent.getTitle(group.filtered[n - 1])
                      }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.getTitle(group.filtered[n - 1]))), 9, _hoisted_22$2)
                    ])
                  ], true)
                ], 10, _hoisted_19$3)
              ], 40, _hoisted_18$3);
            }), 128)),
            group.loading ? (openBlock(), createElementBlock("li", _hoisted_23$2, [
              createBaseVNode("div", _hoisted_24$2, [
                createVNode(_component_Spinner, {
                  class: "slds-input__icon",
                  size: "x-small",
                  withoutContainer: "",
                  isInline: ""
                })
              ])
            ])) : createCommentVNode("", true)
          ], 8, _hoisted_12$8);
        }), 128))
      ], 16, _hoisted_1$s);
    }
    const Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$v], ["__scopeId", "data-v-4e43a862"]]);
    const _sfc_main$w = {
      components: { Checkbox },
      mixins: [decodeHtml],
      data() {
        return {
          dialogId: getGUID(),
          focusableElements: []
        };
      },
      watch: {
        "$parent.groupData": {
          handler(groupData) {
            Object.values(groupData.groups).forEach((group) => {
              group.filtered = group.filtered.map((option) => ({
                ...option,
                isSelected: this.$parent.isOptionSelected(option),
                original: option
              }));
            });
          },
          immediate: true
        }
      },
      mounted() {
        this.$nextTick(() => {
          this.focusableElements = this.$el.querySelectorAll("input:not([disabled])");
          this.focusableElements[0].focus();
        });
      },
      methods: {
        save(e) {
          const valueArray = [];
          Object.values(this.$parent.groupData.groups).forEach((group) => {
            group.filtered.forEach((option) => {
              if (option.isSelected) {
                const id2 = this.$parent.getId(option);
                valueArray.push(id2);
              }
            });
          });
          this.$parent.$emit("update:modelValue", valueArray);
          this.reset(e);
        },
        select(option, e) {
          this.$parent.$emit("selected-option", option.original, e);
        },
        reset(e) {
          this.$parent.reset(e);
          this.$parent.focus();
        },
        focusFirstElement(e) {
          e.stopPropagation();
          e.preventDefault();
          this.focusableElements[0].focus();
        },
        shiftTab(e) {
          if (document.activeElement === this.focusableElements[0]) {
            e.stopPropagation();
            e.preventDefault();
            this.$refs.savebutton.focus();
          }
        }
      }
    };
    const _hoisted_1$r = ["aria-describedby", "aria-label"];
    const _hoisted_2$r = ["id"];
    const _hoisted_3$p = {
      key: 0,
      class: "slds-form-element__legend slds-form-element__label"
    };
    const _hoisted_4$n = { class: "slds-form-element__control" };
    const _hoisted_5$m = { class: "slds-popover__footer slds-popover__footer_form" };
    function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Checkbox = resolveComponent("Checkbox");
      return openBlock(), createElementBlock("section", {
        "aria-describedby": $data.dialogId,
        "aria-label": _ctx.$parent.$props.labels.name,
        class: "slds-popover slds-popover_full-width custom-z-index",
        role: "dialog",
        onKeydown: [
          _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.reset && $options.reset(...args), ["stop"]), ["esc"])),
          _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["exact", "shift"]), ["tab"]))
        ]
      }, [
        createBaseVNode("div", {
          id: $data.dialogId,
          ref: "multiselectdialog",
          class: "slds-popover__body slds-popover__body_small"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$parent.groupData.groups, (group, name2, index) => {
            return openBlock(), createElementBlock("fieldset", {
              key: index,
              class: "slds-form-element"
            }, [
              group.title != null ? (openBlock(), createElementBlock("legend", _hoisted_3$p, toDisplayString(_ctx.decodeHtml(group.title)), 1)) : createCommentVNode("", true),
              createBaseVNode("div", _hoisted_4$n, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(group.filtered, (option) => {
                  return openBlock(), createBlock(_component_Checkbox, {
                    key: option.$__guid,
                    modelValue: option.isSelected,
                    "onUpdate:modelValue": ($event) => option.isSelected = $event,
                    labels: { name: _ctx.$parent.getTitle(option) },
                    onClick: ($event) => $options.select(option, $event)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "labels", "onClick"]);
                }), 128))
              ])
            ]);
          }), 128))
        ], 8, _hoisted_2$r),
        createBaseVNode("footer", _hoisted_5$m, [
          createBaseVNode("button", {
            class: "slds-button slds-button_neutral",
            onClick: _cache[0] || (_cache[0] = (...args) => $options.reset && $options.reset(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.cancel)), 1),
          createBaseVNode("button", {
            ref: "savebutton",
            class: "slds-button slds-button_brand",
            onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.focusFirstElement && $options.focusFirstElement(...args), ["stop", "exact"]), ["tab"])),
            onClick: _cache[2] || (_cache[2] = (...args) => $options.save && $options.save(...args))
          }, toDisplayString(_ctx.decodeHtml(_ctx.$parent.computedLabels.save)), 545)
        ])
      ], 40, _hoisted_1$r);
    }
    const MultiselectDialog = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$u], ["__scopeId", "data-v-0a28cef2"]]);
    const _sfc_main$v = {
      name: "PillList",
      components: { Icon },
      mixins: [decodeHtml],
      props: {
        /**
         * Assistive text for accessibility.
         */
        assistiveText: {
          type: Object,
          default: () => ({
            remove: "Press delete or backspace to remove.",
            listboxLabel: "Selected Options:",
            error: "Warning"
          })
        },
        /**
         * Adds border to pill list container.
         */
        containerBorder: Boolean,
        /**
         * Labels object for the pill list
         */
        labels: {
          type: Object,
          default: () => ({
            removeTitle: "Remove",
            error: "Error"
          })
        },
        /**
         * Options array for the pill list. `label` and `title` props are required.
         */
        options: {
          type: Array,
          default: () => [],
          validator(value) {
            return value.every((item) => {
              const requiredProps = ["label", "title"];
              const missing = getMissingProps(item, requiredProps);
              if (missing.length) {
                console.error(`Options object is missing required properties: ${missing.toString()}`);
                return false;
              }
              return true;
            });
          }
        },
        /**
         * Border for individual pill items.
         */
        pillBorder: {
          type: Boolean,
          default: true
        },
        /**
         * Sets pills to readonly and disables deletion.
         */
        readonly: Boolean
      },
      data() {
        return {
          mutableOptionsArray: [],
          lastFocusedOptionIndex: 0
        };
      },
      watch: {
        options: {
          handler(value) {
            this.mutableOptionsArray = value.map((item) => ({
              $__guid: getGUID(),
              ...item
            }));
          },
          deep: true,
          immediate: true
        }
      },
      methods: {
        focusLastFocusedOption() {
          const option = this.$refs[`option-${this.lastFocusedOptionIndex}`][0];
          if (option)
            option.focus();
        },
        remove(optionIndex, e) {
          if (this.readonly)
            return;
          const removedOption = this.mutableOptionsArray.splice(optionIndex, 1)[0];
          delete removedOption.$__guid;
          this.$emit("update:options", this.mutableOptionsArray);
          this.$emit("remove", removedOption, e);
          if (!this.mutableOptionsArray.length) {
            this.$nextTick(this.$refs.listbox.focus.bind(this.$refs.listbox));
            return;
          }
          if (this.lastFocusedOptionIndex > this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex--;
          }
          this.$nextTick(this.focusLastFocusedOption.bind(this));
        },
        left() {
          if (this.lastFocusedOptionIndex > 0) {
            this.lastFocusedOptionIndex--;
          } else {
            this.lastFocusedOptionIndex = this.mutableOptionsArray.length - 1;
          }
          this.focusLastFocusedOption();
        },
        right() {
          if (this.lastFocusedOptionIndex < this.mutableOptionsArray.length - 1) {
            this.lastFocusedOptionIndex++;
          } else {
            this.lastFocusedOptionIndex = 0;
          }
          this.focusLastFocusedOption();
        }
      }
    };
    const _hoisted_1$q = ["aria-label"];
    const _hoisted_2$q = ["tabindex", "onFocus"];
    const _hoisted_3$o = ["title"];
    function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({ "slds-pill_container": _ctx.$props.containerBorder, "slds-listbox_selection-group": !_ctx.$props.containerBorder })
      }, [
        createBaseVNode("ul", {
          ref: "listbox",
          class: "slds-listbox slds-listbox_horizontal",
          role: "listbox",
          "aria-label": $props.assistiveText.listboxLabel,
          "aria-orientation": "horizontal",
          onKeydown: [
            _cache[0] || (_cache[0] = withKeys((...args) => $options.left && $options.left(...args), ["left"])),
            _cache[1] || (_cache[1] = withKeys((...args) => $options.right && $options.right(...args), ["right"])),
            _cache[2] || (_cache[2] = withKeys(($event) => $options.remove($data.lastFocusedOptionIndex, $event), ["delete"]))
          ]
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.mutableOptionsArray, (option, index) => {
            return openBlock(), createElementBlock("li", {
              key: option.$__guid,
              class: "slds-listbox-item",
              role: "presentation"
            }, [
              createBaseVNode("span", {
                ref_for: true,
                ref: `option-${index}`,
                class: normalizeClass(["slds-pill", { "slds-pill_bare": !$props.pillBorder, "slds-has-error": option.hasError }]),
                role: "option",
                tabindex: $data.lastFocusedOptionIndex === index ? 0 : -1,
                "aria-selected": "true",
                onFocus: ($event) => $data.lastFocusedOptionIndex = index
              }, [
                option.hasError ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  class: "slds-pill__icon_container",
                  category: "utility",
                  name: "error",
                  variant: "error",
                  assistiveText: $props.assistiveText.error,
                  title: $props.labels.error
                }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
                createBaseVNode("span", {
                  class: "slds-pill__label",
                  title: option.title
                }, toDisplayString(_ctx.decodeHtml(option.label)), 9, _hoisted_3$o),
                !$props.readonly ? (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  class: "slds-pill__remove cursor-pointer",
                  category: "utility",
                  name: "close",
                  size: "x-small",
                  assistiveText: $props.assistiveText.remove,
                  onMousedown: withModifiers(($event) => $options.remove(index, $event), ["prevent"])
                }, null, 8, ["assistiveText", "onMousedown"])) : createCommentVNode("", true)
              ], 42, _hoisted_2$q)
            ]);
          }), 128))
        ], 40, _hoisted_1$q)
      ], 2);
    }
    const PillList = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$t], ["__scopeId", "data-v-e31e462f"]]);
    const valuePropUpdater = function valuePropUpdater2(value) {
      if (value) {
        if (Array.isArray(this.$props.modelValue)) {
          this.mutableValueArray = [].concat(...this.$props.modelValue);
        } else {
          this.mutableValueArray = this.$props.modelValue ? [this.$props.modelValue] : [];
          this.$emit("update:modelValue", this.mutableValueArray);
        }
      } else {
        this.$emit("update:modelValue", this.mutableValueArray.length === 1 ? this.mutableValueArray[0] : "");
      }
    };
    const defaultLabels$4 = () => ({
      name: null,
      search: "Search...",
      noSearchResults: "No search results.",
      clearTitle: "Clear the text input",
      clearAssistiveText: "Clear the text input",
      removeTitle: "Remove",
      removeAssistiveText: "Remove",
      comboboxAdd: "Add",
      comboboxSearchAssistiveText: "Search for term",
      save: "Save",
      required: "Required",
      loading: "Loading",
      cancel: "Cancel",
      placeholder: "Select an Option"
    });
    const _sfc_main$u = {
      name: "Picklist",
      components: {
        ButtonIcon,
        Dropdown,
        Icon,
        MultiselectDialog,
        PillList,
        Spinner,
        Tooltip
      },
      directives: {
        "click-outside": vClickOutside.directive,
        "detach-element": detach
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Provides debounce function with delay value.
         */
        asyncDelay: {
          type: Number,
          default: 500
        },
        /**
         * When selected, allows combobox functionality.
         */
        combobox: Boolean,
        /**
         * Allows for Picklist dropdown to be removed from DOM flow
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * List of picklist errors.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Allows for filterable options.
         */
        filterable: Boolean,
        /**
         * Sets height of dropdown in number of options.
         */
        heightInNumOptions: {
          type: [Number, Infinity],
          default: 5
        },
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Value of the id key.
         */
        idKey: {
          type: String,
          default: "id"
        },
        /**
         * If using a label that is not part of this component, use this prop
         * since there is a label being used in the app that is located outside
         * of this component.
         */
        labelForId: {
          type: String,
          default: ""
        },
        /**
         * Picklist labels object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Minimum search length before search func is initiated.
         */
        minSearchLength: {
          type: Number,
          default: 2
        },
        /**
         * Currently selected picklist value(s).
         */
        modelValue: {
          type: [Number, String, Array, Symbol],
          default: ""
        },
        /**
         * Allows for multiselectable options.
         */
        multiselect: Boolean,
        /**
         * Multiselect Dialog options dropdown.
         */
        multiselectDialog: Boolean,
        /**
         * Callback function invoked by the component when a user selects an option.
         */
        onRequestSelectOption: {
          type: Function,
          default: null
        },
        /**
         * Array of item objects in the dropdown menu or asynchronous search function.
         */
        options: {
          type: Array,
          required: true,
          validator(options) {
            let hasUntitledGroup = false;
            for (let i = 0; i < options.length; i++) {
              const option = options[i];
              if (Object.hasOwnProperty.call(option, "options") && !Object.hasOwnProperty.call(option, "title")) {
                if (hasUntitledGroup) {
                  console.error("Cannot have more than one group without a title.");
                  return false;
                }
                hasUntitledGroup = true;
              }
            }
            return true;
          }
        },
        /**
         * When applicable, this value is used to lazily render options. To disable, set to a value of 0.
         */
        pageSize: {
          type: Number,
          default: 50
        },
        /**
         * Readonly version of the picklist.
         */
        readonly: Boolean,
        /**
         * Allows dropdown to remain open on selection of option
         */
        remainOpenOnSelect: Boolean,
        /**
         * Applies label styling for a required form element.
         */
        required: Boolean,
        /**
         * By default the dropdown list will resize itself to the width of the input element (anchor). If resizeToFitContent
         * is toggled on the dropdown width resizes to fit the content with the minimum width set to the width of the anchor.
         */
        resizeToFitContent: Boolean,
        /**
         * Value of the title key.
         */
        titleKey: {
          type: String,
          default: "title"
        }
      },
      emits: [
        "clear",
        "detached",
        "reset",
        "selected-option",
        "update:modelValue"
      ],
      data() {
        return {
          isActive: false,
          doRenderDropdown: false,
          dropdownId: getGUID(),
          errorId: getGUID(),
          focusedOptionId: null,
          input: "",
          cachedInput: "",
          labelId: getGUID(),
          inputId: getGUID(),
          mutableValueArray: [],
          comboboxInputOption: null,
          multiselectOptions: [],
          groupData: {
            groups: {},
            numAsyncGroups: 0,
            hasStaticOptions: false
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().picklist || {} : {};
          return {
            ...defaultLabels$4(),
            ...globals,
            ...this.$props.labels
          };
        },
        clickOutsideOptions() {
          return {
            isActive: this.doRenderDropdown,
            handler: this.clickedOutside
          };
        },
        showSearchIcon() {
          return this.$props.filterable && (this.$props.multiselect || !this.hasValue);
        },
        hasAutocompletedValue() {
          return this.hasValue && this.singleSelect && this.$props.filterable;
        },
        showDownIcon() {
          return !this.$props.filterable;
        },
        isReadOnly() {
          return this.hasAutocompletedValue || !this.$props.filterable && !this.$props.combobox;
        },
        readonlyValue() {
          if (this.singleSelect) {
            const option = this.getOptionById(this.$props.modelValue);
            return !option ? null : this.getTitle(option);
          }
          return null;
        },
        singleSelect() {
          return !this.$props.multiselect;
        },
        hasValue() {
          return this.$props.multiselect ? (this.$props.modelValue || []).length > 0 : !!this.$props.modelValue;
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        computedPlaceholder() {
          if (this.isLoading) {
            return this.computedLabels.loading;
          }
          return this.isReadOnly || this.$props.combobox && !this.$props.filterable ? this.computedLabels.placeholder : this.computedLabels.search;
        },
        doRenderPillList() {
          return this.$props.readonly && this.multiselectOptions.length || this.$props.multiselect && !this.$props.multiselectDialog && (this.multiselectOptions.length > 1 || (this.$props.filterable || this.$props.combobox) && this.multiselectOptions.length);
        },
        isLoading() {
          return Object.values(this.groupData.groups).some((group) => group.loading);
        },
        computedDoRenderDropdown() {
          return !this.$props.multiselectDialog && this.doRenderDropdown || this.groupData.numAsyncGroups > 1 && this.isLoading;
        }
      },
      watch: {
        modelValue: {
          handler(value) {
            if (value === null || Array.isArray(value)) {
              this.mutableValueArray = [].concat(...value || []);
            }
            this.setMultiselectOptions();
            this.setInput();
          },
          immediate: true
        },
        multiselect: valuePropUpdater,
        multiselectDialog: valuePropUpdater,
        $props: {
          handler() {
            if (this.$props.multiselectDialog) {
              if (this.$props.filterable || this.$props.combobox || this.$props.multiselect) {
                throw new Error("Cannot combine multiselectDialog with other features.");
              }
            }
            if (this.$props.labels && (!this.$props.labels.name || !this.$props.labels.name.length) && (!this.$props.labelForId || !this.$props.labelForId.length)) {
              console.error("Must provide label for name or pass value to labelForId prop");
            }
            if (this.$props.remainOpenOnSelect && !this.$props.multiselect) {
              console.error("Must enable multiselect to use remainOpenOnSelect prop");
            }
          },
          deep: true,
          immediate: true
        },
        focusedOptionId(value) {
          if (value && !this.$props.filterable && !this.$props.combobox && this.singleSelect) {
            this.input = this.getTitleById(value);
          }
        },
        options: {
          handler() {
            this.groupData = groupBuilder.call(this);
            this.reconcileOptions();
          },
          deep: true
        },
        asyncDelay(value) {
          Object.values(this.groupData.groups).forEach((group) => {
            if (group.async) {
              group.debounce = _debounce(group.optionsFunction, value);
            }
          });
        }
      },
      created() {
        this.validateValueBindingType();
        this.groupData = groupBuilder.call(this);
      },
      methods: {
        focus() {
          this.$refs.input.focus();
        },
        reconcileOptions() {
          if (this.$props.combobox || !this.hasValue)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            const originalLength = this.mutableValueArray.length;
            this.mutableValueArray = this.mutableValueArray.filter((value) => this.getOptionById(value));
            if (originalLength !== this.mutableValueArray.length) {
              this.$emit("update:modelValue", this.mutableValueArray);
            }
          } else if (this.getOptionById(this.$props.modelValue)) {
            this.setInput();
          } else {
            this.$emit("update:modelValue", "");
          }
        },
        clear() {
          this.input = "";
          this.$emit("update:modelValue", this.input);
          this.$emit("clear");
          this.$nextTick(this.activationHandler);
          this.$nextTick(() => {
            this.$refs.input.focus();
          });
        },
        setMultiselectOptions() {
          this.multiselectOptions = this.mutableValueArray.map((id2) => {
            const option = this.getOptionById(id2);
            const title = option ? this.getTitle(option) : id2;
            return {
              [this.$props.idKey]: id2,
              label: title,
              title
            };
          });
        },
        setInput() {
          if ((this.$props.multiselect || this.$props.multiselectDialog) && !this.$props.filterable) {
            if (this.$props.combobox) {
              this.input = null;
              return;
            }
            if (this.mutableValueArray.length > 1) {
              this.input = `${this.mutableValueArray.length} options selected`;
            } else {
              this.input = this.getTitleById(this.mutableValueArray[0]);
            }
          } else if (this.$props.modelValue) {
            this.input = this.getTitleById(this.$props.modelValue);
          } else {
            this.input = null;
          }
          this.cachedInput = this.input;
        },
        validateValueBindingType() {
          if (this.$props.modelValue === null)
            return;
          if (this.$props.multiselect || this.$props.multiselectDialog) {
            if (!Array.isArray(this.$props.modelValue)) {
              throw new Error("Value binding type must be in array in multi-select mode.");
            }
          } else if (!["string", "number", "symbol"].includes(typeof this.$props.modelValue)) {
            throw new Error("Value binding type must be a Number, String, or Symbol in single-select mode.");
          }
        },
        onBlur(e) {
          if (e.relatedTarget && this.doRenderDropdown && !this.$props.multiselectDialog) {
            this.reset(e);
            this.$emit("reset");
          }
        },
        onClick() {
          if (!this.doRenderDropdown) {
            this.activationHandler();
          }
        },
        onDetachRender() {
          if (!this.$props.multiselectDialog) {
            this.$refs.dropdown.setDropdownHeight();
          }
        },
        enter(e) {
          if (e.isComposing || e.keyCode === 229) {
            return;
          }
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.enter(e);
          } else {
            this.activationHandler();
          }
        },
        up() {
          if (!this.$props.multiselectDialog && this.doRenderDropdown) {
            this.$refs.dropdown.up();
          }
        },
        down() {
          if (this.$props.multiselectDialog && this.doRenderDropdown)
            return;
          if (this.doRenderDropdown) {
            this.$refs.dropdown.down();
          } else {
            this.activationHandler();
          }
        },
        activationHandler() {
          if (this.hasAutocompletedValue || this.isLoading)
            return;
          if (this.groupData.hasStaticOptions) {
            this.doRenderDropdown = true;
          } else if (this.$props.combobox && this.input) {
            this.doRenderDropdown = true;
            this.updateComboboxInputOption();
          } else {
            this.doRenderDropdown = false;
          }
          this.search();
        },
        clickedOutside(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.reset(e);
          this.$emit("reset");
        },
        escape(e) {
          this.reset(e);
          this.$emit("reset");
        },
        reset(e) {
          if (e && e.type === "click" && e.target === this.$refs.input)
            return;
          this.input = this.cachedInput;
          Object.values(this.groupData.groups).forEach((group) => {
            group.filtered = [];
            group.searchIndex++;
            group.loading = false;
          });
          this.comboboxInputOption = null;
          this.focusedOptionId = null;
          this.doRenderDropdown = false;
        },
        getIdType(option) {
          return typeof this.getId(option);
        },
        getId(option) {
          if (!option || ["string", "number", "symbol"].includes(typeof option))
            return option;
          return option[this.$props.idKey];
        },
        getIdAsString(id2) {
          return typeof id2 === "symbol" ? id2.description : id2;
        },
        getTitle(option) {
          if (["string", "number"].includes(typeof option))
            return option.toString();
          if (typeof option === "symbol")
            return option.description;
          return option[this.$props.titleKey];
        },
        getTitleById(id2) {
          return this.getTitle(this.getOptionById(id2) || id2 || "");
        },
        getOptionById(id2) {
          if (!id2)
            return null;
          for (let i = 0; i < this.$props.options.length; i++) {
            const item = this.$props.options[i];
            if (Array.isArray(item.options)) {
              const result = item.options.find((subOption) => this.getId(subOption) === id2);
              if (result)
                return result;
            }
            if (typeof item === "object" && this.getId(item) === id2)
              return item;
            if (["string", "number", "symbol"].includes(typeof item) && item === id2)
              return item;
          }
          const groups = Object.values(this.groupData.groups);
          for (let i = 0; i < groups.length; i++) {
            const option = groups[i].filtered.find((_option) => this.getId(_option) === id2);
            if (option)
              return option;
          }
          return null;
        },
        search() {
          if (this.hasAutocompletedValue)
            return;
          const sanitizedValue = (this.input || "").replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
          const regex = new RegExp(sanitizedValue, "i");
          const returnAllOptions = !sanitizedValue || (!this.$props.filterable || !this.$props.filterable && this.$props.combobox);
          Object.entries(this.groupData.groups).forEach(([, group]) => {
            group.filtered = [];
            if (group.static) {
              if (returnAllOptions || this.groupData.numAsyncGroups) {
                group.filtered = group.options;
              } else {
                group.options.forEach((option) => {
                  if (regex.test(this.getTitle(option))) {
                    group.filtered.push(option);
                  }
                });
              }
            } else if (group.async) {
              if (!this.$props.filterable) {
                group.optionsFunction(sanitizedValue);
              } else if (group.lazy || sanitizedValue.length >= this.$props.minSearchLength) {
                group.debounce(sanitizedValue);
              }
            }
          });
        },
        invokeOptionsFunction(fn, groupId, term) {
          const group = this.groupData.groups[groupId];
          group.loading = true;
          const searchIndex = ++group.searchIndex;
          fn.call(fn, term).then((options = []) => {
            if (searchIndex < group.searchIndex)
              return;
            const filtered = [];
            options.forEach((option) => {
              if (typeof option === "object") {
                filtered.push({ $__guid: getGUID(), ...option });
              } else if (["string", "number"].includes(typeof option)) {
                filtered.push({
                  $__guid: getGUID(),
                  [this.idKey]: option,
                  [this.titleKey]: option.toString()
                });
              }
            });
            group.filtered = group.filtered.concat(filtered);
            if (group.lazy || !this.$props.filterable) {
              group.options = group.filtered;
              group.static = true;
              group.async = false;
              this.groupData.hasStaticOptions = true;
              this.groupData.numAsyncGroups--;
            }
            this.doRenderDropdown = true;
            if (!this.multiselectDialog) {
              this.$nextTick(() => {
                group.loading = false;
              });
            }
          }).catch((error) => {
            throw new Error(error);
          });
        },
        isOptionSelected(option) {
          const id2 = this.getId(option);
          return this.$props.modelValue === id2 || (this.$props.multiselect || this.$props.multiselectDialog) && this.mutableValueArray.includes(id2);
        },
        onInput() {
          this.activationHandler();
          this.updateComboboxInputOption();
        },
        updateComboboxInputOption() {
          if (!this.combobox)
            return;
          if (this.input) {
            this.comboboxInputOption = {
              [this.$props.idKey]: this.input,
              [this.$props.titleKey]: this.input
            };
          } else {
            this.comboboxInputOption = null;
          }
        },
        select(option, e) {
          if (this.onRequestSelectOption && typeof this.onRequestSelectOption === "function" && !this.onRequestSelectOption(option, e)) {
            return;
          }
          const id2 = this.getId(option);
          if (this.singleSelect) {
            this.$emit("update:modelValue", id2);
          } else if (this.isOptionSelected(option)) {
            this.$emit("update:modelValue", this.mutableValueArray.filter((item) => this.getId(item) !== id2));
          } else {
            this.mutableValueArray.push(id2);
            this.$emit("update:modelValue", this.mutableValueArray);
          }
          const optionToEmit = { ...option };
          delete optionToEmit.$__guid;
          this.$emit("selected-option", optionToEmit, e);
          if (!this.$props.multiselectDialog && !this.$props.remainOpenOnSelect) {
            this.$nextTick(() => {
              this.reset();
              this.$nextTick(() => {
                this.$refs.input.focus();
              });
            });
          }
        },
        removePillListOptionHandler(option, e) {
          this.select(option, e);
        }
      }
    };
    const _hoisted_1$p = ["id", "for"];
    const _hoisted_2$p = ["title"];
    const _hoisted_3$n = { class: "slds-form-element__control" };
    const _hoisted_4$m = ["aria-expanded"];
    const _hoisted_5$l = {
      class: "slds-combobox__form-element slds-input-has-icon slds-input-has-icon_right",
      role: "none"
    };
    const _hoisted_6$k = ["id", "disabled", "aria-labelledby", "aria-controls"];
    const _hoisted_7$h = { class: "slds-truncate" };
    const _hoisted_8$e = ["id", "aria-controls", "aria-activedescendant", "aria-invalid", "aria-describedby", "placeholder", "readonly", "disabled"];
    const _hoisted_9$c = {
      key: 1,
      class: "readonly-select-label"
    };
    const _hoisted_10$a = ["id"];
    function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Dropdown = resolveComponent("Dropdown");
      const _component_MultiselectDialog = resolveComponent("MultiselectDialog");
      const _component_PillList = resolveComponent("PillList");
      const _directive_click_outside = resolveDirective("click-outside");
      const _directive_detach_element = resolveDirective("detach-element");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["slds-form-element", { "slds-has-error": $options.hasErrors }])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          class: "slds-form-element__label",
          for: $data.inputId
        }, [
          $props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "* ", 8, _hoisted_2$p)) : createCommentVNode("", true),
          createTextVNode(toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$p)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$n, [
          createBaseVNode("div", {
            class: normalizeClass(["slds-combobox_container", { "slds-has-selection": $options.hasAutocompletedValue }])
          }, [
            createBaseVNode("div", {
              class: normalizeClass(["slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click", { "slds-is-open": $options.computedDoRenderDropdown }]),
              "aria-expanded": `${$options.computedDoRenderDropdown}`,
              "aria-haspopup": "listbox",
              role: "combobox"
            }, [
              createBaseVNode("div", _hoisted_5$l, [
                !_ctx.$props.readonly ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  $options.hasAutocompletedValue ? (openBlock(), createElementBlock("button", {
                    key: 0,
                    id: $data.inputId,
                    ref: "input",
                    disabled: _ctx.$props.disabled,
                    type: "button",
                    class: "slds-input_faux slds-combobox__input slds-combobox__input-value",
                    "aria-labelledby": [$data.labelId, $data.inputId].join(" "),
                    "aria-controls": $data.dropdownId,
                    "aria-expanded": "false",
                    "aria-haspopup": "listbox"
                  }, [
                    createBaseVNode("span", _hoisted_7$h, toDisplayString($data.input), 1)
                  ], 8, _hoisted_6$k)) : withDirectives((openBlock(), createElementBlock("input", mergeProps({
                    key: 1,
                    id: $options.computedLabels.name ? $data.inputId : $props.labelForId,
                    ref: "input",
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.input = $event),
                    type: "text",
                    class: ["slds-input slds-combobox__input", { "slds-combobox__input-value": $options.hasAutocompletedValue }],
                    "aria-autocomplete": "list",
                    autoComplete: "off",
                    role: "textbox",
                    "aria-controls": $options.computedDoRenderDropdown ? $data.dropdownId : null,
                    "aria-activedescendant": $options.getIdAsString($data.focusedOptionId),
                    "aria-invalid": !!_ctx.$props.errors.length,
                    "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
                    placeholder: $options.computedPlaceholder,
                    readonly: $options.isReadOnly,
                    disabled: _ctx.$props.disabled
                  }, _ctx.$attrs, {
                    onInput: _cache[1] || (_cache[1] = (...args) => $options.onInput && $options.onInput(...args)),
                    onClick: _cache[2] || (_cache[2] = (...args) => $options.onClick && $options.onClick(...args)),
                    onBlur: _cache[3] || (_cache[3] = (...args) => $options.onBlur && $options.onBlur(...args)),
                    onKeydown: [
                      _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.down && $options.down(...args), ["prevent"]), ["down"])),
                      _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => $options.up && $options.up(...args), ["prevent"]), ["up"])),
                      _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => $options.enter && $options.enter(...args), ["prevent"]), ["enter"])),
                      _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => $options.escape && $options.escape(...args), ["stop"]), ["esc"]))
                    ]
                  }), null, 16, _hoisted_8$e)), [
                    [vModelText, $data.input]
                  ]),
                  !_ctx.$props.disabled && $options.hasAutocompletedValue ? (openBlock(), createBlock(_component_ButtonIcon, {
                    key: 2,
                    class: "slds-input__icon",
                    iconCategory: "utility",
                    iconName: "clear",
                    assistiveText: $options.computedLabels.clearAssistiveText,
                    title: $options.computedLabels.clearTitle,
                    onClick: $options.clear
                  }, null, 8, ["assistiveText", "title", "onClick"])) : $options.isLoading ? (openBlock(), createBlock(_component_Spinner, {
                    key: 3,
                    class: "slds-input__icon",
                    size: "x-small",
                    theme: "brand",
                    loadingLabel: $options.computedLabels.loading,
                    withoutContainer: ""
                  }, null, 8, ["loadingLabel"])) : renderSlot(_ctx.$slots, "icon", { key: 4 }, () => [
                    $options.showSearchIcon ? (openBlock(), createBlock(_component_Icon, {
                      key: 0,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "search",
                      size: "x-small"
                    })) : $options.showDownIcon && !$options.isLoading ? (openBlock(), createBlock(_component_Icon, {
                      key: 1,
                      class: "slds-input__icon",
                      category: "utility",
                      name: "down",
                      size: "x-small"
                    })) : createCommentVNode("", true)
                  ], true)
                ], 64)) : (openBlock(), createElementBlock("div", _hoisted_9$c, toDisplayString($options.readonlyValue), 1))
              ]),
              $options.computedDoRenderDropdown ? withDirectives((openBlock(), createBlock(_component_Dropdown, {
                key: 0,
                ref: "dropdown"
              }, {
                option: withCtx(({ option, index }) => [
                  renderSlot(_ctx.$slots, "option", {
                    option,
                    index
                  }, void 0, true)
                ]),
                dropdownHeader: withCtx(() => [
                  renderSlot(_ctx.$slots, "dropdownHeader", {}, void 0, true)
                ]),
                _: 3
              })), [
                [_directive_click_outside, $options.clickOutsideOptions],
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true),
              _ctx.$props.multiselectDialog && $data.doRenderDropdown ? withDirectives((openBlock(), createBlock(_component_MultiselectDialog, {
                key: 1,
                ref: "dropdown"
              }, null, 512)), [
                [_directive_detach_element, {
                  disabled: !$props.detach,
                  anchorRef: _ctx.$refs.input,
                  viewPortOverflow: true,
                  anchorTopOnVerticalOverflow: true,
                  onRender: $options.onDetachRender,
                  resizeToAnchor: !_ctx.$props.resizeToFitContent,
                  resizeToFitContent: _ctx.$props.resizeToFitContent,
                  alignment: "left",
                  scrollHandler: $options.reset
                }]
              ]) : createCommentVNode("", true)
            ], 10, _hoisted_4$m)
          ], 2),
          $options.doRenderPillList ? (openBlock(), createBlock(_component_PillList, {
            key: 0,
            readonly: _ctx.$props.readonly,
            options: $data.multiselectOptions,
            onRemove: $options.removePillListOptionHandler
          }, null, 8, ["readonly", "options", "onRemove"])) : createCommentVNode("", true)
        ]),
        renderSlot(_ctx.$slots, "footer", {}, void 0, true),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_10$a)) : createCommentVNode("", true)
      ], 2);
    }
    const Picklist = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$s], ["__scopeId", "data-v-3db3f0d2"]]);
    const defaultLabels$3 = () => ({
      name: null,
      placeholder: null,
      required: "Required"
    });
    const _sfc_main$t = {
      name: "TextInput",
      components: { Tooltip },
      mixins: [decodeHtml],
      props: {
        /**
         * Disables the input and prevents editing the contents.
         */
        disabled: Boolean,
        /**
         * Disables manual resize for textarea type inputs.
         */
        disableResize: Boolean,
        /**
         * Error array for text input.
         */
        errors: {
          type: Array,
          default: () => []
        },
        /**
         * Displays text or node to the left of the input. This follows the fixed text input UX pattern.
         */
        fixedTextLeft: {
          type: String,
          default: ""
        },
        /**
         * Displays text or node to the right of the input. This follows the fixed text input UX pattern.
         */
        fixedTextRight: {
          type: String,
          default: ""
        },
        /**
         * Immediately sets focus to input.
         */
        hasFocus: Boolean,
        /**
         * Content for Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Labels prop for input.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The input is a controlled component, and will always display this value.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * Displays the value of the input as read-only. This is used in the inline edit UX pattern.
         */
        readonly: Boolean,
        /**
         * Highlights the input as a required field (does not perform any validation).
         */
        required: Boolean,
        /**
         * The element includes support for all HTML5 types.
         */
        type: {
          type: String,
          default: "text"
        },
        /**
         * A multi-line plain-text editing control.
         */
        useTextArea: Boolean
      },
      data() {
        return {
          errorId: getGUID(),
          inputId: getGUID(),
          labelId: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().textInput || {} : {};
          return {
            ...defaultLabels$3(),
            ...globals,
            ...this.$props.labels
          };
        },
        hasErrors() {
          return this.$props.errors.length;
        },
        hasFixedAddon() {
          return this.$props.fixedTextLeft || this.$props.fixedTextRight;
        },
        fixedAddonIds() {
          if (!this.hasFixedAddon)
            return null;
          let addonIds = this.labelId;
          if (this.$props.fixedTextLeft)
            addonIds += " fixed-text-addon-pre";
          if (this.$props.fixedTextRight)
            addonIds += " fixed-text-addon-post";
          return addonIds;
        }
      },
      watch: {
        "$props.hasFocus": {
          handler(value) {
            if (value)
              this.focus();
          }
        }
      },
      mounted() {
        if (this.$props.hasFocus)
          this.focus();
      },
      methods: {
        focus() {
          this.$refs.input.focus();
          this.$refs.input.select();
        },
        onInput(e) {
          this.$emit("update:modelValue", e.target.value);
        }
      }
    };
    const _hoisted_1$o = ["id", "for"];
    const _hoisted_2$o = ["title"];
    const _hoisted_3$m = {
      key: 0,
      id: "fixed-text-addon-pre",
      class: "slds-form-element__addon"
    };
    const _hoisted_4$l = ["id", "disabled", "value", "placeholder", "readonly", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_5$k = ["id", "type", "disabled", "readonly", "placeholder", "value", "aria-labelledby", "aria-invalid", "aria-describedby"];
    const _hoisted_6$j = {
      key: 3,
      id: "fixed-text-addon-post",
      class: "slds-form-element__addon"
    };
    const _hoisted_7$g = ["id"];
    function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "slds-has-error": $options.hasErrors }, "slds-form-element"])
      }, [
        $options.computedLabels.name ? (openBlock(), createElementBlock("label", {
          key: 0,
          id: $data.labelId,
          for: $data.inputId,
          class: "slds-form-element__label"
        }, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: $options.computedLabels.required
          }, "*", 8, _hoisted_2$o)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml($options.computedLabels.name)), 1)
        ], 8, _hoisted_1$o)) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          class: "slds-form-element__icon",
          alignment: "top right",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(["slds-form-element__control", { "slds-input-has-fixed-addon": $options.hasFixedAddon }])
        }, [
          _ctx.$props.fixedTextLeft ? (openBlock(), createElementBlock("span", _hoisted_3$m, toDisplayString(_ctx.$props.fixedTextLeft), 1)) : createCommentVNode("", true),
          _ctx.$props.useTextArea ? (openBlock(), createElementBlock("textarea", mergeProps({
            key: 1,
            id: $data.inputId,
            ref: "input",
            disabled: _ctx.$props.disabled,
            value: _ctx.$props.modelValue,
            placeholder: $options.computedLabels.placeholder,
            readonly: _ctx.$props.readonly,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: [{ "disable-resize": _ctx.$props.disableResize }, "slds-textarea"]
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[0] || (_cache[0] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_4$l)) : (openBlock(), createElementBlock("input", mergeProps({
            key: 2,
            id: $data.inputId,
            ref: "input",
            type: _ctx.$props.type,
            disabled: _ctx.$props.disabled,
            readonly: _ctx.$props.readonly,
            placeholder: $options.computedLabels.placeholder,
            value: _ctx.$props.modelValue,
            "aria-labelledby": $options.fixedAddonIds,
            "aria-invalid": !!_ctx.$props.errors.length,
            "aria-describedby": _ctx.$props.errors.length ? $data.errorId : null,
            class: "slds-input"
          }, toHandlers(_ctx.$attrs, true), {
            onInput: _cache[2] || (_cache[2] = (...args) => $options.onInput && $options.onInput(...args)),
            onBlur: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("update:hasFocus", false))
          }), null, 16, _hoisted_5$k)),
          _ctx.$props.fixedTextRight ? (openBlock(), createElementBlock("span", _hoisted_6$j, toDisplayString(_ctx.$props.fixedTextRight), 1)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "extend", {}, void 0, true)
        ], 2),
        _ctx.$props.errors.length ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: $data.errorId,
          class: "slds-form-element__help"
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, index) => {
            return openBlock(), createElementBlock("p", { key: index }, toDisplayString(_ctx.decodeHtml(error)), 1);
          }), 128))
        ], 8, _hoisted_7$g)) : createCommentVNode("", true)
      ], 2);
    }
    const TextInput = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$r], ["__scopeId", "data-v-7b6f943d"]]);
    var columnResizer = { exports: {} };
    (function(module2, exports2) {
      !function webpackUniversalModuleDefinition(e, t) {
        module2.exports = t();
      }(commonjsGlobal, () => (() => {
        var e = { 887: (e2) => {
          e2.exports = function hash2(e3) {
            for (var t2 = 5381, r2 = e3.length; r2; )
              t2 = 33 * t2 ^ e3.charCodeAt(--r2);
            return t2 >>> 0;
          };
        } }, t = {};
        function __webpack_require__(r2) {
          var i = t[r2];
          if (void 0 !== i)
            return i.exports;
          var o = t[r2] = { exports: {} };
          return e[r2](o, o.exports, __webpack_require__), o.exports;
        }
        __webpack_require__.n = (e2) => {
          var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
          return __webpack_require__.d(t2, { a: t2 }), t2;
        }, __webpack_require__.d = (e2, t2) => {
          for (var r2 in t2)
            __webpack_require__.o(t2, r2) && !__webpack_require__.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
        }, __webpack_require__.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), __webpack_require__.r = (e2) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        };
        var r = {};
        return (() => {
          __webpack_require__.r(r), __webpack_require__.d(r, { default: () => n });
          var e2 = __webpack_require__(887), t2 = __webpack_require__.n(e2);
          function _typeof(e3) {
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, _typeof(e3);
          }
          function _defineProperties(e3, t3) {
            for (var r2 = 0; r2 < t3.length; r2++) {
              var i2 = t3[r2];
              i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e3, _toPropertyKey(i2.key), i2);
            }
          }
          function _createClass(e3, t3, r2) {
            return t3 && _defineProperties(e3.prototype, t3), r2 && _defineProperties(e3, r2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }
          function _classCallCheck(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }
          function _defineProperty(e3, t3, r2) {
            return (t3 = _toPropertyKey(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t3] = r2, e3;
          }
          function _toPropertyKey(e3) {
            var t3 = function _toPrimitive(e4, t4) {
              if ("object" !== _typeof(e4) || null === e4)
                return e4;
              var r2 = e4[Symbol.toPrimitive];
              if (void 0 !== r2) {
                var i2 = r2.call(e4, t4 || "default");
                if ("object" !== _typeof(i2))
                  return i2;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return ("string" === t4 ? String : Number)(e4);
            }(e3, "string");
            return "symbol" === _typeof(t3) ? t3 : String(t3);
          }
          var i, o = (i = 0, function() {
            return i++;
          }), n = _createClass(function ColumnResizer2(e3) {
            var r2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            _classCallCheck(this, ColumnResizer2), _defineProperty(this, "ID", "id"), _defineProperty(this, "PX", "px"), _defineProperty(this, "RESIZABLE", "grip-resizable"), _defineProperty(this, "FLEX", "grip-flex"), _defineProperty(this, "legacyIE", navigator.userAgent.indexOf("Trident/4.0") > 0), _defineProperty(this, "reset", function(e4) {
              return r2.init(e4);
            }), _defineProperty(this, "onResize", function() {
              var e4 = r2.tb;
              if (e4.classList.remove(r2.RESIZABLE), e4.opt.fixed) {
                e4.tableWidth = Number(window.getComputedStyle(e4).width.replace(/px/, "")).valueOf();
                for (var t3 = 0, i3 = 0; i3 < e4.columnCnt; i3++)
                  t3 += e4.columns[i3].w;
                for (var o2 = 0; o2 < e4.columnCnt; o2++)
                  e4.columns[o2].style.width = Math.round(1e3 * e4.columns[o2].w / t3) / 10 + "%", e4.columns[o2].locked = true, e4.opt.currentWidths[o2] = Number(window.getComputedStyle(e4.columns[o2]).width.replace(/px/, "")).valueOf();
              } else
                r2.applyBounds(), "flex" === e4.opt.resizeMode && e4.opt.serialize && r2.serializeStore();
              e4.classList.add(r2.RESIZABLE), r2.syncGrips();
            }), _defineProperty(this, "onGripMouseDown", function(e4) {
              var t3 = e4.target.parentNode.data, i3 = r2.tb, o2 = i3.grips[t3.i], n2 = e4.touches;
              if (o2.ox = n2 ? n2[0].pageX : e4.pageX, o2.l = o2.offsetLeft, o2.x = o2.l, r2.createStyle(document.querySelector("head"), "*{cursor:" + i3.opt.dragCursor + "!important}"), document.addEventListener("touchmove", r2.onGripDrag), document.addEventListener("mousemove", r2.onGripDrag), document.addEventListener("touchend", r2.onGripDragOver), document.addEventListener("mouseup", r2.onGripDragOver), o2.classList.add(i3.opt.draggingClass), r2.grip = o2, i3.columns[t3.i].locked)
                for (var l, a = 0; a < i3.columnCnt; a++)
                  (l = i3.columns[a]).locked = false, l.w = Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf();
              e4.preventDefault();
            }), _defineProperty(this, "onGripDrag", function(e4) {
              var t3 = r2.grip;
              if (t3) {
                var i3 = t3.t, o2 = e4.touches, n2 = (o2 ? o2[0].pageX : e4.pageX) - t3.ox + t3.l, l = i3.opt.minWidth, a = t3.i, s = 1.5 * i3.cellSpace + l + i3.borderSpace, d = a === i3.columnCnt - 1, p2 = a ? i3.grips[a - 1].offsetLeft + i3.cellSpace + l : s, u = i3.opt.fixed ? a === i3.columnCnt - 1 ? i3.tableWidth - s : i3.grips[a + 1].offsetLeft - i3.cellSpace - l : 1 / 0;
                if (n2 = Math.max(p2, Math.min(u, n2)), t3.x = n2, t3.style.left = n2 + r2.PX, d && (t3.w = i3.columns[a].w + n2 - t3.l), i3.opt.liveDrag) {
                  d ? (i3.columns[a].style.width = t3.w + r2.PX, !i3.opt.fixed && i3.opt.overflow ? i3.style.minWidth = i3.tableWidth + n2 - t3.l + r2.PX : i3.tableWidth = Number(window.getComputedStyle(i3).width.replace(/px/, "")).valueOf()) : r2.syncCols(i3, a, false, i3.opt), r2.syncGrips();
                  var c = i3.opt.onDrag;
                  c && c(e4);
                }
                e4.preventDefault();
              }
            }), _defineProperty(this, "onGripDragOver", function(e4) {
              var t3 = r2.grip;
              document.removeEventListener("touchend", r2.onGripDragOver), document.removeEventListener("mouseup", r2.onGripDragOver), document.removeEventListener("touchmove", r2.onGripDrag), document.removeEventListener("mousemove", r2.onGripDrag);
              var i3 = document.querySelector("head").lastChild;
              if (i3.parentNode.removeChild(i3), t3) {
                if (t3.classList.remove(t3.t.opt.draggingClass), t3.x - t3.l != 0) {
                  var o2 = t3.t, n2 = o2.opt.onResize, l = t3.i;
                  if (l === o2.columnCnt - 1) {
                    var a = o2.columns[l];
                    a.style.width = t3.w + r2.PX, a.w = t3.w;
                  } else
                    r2.syncCols(o2, l, true, o2.opt);
                  o2.opt.fixed || r2.applyBounds(), r2.syncGrips(), n2 && n2(e4), o2.opt.serialize && r2.serializeStore();
                }
                r2.grip = null;
              }
            }), _defineProperty(this, "init", function(e4) {
              if (e4.disable)
                return r2.destroy();
              var t3 = r2.tb, i3 = t3.getAttribute(r2.ID) || r2.RESIZABLE + o();
              if (!t3.matches("table") || t3.extended && !e4.partialRefresh)
                return null;
              var n2 = document.querySelector("head");
              if (r2.createStyle(n2, " .grip-resizable{table-layout:fixed;} .grip-resizable > tbody > tr > td, .grip-resizable > tbody > tr > th{overflow:hidden} .grip-padding > tbody > tr > td, .grip-padding > tbody > tr > th{padding-left:0!important; padding-right:0!important;} .grip-container{ height:0px; position:relative;} .grip-handle{margin-left:-5px; position:absolute; z-index:5; } .grip-handle .grip-resizable{position:absolute;background-color:red;filter:alpha(opacity=1);opacity:0;width:10px;height:100%;cursor: col-resize;top:0px} .grip-lastgrip{position:absolute; width:1px; } .grip-drag{ border-left:1px dotted black;	} .grip-flex{width:auto!important;} .grip-handle.grip-disabledgrip .grip-resizable{cursor:default; display:none;}"), e4.hoverCursor && "col-resize" !== e4.hoverCursor) {
                var l = ".grip-handle .grip-resizable:hover{cursor:" + e4.hoverCursor + "!important}";
                r2.createStyle(n2, l);
              }
              t3.setAttribute(r2.ID, i3);
              var a = t3.opt;
              t3.opt = r2.extendOptions(e4);
              var s = r2.getTableHeaders(t3);
              if (r2.extendTable(s), e4.remoteTable && e4.remoteTable.matches("table")) {
                var d = r2.getTableHeaders(t3.opt.remoteTable);
                s.length === d.length ? r2.extendRemoteTable(t3.opt.remoteTable, d, t3) : console.warn("column count for remote table did not match");
              }
              return a;
            }), _defineProperty(this, "applyBounds", function() {
              var e4 = r2.tb, t3 = e4.columns.map(function(e5) {
                return window.getComputedStyle(e5).width;
              });
              e4.style.width = window.getComputedStyle(e4).width, e4.tableWidth = Number(e4.style.width.replace(/px/, "")).valueOf(), e4.classList.remove(r2.FLEX), e4.columns.forEach(function(r3, i3) {
                r3.style.width = t3[i3];
                var o2 = Number(t3[i3].replace(/px/, "")).valueOf();
                r3.w = o2, e4.opt.currentWidths[i3] = o2;
              }), e4.classList.add(r2.FLEX);
            }), _defineProperty(this, "serializeStore", function() {
              var e4 = r2.store, t3 = r2.tb;
              e4[t3.getAttribute(r2.ID)] = "";
              for (var i3 = 0, o2 = 0; o2 < t3.columns.length; o2++) {
                var n2 = window.getComputedStyle(t3.columns[o2]).width.replace(/px/, "");
                e4[t3.getAttribute(r2.ID)] += n2 + ";", i3 += Number(n2).valueOf();
              }
              e4[t3.getAttribute(r2.ID)] += i3.toString(), t3.opt.fixed || (e4[t3.getAttribute(r2.ID)] += ";" + window.getComputedStyle(t3).width.replace(/px/, ""));
            }), _defineProperty(this, "syncGrips", function() {
              var e4 = r2.tb;
              e4.gripContainer.style.width = e4.tableWidth + r2.PX;
              for (var t3 = 0; t3 < e4.columnCnt; t3++) {
                var i3 = e4.columns[t3], o2 = i3.getBoundingClientRect(), n2 = e4.getBoundingClientRect();
                e4.grips[t3].style.left = o2.left - n2.left + i3.offsetWidth + e4.cellSpace / 2 + r2.PX, e4.grips[t3].style.height = (e4.opt.headerOnly ? e4.columns[0].offsetHeight : e4.offsetHeight) + r2.PX;
              }
            }), _defineProperty(this, "destroy", function() {
              var e4 = r2.tb, t3 = e4.getAttribute(r2.ID);
              return t3 ? (r2.store[t3] = "", e4.classList.remove(r2.RESIZABLE), e4.classList.remove(r2.FLEX), e4.remote && (e4.remote.classList.remove(r2.RESIZABLE), e4.remote.classList.remove(r2.FLEX)), e4.gripContainer && e4.gripContainer.parentNode && e4.gripContainer.parentNode.removeChild(e4.gripContainer), delete e4.extended, e4.opt) : null;
            }), _defineProperty(this, "createStyle", function(e4, r3) {
              var i3 = t2()(r3).toString(), o2 = e4.querySelectorAll("style"), n2 = Array.from(o2).filter(function(e5) {
                return e5.gripid === i3;
              });
              if (!n2.length) {
                var l = document.createElement("style");
                l.type = "text/css", l.gripid = i3, l.styleSheet ? l.styleSheet.cssText = r3 : l.appendChild(document.createTextNode(r3)), e4.appendChild(l);
              }
            }), _defineProperty(this, "extendOptions", function(e4) {
              var t3 = Object.assign({}, ColumnResizer2.DEFAULTS, e4);
              switch (t3.fixed = true, t3.overflow = false, t3.resizeMode) {
                case "flex":
                  t3.fixed = false;
                  break;
                case "overflow":
                  t3.fixed = false, t3.overflow = true;
              }
              return t3;
            }), _defineProperty(this, "getTableHeaders", function(e4) {
              var t3 = "#" + e4.id, i3 = Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>th"));
              return (i3 = i3.concat(Array.from(e4.querySelectorAll(t3 + ">thead>tr:nth-of-type(1)>td")))).length || (i3 = (i3 = (i3 = (i3 = Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>th"))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>th")))).concat(Array.from(e4.querySelectorAll(t3 + ">tbody>tr:nth-of-type(1)>td")))).concat(Array.from(e4.querySelectorAll(t3 + ">tr:nth-of-type(1)>td")))), r2.filterInvisible(i3, false);
            }), _defineProperty(this, "filterInvisible", function(e4, t3) {
              return e4.filter(function(e5) {
                var r3 = t3 ? -1 : e5.offsetWidth, i3 = t3 ? -1 : e5.offsetHeight;
                return !(0 === r3 && 0 === i3 || e5.style && e5.style.display && "none" === window.getComputedStyle(e5).display || false);
              });
            }), _defineProperty(this, "extendTable", function(e4) {
              var t3 = r2.tb;
              t3.opt.removePadding && t3.classList.add("grip-padding"), t3.classList.add(r2.RESIZABLE), t3.insertAdjacentHTML("beforebegin", '<div class="grip-container"/>'), t3.grips = [], t3.columns = [], t3.tableWidth = Number(window.getComputedStyle(t3).width.replace(/px/, "")).valueOf(), t3.gripContainer = t3.previousElementSibling, t3.opt.marginLeft && (t3.gripContainer.style.marginLeft = t3.opt.marginLeft), t3.opt.marginRight && (t3.gripContainer.style.marginRight = t3.opt.marginRight), t3.cellSpace = parseInt(r2.legacyIE ? t3.cellSpacing || t3.currentStyle.borderSpacing : window.getComputedStyle(t3).borderSpacing.split(" ")[0].replace(/px/, "")) || 2, t3.borderSpace = parseInt(r2.legacyIE ? t3.border || t3.currentStyle.borderLeftWidth : window.getComputedStyle(t3).borderLeftWidth.replace(/px/, "")) || 1, t3.extended = true, r2.createGrips(e4);
            }), _defineProperty(this, "extendRemoteTable", function(e4, t3, i3) {
              i3.opt.removePadding && e4.classList.add("grip-padding"), e4.classList.add(r2.RESIZABLE), e4.getAttribute(r2.ID) || e4.setAttribute(r2.ID, i3.getAttribute(r2.ID) + "remote"), e4.columns = [], t3.forEach(function(o3, n2) {
                var l = t3[n2];
                l.w = i3.columns[n2].w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), e4.columns.push(l);
              }), e4.tableWidth = i3.tableWidth, e4.cellSpace = i3.cellSpace, e4.borderSpace = i3.borderSpace;
              var o2 = Array.from(e4.querySelectorAll("col"));
              e4.columnGrp = r2.filterInvisible(o2, true), e4.columnGrp.forEach(function(e5, t4) {
                e5.removeAttribute("width"), e5.style.width = i3.columnGrp[t4].style.width;
              }), i3.remote = e4;
            }), _defineProperty(this, "createGrips", function(e4) {
              var t3 = r2.tb;
              t3.columnGrp = r2.filterInvisible(Array.from(t3.querySelectorAll("col")), true), t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.columnCnt = e4.length;
              var i3 = false;
              r2.store[t3.getAttribute(r2.ID)] && (r2.deserializeStore(e4), i3 = true), e4.forEach(function(o3, n2) {
                var l = e4[n2], a = -1 !== t3.opt.disabledColumns.indexOf(n2);
                r2.createDiv(t3.gripContainer, "grip-handle");
                var s = t3.gripContainer.lastChild;
                !a && t3.opt.gripInnerHtml && (s.innerHTML = t3.opt.gripInnerHtml), r2.createDiv(s, r2.RESIZABLE), n2 === t3.columnCnt - 1 && (s.classList.add("grip-lastgrip"), t3.opt.fixed && (s.innerHTML = "")), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true), a ? s.classList.add("grip-disabledgrip") : (s.classList.remove("grip-disabledgrip"), s.addEventListener("touchstart", r2.onGripMouseDown, { capture: true, passive: true }), s.addEventListener("mousedown", r2.onGripMouseDown, true)), s.t = t3, s.i = n2, t3.opt.widths[n2] ? l.w = t3.opt.widths[n2] : l.w = i3 ? Number(l.style.width.replace(/px/, "")).valueOf() : Number(window.getComputedStyle(l).width.replace(/px/, "")).valueOf(), t3.opt.currentWidths[n2] = l.w, l.style.width = l.w + r2.PX, l.removeAttribute("width"), s.data = { i: n2, t: t3.getAttribute(r2.ID), last: n2 === t3.columnCnt - 1 }, t3.grips.push(s), t3.columns.push(l);
              });
              var o2 = Array.from(t3.querySelectorAll("td"));
              o2.concat(Array.from(t3.querySelectorAll("th"))), (o2 = (o2 = o2.filter(function(t4) {
                for (var r3 = 0; r3 < e4.length; r3++)
                  if (e4[r3] === t4)
                    return false;
                return true;
              })).filter(function(e5) {
                return !(e5.querySelectorAll("table th").length || e5.querySelectorAll("table td").length);
              })).forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.fixed || (t3.removeAttribute("width"), t3.classList.add(r2.FLEX)), r2.syncGrips();
            }), _defineProperty(this, "deserializeStore", function(e4) {
              var t3 = r2.tb;
              if (t3.columnGrp.forEach(function(e5) {
                e5.removeAttribute("width");
              }), t3.opt.flush)
                r2.store[t3.getAttribute(r2.ID)] = "";
              else {
                var i3 = r2.store[t3.getAttribute(r2.ID)].split(";"), o2 = i3[t3.columnCnt + 1];
                !t3.opt.fixed && o2 && (t3.style.width = o2 + r2.PX, t3.opt.overflow && (t3.style.minWidth = o2 + r2.PX, t3.tableWidth = Number(o2).valueOf()));
                for (var n2 = 0; n2 < t3.columnCnt; n2++)
                  e4[n2].style.width = i3[n2] + r2.PX, t3.columnGrp[n2] && (t3.columnGrp[n2].style.width = 100 * Number(i3[n2]).valueOf() / Number(i3[t3.columnCnt]).valueOf() + "%");
              }
            }), _defineProperty(this, "createDiv", function(e4, t3, r3) {
              var i3 = document.createElement("div");
              i3.classList.add(t3), r3 && (i3.innerHTML = r3), e4.appendChild(i3);
            }), _defineProperty(this, "syncCols", function(e4, t3, i3, o2) {
              var n2 = e4.remote, l = r2.grip.x - r2.grip.l, a = e4.columns[t3], s = e4.columns[t3 + 1];
              if (a && s) {
                var d = a.w + l, p2 = s.w - l, u = d + r2.PX;
                if (a.style.width = u, e4.columnGrp[t3] && e4.columnGrp[t3].style.width && (e4.columnGrp[t3].style.width = u), n2 && (n2.columns[t3].style.width = u, n2.columnGrp[t3] && n2.columnGrp[t3].style.width && (n2.columnGrp[t3].style.width = u)), o2.fixed) {
                  var c = p2 + r2.PX;
                  s.style.width = c, e4.columnGrp[t3 + 1] && e4.columnGrp[t3 + 1].style.width && (e4.columnGrp[t3 + 1].style.width = c), n2 && (n2.columns[t3 + 1].style.width = c, n2.columnGrp[t3 + 1] && n2.columnGrp[t3 + 1].style.width && (n2.columnGrp[t3 + 1].style.width = c));
                } else
                  o2.overflow && (e4.style.minWidth = e4.tableWidth + l + r2.PX);
                i3 && (a.w = d, s.w = o2.fixed ? p2 : s.w, n2 && (n2.columns[t3].w = d, n2.columns[t3 + 1].w = o2.fixed ? p2 : s.w));
              }
            });
            try {
              this.store = sessionStorage;
            } catch (e4) {
              this.store = {};
            }
            this.grip = null, this.tb = e3, window.addEventListener("resize", this.onResize), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector), this.init(i2);
          });
          n.DEFAULTS = { resizeMode: "fit", draggingClass: "grip-drag", gripInnerHtml: "", liveDrag: false, minWidth: 15, headerOnly: false, hoverCursor: "col-resize", dragCursor: "col-resize", flush: false, marginLeft: null, marginRight: null, remoteTable: null, disable: false, partialRefresh: false, disabledColumns: [], removePadding: true, widths: [], currentWidths: [], serialize: true, onDrag: null, onResize: null };
        })(), r;
      })());
    })(columnResizer);
    var columnResizerExports = columnResizer.exports;
    const ColumnResizer = /* @__PURE__ */ getDefaultExportFromCjs(columnResizerExports);
    const HALIN_CLASS = {
      center: "slds-grid_align-center",
      space: "slds-grid_align-space",
      spread: "slds-grid_align-spread",
      end: "slds-grid_align-end"
    };
    const VALIN_CLASS = {
      start: "slds-grid_vertical-align-start",
      center: "slds-grid_vertical-align-center",
      end: "slds-grid_vertical-align-end",
      stretch: "slds-grid_vertical-stretch"
    };
    const BOUNDARY_CLASS = {
      small: "slds-grid_pull-padded",
      medium: "slds-grid_pull-padded-medium",
      large: "slds-grid_pull-padded-large"
    };
    const VERTICAL_ALIGN = Object.keys(VALIN_CLASS);
    const BOUNDARY = Object.keys(BOUNDARY_CLASS);
    const HORIZONTAL_ALIGN = Object.keys(HALIN_CLASS);
    const ROWS_CLASS = "slds-wrap";
    const GRID_CLASS = "slds-grid";
    const VERTICAL_CLASS = "slds-grid_vertical";
    const GUTTERS_CLASS = "slds-gutters";
    const _sfc_main$s = {
      name: "Layout",
      props: {
        gutters: Boolean,
        horizontalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || HORIZONTAL_ALIGN.includes(value);
          }
        },
        multipleRows: Boolean,
        pullToBoundary: {
          type: String,
          default: null,
          validator(value) {
            return !value || BOUNDARY.includes(value);
          }
        },
        vertical: Boolean,
        verticalAlign: {
          type: String,
          default: null,
          validator(value) {
            return !value || VERTICAL_ALIGN.includes(value);
          }
        }
      },
      computed: {
        computedClasses() {
          const result = [
            GRID_CLASS,
            HALIN_CLASS[this.$props.horizontalAlign],
            VALIN_CLASS[this.$props.verticalAlign],
            BOUNDARY_CLASS[this.$props.boundary]
          ];
          if (this.$props.multipleRows) {
            result.push(ROWS_CLASS);
          }
          if (this.$props.vertical) {
            result.push(VERTICAL_CLASS);
          }
          if (this.$props.gutters) {
            result.push(GUTTERS_CLASS);
          }
          return result;
        }
      }
    };
    function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 2);
    }
    const Layout = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$q], ["__scopeId", "data-v-8aa1ef04"]]);
    const PADDING = [
      "horizontal-small",
      "horizontal-medium",
      "horizontal-large",
      "around-small",
      "around-medium",
      "around-large"
    ];
    const PADDING_CLASS = {
      "slds-p-right_small": "horizontal-small",
      "slds-p-left_small": "horizontal-small",
      "slds-p-right_medium": "horizontal-medium",
      "slds-p-left_medium": "horizontal-medium",
      "slds-p-right_large": "horizontal-large",
      "slds-p-left_large": "horizontal-large",
      "slds-p-around_small": "around-small",
      "slds-p-around_medium": "around-medium",
      "slds-p-around_large": "around-large"
    };
    const FLEXIBILITY = [
      "auto",
      "shrink",
      "no-shrink",
      "grow",
      "no-grow",
      "no-flex"
    ];
    const FLEX_CLASS = {
      "slds-col": "auto",
      "slds-grow": "grow",
      "slds-shrink": "shrink",
      "slds-grow-none": "no-grow",
      "slds-shrink-none": "no-shrink",
      "slds-no-flex": "no-flex"
    };
    const SIZE_MIN = 1;
    const SIZE_MAX = 12;
    const SIZE_CLASS = {
      default: "slds-size_",
      small: "slds-small-size_",
      medium: "slds-medium-size_",
      large: "slds-large-size_"
    };
    const DIRECTION = ["left", "top", "right", "bottom"];
    const ERRORS = {
      FLEX_CONFLICT: "You cannot have `flexibility` value to be set to `auto` and `no-flex` together for LayoutItem component",
      SIZE_RANGE: "Invalid `size` attribute for LayoutItem component. The `size` attribute should be an integer between 1 and 12",
      SMALL_SIZE_RANGE: "Invalid `smallDeviceSize` attribute for LayoutItem component. The `smallDeviceSize` attribute should be an integer between 1 and 12",
      MEDIUM_SIZE_RANGE: "Invalid `mediumDeviceSize` attribute for LayoutItem component. The `mediumDeviceSize` attribute should be an integer between 1 and 12",
      LARGE_SIZE_RANGE: "Invalid `largeDeviceSize` attribute for LayoutItem component. The `largeDeviceSize` attribute should be an integer between 1 and 12",
      SIZE_REQUIRED: "You cannot have device specific size attributes for LayoutItem component without specifying the `size` attribute"
    };
    const _sfc_main$r = {
      name: "LayoutItem",
      props: {
        /**
         * Make the item fluid so that it absorbs any extra space in its
         * container or shrinks when there is less space. Allowed values are:
         *   auto (columns grow or shrink equally as space allows),
         *   shrink (columns shrink equally as space decreases),
         *   no-shrink (columns don't shrink as space reduces),
         *   grow (columns grow equally as space increases),
         *   no-grow (columns don't grow as space increases),
         *   no-flex (columns don't grow or shrink as space changes).
         * Use a comma-separated or space-separated value for multiple options, such as 'auto, no-shrink'.
         */
        flexibility: {
          type: String,
          default: "auto",
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/).map((item) => item.trim());
            if (classes.some((item) => item === "auto") && classes.some((item) => item === "no-flex")) {
              throw new Error(ERRORS.FLEX_CONFLICT);
            }
            return classes.every((item) => FLEXIBILITY.some((allowed) => item === allowed));
          }
        },
        /**
         * Specifies a direction to bump the alignment of adjacent layout items. Allowed values are left, top, right, bottom.
         */
        alignmentBump: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one alignment class set.");
            }
            return classes.every((item) => DIRECTION.some((allowed) => item === allowed));
          }
        },
        padding: {
          type: String,
          default: null,
          validator(value) {
            const classes = value.trim().split(/[,|\s]+/);
            if (classes.size > 1) {
              throw new Error("You cannot have more than one padding class set.");
            }
            return classes.every((item) => PADDING.some((allowed) => item === allowed));
          }
        },
        size: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SIZE_RANGE);
            }
            return true;
          }
        },
        smallDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.SMALL_SIZE_RANGE);
            }
            return true;
          }
        },
        mediumDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.MEDIUM_SIZE_RANGE);
            }
            return true;
          }
        },
        largeDeviceSize: {
          type: [Number, String],
          default: null,
          validator(value) {
            const num = parseInt(value, 10);
            if (!(SIZE_MIN <= num && num <= SIZE_MAX)) {
              throw new Error(ERRORS.LARGE_SIZE_RANGE);
            }
            return true;
          }
        }
      },
      data() {
        return {
          pFlexibility: null,
          pPadding: null,
          pAlignmentBump: null
        };
      },
      computed: {
        computedClasses() {
          const classes = /* @__PURE__ */ new Set();
          this.computeSizeClasses(
            {
              default: this.$props.size,
              small: this.$props.smallDeviceSize,
              medium: this.$props.mediumDeviceSize,
              large: this.$props.largeDeviceSize
            },
            classes
          );
          this.computePaddingClass(this.$props.padding, classes);
          this.computeFlexibilityClass(this.$props.flexibility, classes);
          this.computeBumpClass(this.$props.alignmentBump, classes);
          return Array.from(classes);
        }
      },
      watch: {
        size() {
          this.validateSizes();
        },
        smallDeviceSize() {
          this.validateSizes();
        },
        mediumDeviceSize() {
          this.validateSizes();
        },
        largeDeviceSize() {
          this.validateSizes();
        }
      },
      created() {
        this.validateSizes();
      },
      methods: {
        validateSizes() {
          if (this.$props.size === null && (this.$props.smallDeviceSize != null || this.$props.mediumDeviceSize != null || this.$props.largeDeviceSize != null)) {
            throw new Error(ERRORS.SIZE_REQUIRED);
          }
        },
        computeSizeClasses(sizes, classes) {
          Object.keys(SIZE_CLASS).forEach((key) => {
            const size2 = sizes[key];
            if (size2 != null && size2 !== 0) {
              classes.add(`${SIZE_CLASS[key]}${size2}-of-12`);
            }
          });
        },
        computeFlexibilityClass(flexibility, classes) {
          if (flexibility === null)
            return;
          flexibility = flexibility.trim().split(/[,|\s]+/).map((item) => item.trim());
          Object.keys(FLEX_CLASS).forEach((key) => {
            if (flexibility.some((flex) => flex === FLEX_CLASS[key])) {
              classes.add(key);
            }
          });
        },
        computePaddingClass(padding, classes) {
          if (padding === null)
            return;
          Object.keys(PADDING_CLASS).forEach((key) => {
            if (PADDING_CLASS[key].toLowerCase() === padding.trim()) {
              classes.add(key);
            }
          });
        },
        computeBumpClass(direction, classes) {
          if (direction) {
            classes.add(`slds-col_bump-${direction}`);
          }
        }
      }
    };
    function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass($options.computedClasses)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    }
    const LayoutItem = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$p]]);
    const _sfc_main$q = {
      name: "DataTableRow",
      components: {
        ActionMenu,
        ActionMenuItem,
        Badge,
        ButtonIcon,
        Checkbox,
        ConditionalWrapper,
        Icon
      },
      inject: [
        "rootProps",
        "selectAllId",
        "rootEmit"
      ],
      props: [
        "childIndex",
        "depth",
        "parentRef",
        "row"
      ],
      data() {
        return {
          indexOfColumnBeingEdited: null
        };
      },
      methods: {
        handleAnchorClick(data, e) {
          if (typeof data.onClick === "function") {
            e.preventDefault();
            data.onClick(data, e);
          }
        },
        handleRowToggleClick() {
          this.$props.row.expanded = !this.$props.row.expanded;
        },
        handleCellEdit(event, index) {
          this.indexOfColumnBeingEdited = index;
          const cell = event.path.find((el) => ["td", "th"].includes(el.localName) && el.className.includes("slds-cell-edit"));
          this.$nextTick(() => cell.querySelector("input").focus());
        },
        handleRowAction(action) {
          this.rootEmit(
            "row-action",
            {
              action,
              ...this.$props
            }
          );
        },
        updateCellValue(e) {
          const cellValue = e.path[0].value;
          this.$props.row.data[this.indexOfColumnBeingEdited].value = cellValue;
          this.rootEmit("update-cell", { value: cellValue, row: this.$props.row, columnIndex: this.indexOfColumnBeingEdited });
          this.$nextTick(() => {
            if (!this.$props.row.data[this.indexOfColumnBeingEdited].error)
              this.indexOfColumnBeingEdited = null;
          });
        },
        resetEditMode() {
          this.indexOfColumnBeingEdited = null;
        }
      }
    };
    const _hoisted_1$n = ["aria-selected", "aria-level"];
    const _hoisted_2$n = {
      key: 0,
      class: "slds-text-align_right slds-cell_action-mode",
      role: "gridcell"
    };
    const _hoisted_3$l = ["title"];
    const _hoisted_4$k = {
      key: 0,
      "aria-describedby": "dialog-body-id-1",
      class: "slds-popover slds-popover slds-popover_edit",
      role: "dialog",
      style: { "position": "absolute", "top": "0px", "left": "0.0625rem" }
    };
    const _hoisted_5$j = {
      id: "dialog-body-id-1",
      class: "slds-popover__body"
    };
    const _hoisted_6$i = { class: "slds-media" };
    const _hoisted_7$f = { class: "slds-media__body" };
    const _hoisted_8$d = ["for"];
    const _hoisted_9$b = { class: "slds-assistive-text" };
    const _hoisted_10$9 = { class: "slds-form-element__control slds-grow" };
    const _hoisted_11$9 = ["id", "value"];
    const _hoisted_12$7 = {
      key: 0,
      class: "slds-form-element__help"
    };
    const _hoisted_13$8 = {
      key: 1,
      class: "slds-cell_action-mode",
      role: "gridcell"
    };
    function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Badge = resolveComponent("Badge");
      const _component_Icon = resolveComponent("Icon");
      const _component_ConditionalWrapper = resolveComponent("ConditionalWrapper");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      return openBlock(), createElementBlock("tr", {
        ref: "row",
        key: _ctx.$props.row.id,
        "aria-selected": $options.rootProps.multiselectable ? _ctx.$props.row.selected || "false" : null,
        "aria-level": _ctx.$props.depth ? _ctx.$props.depth : null,
        class: normalizeClass([{ "slds-is-selected": _ctx.$props.row.selected }, "slds-hint-parent"])
      }, [
        $options.rootProps.multiselectable ? (openBlock(), createElementBlock("td", _hoisted_2$n, [
          createVNode(_component_Checkbox, {
            modelValue: _ctx.$props.row.selected,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.$props.row.selected = $event),
            ariaLabeledBy: $options.selectAllId,
            labels: { name: `Select item ${_ctx.$props.childIndex + 1}` },
            hideLabel: "",
            onInput: _cache[1] || (_cache[1] = ($event) => $options.rootEmit("select-row", { id: _ctx.$props.row.id, row: _ctx.$props.row, selected: _ctx.$props.row.selected }))
          }, null, 8, ["modelValue", "ariaLabeledBy", "labels"])
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.data, (data, i) => {
          var _a2, _b;
          return openBlock(), createBlock(resolveDynamicComponent(i === 0 ? "th" : "td"), {
            key: `'Root' + ${i}`,
            "data-label": $options.rootProps.columns[i].name,
            class: normalizeClass([
              `slds-text-align_${((_a2 = $options.rootProps.columns[i]) == null ? void 0 : _a2.alignment) || "left"}`,
              {
                "slds-tree__item": i === 0 && $options.rootProps.tree,
                "slds-cell-edit": (_b = $options.rootProps) == null ? void 0 : _b.editableColumnIndices.includes(i),
                "slds-is-edited": data == null ? void 0 : data.dirty,
                "slds-has-error": data == null ? void 0 : data.error
              }
            ]),
            role: i > 0 && $options.rootProps.tree ? "gridcell" : null,
            scope: i === 0 ? "row" : null
          }, {
            default: withCtx(() => {
              var _a3;
              return [
                createVNode(_component_ConditionalWrapper, {
                  class: normalizeClass(["slds-grid slds-grid_align-spread", { "slds-grow": i === 0 }]),
                  element: "span",
                  style: { "width": "100%" },
                  active: (_a3 = $options.rootProps) == null ? void 0 : _a3.editableColumnIndices.includes(i)
                }, {
                  default: withCtx(() => {
                    var _a4, _b2;
                    return [
                      createVNode(_component_ConditionalWrapper, {
                        element: "span",
                        class: "slds-grid slds-truncate",
                        active: i === 0 && ((_a4 = $options.rootProps) == null ? void 0 : _a4.editableColumnIndices.includes(i))
                      }, {
                        default: withCtx(() => {
                          var _a5;
                          return [
                            $options.rootProps.tree && i === 0 ? (openBlock(), createBlock(_component_ButtonIcon, {
                              key: 0,
                              variant: "bare",
                              iconCategory: "utility",
                              iconName: _ctx.$props.row.expanded ? "chevrondown" : "chevronright",
                              size: "x-small",
                              class: normalizeClass(["slds-m-right_x-small", { "slds-is-disabled": !((_a5 = _ctx.$props.row.children) == null ? void 0 : _a5.length) }]),
                              tabindex: "-1",
                              title: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              assistiveText: `Expand ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                              onClick: $options.handleRowToggleClick
                            }, null, 8, ["iconName", "class", "title", "assistiveText", "onClick"])) : createCommentVNode("", true),
                            (data == null ? void 0 : data.type) === "custom" ? renderSlot(_ctx.$slots, "cell", mergeProps({
                              key: 1,
                              column: $options.rootProps.columns[i],
                              columnIndex: i,
                              data
                            }, _ctx.$props)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
                              (data == null ? void 0 : data.type) === "badge" ? (openBlock(), createBlock(_component_Badge, {
                                key: 0,
                                theme: data.theme,
                                content: data.value
                              }, null, 8, ["theme", "content"])) : typeof data === "boolean" ? (openBlock(), createBlock(_component_Icon, {
                                key: 1,
                                category: "utility",
                                name: "check",
                                size: "xx-small"
                              })) : (openBlock(), createElementBlock("div", {
                                key: 2,
                                title: (data == null ? void 0 : data.type) === "anchor" ? data.value : data,
                                class: "slds-truncate"
                              }, [
                                createVNode(_component_ConditionalWrapper, mergeProps({
                                  tabindex: "-1",
                                  element: "a"
                                }, (data == null ? void 0 : data.attrs) || {}, {
                                  active: (data == null ? void 0 : data.type) === "anchor",
                                  onClick: ($event) => $options.handleAnchorClick(data, $event)
                                }), {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString((data == null ? void 0 : data.type) === "anchor" ? data.value : data), 1)
                                  ]),
                                  _: 2
                                }, 1040, ["active", "onClick"])
                              ], 8, _hoisted_3$l))
                            ], 64))
                          ];
                        }),
                        _: 2
                      }, 1032, ["active"]),
                      ((_b2 = $options.rootProps) == null ? void 0 : _b2.editableColumnIndices.includes(i)) ? (openBlock(), createBlock(_component_ButtonIcon, {
                        key: 0,
                        variant: "bare",
                        iconCategory: "utility",
                        iconClass: "slds-button__icon_hint slds-button__icon_edit",
                        iconName: data.locked ? "lock" : "edit",
                        size: "x-small",
                        class: "slds-cell-edit__button slds-m-left_x-small",
                        title: `Edit ${$options.rootProps.columns[i].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        assistiveText: `Edit ${$options.rootProps.columns[i].name} of ${(data == null ? void 0 : data.type) === "anchor" ? data.value : data}`,
                        disabled: data.locked,
                        onClick: ($event) => $options.handleCellEdit($event, i)
                      }, null, 8, ["iconName", "title", "assistiveText", "disabled", "onClick"])) : createCommentVNode("", true)
                    ];
                  }),
                  _: 2
                }, 1032, ["class", "active"]),
                i === $data.indexOfColumnBeingEdited ? (openBlock(), createElementBlock("section", _hoisted_4$k, [
                  createBaseVNode("div", _hoisted_5$j, [
                    createBaseVNode("div", _hoisted_6$i, [
                      createBaseVNode("div", _hoisted_7$f, [
                        createBaseVNode("div", {
                          class: normalizeClass(["slds-form-element slds-grid slds-wrap", { "slds-has-error": data.error }])
                        }, [
                          createBaseVNode("label", {
                            class: "slds-form-element__label slds-form-element__label_edit slds-no-flex",
                            for: `${$options.rootProps.columns[i].name}-${i}`
                          }, [
                            createBaseVNode("span", _hoisted_9$b, toDisplayString($options.rootProps.columns[i].name), 1)
                          ], 8, _hoisted_8$d),
                          createBaseVNode("div", _hoisted_10$9, [
                            createBaseVNode("input", {
                              id: `${$options.rootProps.columns[i].name}-${i}`,
                              class: "slds-input",
                              type: "text",
                              value: data.value,
                              onBlur: _cache[2] || (_cache[2] = (...args) => $options.resetEditMode && $options.resetEditMode(...args)),
                              onKeydown: [
                                _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.resetEditMode && $options.resetEditMode(...args), ["stop"]), ["esc"])),
                                _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => $options.updateCellValue($event), ["stop"]), ["enter"]))
                              ]
                            }, null, 40, _hoisted_11$9)
                          ]),
                          data.error ? (openBlock(), createElementBlock("div", _hoisted_12$7, toDisplayString(data.error), 1)) : createCommentVNode("", true)
                        ], 2)
                      ])
                    ])
                  ])
                ])) : createCommentVNode("", true)
              ];
            }),
            _: 2
          }, 1032, ["data-label", "class", "role", "scope"]);
        }), 128)),
        ((_a = _ctx.$props.row.actions) == null ? void 0 : _a.length) ? (openBlock(), createElementBlock("td", _hoisted_13$8, [
          createVNode(_component_ActionMenu, null, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.row.actions, (action, i) => {
                return openBlock(), createBlock(_component_ActionMenuItem, {
                  key: i,
                  label: action.label,
                  onClick: ($event) => $options.handleRowAction(action)
                }, null, 8, ["label", "onClick"]);
              }), 128))
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ], 10, _hoisted_1$n);
    }
    const Row = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$o]]);
    const Node$2 = {
      name: "DataTableTreeNode",
      components: {
        Row
      },
      props: [
        "depth",
        "parentRef",
        "row",
        "childIndex"
      ],
      render() {
        const children2 = [
          h(
            Row,
            {
              ...this.$props
            },
            {
              cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
            }
          )
        ];
        if (this.$props.row.children && this.$props.row.expanded) {
          this.$props.row.children.forEach((row, childIndex) => children2.push(
            h(
              Node$2,
              {
                childIndex,
                depth: this.$props.depth + 1,
                parentRef: this.$props.row,
                row
              },
              {
                cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
              }
            )
          ));
        }
        return [children2];
      }
    };
    const Tree = {
      name: "DataTableTree",
      components: {
        Node: Node$2
      },
      props: ["rows"],
      render() {
        const _default = this.$slots.default ? this.$slots.default() : null;
        return this.$props.rows.map((row, childIndex) => h(
          Node$2,
          {
            childIndex,
            depth: 0,
            parentRef: null,
            row
          },
          {
            cell: (propsData) => this.$slots.cell ? this.$slots.cell(propsData) : null
          }
        )).concat(_default);
      }
    };
    const _sfc_main$p = {
      name: "DataTable",
      components: {
        ActionMenu,
        ActionMenuItem,
        Checkbox,
        // ConditionalWrapper,
        Icon,
        Layout,
        LayoutItem,
        Row,
        Tree
      },
      provide() {
        return {
          rootProps: this.$props,
          selectAllId: this.selectAllId,
          rootEmit: (...args) => {
            this.$emit(args[0], ...args.slice(1));
          }
        };
      },
      props: {
        actions: Boolean,
        ariaLabel: {
          type: String,
          default: ""
        },
        bordered: Boolean,
        bufferCells: Boolean,
        columns: {
          type: Array,
          required: true
        },
        columnsBordered: Boolean,
        editableColumnIndices: {
          type: Array,
          default: () => []
        },
        hideHeader: Boolean,
        multiselectable: Boolean,
        resizable: Boolean,
        // TODO: Explore making a copy of this array to avoid directly manipulating rows
        rows: {
          type: Array,
          required: true
        },
        selectAll: Boolean,
        summaryFooter: Boolean,
        summaryHeader: Boolean,
        tree: Boolean,
        virtual: Boolean
      },
      emits: [
        "column-action",
        "row-action",
        "select-all",
        "select-column",
        "select-row",
        "update-cell"
      ],
      data() {
        return {
          selectedAll: false,
          selectAllId: getGUID(),
          columnResizer: {},
          rowHeight: 0,
          containerHeight: 0,
          visibleRowsStartIndex: 0,
          // CSS vars
          selectedColumnBackgroundColor: "blue"
        };
      },
      computed: {
        computedRole() {
          if (this.$props.tree)
            return "treegrid";
          if (this.$props.multiselectable)
            return "grid";
          return null;
        },
        visibleRows() {
          return this.$props.virtual ? this.rows.slice(this.visibleRowsStartIndex, this.visibleRowsStartIndex + 200) : this.rows;
        },
        tableContainerPaddingTop() {
          return this.visibleRowsStartIndex * this.rowHeight;
        },
        tableContainerPaddingBottom() {
          return (this.rows.length - this.visibleRows.length) * this.rowHeight - this.tableContainerPaddingTop;
        },
        hasSelectableColumns() {
          return this.$props.columns.some((column) => column.selectable);
        },
        verticalHeaderCellPadding() {
          return this.$props.summaryHeader && this.hasSelectableColumns ? "0.75rem" : "0.5rem";
        },
        selectedPseudoElementTop() {
          return !this.hasSelectableColumns || !this.$props.summaryHeader ? "-4px" : 0;
        },
        selectedBorderRadius() {
          return this.$props.summaryHeader ? 0 : "2px";
        }
      },
      watch: {
        "$props.rows": {
          handler(rows) {
            if (rows.length) {
              this.initColumnResizer();
              if (this.$props.virtual) {
                this.$nextTick(() => {
                  this.rowHeight = this.$refs["row-0"][0].$refs.row.offsetHeight;
                  this.containerHeight = this.$refs.tableContainer.offsetHeight;
                });
              }
            }
          },
          immediate: true
        }
      },
      methods: {
        async initColumnResizer() {
          if (!this.$props.resizable)
            return;
          await this.$nextTick();
          this.columnResizer = new ColumnResizer(this.$refs.table, {
            disable: !this.$props.resizable,
            innerGripHtml: "<div class='rangeGrip'></div>",
            removePadding: false,
            minWidth: 48
          });
        },
        onSelectAllChange() {
          this.rows.forEach((row) => {
            row.selected = this.selectedAll;
          });
          this.$emit("select-all", this.selectedAll);
        },
        onScroll() {
          if (!this.$props.virtual || this.scrollTimeout)
            return;
          this.scrollTimeout = setTimeout(() => {
            this.visibleRowsStartIndex = Math.max(0, Math.floor(this.$refs.tableContainer.scrollTop / this.rowHeight) - 100);
            this.scrollTimeout = null;
          }, 500);
        },
        getListeners(column, columnIndex) {
          const base = { ...column.listeners || {} };
          if (column.selectable) {
            base.click = [base.click, this.onHeaderClick.bind(this, column, columnIndex)];
          }
          return base;
        },
        onHeaderClick(column, columnIndex, e) {
          function getParentTH(el) {
            if (el.nodeName === "TH")
              return el;
            while (el.parentNode) {
              el = el.parentNode;
              if (el.nodeName === "TH") {
                return el;
              }
            }
            return null;
          }
          if (e.target.nodeName !== "BUTTON") {
            this.$emit("select-column", { column, columnIndex });
            column.selected = true;
            this.$refs.tableContainer.style.paddingTop = "5px";
            if (column.icon) {
              const iconContainer = getParentTH(e.target).querySelector("div.slds-icon_container");
              if (iconContainer) {
                this.selectedColumnBackgroundColor = window.getComputedStyle(iconContainer).backgroundColor;
              }
            }
          }
        }
      }
    };
    const __injectCSSVars__ = () => {
      useCssVars((_ctx) => ({
        "4d4e3100": _ctx.selectedPseudoElementTop,
        "85016f72": _ctx.selectedBorderRadius,
        "484c9e56": _ctx.selectedColumnBackgroundColor,
        "f99d0584": _ctx.verticalHeaderCellPadding
      }));
    };
    const __setup__ = _sfc_main$p.setup;
    _sfc_main$p.setup = __setup__ ? (props, ctx) => {
      __injectCSSVars__();
      return __setup__(props, ctx);
    } : __injectCSSVars__;
    //! moment.js
    //! version : 2.30.1
    //! authors : Tim Wood, Iskren Chernev, Moment.js contributors
    //! license : MIT
    //! momentjs.com
    var hookCallback;
    function hooks() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend$1(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t = Object(this), len = t.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t && fun.call(this, t[i], i, t)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid(m) {
      var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend$1(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend$1(function() {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name2, msg) {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name2, msg);
      }
      if (!deprecations[name2]) {
        warn(msg);
        deprecations[name2] = true;
      }
    }
    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set$2(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend$1({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend$1(res[prop], parentConfig[prop]);
            extend$1(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend$1({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now2) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now2) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array2 = format2.match(formattingTokens), i, length;
      for (i = 0, length = array2.length; i < length; i++) {
        if (formatTokenFunctions[array2[i]]) {
          array2[i] = formatTokenFunctions[array2[i]];
        } else {
          array2[i] = removeFormattingTokens(array2[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array2[i2]) ? array2[i2].call(mom, format2) : array2[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units) {
      return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units.push({ unit: u, priority: priorities[u] });
        }
      }
      units.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s) {
      return regexEscape(
        s.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s) {
      return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array2) {
          array2[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array2, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array2) {
      array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array2) {
      array2[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array2) {
      array2[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$1$1(this, unit, value);
          hooks.updateOffset(this, keepTime);
          return this;
        } else {
          return get$2(this, unit);
        }
      };
    }
    function get$2(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d = mom._d, isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
        case "Seconds":
          return isUTC ? d.getUTCSeconds() : d.getSeconds();
        case "Minutes":
          return isUTC ? d.getUTCMinutes() : d.getMinutes();
        case "Hours":
          return isUTC ? d.getUTCHours() : d.getHours();
        case "Date":
          return isUTC ? d.getUTCDate() : d.getDate();
        case "Day":
          return isUTC ? d.getUTCDay() : d.getDay();
        case "Month":
          return isUTC ? d.getUTCMonth() : d.getMonth();
        case "FullYear":
          return isUTC ? d.getUTCFullYear() : d.getFullYear();
        default:
          return NaN;
      }
    }
    function set$1$1(mom, unit, value) {
      var d, isUTC, year, month, date;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
        case "Hours":
          return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
        case "Date":
          return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value;
      month = mom.month();
      date = mom.date();
      date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
      void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
    }
    function stringGet(units) {
      units = normalizeUnits(units);
      if (isFunction(this[units])) {
        return this[units]();
      }
      return this;
    }
    function stringSet(units, value) {
      if (typeof units === "object") {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units[prioritized[i].unit]);
        }
      } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units](value);
        }
      }
      return this;
    }
    function mod(n, x2) {
      return (n % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array2) {
      array2[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array2, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array2[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      var month = value, date = mom.date();
      date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
      } else {
        return get$2(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y2, m, d, h2, M, s, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m, d, h2, M, s, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m, d, h2, M, s, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week = this.localeData().week(this);
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week = weekOfYear(this, 1, 4).week;
      return input == null ? week : this.add((input - week) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
      week[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n) {
      return ws.slice(n, 7).concat(ws.slice(0, n));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get$2(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array2, config) {
      var kInput = toInt(input);
      array2[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array2, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array2, config) {
      array2[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array2, config) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array2, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array2, config) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array2, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name2) {
      return !!(name2 && name2.match("^[^/\\\\]*$"));
    }
    function loadLocale(name2) {
      var oldLocale = null, aliasedRequire;
      if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = require;
          aliasedRequire("./locale/" + name2);
          getSetGlobalLocale(oldLocale);
        } catch (e) {
          locales[name2] = null;
        }
      }
      return locales[name2];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name2, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name2;
        if (locales[name2] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name2]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name: name2,
                config
              });
              return null;
            }
          }
        }
        locales[name2] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name2]) {
          localeFamilies[name2].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name2);
        return locales[name2];
      } else {
        delete locales[name2];
        return null;
      }
    }
    function updateLocale(name2, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name2] != null && locales[name2].parentLocale != null) {
          locales[name2].set(mergeConfigs(locales[name2]._config, config));
        } else {
          tmpLocale = loadLocale(name2);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name2;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name2];
          locales[name2] = locale2;
        }
        getSetGlobalLocale(name2);
      } else {
        if (locales[name2] != null) {
          if (locales[name2].parentLocale != null) {
            locales[name2] = locales[name2].parentLocale;
            if (name2 === getSetGlobalLocale()) {
              getSetGlobalLocale(name2);
            }
          } else if (locales[name2] != null) {
            delete locales[name2];
          }
        }
      }
      return locales[name2];
    }
    function getLocale(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDatesLen; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimesLen; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s) {
      return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h2 = (hm - m) / 100;
        return h2 * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    hooks.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults$1(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults$1(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults$1(
          w.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week = defaults$1(w.W, 1);
        weekday = defaults$1(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults$1(w.gg, config._a[YEAR], curWeek.year);
        week = defaults$1(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks.ISO_8601 = function() {
    };
    hooks.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend$1(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min$1() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max$1() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now$1 = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array2, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher2, string) {
      var matches = (string || "").match(matcher2), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name2) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name2,
            "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get$2(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$1$1(mom, "Date", get$2(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now2) {
      var diff2 = myMoment.diff(now2, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now2))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
      }
    }
    function isBefore(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }
    function isSame(input, units) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units = normalizeUnits(units) || "millisecond";
      if (units === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
      }
    }
    function isSameOrAfter(input, units) {
      return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
      return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units = normalizeUnits(units);
      switch (units) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(
          m,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(
        m,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale$1(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m, d) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m, d).valueOf();
      }
    }
    function utcStartOfDate(y2, m, d) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m, d);
      }
    }
    function startOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function endOf(units) {
      var time, startOfDate;
      units = normalizeUnits(units);
      if (units === void 0 || units === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid(this);
    }
    function parsingFlags() {
      return extend$1({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array2, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array2, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array2[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array2[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date, eras = this._eras || getLocale("en")._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name2, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length; i < l; ++i) {
        name2 = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name2 === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks(era.since).year();
      } else {
        return hooks(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
      week[token2] = hooks.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
          week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array2) {
      array2[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array2) {
      array2[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array2, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array2) {
      array2[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale$1;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set$2;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$1$1(format2, index, field, setter) {
      var locale2 = getLocale(), utc = createUTC().set(setter, index);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index, field) {
      if (isNumber(format2)) {
        index = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index != null) {
        return get$1$1(format2, index, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$1$1(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index != null) {
        return get$1$1(format2, (index + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$1$1(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index) {
      return listMonthsImpl(format2, index, "months");
    }
    function listMonthsShort(format2, index) {
      return listMonthsImpl(format2, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index) {
      return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units = normalizeUnits(units);
      if (units === "month" || units === "quarter" || units === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2$1(units) {
      units = normalizeUnits(units);
      return this.isValid() ? this[units + "s"]() : NaN;
    }
    function makeGetter(name2) {
      return function() {
        return this.isValid() ? this._data[name2] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2$1;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale$1;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array2, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array2, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks.version = "2.30.1";
    setHookCallback(createLocal);
    hooks.fn = proto;
    hooks.min = min$1;
    hooks.max = max$1;
    hooks.now = now$1;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;
    hooks.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    const Modes = Object.freeze({
      ALL: Symbol.for("slds-vue-expression-all"),
      ANY: Symbol.for("slds-vue-expression-any"),
      CUSTOM: Symbol.for("slds-vue-expression-custom")
    });
    const getDefaultLabels = () => ({
      addCondition: "Add Condition",
      customLogic: "Custom Logic",
      takeAction: "Take Action When",
      title: "Conditions",
      modeAll: "All Conditions Are Met",
      modeAny: "Any Condition Is Met",
      modeCustom: "Custom Logic Is Met",
      and: "AND",
      or: "OR",
      customLogicPlaceholder: "e.g. (1 AND 2) OR 3"
    });
    ({
      name: "Expression",
      components: {
        Button,
        TextInput,
        Picklist
      },
      mixins: [decodeHtml],
      props: {
        /**
         * Proxied listeners to the custom logic TextInput component.
         */
        customLogicListeners: {
          type: Object,
          default: () => {
          }
        },
        /**
         * If true, disables built-in accessibility logic when component state changes.
         */
        disableA11y: Boolean,
        /**
         * If true, the logic selection picklist is diabled.
         */
        disableLogic: Boolean,
        /**
         * @param {Object} labels Text labels for internationalization.
         * @param {String} labels.addCondition Label for the Add Condition button. Defaults to "Add Condition".
         * @param {String} labels.customLogic Label for the custom logic input. Default to "Custom Logic".
         * @param {String} labels.takeAction Label for the expression mode dropdown. Defaults to "Take Action When".
         * @param {String} labels.title Label for the expression title. Defaults to "Conditions".
         * @param {String} labels.modeAll Label for the ALL mode. Defaults to "All Conditions Are Met".
         * @param {String} labels.modeAny Label for the ANY mode. Defaults to "Any Condition Is Met".
         * @param {String} labels.modeCustom Label for the CUSTOM mode. Defaults to "Custom Logic Is Met".
         * @param {String} labels.and Label for the gutter label when mode is ALL. Defaults to "AND".
         * @param {String} labels.or Label for the gutter label when mode is ANY. Defaults to "OR".
         */
        labels: {
          type: Object,
          default: () => getDefaultLabels()
        },
        /**
         * @param {Symbol} mode The selected mode. Defaults to Modes.ALL.
         */
        mode: {
          type: Symbol,
          default: Modes.ALL,
          validator(value) {
            const valid = Object.values(Modes).includes(value);
            if (!valid) {
              console.warn("Mode prop must be equal to one of the enumerated values from the exported Expression.Modes module.");
            }
            return valid;
          }
        },
        /**
        * @param {Array} modes The list of available modes. Defaults to ALL, ANY, and CUSTOM. Array members must be
        *                      one or more of the available properties from the exported Modes module.
        */
        modes: {
          type: Array,
          default: () => [
            Modes.ALL,
            Modes.ANY,
            Modes.CUSTOM
          ],
          validator() {
            return true;
          }
        },
        /**
         * If true, gutters are not rendered.
         */
        noGutter: Boolean,
        /**
         * If true, all logic-related artifacts will not be rendered.
         */
        noLogic: Boolean,
        /**
         * If true, no title is rendered.
         */
        noTitle: Boolean,
        /**
        * @param {String} customLogic The custom logic value. If set, it will appear in the custom logic input box
        *                             if the current mode is Modes.CUSTOM.
        */
        customLogic: {
          type: String,
          default: ""
        },
        customLogicErrors: {
          type: Array,
          default: () => []
        }
      },
      data() {
        return {
          registeredConditions: {},
          localMode: this.$props.mode,
          addConditionFlag: false,
          mergedLabels: {
            ...getDefaultLabels(),
            ...this.$props.labels
          }
        };
      },
      computed: {
        modeOptions() {
          return this.$props.modes.map((mode) => ({
            id: mode,
            title: this.modeLabels[mode]
          }));
        },
        modeLabels() {
          return {
            [Modes.ALL]: this.mergedLabels.modeAll,
            [Modes.ANY]: this.mergedLabels.modeAny,
            [Modes.CUSTOM]: this.mergedLabels.modeCustom
          };
        },
        showCustomLogicInput() {
          return this.$props.mode === Modes.CUSTOM;
        },
        numConditions() {
          return Object.keys(this.registeredConditions).length;
        }
      },
      watch: {
        numConditions(newValue, oldValue) {
          this.updateConditions();
          if (this.addConditionFlag && newValue > oldValue) {
            const conditionId = Object.keys(this.registeredConditions)[newValue - 1];
            this.$nextTick(this.registeredConditions[conditionId].focusResource);
          }
        },
        "$props.mode": {
          handler(value) {
            this.localMode = value;
          }
        },
        "$props.noGutter": {
          handler() {
            this.updateConditions();
          }
        },
        localMode() {
          this.updateConditions();
        }
      },
      mounted() {
        this.$el.addEventListener("register-condition", this.onRegisterCondition);
      },
      methods: {
        registerCondition(id2, callbacks) {
          this.registeredConditions[id2] = callbacks;
        },
        unregisterCondition(id2) {
          this.updateFocus(id2);
          delete this.registeredConditions[id2];
        },
        updateFocus(id2) {
          const conditionIds = Object.keys(this.registeredConditions);
          const indexToBeUnregistered = conditionIds.indexOf(id2);
          let registeredCondition;
          if (indexToBeUnregistered === conditionIds.length - 1) {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered - 1]];
          } else {
            registeredCondition = this.registeredConditions[conditionIds[indexToBeUnregistered + 1]];
          }
          if (registeredCondition && registeredCondition.focusResource) {
            registeredCondition.focusResource();
          }
        },
        addCondition() {
          this.addConditionFlag = true;
          this.$emit("add-condition");
        },
        updateConditions() {
          Object.entries(this.registeredConditions).forEach(([, callbacks], index) => {
            callbacks.setGutterLabel(null);
            switch (this.localMode) {
              case Modes.ALL:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.and);
                }
                break;
              case Modes.ANY:
                if (index > 0) {
                  callbacks.setGutterLabel(this.mergedLabels.or);
                }
                break;
              case Modes.CUSTOM:
                callbacks.setGutterLabel(index + 1);
                break;
            }
            callbacks.setGutterVisibility(!this.$props.noGutter);
            callbacks.setIndex(index);
            callbacks.setNumSiblings(this.numConditions - 1);
          });
        }
      }
    });
    const defaultLabels$2 = () => ({
      prompt: "Okay",
      closeTitle: "Close",
      closeAssistiveText: "Close"
    });
    const _sfc_main$o = {
      name: "Modal",
      components: { ButtonIcon },
      mixins: [decodeHtml],
      props: {
        /**
         * Hides modal body.
         */
        bodyless: Boolean,
        /**
         * Detaches modal from flow of DOM.
         */
        detach: {
          type: Boolean,
          default: true
        },
        /**
         * Hides modal header.
         */
        headless: Boolean,
        /**
         * Hides close button.
         */
        hideCloseButton: Boolean,
        /**
         * Hides modal footer.
         */
        footless: Boolean,
        /**
         * Modal label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Styles the modal as a prompt.
         */
        prompt: Boolean,
        /**
         * Specifies the modal's width.
         */
        size: {
          type: String,
          default: "medium",
          validator: (value) => {
            const validSizes = [
              "small",
              "base",
              "medium",
              "large",
              "x-large"
            ];
            if (!value || !validSizes.includes(value)) {
              console.error(`Valid size prop values are ${validSizes.join(", ")}`);
              return false;
            }
            return true;
          }
        },
        /**
         * Text heading at the top of a modal.
         */
        title: {
          type: String,
          required: true
        }
      },
      data() {
        return {
          container: null,
          focusableElements: [],
          modalId: getGUID(),
          triggerElement: null
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().modal || {} : {};
          return {
            ...defaultLabels$2(),
            ...globals,
            ...this.$props.labels
          };
        },
        headerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_alert-texture slds-theme_error");
          if (this.headless)
            classes.push("slds-modal__header_empty");
          return classes;
        },
        footerClasses() {
          const classes = [];
          if (this.prompt)
            classes.push("slds-theme_default");
          if (this.bodyless)
            classes.push("footer-bodyless");
          return classes;
        },
        modalClass() {
          const classes = [];
          if (this.size !== "base") {
            classes.push(`slds-modal_${this.size}`);
          }
          if (this.prompt) {
            classes.push("slds-modal_prompt");
          }
          return classes;
        }
      },
      mounted() {
        this.triggerElement = document.activeElement || document.body;
        if (this.detach) {
          this._detach();
          Array.from(this.container.parentNode.children).filter((node) => node !== this.container && !(node instanceof HTMLScriptElement)).forEach((node) => {
            node.setAttribute("aria-hidden", true);
          });
        }
        this.getFocusableElements();
        this.setFocusOnFirstFocusableItem();
        this.$emit("mounted");
      },
      beforeUnmount() {
        if (this.container) {
          this.container.remove();
          this.container = null;
        }
        this.triggerElement.focus();
      },
      updated() {
        this.getFocusableElements();
      },
      methods: {
        _detach() {
          this.container = document.createElement("div");
          this.container.className = `slds-scope ${this.$el.className}`;
          this.container.appendChild(this.$el);
          document.body.appendChild(this.container);
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.section.querySelectorAll("a, button, input, textarea, select, details")].filter((el) => !el.hasAttribute("disabled") && el.tabIndex !== -1);
        },
        setFocusOnFirstFocusableItem() {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton.$el) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _hoisted_1$m = {
      appear: "",
      name: "fade"
    };
    const _hoisted_2$m = ["role", "tabindex", "aria-labelledby", "aria-describedby"];
    const _hoisted_3$k = { class: "slds-modal__container" };
    const _hoisted_4$j = ["id"];
    const _hoisted_5$i = ["id"];
    const _hoisted_6$h = { key: 1 };
    const _hoisted_7$e = {
      ref: "backdrop",
      key: "backdrop",
      class: "slds-backdrop-custom"
    };
    function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", _hoisted_1$m, [
        createBaseVNode("section", {
          ref: "section",
          key: "section",
          role: $props.prompt ? "alertdialog" : "dialog",
          tabindex: $props.prompt ? "0" : null,
          class: normalizeClass(["slds-modal-custom", $options.modalClass]),
          "aria-labelledby": $props.headless ? null : `modal-heading-${$data.modalId}`,
          "aria-describedby": `modal-content-${$data.modalId}`,
          onKeydown: [
            _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact"]), ["tab"])),
            _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift"]), ["tab"])),
            _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.$emit("close"), ["stop"]), ["esc"]))
          ]
        }, [
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("header", {
              class: normalizeClass([$options.headerClasses, "slds-modal__header"])
            }, [
              !$props.hideCloseButton ? (openBlock(), createBlock(_component_ButtonIcon, {
                key: 0,
                ref: "closeButton",
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                class: "slds-modal__close slds-button_icon-inverse",
                assistiveText: $options.computedLabels.closeAssistiveText,
                title: $options.computedLabels.closeTitle,
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
              }, null, 8, ["assistiveText", "title"])) : createCommentVNode("", true),
              !$props.headless ? (openBlock(), createElementBlock("h2", {
                key: 1,
                id: `modal-heading-${$data.modalId}`,
                class: "slds-text-heading_medium slds-hyphenate"
              }, toDisplayString(_ctx.decodeHtml($props.title)), 9, _hoisted_4$j)) : createCommentVNode("", true),
              !$props.headless ? renderSlot(_ctx.$slots, "tagline", { key: 2 }, void 0, true) : createCommentVNode("", true)
            ], 2),
            !$props.bodyless ? (openBlock(), createElementBlock("div", {
              key: 0,
              id: `modal-content-${$data.modalId}`,
              ref: "content",
              class: "slds-modal__content slds-p-around_medium slds-is-relative",
              onKeydown: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.$emit("submit"), ["enter"]))
            }, [
              renderSlot(_ctx.$slots, "content", {}, () => [
                createTextVNode("default content")
              ], true)
            ], 40, _hoisted_5$i)) : createCommentVNode("", true),
            !$props.footless ? (openBlock(), createElementBlock("footer", {
              key: 1,
              class: normalizeClass(["slds-modal__footer", $options.footerClasses])
            }, [
              renderSlot(_ctx.$slots, "footer", {}, () => [
                $props.prompt ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("close"))
                }, toDisplayString($options.computedLabels.prompt), 1)) : (openBlock(), createElementBlock("span", _hoisted_6$h, " default footer "))
              ], true)
            ], 2)) : createCommentVNode("", true)
          ])
        ], 42, _hoisted_2$m),
        createBaseVNode("div", _hoisted_7$e, null, 512)
      ]);
    }
    const Modal = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$n], ["__scopeId", "data-v-7777abc4"]]);
    const alignmentPositions = {
      top: "top",
      "top left": "top-end",
      "top right": "top-start",
      right: "right",
      "right top": "right-end",
      "right bottom": "right-start",
      bottom: "bottom",
      "bottom left": "bottom-end",
      "bottom right": "bottom-start",
      left: "left",
      "left top": "left-end",
      "left bottom": "left-start"
    };
    const defaultLabels$1 = () => ({
      closeTitle: "Close Dialog",
      closeAssistiveText: "Close Dialog"
    });
    const isAlignmentValid = (alignment) => Object.keys(alignmentPositions).find((value) => value === alignment);
    const _sfc_main$n = {
      name: "Popover",
      description: "Renders a SLDS-themed popover dialog",
      components: {
        ButtonIcon,
        Icon
      },
      directives: {
        "click-outside": clickOutside
      },
      props: {
        /**
         * Alignment of popover in relation to trigger element.
         */
        alignment: {
          type: String,
          default: "top",
          validator(alignment) {
            return isAlignmentValid(alignment);
          }
        },
        /**
         * `aria-label` for popover section element. If no Heading element is present, use this prop and set the value to be a meaningful title of the dialog
         */
        ariaLabel: {
          type: String,
          default: null
        },
        /**
         * Bind the dialog to a specific element.
         */
        bindTo: {
          type: HTMLElement,
          default: null
        },
        /**
         * Bind to coordinates. Overrides bindTo.
         */
        bindToRect: {
          type: Object,
          default: () => {
          },
          validator: (value) => value.x && value.y
        },
        /**
         * Allow mouse click on elements outside popover to close popover.
         */
        closeOnClickOutside: Boolean,
        /**
         * Popover label object.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * The rem set for the nubbin.
         */
        nubbinREM: {
          type: Number,
          default: 1.8
        },
        /**
         * Amount of padding in px from edge of viewport if overflow is detected.
         */
        overflowPadding: {
          type: Number,
          default: 5
        },
        /**
         * Position attribute for the popover.
         */
        position: {
          type: String,
          default: "fixed",
          validator(position) {
            return ["absolute", "fixed"].find((value) => value === position);
          }
        },
        /**
         * Array of elements to allow scrolling without closing popover.
         */
        scrollElementsToIgnore: {
          type: Array,
          default: () => []
        },
        /**
         * Determines the type of the popover.
         */
        theme: {
          type: String,
          default: "base",
          validator: (value) => {
            const validThemes = [
              "base",
              "error",
              "warning"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid theme prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        },
        /**
         * Sets width of popover.
         */
        width: {
          type: String,
          default: "small",
          validator: (value) => {
            const validThemes = [
              "small",
              "medium",
              "large",
              "x-large",
              "full-width"
            ];
            const isValid2 = !value || validThemes.includes(value);
            if (!isValid2)
              console.error(`Valid width prop values are ${validThemes.join(", ")}`);
            return isValid2;
          }
        }
      },
      data() {
        return {
          container: null,
          el: null,
          focusableElements: [],
          triggerElement: null,
          popoverId: getGUID(),
          observer: null,
          popperInstance: () => {
          }
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().popover || {} : {};
          return {
            ...defaultLabels$1(),
            ...globals,
            ...this.$props.labels
          };
        },
        widthClass() {
          return `slds-popover_${this.width}`;
        },
        popoverClass() {
          return this.theme !== "base" ? `slds-popover_${this.theme}` : "";
        },
        showHeader() {
          return this.$slots.header || this.$slots.custom;
        },
        showFooter() {
          return this.$slots.footer;
        },
        clickOutsideOptions() {
          return {
            active: this.closeOnClickOutside,
            handler: this.doHide
          };
        }
      },
      watch: {
        alignment() {
          if (isAlignmentValid(this.$props.alignment)) {
            this.popperInstance.setOptions({
              placement: alignmentPositions[this.$props.alignment]
            });
          }
        },
        width() {
          this.popperInstance.setOptions({
            placement: alignmentPositions[this.$props.alignment]
          });
        },
        "$props.bindTo": {
          handler() {
            if (!this.$props.bindTo)
              return;
            this.popperInstance.state.elements.reference = this.$props.bindTo;
            this.popperInstance.update();
          }
        }
      },
      mounted() {
        this.triggerElement = this.bindTo || document.activeElement || document.body;
        this.getFocusableElements();
        this.popperInstance = createPopper(this.triggerElement, this.$refs.popover, {
          strategy: this.position,
          placement: alignmentPositions[this.alignment],
          modifiers: [
            {
              name: "offset",
              options: {
                offset: ({ placement }) => {
                  if (placement.includes("end")) {
                    return [16, 16];
                  }
                  if (placement.includes("start")) {
                    return [-16, 16];
                  }
                  return [0, 16];
                }
              }
            },
            {
              name: "preventOverflow",
              options: {
                padding: this.$props.overflowPadding
              }
            }
          ]
        });
        this.observer = new MutationObserver(() => this.popperInstance.update());
        this.observer.observe(this.triggerElement, { attributes: true, childList: true, subtree: true });
        if (this.focusableElements.length) {
          if (this.focusableElements.length > 1 && this.focusableElements[0] === this.$refs.closeButton) {
            this.focusableElements[1].focus();
          } else {
            this.focusableElements[0].focus();
          }
        }
      },
      updated() {
        this.getFocusableElements();
      },
      beforeUnmount() {
        this.destroy();
      },
      methods: {
        doHide(e) {
          if (e) {
            if (e.type !== "scroll") {
              if (this.bindTo && this.bindTo.contains(e.target))
                return;
            } else {
              const isTargetInPopover = this.$refs.popover.contains(e.target);
              const targetIsInIgnoreList = this.scrollElementsToIgnore.includes(e.target) || this.scrollElementsToIgnore.some((el) => el && el.contains(e.target));
              if (isTargetInPopover || targetIsInIgnoreList)
                return;
            }
          }
          this.$emit("close", e);
        },
        destroy() {
          if (this.el)
            this.el.remove();
          if (this.container)
            this.container.remove();
          this.el = null;
          this.container = null;
          window.removeEventListener("scroll", this.doHide, true);
          this.triggerElement.focus();
          this.observer.disconnect();
          this.observer = null;
        },
        getFocusableElements() {
          this.focusableElements = [...this.$refs.popover.querySelectorAll('a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])')].filter((el) => !el.hasAttribute("disabled"));
        },
        tab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[this.focusableElements.length - 1] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[0].focus();
          }
        },
        shiftTab(e) {
          if (!this.focusableElements.length)
            return;
          if (this.focusableElements[0] === document.activeElement) {
            e.preventDefault();
            this.focusableElements[this.focusableElements.length - 1].focus();
          }
        }
      }
    };
    const _withScopeId$6 = (n) => (pushScopeId("data-v-ee69ade2"), n = n(), popScopeId(), n);
    const _hoisted_1$l = ["aria-describedby", "aria-labelledby", "aria-label"];
    const _hoisted_2$l = ["id"];
    const _hoisted_3$j = { class: "slds-media" };
    const _hoisted_4$i = { class: "slds-media__body" };
    const _hoisted_5$h = ["id"];
    const _hoisted_6$g = { class: "slds-text-heading_small" };
    const _hoisted_7$d = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_8$c = ["id"];
    const _hoisted_9$a = { class: "slds-media slds-media_center slds-has-flexi-truncate" };
    const _hoisted_10$8 = { class: "slds-media__figure" };
    const _hoisted_11$8 = { class: "slds-media__body" };
    const _hoisted_12$6 = { class: "slds-truncate slds-text-heading_medium" };
    const _hoisted_13$7 = ["id"];
    const _hoisted_14$6 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("p", null, "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.", -1));
    const _hoisted_15$4 = {
      key: 2,
      class: "slds-popover__footer"
    };
    const _hoisted_16$4 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createBaseVNode("div", {
      id: "arrow",
      "data-popper-arrow": ""
    }, null, -1));
    function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Icon = resolveComponent("Icon");
      const _directive_click_outside = resolveDirective("click-outside");
      return withDirectives((openBlock(), createElementBlock("section", {
        ref: "popover",
        role: "dialog",
        "aria-describedby": `dialog-body-${$data.popoverId}`,
        "aria-labelledby": $options.showHeader ? `dialog-heading-${$data.popoverId}` : null,
        "aria-label": $props.ariaLabel,
        tabindex: "-1",
        class: normalizeClass([[$options.popoverClass, $options.widthClass], "slds-popover"]),
        onKeydown: [
          _cache[0] || (_cache[0] = withKeys(withModifiers((...args) => $options.tab && $options.tab(...args), ["exact", "stop"]), ["tab"])),
          _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => $options.shiftTab && $options.shiftTab(...args), ["shift", "stop"]), ["tab"])),
          _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => $options.doHide && $options.doHide(...args), ["stop"]), ["esc"]))
        ]
      }, [
        createVNode(_component_ButtonIcon, {
          ref: "closeButton",
          variant: $props.theme === "error" ? "inverse" : "bare",
          title: $options.computedLabels.closeTitle,
          class: "slds-float_right slds-popover__close",
          iconCategory: "utility",
          size: "small",
          iconName: "close",
          assistiveText: $options.computedLabels.closeAssistiveText,
          onClick: withModifiers($options.doHide, ["stop"])
        }, null, 8, ["variant", "title", "assistiveText", "onClick"]),
        $props.theme === "base" ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: `dialog-body-${$data.popoverId}`,
          class: "slds-popover__body"
        }, [
          createBaseVNode("div", _hoisted_3$j, [
            createBaseVNode("div", _hoisted_4$i, [
              $options.showHeader ? (openBlock(), createElementBlock("header", {
                key: 0,
                id: `dialog-heading-${$data.popoverId}`,
                class: "slds-popover__header"
              }, [
                renderSlot(_ctx.$slots, "custom", {}, () => [
                  createBaseVNode("h2", _hoisted_6$g, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ], true)
              ], 8, _hoisted_5$h)) : createCommentVNode("", true)
            ])
          ]),
          renderSlot(_ctx.$slots, "content", {}, () => [
            _hoisted_7$d
          ], true)
        ], 8, _hoisted_2$l)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          $options.showHeader ? (openBlock(), createElementBlock("header", {
            key: 0,
            id: `dialog-heading-${$data.popoverId}`,
            class: "slds-popover__header"
          }, [
            createBaseVNode("div", _hoisted_9$a, [
              renderSlot(_ctx.$slots, "custom", {}, () => [
                createBaseVNode("div", _hoisted_10$8, [
                  $props.theme !== "base" ? (openBlock(), createBlock(_component_Icon, {
                    key: 0,
                    category: "utility",
                    name: _ctx.$props.theme,
                    variant: "inverse",
                    iconClass: ["slds-icon", "slds-icon_x-small"]
                  }, null, 8, ["name"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", _hoisted_11$8, [
                  createBaseVNode("h2", _hoisted_12$6, [
                    renderSlot(_ctx.$slots, "header", {}, void 0, true)
                  ])
                ])
              ], true)
            ])
          ], 8, _hoisted_8$c)) : createCommentVNode("", true),
          createBaseVNode("div", {
            id: `dialog-body-${$data.popoverId}`,
            class: "slds-popover__body"
          }, [
            renderSlot(_ctx.$slots, "content", {}, () => [
              _hoisted_14$6
            ], true)
          ], 8, _hoisted_13$7)
        ], 64)),
        $options.showFooter ? (openBlock(), createElementBlock("footer", _hoisted_15$4, [
          renderSlot(_ctx.$slots, "footer", {}, void 0, true)
        ])) : createCommentVNode("", true),
        _hoisted_16$4
      ], 42, _hoisted_1$l)), [
        [_directive_click_outside, void 0, $options.clickOutsideOptions]
      ]);
    }
    const Popover = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$m], ["__scopeId", "data-v-ee69ade2"]]);
    const defaultLabels = () => ({
      name: null,
      required: "Required"
    });
    const _sfc_main$m = {
      components: { Tooltip },
      props: {
        /**
         * Disable all radio inputs.
         */
        disabled: Boolean,
        /**
         * A Tooltip component that is displayed next to the label.
         */
        helpText: {
          type: String,
          default: ""
        },
        /**
         * Indicates that the radio group is in an invalid state.
         */
        invalid: Boolean,
        /**
         * Label object for the radio group.
         */
        labels: {
          type: Object,
          default: () => {
          }
        },
        /**
         * Selected value for the radio group.
         */
        modelValue: {
          type: [String, Number],
          default: null
        },
        /**
         * options needs to be an array of objects with label and value (optionally disabled).
         */
        options: {
          type: Array,
          required: true
        },
        /**
         * Read only state for the radio group.
         */
        readonly: Boolean,
        /**
         * Adds an indicator that this field is required.
         */
        required: Boolean
      },
      data() {
        return {
          guid: getGUID()
        };
      },
      computed: {
        computedLabels() {
          const globals = Object.hasOwn(this, "$__getGlobalLabels") ? this.$__getGlobalLabels().radio || {} : {};
          return {
            ...defaultLabels(),
            ...globals,
            ...this.$props.labels
          };
        },
        input: {
          get() {
            return this.$props.modelValue;
          },
          set(val) {
            this.$emit("update:modelValue", val);
          }
        }
      }
    };
    const BaseRadio = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-20f14d8f"]]);
    const _sfc_main$l = {
      name: "RadioButtonGroup",
      extends: BaseRadio,
      mixins: [decodeHtml]
    };
    const _hoisted_1$k = {
      key: 0,
      class: "slds-form-element__legend slds-form-element__label"
    };
    const _hoisted_2$k = ["title"];
    const _hoisted_3$i = { class: "slds-form-element__control" };
    const _hoisted_4$h = {
      key: 0,
      class: "slds-radio_button-group"
    };
    const _hoisted_5$g = ["id", "name", "value", "disabled", "aria-describedby"];
    const _hoisted_6$f = ["for"];
    const _hoisted_7$c = { class: "slds-radio_faux" };
    const _hoisted_8$b = {
      key: 1,
      class: "readonly-radio-label"
    };
    const _hoisted_9$9 = ["id"];
    function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Tooltip = resolveComponent("Tooltip");
      return openBlock(), createElementBlock("fieldset", {
        class: normalizeClass([{ "slds-has-error": _ctx.$props.invalid }, "slds-form-element"])
      }, [
        _ctx.computedLabels.name ? (openBlock(), createElementBlock("legend", _hoisted_1$k, [
          _ctx.$props.required ? (openBlock(), createElementBlock("abbr", {
            key: 0,
            class: "slds-required",
            title: _ctx.computedLabels.required
          }, "*", 8, _hoisted_2$k)) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.decodeHtml(_ctx.computedLabels.name)), 1)
        ])) : createCommentVNode("", true),
        _ctx.$props.helpText ? (openBlock(), createBlock(_component_Tooltip, {
          key: 1,
          alignment: "top right",
          class: "slds-form-element__icon",
          text: _ctx.$props.helpText
        }, null, 8, ["text"])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$i, [
          !_ctx.$props.readonly ? (openBlock(), createElementBlock("div", _hoisted_4$h, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
              return openBlock(), createElementBlock("span", {
                key: index,
                class: "slds-button slds-radio_button"
              }, [
                withDirectives(createBaseVNode("input", {
                  id: _ctx.guid + index,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.input = $event),
                  class: normalizeClass({ "ma-is-selected": _ctx.input === option.value }),
                  name: _ctx.guid,
                  value: option.value,
                  disabled: _ctx.$props.disabled || option.disabled,
                  "aria-describedby": _ctx.$props.invalid ? `error-${_ctx.guid}` : null,
                  type: "radio"
                }, null, 10, _hoisted_5$g), [
                  [vModelRadio, _ctx.input]
                ]),
                createBaseVNode("label", {
                  class: "slds-radio_button__label",
                  for: _ctx.guid + index
                }, [
                  createBaseVNode("span", _hoisted_7$c, toDisplayString(_ctx.decodeHtml(option.label)), 1)
                ], 8, _hoisted_6$f)
              ]);
            }), 128))
          ])) : (openBlock(), createElementBlock("div", _hoisted_8$b, toDisplayString(_ctx.decodeHtml(_ctx.$props.modelValue) || " "), 1))
        ]),
        _ctx.$props.invalid ? (openBlock(), createElementBlock("div", {
          key: 2,
          id: `error-${_ctx.guid}`,
          class: "slds-form-element__help"
        }, [
          renderSlot(_ctx.$slots, "errors")
        ], 8, _hoisted_9$9)) : createCommentVNode("", true)
      ], 2);
    }
    const RadioButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
    const stateMap = /* @__PURE__ */ new Map();
    stateMap.set("info", {
      divClass: "slds-theme_info"
    });
    stateMap.set("success", {
      divClass: "slds-theme_success"
    });
    stateMap.set("warning", {
      divClass: "slds-theme_warning"
    });
    stateMap.set("error", {
      divClass: "slds-theme_error"
    });
    const _sfc_main$k = {
      name: "ToastContainer",
      components: {
        ButtonIcon,
        Icon
      },
      mixins: [decodeHtml],
      props: {
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          stateMap
        };
      }
    };
    const _hoisted_1$j = { class: "slds-assistive-text" };
    const _hoisted_2$j = { class: "slds-notify__content" };
    const _hoisted_3$h = { class: "slds-text-heading_small" };
    const _hoisted_4$g = { key: 0 };
    function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createBlock(TransitionGroup, {
        name: "slide",
        tag: "div"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.toasts, (toast) => {
            return openBlock(), createElementBlock("div", {
              key: toast.$__id,
              class: normalizeClass([$data.stateMap.get(toast.state).divClass, "slds-notify slds-notify_toast"]),
              role: "status"
            }, [
              createBaseVNode("span", _hoisted_1$j, toDisplayString(toast.state), 1),
              createVNode(_component_Icon, {
                category: "utility",
                name: toast.state,
                size: "small",
                variant: "none",
                class: "slds-icon_container slds-m-right_small slds-no-flex slds-align-top"
              }, null, 8, ["name"]),
              createBaseVNode("div", _hoisted_2$j, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  createBaseVNode("h2", _hoisted_3$h, toDisplayString(_ctx.decodeHtml(toast.message)), 1),
                  toast.subMessage ? (openBlock(), createElementBlock("p", _hoisted_4$g, toDisplayString(_ctx.decodeHtml(toast.subMessage)), 1)) : createCommentVNode("", true)
                ], true)
              ]),
              createVNode(_component_ButtonIcon, {
                title: toast.closeLabel,
                iconCategory: "utility",
                iconName: "close",
                iconSize: "large",
                variant: "inverse",
                class: "slds-notify__close",
                assistiveText: toast.closeLabel,
                onClick: ($event) => _ctx.$parent.close(toast.$__id)
              }, null, 8, ["title", "assistiveText", "onClick"])
            ], 2);
          }), 128))
        ]),
        _: 3
      });
    }
    const ToastContainer = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k], ["__scopeId", "data-v-f8233d6c"]]);
    const _sfc_main$j = {
      name: "Toast",
      components: { ToastContainer },
      props: {
        /**
         * Array of toasts. Each toast object should have `position`, `state`, `message` and optionally `submessage` properties.
         */
        toasts: {
          type: Array,
          required: true
        }
      },
      data() {
        return {
          timeoutMap: /* @__PURE__ */ new Map(),
          callbackMap: /* @__PURE__ */ new Map()
        };
      },
      computed: {
        topCenterToasts() {
          return this.toasts.filter((toast) => toast.position === "top-center");
        },
        topRightToasts() {
          return this.toasts.filter((toast) => toast.position === "top-right");
        },
        bottomRightToasts() {
          return this.toasts.filter((toast) => toast.position === "bottom-right");
        }
      },
      watch: {
        toasts: {
          handler(value) {
            value.forEach((toast) => {
              if (!Object.prototype.hasOwnProperty.call(toast, "$__id")) {
                if (!toast.state) {
                  toast.state = "info";
                }
                if (!toast.closeLabel) {
                  toast.closeLabel = "Close";
                }
                if (!toast.position) {
                  toast.position = "top-center";
                }
                const guid = getGUID();
                toast.$__id = guid;
                if (typeof toast.onClose === "function") {
                  this.callbackMap.set(guid, toast.onClose);
                }
                if (toast.duration > 0) {
                  this.timeoutMap.set(guid, setTimeout(this.close.bind(this, guid), toast.duration));
                }
              }
            });
          },
          immediate: true,
          deep: true
        }
      },
      beforeUnmount() {
        this.timeoutMap.forEach((timeoutId) => clearTimeout(timeoutId));
      },
      methods: {
        close(id2) {
          this.$emit("close", id2);
          const indexToRemove = this.toasts.findIndex((toast) => toast.$__id === id2);
          const newToasts = this.toasts.splice(indexToRemove, 1);
          this.$emit("input", newToasts);
          this.$emit("update:toasts", newToasts);
          if (this.timeoutMap.has(id2)) {
            clearTimeout(this.timeoutMap.get(id2));
            this.timeoutMap.delete(id2);
          }
          if (this.callbackMap.has(id2)) {
            this.callbackMap.get(id2)();
          }
        }
      }
    };
    function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ToastContainer = resolveComponent("ToastContainer");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_ToastContainer, {
          toasts: $options.topCenterToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_vertical-reverse"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.bottomRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_bottom-right slds-grid_vertical-align-end"
        }, null, 8, ["toasts"]),
        createVNode(_component_ToastContainer, {
          toasts: $options.topRightToasts,
          class: "slds-notify_container slds-is-fixed slds-grid slds-grid_vertical slds-grid_vertical-align-center notify_top-right slds-grid_vertical-reversee"
        }, null, 8, ["toasts"])
      ]);
    }
    const Toasts = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j], ["__scopeId", "data-v-339e5872"]]);
    const _sfc_main$i = {
      name: "NoAccess",
      props: {
        type: {
          type: String,
          default: "plan"
        }
      },
      computed: {
        text() {
          return this.type === "segment" ? "To access this segment, contact its owner." : "To access this sales plan, contact its owner or your Salesforce admin.";
        }
      }
    };
    const _hoisted_1$i = {
      class: "slds-grid slds-grid_vertical-align-center slds-grid_align-center",
      style: { "height": "100%", "background": "#fff" }
    };
    const _hoisted_2$i = { class: "slds-illustration slds-illustration_small" };
    const _hoisted_3$g = /* @__PURE__ */ createStaticVNode('<svg class="slds-illustration__svg" viewBox="0 0 454 212" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="translate(-70.000000, -95.000000)"><g><g transform="translate(124.500000, 222.000000)"><g fill="#FFFFFF"><path vector-effect="non-scaling-stroke" d="M18.9209988,1.95433401 L33.259296,51.443436 C33.5666778,52.5043744 32.9557995,53.613617 31.8948612,53.9209988 C31.7139843,53.9734036 31.5266126,54 31.3382972,54 L2.6617028,54 C1.5571333,54 0.661702805,53.1045695 0.661702805,52 C0.661702805,51.8116846 0.688299176,51.6243129 0.74070397,51.443436 L15.0790012,1.95433401 C15.386383,0.893395645 16.4956256,0.282517358 17.556564,0.589899164 C18.2152102,0.780726338 18.7301717,1.29568777 18.9209988,1.95433401 Z"></path></g><g class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><polygon vector-effect="non-scaling-stroke" stroke-linejoin="round" points="17 0.323943662 34 54 -1.81721305e-12 54"></polygon><path vector-effect="non-scaling-stroke" d="M17,4.6953125 C17,43.0456294 17,62.6471919 17,63.5 C17,62.6471919 17,43.0456294 17,4.6953125 Z"></path><path vector-effect="non-scaling-stroke" d="M17,29.3239437 C22.3333333,35.7851611 25,39.1184944 25,39.3239437 C25,39.1184944 22.3333333,35.7851611 17,29.3239437 Z" stroke-linejoin="round" transform="translate(21.000000, 34.323944) scale(-1, 1) translate(-21.000000, -34.323944) "></path></g></g><g transform="translate(145.000000, 194.000000)"><g transform="translate(1.000000, 0.000000)" fill="#FFFFFF"><path vector-effect="non-scaling-stroke" d="M25.6478873,0 L50.879042,84.4273253 C51.1953215,85.4856452 50.5937789,86.5999782 49.535459,86.9162577 C49.3496374,86.9717906 49.1567264,87 48.9627843,87 L2.33299037,87 C1.22842087,87 0.332990367,86.1045695 0.332990367,85 C0.332990367,84.8060578 0.361199757,84.6131469 0.416732643,84.4273253 L25.6478873,0 Z"></path></g><g class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><polygon vector-effect="non-scaling-stroke" stroke-linejoin="round" points="26.5 0 52.5 87 0.5 87"></polygon><path vector-effect="non-scaling-stroke" d="M26.5,2.58642578 C26.5,61.0261034 26.5,90.9972948 26.5,92.5 C26.5,90.9972948 26.5,61.0261034 26.5,2.58642578 Z"></path><path vector-effect="non-scaling-stroke" d="M15.6478873,42 C22.314554,49.078692 25.6478873,52.7453587 25.6478873,53 C25.6478873,52.7453587 22.314554,49.078692 15.6478873,42 Z" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M27.6478873,68 C36.9812207,57.078692 41.6478873,51.7453587 41.6478873,52 C41.6478873,51.7453587 36.9812207,57.078692 27.6478873,68 Z" stroke-linejoin="round"></path></g></g><g transform="translate(404.500000, 245.000000) scale(-1, 1) translate(-404.500000, -245.000000) translate(348.000000, 226.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-linejoin="round" stroke-width="3"><g><polyline vector-effect="non-scaling-stroke" points="0 38 47.5 0 80.5 26"></polyline><polyline vector-effect="non-scaling-stroke" points="71 17 80.5 9 113 36"></polyline></g></g><g transform="translate(72.000000, 262.500000)"><path vector-effect="non-scaling-stroke" d="M153.962142,26.4644491 C151.225735,20.0143094 144.944776,15.5029106 137.633892,15.5029106 C135.619663,15.5029106 133.683612,15.8453541 131.878328,16.4764392 C128.451481,11.1704266 122.567406,7.66985447 115.883789,7.66985447 C109.491267,7.66985447 103.830159,10.8721423 100.350851,15.7935668 C98.9589956,14.968161 97.3423157,14.4956341 95.6177606,14.4956341 C94.1083143,14.4956341 92.6815102,14.8576334 91.4157672,15.5014039 C87.9975328,6.58722215 79.5098304,0.275259875 69.5804557,0.275259875 C60.4632836,0.275259875 52.5615782,5.59684366 48.6837305,13.3681823 C46.3912034,12.266973 43.8314865,11.6515593 41.1312741,11.6515593 C32.4373504,11.6515593 25.1998844,18.0312998 23.6476214,26.4644491 L153.962142,26.4644491 Z" class="slds-illustration__fill-secondary"></path><path vector-effect="non-scaling-stroke" d="M13,25 L143,25" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path><path vector-effect="non-scaling-stroke" d="M0,25 L450,25" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path></g><g transform="translate(344.000000, 247.000000)"><g transform="translate(0.293436, 0.054545)"><path vector-effect="non-scaling-stroke" d="M165.428708,41.9454545 L0.0995432562,41.9454545 C0.0336614956,41.2089487 0,40.4630069 0,39.7090909 C0,26.2132599 10.7866531,15.2727273 24.0926641,15.2727273 C27.7492016,15.2727273 31.215485,16.0989227 34.3199502,17.5772977 C39.5712028,7.14424616 50.271428,0 62.6175975,0 C76.0636257,0 87.5573893,8.47383452 92.1862485,20.441159 C93.9002755,19.5768947 95.8324059,19.0909091 97.8764479,19.0909091 C100.211783,19.0909091 102.401037,19.7252784 104.285841,20.8333889 C108.997403,14.2263569 116.663488,9.92727273 125.320028,9.92727273 C138.043441,9.92727273 148.627152,19.2146805 150.834755,31.4671412 C151.487388,31.3631046 152.156394,31.3090909 152.837838,31.3090909 C159.117096,31.3090909 164.340238,35.8953699 165.428708,41.9454545 Z" class="slds-illustration__fill-secondary"></path><path vector-effect="non-scaling-stroke" d="M32.7065637,40.4454545 L173.706564,40.4454545" class="slds-illustration__stroke-secondary" stroke-width="3" stroke-linecap="round"></path></g></g><g transform="translate(105.000000, 203.000000)"><g transform="translate(106.000000, 0.000000)" fill="#FFFFFF"><polygon vector-effect="non-scaling-stroke" points="121.5 48.5 158.5 48.5 158.5 34.5 47.5 34.5 47.5 48.5 93.5 48.5 93.5 69.5 121.5 69.5 121.5 48.5"></polygon><path vector-effect="non-scaling-stroke" d="M33.9882812,0.21875 C36.5611979,0.21875 70.6126302,0.21875 136.142578,0.21875 L152.384766,11.1132813 C155.083088,16.811292 155.656656,19.677503 154.105469,19.7119141 C152.554281,19.7463252 116.293865,17.6717809 45.3242187,13.4882812 C35.1940104,4.64192708 31.4153646,0.21875 33.9882812,0.21875 Z"></path><path vector-effect="non-scaling-stroke" d="M32.6708984,2.02246094 L21.5554199,0.374195518 L17.6036034,0.374195518 L5.77148437,7.90429688 C3.09089817,12.6737672 3.09089817,15.2284547 5.77148437,15.5683594 C8.45207058,15.9082641 16.1278518,14.3268839 28.7988281,10.8242188 L42.9921875,7.90429688 L41.0699892,5.68448183 L32.6708984,2.02246094 Z"></path><rect x="0" y="34" width="48" height="14"></rect></g><g transform="translate(106.000000, 5.000000)" class="slds-illustration__fill-secondary"><polygon vector-effect="non-scaling-stroke" points="93.3109375 43.4566406 93.3109375 64.6722656 120.925 64.6722656 121.823047 44.1324219 158.5 43.4566406 158.5 97.5 48.5 97.5 48.5 43.6933594"></polygon><path vector-effect="non-scaling-stroke" d="M132.670898,7.66300119e-19 C125.172201,-2.55433373e-19 94.1907552,-2.55433373e-19 39.7265625,7.66300119e-19 L31.8183594,12.5058594 L29.7050781,28.2714844 L157.78125,28.2714844 L157.78125,15.4775391 C148.539714,5.15917969 140.169596,1.78803361e-18 132.670898,7.66300119e-19 Z"></path><path vector-effect="non-scaling-stroke" d="M37.8266602,0 C34.4632704,0 29.4181858,0 22.6914062,0 C16.1624349,0 9.53808594,3.83528646 2.81835938,11.5058594 L0.705078125,30.2714844 L48.4101562,30.2714844 L48.4101562,14.4775391 L48.1789909,12.3275853 C43.283405,4.10919509 39.832628,0 37.8266602,0 Z"></path><rect x="0.5" y="43.5" width="48" height="54"></rect></g><g><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="154.5" y="34.5" width="110" height="68"></rect><polygon vector-effect="non-scaling-stroke" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" points="264.5 48.5 264.5 34.5 154.5 34.5 154.5 48.5 199.5 48.5 199.5 69.5 227.5 69.5 227.5 48.5"></polygon><path vector-effect="non-scaling-stroke" d="M130.5,0.5 L234.5,0.5 C251.068542,0.5 264.5,13.9314575 264.5,30.5 L264.5,34.5 L106.5,34.5 L106.5,24.5 C106.5,11.245166 117.245166,0.5 130.5,0.5 Z" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M130.5,0.5 L130.5,0.5 C143.754834,0.5 154.5,11.245166 154.5,24.5 L154.5,34.5 L106.5,34.5 L106.5,24.5 C106.5,11.245166 117.245166,0.5 130.5,0.5 Z" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="106.5" y="48.5" width="48" height="54"></rect><rect class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" x="106.5" y="34.5" width="48" height="14"></rect><path vector-effect="non-scaling-stroke" d="M219,52 C219,54.765 216.765,57 214,57 C211.235,57 209,54.765 209,52 C209,49.235 211.235,47 214,47 C216.765,47 219,49.235 219,52 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M214,55 L214,60" class="slds-illustration__stroke-primary" stroke-width="4" stroke-linecap="round"></path><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="164" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="164" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="255" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="255" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="145" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="145" cy="93" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="116" cy="58" r="3"></circle><circle vector-effect="non-scaling-stroke" class="slds-illustration__fill-primary" cx="116" cy="93" r="3"></circle><path vector-effect="non-scaling-stroke" d="M289.928751,82.2971422 L298,102.518658 L280,102.518658 L288.071249,82.2971422 C288.275982,81.784207 288.857768,81.5343604 289.370703,81.7390942 C289.625359,81.8407378 289.827108,82.0424867 289.928751,82.2971422 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M300.428751,89.8132712 L305.5,102.518658 L293.5,102.518658 L298.571249,89.8132712 C298.775982,89.300336 299.357768,89.0504894 299.870703,89.2552232 C300.125359,89.3568668 300.327108,89.5586158 300.428751,89.8132712 Z" class="slds-illustration__fill-primary"></path><path vector-effect="non-scaling-stroke" d="M93.4287513,82.2971422 L101.5,102.518658 L83.5,102.518658 L91.5712487,82.2971422 C91.7759825,81.784207 92.3577681,81.5343604 92.8707033,81.7390942 C93.1253588,81.8407378 93.3271077,82.0424867 93.4287513,82.2971422 Z" class="slds-illustration__fill-primary" transform="translate(92.500000, 92.517446) scale(-1, 1) translate(-92.500000, -92.517446) "></path><path vector-effect="non-scaling-stroke" d="M76.9287513,89.8132712 L82,102.518658 L70,102.518658 L75.0712487,89.8132712 C75.2759825,89.300336 75.8577681,89.0504894 76.3707033,89.2552232 C76.6253588,89.3568668 76.8271077,89.5586158 76.9287513,89.8132712 Z" class="slds-illustration__fill-primary" transform="translate(76.000000, 96.275510) scale(-1, 1) translate(-76.000000, -96.275510) "></path><path vector-effect="non-scaling-stroke" d="M360,102.5 L372,102.5" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path><path vector-effect="non-scaling-stroke" d="M0,102.5 L350,102.5" class="slds-illustration__stroke-primary" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></path></g></g><g transform="translate(150.000000, 96.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g><g transform="translate(271.000000, 135.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><g><path vector-effect="non-scaling-stroke" d="M44,17.5 L63,17.5 C62.2789714,12.0723971 64.081543,7.53186978 68.4077148,3.87841797 C73.3754883,-0.195556641 79.2734375,0.717773438 82.440918,2.12353516 C85.6083984,3.52929687 87.9606934,5.46069336 89.5913086,9.10524041 C90.2822266,10.6397351 90.7517904,11.9379883 91,13"></path><path vector-effect="non-scaling-stroke" d="M83,20.5 C84.0558268,16.8461914 86.2227376,14.4572754 89.5007324,13.333252 C94.4177246,11.6472168 99.0800781,13.8925781 100.942383,16.1518555 C102.804687,18.4111328 103.39502,20.2260742 103.746582,22.1201172 C103.980957,23.3828125 104.06543,24.8427734 104,26.5 C108.141764,26.3313802 110.918945,27.1647135 112.331543,29 C114.040039,31.1936035 114.215332,33.817627 113.593018,35.75 C112.970703,37.682373 110.894531,40.5 107,40.5 L28,40.5"></path><path vector-effect="non-scaling-stroke" d="M18,27.5 L83.0004985,27.5"></path><path vector-effect="non-scaling-stroke" d="M0,27.5 L8,27.5"></path></g></g><g transform="translate(402.000000, 164.000000)" class="slds-illustration__stroke-secondary" stroke-linecap="round" stroke-width="3"><g transform="translate(31.713442, 25.088326) rotate(-15.000000) translate(-31.713442, -25.088326) translate(4.713442, 6.588326)"><path vector-effect="non-scaling-stroke" d="M31.0360707,3.43528591 C31.0360707,3.43528591 40.5802283,0.671893051 42.6488424,10.6908663" transform="translate(36.842457, 6.888440) rotate(41.000000) translate(-36.842457, -6.888440) "></path><path vector-effect="non-scaling-stroke" d="M40.4282002,10.1797377 C40.4282002,10.1797377 49.9723578,7.4163448 52.0409719,17.435318" transform="translate(46.234586, 13.632892) scale(-1, 1) rotate(-41.000000) translate(-46.234586, -13.632892) "></path><path vector-effect="non-scaling-stroke" d="M0.730284783,29.5865514 C0.730284783,29.5865514 10.2744424,26.8231586 12.3430565,36.8421318"></path><path vector-effect="non-scaling-stroke" d="M12.7302848,29.5865514 C12.7302848,29.5865514 22.2744424,26.8231586 24.3430565,36.8421318" transform="translate(18.536671, 33.039705) scale(-1, 1) translate(-18.536671, -33.039705) "></path></g></g></g></g></g></svg>', 1);
    const _hoisted_4$f = { class: "slds-text-longform" };
    const _hoisted_5$f = /* @__PURE__ */ createBaseVNode("h3", { class: "slds-text-heading_medium" }, "No access yet", -1);
    const _hoisted_6$e = { class: "slds-text-body_regular" };
    function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("div", _hoisted_1$i, [
        createBaseVNode("div", _hoisted_2$i, [
          _hoisted_3$g,
          createBaseVNode("div", _hoisted_4$f, [
            _hoisted_5$f,
            createBaseVNode("p", _hoisted_6$e, toDisplayString($options.text), 1)
          ])
        ])
      ]);
    }
    const NoAccess = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
    const _sfc_main$h = {
      name: "BuilderHeader",
      components: {
        Icon,
        Spinner
      },
      props: ["plan"],
      data() {
        return {
          segmentBuilderStatus: "Ready"
        };
      },
      computed: {
        hasDataSource() {
          return SPM.Components.Root.plan._hasDataSource;
        }
      },
      mounted() {
        SPM.Components.BuilderHeader = this;
      },
      methods: {
        openConfigureModal() {
          SPM.Components.OrgView.configureModalConfig = {};
        }
      }
    };
    const _withScopeId$5 = (n) => (pushScopeId("data-v-ed4d5bc2"), n = n(), popScopeId(), n);
    const _hoisted_1$h = {
      class: "slds-builder-header_container",
      style: { "position": "relative" }
    };
    const _hoisted_2$h = { class: "slds-builder-header" };
    const _hoisted_3$f = { class: "slds-builder-header__item" };
    const _hoisted_4$e = ["href"];
    const _hoisted_5$e = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-builder-header__item" }, [
      /* @__PURE__ */ createBaseVNode("div", { class: "slds-builder-header__item-label slds-media slds-grid slds-grid--vertical slds-grid--align-center" }, [
        /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-color_inverse logoLight" }, "Segment Builder")
      ])
    ], -1));
    const _hoisted_6$d = { class: "slds-builder-header__item" };
    const _hoisted_7$b = { class: "slds-builder-header__item-label slds-media slds-grid slds-grid--vertical slds-grid--align-center" };
    const _hoisted_8$a = ["title"];
    const _hoisted_9$8 = { class: "slds-builder-header__item slds-builder-header__utilities" };
    const _hoisted_10$7 = { class: "slds-builder-header__utilities-item" };
    const _hoisted_11$7 = { class: "slds-builder-header__item-label slds-grid slds-grid_vertical-align-center" };
    const _hoisted_12$5 = {
      key: 0,
      class: "slds-media__figure"
    };
    const _hoisted_13$6 = {
      key: 1,
      class: "slds-is-relative",
      style: { "width": "2.5rem" }
    };
    const _hoisted_14$5 = { class: "slds-builder-header__item-label slds-p-left_none" };
    const _hoisted_15$3 = {
      class: "slds-truncate",
      title: "Page Type"
    };
    const _hoisted_16$3 = {
      key: 0,
      class: "slds-builder-header__utilities-item"
    };
    const _hoisted_17$3 = { class: "slds-media__figure slds-m-right_none" };
    function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Spinner = resolveComponent("Spinner");
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createBaseVNode("header", _hoisted_2$h, [
          createBaseVNode("div", _hoisted_3$f, [
            createBaseVNode("a", {
              id: "back-button",
              href: `/${$props.plan.Id}`,
              class: "slds-builder-header__item-action",
              title: "Back"
            }, [
              createVNode(_component_Icon, {
                category: "utility",
                name: "back",
                class: "slds-current-color",
                size: "x-small",
                assistiveText: "Back"
              })
            ], 8, _hoisted_4$e)
          ]),
          _hoisted_5$e,
          createBaseVNode("div", _hoisted_6$d, [
            createBaseVNode("div", _hoisted_7$b, [
              createBaseVNode("div", {
                id: "plan-name",
                class: "slds-text-color_inverse logoLight",
                title: $props.plan.Name
              }, toDisplayString($props.plan.Name), 9, _hoisted_8$a)
            ])
          ]),
          createBaseVNode("div", _hoisted_9$8, [
            createBaseVNode("div", _hoisted_10$7, [
              createBaseVNode("div", _hoisted_11$7, [
                $data.segmentBuilderStatus === "Ready" ? (openBlock(), createElementBlock("div", _hoisted_12$5, [
                  createVNode(_component_Icon, {
                    category: "utility",
                    name: "check",
                    class: "slds-current-color",
                    size: "x-small"
                  })
                ])) : (openBlock(), createElementBlock("div", _hoisted_13$6, [
                  createVNode(_component_Spinner, {
                    withoutContainer: "",
                    size: "x-small"
                  })
                ])),
                createBaseVNode("h2", _hoisted_14$5, [
                  createBaseVNode("span", _hoisted_15$3, toDisplayString($data.segmentBuilderStatus), 1)
                ])
              ])
            ]),
            $options.hasDataSource ? (openBlock(), createElementBlock("div", _hoisted_16$3, [
              createBaseVNode("a", {
                href: "#",
                class: "slds-builder-header__item-action slds-media slds-media_center",
                onClick: _cache[0] || (_cache[0] = (...args) => $options.openConfigureModal && $options.openConfigureModal(...args))
              }, [
                createBaseVNode("span", _hoisted_17$3, [
                  createVNode(_component_Icon, {
                    category: "utility",
                    name: "settings",
                    size: "x-small",
                    class: "slds-current-color",
                    title: "Open Settings Modal",
                    assistiveText: "Open Settings Modal"
                  })
                ])
              ])
            ])) : createCommentVNode("", true)
          ])
        ])
      ]);
    }
    const BuilderHeader = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h], ["__scopeId", "data-v-ed4d5bc2"]]);
    var xhtml = "http://www.w3.org/1999/xhtml";
    const namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    function namespace(name2) {
      var prefix = name2 += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns")
        name2 = name2.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name2 } : name2;
    }
    function creatorInherit(name2) {
      return function() {
        var document2 = this.ownerDocument, uri = this.namespaceURI;
        return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
      };
    }
    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }
    function creator(name2) {
      var fullname = namespace(name2);
      return (fullname.local ? creatorFixed : creatorInherit)(fullname);
    }
    function none() {
    }
    function selector(selector2) {
      return selector2 == null ? none : function() {
        return this.querySelector(selector2);
      };
    }
    function selection_select(select2) {
      if (typeof select2 !== "function")
        select2 = selector(select2);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function array(x2) {
      return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
    }
    function empty() {
      return [];
    }
    function selectorAll(selector2) {
      return selector2 == null ? empty : function() {
        return this.querySelectorAll(selector2);
      };
    }
    function arrayAll(select2) {
      return function() {
        return array(select2.apply(this, arguments));
      };
    }
    function selection_selectAll(select2) {
      if (typeof select2 === "function")
        select2 = arrayAll(select2);
      else
        select2 = selectorAll(select2);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select2.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }
      return new Selection$1(subgroups, parents);
    }
    function matcher(selector2) {
      return function() {
        return this.matches(selector2);
      };
    }
    function childMatcher(selector2) {
      return function(node) {
        return node.matches(selector2);
      };
    }
    var find = Array.prototype.find;
    function childFind(match) {
      return function() {
        return find.call(this.children, match);
      };
    }
    function childFirst() {
      return this.firstElementChild;
    }
    function selection_selectChild(match) {
      return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
    }
    var filter = Array.prototype.filter;
    function children() {
      return Array.from(this.children);
    }
    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }
    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }
    function selection_filter(match) {
      if (typeof match !== "function")
        match = matcher(match);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Selection$1(subgroups, this._parents);
    }
    function sparse(update) {
      return new Array(update.length);
    }
    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum2) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum2;
    }
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    function constant$3(x2) {
      return function() {
        return x2;
      };
    }
    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0, node, groupLength = group.length, dataLength = data.length;
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
      var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
          exit[i] = node;
        }
      }
    }
    function datum(node) {
      return node.__data__;
    }
    function selection_data(value, key) {
      if (!arguments.length)
        return Array.from(this, datum);
      var bind2 = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
      if (typeof value !== "function")
        value = constant$3(value);
      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
        bind2(parent, group, enterGroup, updateGroup, exitGroup, data, key);
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1)
              i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength)
              ;
            previous._next = next || null;
          }
        }
      }
      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }
    function arraylike(data) {
      return typeof data === "object" && "length" in data ? data : Array.from(data);
    }
    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }
    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter)
          enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update)
          update = update.selection();
      }
      if (onexit == null)
        exit.remove();
      else
        onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }
    function selection_merge(context) {
      var selection2 = context.selection ? context.selection() : context;
      for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge2[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Selection$1(merges, this._parents);
    }
    function selection_order() {
      for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4)
              next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }
      return this;
    }
    function selection_sort(compare) {
      if (!compare)
        compare = ascending;
      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }
      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }
      return new Selection$1(sortgroups, this._parents).order();
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }
    function selection_nodes() {
      return Array.from(this);
    }
    function selection_node() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node)
            return node;
        }
      }
      return null;
    }
    function selection_size() {
      let size2 = 0;
      for (const node of this)
        ++size2;
      return size2;
    }
    function selection_empty() {
      return !this.node();
    }
    function selection_each(callback) {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i])
            callback.call(node, node.__data__, i, group);
        }
      }
      return this;
    }
    function attrRemove$1(name2) {
      return function() {
        this.removeAttribute(name2);
      };
    }
    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant$1(name2, value) {
      return function() {
        this.setAttribute(name2, value);
      };
    }
    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }
    function attrFunction$1(name2, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttribute(name2);
        else
          this.setAttribute(name2, v);
      };
    }
    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.removeAttributeNS(fullname.space, fullname.local);
        else
          this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }
    function selection_attr(name2, value) {
      var fullname = namespace(name2);
      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
      }
      return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
    }
    function defaultView(node) {
      return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
    }
    function styleRemove$1(name2) {
      return function() {
        this.style.removeProperty(name2);
      };
    }
    function styleConstant$1(name2, value, priority) {
      return function() {
        this.style.setProperty(name2, value, priority);
      };
    }
    function styleFunction$1(name2, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          this.style.removeProperty(name2);
        else
          this.style.setProperty(name2, v, priority);
      };
    }
    function selection_style(name2, value, priority) {
      return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
    }
    function styleValue(node, name2) {
      return node.style.getPropertyValue(name2) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name2);
    }
    function propertyRemove(name2) {
      return function() {
        delete this[name2];
      };
    }
    function propertyConstant(name2, value) {
      return function() {
        this[name2] = value;
      };
    }
    function propertyFunction(name2, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null)
          delete this[name2];
        else
          this[name2] = v;
      };
    }
    function selection_property(name2, value) {
      return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
    }
    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }
    function classList(node) {
      return node.classList || new ClassList(node);
    }
    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
      add: function(name2) {
        var i = this._names.indexOf(name2);
        if (i < 0) {
          this._names.push(name2);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name2) {
        var i = this._names.indexOf(name2);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name2) {
        return this._names.indexOf(name2) >= 0;
      }
    };
    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n)
        list.add(names[i]);
    }
    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n)
        list.remove(names[i]);
    }
    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }
    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }
    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }
    function selection_classed(name2, value) {
      var names = classArray(name2 + "");
      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n)
          if (!list.contains(names[i]))
            return false;
        return true;
      }
      return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
    }
    function textRemove() {
      this.textContent = "";
    }
    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }
    function selection_text(value) {
      return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
    }
    function htmlRemove() {
      this.innerHTML = "";
    }
    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }
    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }
    function selection_html(value) {
      return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
    }
    function raise() {
      if (this.nextSibling)
        this.parentNode.appendChild(this);
    }
    function selection_raise() {
      return this.each(raise);
    }
    function lower() {
      if (this.previousSibling)
        this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower() {
      return this.each(lower);
    }
    function selection_append(name2) {
      var create2 = typeof name2 === "function" ? name2 : creator(name2);
      return this.select(function() {
        return this.appendChild(create2.apply(this, arguments));
      });
    }
    function constantNull() {
      return null;
    }
    function selection_insert(name2, before) {
      var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
      });
    }
    function remove() {
      var parent = this.parentNode;
      if (parent)
        parent.removeChild(this);
    }
    function selection_remove() {
      return this.each(remove);
    }
    function selection_cloneShallow() {
      var clone2 = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
    }
    function selection_cloneDeep() {
      var clone2 = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
    }
    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }
    function selection_datum(value) {
      return arguments.length ? this.property("__data__", value) : this.node().__data__;
    }
    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }
    function parseTypenames$1(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name2 = "", i = t.indexOf(".");
        if (i >= 0)
          name2 = t.slice(i + 1), t = t.slice(0, i);
        return { type: t, name: name2 };
      });
    }
    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on)
          return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i)
          on.length = i;
        else
          delete this.__on;
      };
    }
    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on)
          for (var j = 0, m = on.length; j < m; ++j) {
            if ((o = on[j]).type === typename.type && o.name === typename.name) {
              this.removeEventListener(o.type, o.listener, o.options);
              this.addEventListener(o.type, o.listener = listener, o.options = options);
              o.value = value;
              return;
            }
          }
        this.addEventListener(typename.type, listener, options);
        o = { type: typename.type, name: typename.name, value, listener, options };
        if (!on)
          this.__on = [o];
        else
          on.push(o);
      };
    }
    function selection_on(typename, value, options) {
      var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;
      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on)
          for (var j = 0, m = on.length, o; j < m; ++j) {
            for (i = 0, o = on[j]; i < n; ++i) {
              if ((t = typenames[i]).type === o.type && t.name === o.name) {
                return o.value;
              }
            }
          }
        return;
      }
      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i)
        this.each(on(typenames[i], value, options));
      return this;
    }
    function dispatchEvent(node, type, params) {
      var window2 = defaultView(node), event = window2.CustomEvent;
      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window2.document.createEvent("Event");
        if (params)
          event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else
          event.initEvent(type, false, false);
      }
      node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }
    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }
    function selection_dispatch(type, params) {
      return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
    }
    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i])
            yield node;
        }
      }
    }
    var root = [null];
    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }
    function selection() {
      return new Selection$1([[document.documentElement]], root);
    }
    function selection_selection() {
      return this;
    }
    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };
    function select(selector2) {
      return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
    }
    function sourceEvent(event) {
      let sourceEvent2;
      while (sourceEvent2 = event.sourceEvent)
        event = sourceEvent2;
      return event;
    }
    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === void 0)
        node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }
    function cumsum(values, valueof) {
      var sum2 = 0, index = 0;
      return Float64Array.from(values, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index++, values) || 0);
    }
    function max(values, valueof) {
      let max2;
      if (valueof === void 0) {
        for (const value of values) {
          if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
            max2 = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
            max2 = value;
          }
        }
      }
      return max2;
    }
    function min(values, valueof) {
      let min2;
      if (valueof === void 0) {
        for (const value of values) {
          if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
            min2 = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
            min2 = value;
          }
        }
      }
      return min2;
    }
    function sum(values, valueof) {
      let sum2 = 0;
      if (valueof === void 0) {
        for (let value of values) {
          if (value = +value) {
            sum2 += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum2 += value;
          }
        }
      }
      return sum2;
    }
    function count$1(node) {
      var sum2 = 0, children2 = node.children, i = children2 && children2.length;
      if (!i)
        sum2 = 1;
      else
        while (--i >= 0)
          sum2 += children2[i].value;
      node.value = sum2;
    }
    function node_count$1() {
      return this.eachAfter(count$1);
    }
    function node_each$1(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }
    function node_eachBefore$1(callback, that) {
      var node = this, nodes = [node], children2, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children2 = node.children) {
          for (i = children2.length - 1; i >= 0; --i) {
            nodes.push(children2[i]);
          }
        }
      }
      return this;
    }
    function node_eachAfter$1(callback, that) {
      var node = this, nodes = [node], next = [], children2, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children2 = node.children) {
          for (i = 0, n = children2.length; i < n; ++i) {
            nodes.push(children2[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }
    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }
    function node_sum$1(value) {
      return this.eachAfter(function(node) {
        var sum2 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
        while (--i >= 0)
          sum2 += children2[i].value;
        node.value = sum2;
      });
    }
    function node_sort$1(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }
    function node_path$1(end2) {
      var start2 = this, ancestor = leastCommonAncestor$1(start2, end2), nodes = [start2];
      while (start2 !== ancestor) {
        start2 = start2.parent;
        nodes.push(start2);
      }
      var k = nodes.length;
      while (end2 !== ancestor) {
        nodes.splice(k, 0, end2);
        end2 = end2.parent;
      }
      return nodes;
    }
    function leastCommonAncestor$1(a, b) {
      if (a === b)
        return a;
      var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }
    function node_ancestors$1() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }
    function node_descendants$1() {
      return Array.from(this);
    }
    function node_leaves$1() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }
    function node_links$1() {
      var root2 = this, links = [];
      root2.each(function(node) {
        if (node !== root2) {
          links.push({ source: node.parent, target: node });
        }
      });
      return links;
    }
    function* node_iterator() {
      var node = this, current, next = [node], children2, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children2 = node.children) {
            for (i = 0, n = children2.length; i < n; ++i) {
              next.push(children2[i]);
            }
          }
        }
      } while (next.length);
    }
    function hierarchy$1(data, children2) {
      if (data instanceof Map) {
        data = [void 0, data];
        if (children2 === void 0)
          children2 = mapChildren;
      } else if (children2 === void 0) {
        children2 = objectChildren;
      }
      var root2 = new Node$1(data), node, nodes = [root2], child, childs, i, n;
      while (node = nodes.pop()) {
        if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$1(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }
      return root2.eachBefore(computeHeight$1);
    }
    function node_copy$1() {
      return hierarchy$1(this).eachBefore(copyData$1);
    }
    function objectChildren(d) {
      return d.children;
    }
    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }
    function copyData$1(node) {
      if (node.data.value !== void 0)
        node.value = node.data.value;
      node.data = node.data.data;
    }
    function computeHeight$1(node) {
      var height = 0;
      do
        node.height = height;
      while ((node = node.parent) && node.height < ++height);
    }
    function Node$1(data) {
      this.data = data;
      this.depth = this.height = 0;
      this.parent = null;
    }
    Node$1.prototype = hierarchy$1.prototype = {
      constructor: Node$1,
      count: node_count$1,
      each: node_each$1,
      eachAfter: node_eachAfter$1,
      eachBefore: node_eachBefore$1,
      find: node_find,
      sum: node_sum$1,
      sort: node_sort$1,
      path: node_path$1,
      ancestors: node_ancestors$1,
      descendants: node_descendants$1,
      leaves: node_leaves$1,
      links: node_links$1,
      copy: node_copy$1,
      [Symbol.iterator]: node_iterator
    };
    function optional(f) {
      return f == null ? null : required(f);
    }
    function required(f) {
      if (typeof f !== "function")
        throw new Error();
      return f;
    }
    var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
    function defaultId(d) {
      return d.id;
    }
    function defaultParentId(d) {
      return d.parentId;
    }
    function stratify() {
      var id2 = defaultId, parentId = defaultParentId, path;
      function stratify2(data) {
        var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node, nodeId2, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
        if (path != null) {
          const I = nodes.map((d2, i2) => normalize(path(d2, i2, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i2 of P) {
            if (!S.has(i2)) {
              S.add(i2);
              I.push(i2);
              P.push(parentof(i2));
              nodes.push(imputed);
            }
          }
          currentId = (_, i2) => I[i2];
          currentParentId = (_, i2) => P[i2];
        }
        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$1(d);
          if ((nodeId2 = currentId(d, i, data)) != null && (nodeId2 += "")) {
            nodeKey = node.id = nodeId2;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId2 = currentParentId(d, i, data)) != null && (nodeId2 += "")) {
            node.parent = nodeId2;
          }
        }
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId2 = node.parent) {
            parent = nodeByKey.get(nodeId2);
            if (!parent)
              throw new Error("missing: " + nodeId2);
            if (parent === ambiguous)
              throw new Error("ambiguous: " + nodeId2);
            if (parent.children)
              parent.children.push(node);
            else
              parent.children = [node];
            node.parent = parent;
          } else {
            if (root2)
              throw new Error("multiple roots");
            root2 = node;
          }
        }
        if (!root2)
          throw new Error("no root");
        if (path != null) {
          while (root2.data === imputed && root2.children.length === 1) {
            root2 = root2.children[0], --n;
          }
          for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
            node = nodes[i2];
            if (node.data !== imputed)
              break;
            node.data = null;
          }
        }
        root2.parent = preroot;
        root2.eachBefore(function(node2) {
          node2.depth = node2.parent.depth + 1;
          --n;
        }).eachBefore(computeHeight$1);
        root2.parent = null;
        if (n > 0)
          throw new Error("cycle");
        return root2;
      }
      stratify2.id = function(x2) {
        return arguments.length ? (id2 = optional(x2), stratify2) : id2;
      };
      stratify2.parentId = function(x2) {
        return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
      };
      stratify2.path = function(x2) {
        return arguments.length ? (path = optional(x2), stratify2) : path;
      };
      return stratify2;
    }
    function normalize(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2))
        path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }
    function parentof(path) {
      let i = path.length;
      if (i < 2)
        return "";
      while (--i > 1)
        if (slash(path, i))
          break;
      return path.slice(0, i);
    }
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\")
          ++k;
        if ((k & 1) === 0)
          return true;
      }
      return false;
    }
    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }
    function nextLeft(v) {
      var children2 = v.children;
      return children2 ? children2[0] : v.t;
    }
    function nextRight(v) {
      var children2 = v.children;
      return children2 ? children2[children2.length - 1] : v.t;
    }
    function moveSubtree$1(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }
    function executeShifts(v) {
      var shift = 0, change = 0, children2 = v.children, i = children2.length, w;
      while (--i >= 0) {
        w = children2[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null;
      this.a = this;
      this.z = 0;
      this.m = 0;
      this.c = 0;
      this.s = 0;
      this.t = null;
      this.i = i;
    }
    TreeNode.prototype = Object.create(Node$1.prototype);
    function treeRoot(root2) {
      var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n;
      while (node = nodes.pop()) {
        if (children2 = node._.children) {
          node.children = new Array(n = children2.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
            child.parent = node;
          }
        }
      }
      (tree2.parent = new TreeNode(null, 0)).children = [tree2];
      return tree2;
    }
    function tree() {
      var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
      function tree2(root2) {
        var t = treeRoot(root2);
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);
        if (nodeSize)
          root2.eachBefore(sizeNode);
        else {
          var left2 = root2, right2 = root2, bottom2 = root2;
          root2.eachBefore(function(node) {
            if (node.x < left2.x)
              left2 = node;
            if (node.x > right2.x)
              right2 = node;
            if (node.depth > bottom2.depth)
              bottom2 = node;
          });
          var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s - left2.x, kx = dx / (right2.x + s + tx), ky = dy / (bottom2.depth || 1);
          root2.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }
        return root2;
      }
      function firstWalk(v) {
        var children2 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
        if (children2) {
          executeShifts(v);
          var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree$1(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }
      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }
      tree2.separation = function(x2) {
        return arguments.length ? (separation = x2, tree2) : separation;
      };
      tree2.size = function(x2) {
        return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
      };
      tree2.nodeSize = function(x2) {
        return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
      };
      return tree2;
    }
    var noop = { value: () => {
    } };
    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
          throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }
    function Dispatch(_) {
      this._ = _;
    }
    function parseTypenames(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name2 = "", i = t.indexOf(".");
        if (i >= 0)
          name2 = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t))
          throw new Error("unknown type: " + t);
        return { type: t, name: name2 };
      });
    }
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i < n)
            if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name)))
              return t;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type)
            _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null)
            for (t in _)
              _[t] = set$1(_[t], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _)
          copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i = 0, n, t; i < n; ++i)
            args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type))
          throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
          t[i].value.apply(that, args);
      }
    };
    function get$1(type, name2) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name2) {
          return c.value;
        }
      }
    }
    function set$1(type, name2, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name2) {
          type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null)
        type.push({ name: name2, value: callback });
      return type;
    }
    const nonpassivecapture = { capture: true, passive: false };
    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    function dragDisable(view) {
      var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
      if ("onselectstart" in root2) {
        selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
      } else {
        root2.__noselect = root2.style.MozUserSelect;
        root2.style.MozUserSelect = "none";
      }
    }
    function yesdrag(view, noclick) {
      var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection2.on("click.drag", noevent$1, nonpassivecapture);
        setTimeout(function() {
          selection2.on("click.drag", null);
        }, 0);
      }
      if ("onselectstart" in root2) {
        selection2.on("selectstart.drag", null);
      } else {
        root2.style.MozUserSelect = root2.__noselect;
        delete root2.__noselect;
      }
    }
    function define(constructor, factory, prototype2) {
      constructor.prototype = factory.prototype = prototype2;
      prototype2.constructor = constructor;
    }
    function extend(parent, definition) {
      var prototype2 = Object.create(parent.prototype);
      for (var key in definition)
        prototype2[key] = definition[key];
      return prototype2;
    }
    function Color() {
    }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
    var named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    function color_formatHex() {
      return this.rgb().formatHex();
    }
    function color_formatHex8() {
      return this.rgb().formatHex8();
    }
    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
      return this.rgb().formatRgb();
    }
    function color(format2) {
      var m, l;
      format2 = (format2 + "").trim().toLowerCase();
      return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
    }
    function rgbn(n) {
      return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function rgba(r, g, b, a) {
      if (a <= 0)
        r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }
    function rgbConvert(o) {
      if (!(o instanceof Color))
        o = color(o);
      if (!o)
        return new Rgb();
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }
    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }
    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }
    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }
    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h2, s, l, a) {
      if (a <= 0)
        h2 = s = l = NaN;
      else if (l <= 0 || l >= 1)
        h2 = s = NaN;
      else if (s <= 0)
        h2 = NaN;
      return new Hsl(h2, s, l, a);
    }
    function hslConvert(o) {
      if (o instanceof Hsl)
        return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color))
        o = color(o);
      if (!o)
        return new Hsl();
      if (o instanceof Hsl)
        return o;
      o = o.rgb();
      var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h2 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
      if (s) {
        if (r === max2)
          h2 = (g - b) / s + (g < b) * 6;
        else if (g === max2)
          h2 = (b - r) / s + 2;
        else
          h2 = (r - g) / s + 4;
        s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
        h2 *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h2;
      }
      return new Hsl(h2, s, l, o.opacity);
    }
    function hsl(h2, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl(h2, s, l, opacity) {
      this.h = +h2;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }
    define(Hsl, hsl, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
          hsl2rgb(h2, m1, m2),
          hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));
    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }
    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }
    function hsl2rgb(h2, m1, m2) {
      return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
    }
    const constant$2 = (x2) => () => x2;
    function linear(a, d) {
      return function(t) {
        return a + t * d;
      };
    }
    function exponential(a, b, y2) {
      return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
        return Math.pow(a + t * b, y2);
      };
    }
    function gamma(y2) {
      return (y2 = +y2) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential(a, b, y2) : constant$2(isNaN(a) ? b : a);
      };
    }
    function nogamma(a, b) {
      var d = b - a;
      return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
    }
    const interpolateRgb = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb$1(start2, end2) {
        var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
        return function(t) {
          start2.r = r(t);
          start2.g = g(t);
          start2.b = b(t);
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    }(1);
    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }
    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero(b) {
      return function() {
        return b;
      };
    }
    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }
    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
      a = a + "", b = b + "";
      while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) {
          bs = b.slice(bi, bs);
          if (s[i])
            s[i] += bs;
          else
            s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) {
          if (s[i])
            s[i] += bm;
          else
            s[++i] = bm;
        } else {
          s[++i] = null;
          q.push({ i, x: interpolateNumber(am, bm) });
        }
        bi = reB.lastIndex;
      }
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
        for (var i2 = 0, o; i2 < b; ++i2)
          s[(o = q[i2]).i] = o.x(t);
        return s.join("");
      });
    }
    var degrees = 180 / Math.PI;
    var identity$1 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b))
        a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d)
        c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d))
        c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c)
        a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees,
        skewX: Math.atan(skewX) * degrees,
        scaleX,
        scaleY
      };
    }
    var svgNode;
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }
    function parseSvg(value) {
      if (value == null)
        return identity$1;
      if (!svgNode)
        svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate()))
        return identity$1;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }
    function interpolateTransform(parse, pxComma, pxParen, degParen) {
      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }
      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }
      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180)
            b += 360;
          else if (b - a > 180)
            a += 360;
          q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }
      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }
      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }
      return function(a, b) {
        var s = [], q = [];
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null;
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n)
            s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
    var epsilon2 = 1e-12;
    function cosh(x2) {
      return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
    }
    function sinh(x2) {
      return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
    }
    function tanh(x2) {
      return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
    }
    const interpolateZoom = function zoomRho(rho, rho2, rho4) {
      function zoom2(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon2) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        } else {
          var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }
        i.duration = S * 1e3 * rho / Math.SQRT2;
        return i;
      }
      zoom2.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };
      return zoom2;
    }(Math.SQRT2, 2, 4);
    var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
      setTimeout(f, 17);
    };
    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
      clockNow = 0;
    }
    function Timer() {
      this._call = this._time = this._next = null;
    }
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    function timer(callback, delay, time) {
      var t = new Timer();
      t.restart(callback, delay, time);
      return t;
    }
    function timerFlush() {
      now();
      ++frame;
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0)
          t._call.call(void 0, e);
        t = t._next;
      }
      --frame;
    }
    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }
    function poke() {
      var now2 = clock.now(), delay = now2 - clockLast;
      if (delay > pokeDelay)
        clockSkew -= delay, clockLast = now2;
    }
    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time)
            time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }
    function sleep(time) {
      if (frame)
        return;
      if (timeout$1)
        timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow;
      if (delay > 24) {
        if (time < Infinity)
          timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval)
          interval = clearInterval(interval);
      } else {
        if (!interval)
          clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }
    function timeout(callback, delay, time) {
      var t = new Timer();
      delay = delay == null ? 0 : +delay;
      t.restart((elapsed) => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }
    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule(node, name2, id2, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules)
        node.__transition = {};
      else if (id2 in schedules)
        return;
      create(node, id2, {
        name: name2,
        index,
        // For context during callback.
        group,
        // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }
    function init(node, id2) {
      var schedule2 = get(node, id2);
      if (schedule2.state > CREATED)
        throw new Error("too late; already scheduled");
      return schedule2;
    }
    function set(node, id2) {
      var schedule2 = get(node, id2);
      if (schedule2.state > STARTED)
        throw new Error("too late; already running");
      return schedule2;
    }
    function get(node, id2) {
      var schedule2 = node.__transition;
      if (!schedule2 || !(schedule2 = schedule2[id2]))
        throw new Error("transition not found");
      return schedule2;
    }
    function create(node, id2, self2) {
      var schedules = node.__transition, tween;
      schedules[id2] = self2;
      self2.timer = timer(schedule2, 0, self2.time);
      function schedule2(elapsed) {
        self2.state = SCHEDULED;
        self2.timer.restart(start2, self2.delay, self2.time);
        if (self2.delay <= elapsed)
          start2(elapsed - self2.delay);
      }
      function start2(elapsed) {
        var i, j, n, o;
        if (self2.state !== SCHEDULED)
          return stop();
        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self2.name)
            continue;
          if (o.state === STARTED)
            return timeout(start2);
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          } else if (+i < id2) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }
        timeout(function() {
          if (self2.state === STARTED) {
            self2.state = RUNNING;
            self2.timer.restart(tick, self2.delay, self2.time);
            tick(elapsed);
          }
        });
        self2.state = STARTING;
        self2.on.call("start", node, node.__data__, self2.index, self2.group);
        if (self2.state !== STARTING)
          return;
        self2.state = STARTED;
        tween = new Array(n = self2.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self2.tween[i].value.call(node, node.__data__, self2.index, self2.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }
      function tick(elapsed) {
        var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
        while (++i < n) {
          tween[i].call(node, t);
        }
        if (self2.state === ENDING) {
          self2.on.call("end", node, node.__data__, self2.index, self2.group);
          stop();
        }
      }
      function stop() {
        self2.state = ENDED;
        self2.timer.stop();
        delete schedules[id2];
        for (var i in schedules)
          return;
        delete node.__transition;
      }
    }
    function interrupt(node, name2) {
      var schedules = node.__transition, schedule2, active, empty2 = true, i;
      if (!schedules)
        return;
      name2 = name2 == null ? null : name2 + "";
      for (i in schedules) {
        if ((schedule2 = schedules[i]).name !== name2) {
          empty2 = false;
          continue;
        }
        active = schedule2.state > STARTING && schedule2.state < ENDING;
        schedule2.state = ENDED;
        schedule2.timer.stop();
        schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
        delete schedules[i];
      }
      if (empty2)
        delete node.__transition;
    }
    function selection_interrupt(name2) {
      return this.each(function() {
        interrupt(this, name2);
      });
    }
    function tweenRemove(id2, name2) {
      var tween0, tween1;
      return function() {
        var schedule2 = set(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name2) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }
        schedule2.tween = tween1;
      };
    }
    function tweenFunction(id2, name2, value) {
      var tween0, tween1;
      if (typeof value !== "function")
        throw new Error();
      return function() {
        var schedule2 = set(this, id2), tween = schedule2.tween;
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name2) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n)
            tween1.push(t);
        }
        schedule2.tween = tween1;
      };
    }
    function transition_tween(name2, value) {
      var id2 = this._id;
      name2 += "";
      if (arguments.length < 2) {
        var tween = get(this.node(), id2).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name2) {
            return t.value;
          }
        }
        return null;
      }
      return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
    }
    function tweenValue(transition, name2, value) {
      var id2 = transition._id;
      transition.each(function() {
        var schedule2 = set(this, id2);
        (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
      });
      return function(node) {
        return get(node, id2).value[name2];
      };
    }
    function interpolate(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
    }
    function attrRemove(name2) {
      return function() {
        this.removeAttribute(name2);
      };
    }
    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }
    function attrConstant(name2, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttribute(name2);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrConstantNS(fullname, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function attrFunction(name2, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttribute(name2);
        string0 = this.getAttribute(name2);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function attrFunctionNS(fullname, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null)
          return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function transition_attr(name2, value) {
      var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
      return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }
    function attrInterpolate(name2, i) {
      return function(t) {
        this.setAttribute(name2, i.call(this, t));
      };
    }
    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }
    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function attrTween(name2, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t0 = (i0 = i) && attrInterpolate(name2, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_attrTween(name2, value) {
      var key = "attr." + name2;
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      var fullname = namespace(name2);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }
    function delayFunction(id2, value) {
      return function() {
        init(this, id2).delay = +value.apply(this, arguments);
      };
    }
    function delayConstant(id2, value) {
      return value = +value, function() {
        init(this, id2).delay = value;
      };
    }
    function transition_delay(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
    }
    function durationFunction(id2, value) {
      return function() {
        set(this, id2).duration = +value.apply(this, arguments);
      };
    }
    function durationConstant(id2, value) {
      return value = +value, function() {
        set(this, id2).duration = value;
      };
    }
    function transition_duration(value) {
      var id2 = this._id;
      return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
    }
    function easeConstant(id2, value) {
      if (typeof value !== "function")
        throw new Error();
      return function() {
        set(this, id2).ease = value;
      };
    }
    function transition_ease(value) {
      var id2 = this._id;
      return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
    }
    function easeVarying(id2, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function")
          throw new Error();
        set(this, id2).ease = v;
      };
    }
    function transition_easeVarying(value) {
      if (typeof value !== "function")
        throw new Error();
      return this.each(easeVarying(this._id, value));
    }
    function transition_filter(match) {
      if (typeof match !== "function")
        match = matcher(match);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }
      return new Transition(subgroups, this._parents, this._name, this._id);
    }
    function transition_merge(transition) {
      if (transition._id !== this._id)
        throw new Error();
      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge2[i] = node;
          }
        }
      }
      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }
      return new Transition(merges, this._parents, this._name, this._id);
    }
    function start(name2) {
      return (name2 + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0)
          t = t.slice(0, i);
        return !t || t === "start";
      });
    }
    function onFunction(id2, name2, listener) {
      var on0, on1, sit = start(name2) ? init : set;
      return function() {
        var schedule2 = sit(this, id2), on = schedule2.on;
        if (on !== on0)
          (on1 = (on0 = on).copy()).on(name2, listener);
        schedule2.on = on1;
      };
    }
    function transition_on(name2, listener) {
      var id2 = this._id;
      return arguments.length < 2 ? get(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
    }
    function removeFunction(id2) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition)
          if (+i !== id2)
            return;
        if (parent)
          parent.removeChild(this);
      };
    }
    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }
    function transition_select(select2) {
      var name2 = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selector(select2);
      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
            if ("__data__" in node)
              subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name2, id2, i, subgroup, get(node, id2));
          }
        }
      }
      return new Transition(subgroups, this._parents, name2, id2);
    }
    function transition_selectAll(select2) {
      var name2 = this._name, id2 = this._id;
      if (typeof select2 !== "function")
        select2 = selectorAll(select2);
      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children2 = select2.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
              if (child = children2[k]) {
                schedule(child, name2, id2, k, children2, inherit2);
              }
            }
            subgroups.push(children2);
            parents.push(node);
          }
        }
      }
      return new Transition(subgroups, parents, name2, id2);
    }
    var Selection = selection.prototype.constructor;
    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }
    function styleNull(name2, interpolate2) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
      };
    }
    function styleRemove(name2) {
      return function() {
        this.style.removeProperty(name2);
      };
    }
    function styleConstant(name2, interpolate2, value1) {
      var string00, string1 = value1 + "", interpolate0;
      return function() {
        var string0 = styleValue(this, name2);
        return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
      };
    }
    function styleFunction(name2, interpolate2, value) {
      var string00, string10, interpolate0;
      return function() {
        var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
        if (value1 == null)
          string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
        return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
      };
    }
    function styleMaybeRemove(id2, name2) {
      var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
      return function() {
        var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
        if (on !== on0 || listener0 !== listener)
          (on1 = (on0 = on).copy()).on(event, listener0 = listener);
        schedule2.on = on1;
      };
    }
    function transition_style(name2, value, priority) {
      var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate;
      return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value), priority).on("end.style." + name2, null);
    }
    function styleInterpolate(name2, i, priority) {
      return function(t) {
        this.style.setProperty(name2, i.call(this, t), priority);
      };
    }
    function styleTween(name2, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t = (i0 = i) && styleInterpolate(name2, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }
    function transition_styleTween(name2, value, priority) {
      var key = "style." + (name2 += "");
      if (arguments.length < 2)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
    }
    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }
    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }
    function transition_text(value) {
      return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
    }
    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }
    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0)
          t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }
    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1)
        return (key = this.tween(key)) && key._value;
      if (value == null)
        return this.tween(key, null);
      if (typeof value !== "function")
        throw new Error();
      return this.tween(key, textTween(value));
    }
    function transition_transition() {
      var name2 = this._name, id0 = this._id, id1 = newId();
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit2 = get(node, id0);
            schedule(node, name2, id1, i, group, {
              time: inherit2.time + inherit2.delay + inherit2.duration,
              delay: 0,
              duration: inherit2.duration,
              ease: inherit2.ease
            });
          }
        }
      }
      return new Transition(groups, this._parents, name2, id1);
    }
    function transition_end() {
      var on0, on1, that = this, id2 = that._id, size2 = that.size();
      return new Promise(function(resolve2, reject) {
        var cancel = { value: reject }, end2 = { value: function() {
          if (--size2 === 0)
            resolve2();
        } };
        that.each(function() {
          var schedule2 = set(this, id2), on = schedule2.on;
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end2);
          }
          schedule2.on = on1;
        });
        if (size2 === 0)
          resolve2();
      });
    }
    var id = 0;
    function Transition(groups, parents, name2, id2) {
      this._groups = groups;
      this._parents = parents;
      this._name = name2;
      this._id = id2;
    }
    function newId() {
      return ++id;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }
    var defaultTiming = {
      time: null,
      // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    function inherit(node, id2) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id2])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id2} not found`);
        }
      }
      return timing;
    }
    function selection_transition(name2) {
      var id2, timing;
      if (name2 instanceof Transition) {
        id2 = name2._id, name2 = name2._name;
      } else {
        id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
      }
      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name2, id2, i, group, timing || inherit(node, id2));
          }
        }
      }
      return new Transition(groups, this._parents, name2, id2);
    }
    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;
    const constant$1 = (x2) => () => x2;
    function ZoomEvent(type, {
      sourceEvent: sourceEvent2,
      target,
      transform,
      dispatch: dispatch2
    }) {
      Object.defineProperties(this, {
        type: { value: type, enumerable: true, configurable: true },
        sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
        target: { value: target, enumerable: true, configurable: true },
        transform: { value: transform, enumerable: true, configurable: true },
        _: { value: dispatch2 }
      });
    }
    function Transform(k, x2, y2) {
      this.k = k;
      this.x = x2;
      this.y = y2;
    }
    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x2, y2) {
        return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x2) {
        return x2 * this.k + this.x;
      },
      applyY: function(y2) {
        return y2 * this.k + this.y;
      },
      invert: function(location2) {
        return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
      },
      invertX: function(x2) {
        return (x2 - this.x) / this.k;
      },
      invertY: function(y2) {
        return (y2 - this.y) / this.k;
      },
      rescaleX: function(x2) {
        return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
      },
      rescaleY: function(y2) {
        return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };
    var identity = new Transform(1, 0, 0);
    Transform.prototype;
    function nopropagation(event) {
      event.stopImmediatePropagation();
    }
    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === "wheel") && !event.button;
    }
    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }
    function defaultTransform() {
      return this.__zoom || identity;
    }
    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
    }
    function defaultTouchable() {
      return navigator.maxTouchPoints || "ontouchstart" in this;
    }
    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }
    function zoom() {
      var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
      function zoom2(selection2) {
        selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }
      zoom2.transform = function(collection, transform, point, event) {
        var selection2 = collection.selection ? collection.selection() : collection;
        selection2.property("__zoom", defaultTransform);
        if (collection !== selection2) {
          schedule2(collection, transform, point, event);
        } else {
          selection2.interrupt().each(function() {
            gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
          });
        }
      };
      zoom2.scaleBy = function(selection2, k, p2, event) {
        zoom2.scaleTo(selection2, function() {
          var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p2, event);
      };
      zoom2.scaleTo = function(selection2, k, p2, event) {
        zoom2.transform(selection2, function() {
          var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p2 == null ? centroid(e) : typeof p2 === "function" ? p2.apply(this, arguments) : p2, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p2, event);
      };
      zoom2.translateBy = function(selection2, x2, y2, event) {
        zoom2.transform(selection2, function() {
          return constrain(this.__zoom.translate(
            typeof x2 === "function" ? x2.apply(this, arguments) : x2,
            typeof y2 === "function" ? y2.apply(this, arguments) : y2
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };
      zoom2.translateTo = function(selection2, x2, y2, p2, event) {
        zoom2.transform(selection2, function() {
          var e = extent.apply(this, arguments), t = this.__zoom, p0 = p2 == null ? centroid(e) : typeof p2 === "function" ? p2.apply(this, arguments) : p2;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
            typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
          ), e, translateExtent);
        }, p2, event);
      };
      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }
      function translate(transform, p0, p1) {
        var x2 = p0[0] - p1[0] * transform.k, y2 = p0[1] - p1[1] * transform.k;
        return x2 === transform.x && y2 === transform.y ? transform : new Transform(transform.k, x2, y2);
      }
      function centroid(extent2) {
        return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
      }
      function schedule2(transition, transform, point, event) {
        transition.on("start.zoom", function() {
          gesture(this, arguments).event(event).start();
        }).on("interrupt.zoom end.zoom", function() {
          gesture(this, arguments).event(event).end();
        }).tween("zoom", function() {
          var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p2 = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate2(a.invert(p2).concat(w / a.k), b.invert(p2).concat(w / b.k));
          return function(t) {
            if (t === 1)
              t = b;
            else {
              var l = i(t), k = w / l[2];
              t = new Transform(k, p2[0] - l[0] * k, p2[1] - l[1] * k);
            }
            g.zoom(null, t);
          };
        });
      }
      function gesture(that, args, clean) {
        return !clean && that.__zooming || new Gesture(that, args);
      }
      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }
      Gesture.prototype = {
        event: function(event) {
          if (event)
            this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse")
            this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch")
            this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch")
            this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom2,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };
      function wheeled(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p2 = pointer(event);
        if (g.wheel) {
          if (g.mouse[0][0] !== p2[0] || g.mouse[0][1] !== p2[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p2);
          }
          clearTimeout(g.wheel);
        } else if (t.k === k)
          return;
        else {
          g.mouse = [p2, t.invert(p2)];
          interrupt(this);
          g.start();
        }
        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }
      function mousedowned(event, ...args) {
        if (touchending || !filter2.apply(this, arguments))
          return;
        var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p2 = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p2, this.__zoom.invert(p2)];
        interrupt(this);
        g.start();
        function mousemoved(event2) {
          noevent(event2);
          if (!g.moved) {
            var dx = event2.clientX - x0, dy = event2.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }
        function mouseupped(event2) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event2.view, g.moved);
          noevent(event2);
          g.event(event2).end();
        }
      }
      function dblclicked(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
        noevent(event);
        if (duration > 0)
          select(this).transition().duration(duration).call(schedule2, t1, p0, event);
        else
          select(this).call(zoom2.transform, t1, p0, event);
      }
      function touchstarted(event, ...args) {
        if (!filter2.apply(this, arguments))
          return;
        var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p2;
        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p2 = pointer(t, this);
          p2 = [p2, this.__zoom.invert(p2), t.identifier];
          if (!g.touch0)
            g.touch0 = p2, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p2[2])
            g.touch1 = p2, g.taps = 0;
        }
        if (touchstarting)
          touchstarting = clearTimeout(touchstarting);
        if (started) {
          if (g.taps < 2)
            touchfirst = p2[0], touchstarting = setTimeout(function() {
              touchstarting = null;
            }, touchDelay);
          interrupt(this);
          g.start();
        }
      }
      function touchmoved(event, ...args) {
        if (!this.__zooming)
          return;
        var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p2, l;
        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p2 = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier)
            g.touch0[0] = p2;
          else if (g.touch1 && g.touch1[2] === t.identifier)
            g.touch1[0] = p2;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p2 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        } else if (g.touch0)
          p2 = g.touch0[0], l = g.touch0[1];
        else
          return;
        g.zoom("touch", constrain(translate(t, p2, l), g.extent, translateExtent));
      }
      function touchended(event, ...args) {
        if (!this.__zooming)
          return;
        var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
        nopropagation(event);
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier)
            delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier)
            delete g.touch1;
        }
        if (g.touch1 && !g.touch0)
          g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0)
          g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p2 = select(this).on("dblclick.zoom");
              if (p2)
                p2.apply(this, arguments);
            }
          }
        }
      }
      zoom2.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$1(+_), zoom2) : wheelDelta;
      };
      zoom2.filter = function(_) {
        return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$1(!!_), zoom2) : filter2;
      };
      zoom2.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), zoom2) : touchable;
      };
      zoom2.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
      };
      zoom2.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
      };
      zoom2.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };
      zoom2.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom2) : constrain;
      };
      zoom2.duration = function(_) {
        return arguments.length ? (duration = +_, zoom2) : duration;
      };
      zoom2.interpolate = function(_) {
        return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
      };
      zoom2.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom2 : value;
      };
      zoom2.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
      };
      zoom2.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
      };
      return zoom2;
    }
    function count(node) {
      var sum2 = 0, children2 = node.children, i = children2 && children2.length;
      if (!i)
        sum2 = 1;
      else
        while (--i >= 0)
          sum2 += children2[i].value;
      node.value = sum2;
    }
    function node_count() {
      return this.eachAfter(count);
    }
    function node_each(callback) {
      var node = this, current, next = [node], children2, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          callback(node), children2 = node.children;
          if (children2)
            for (i = 0, n = children2.length; i < n; ++i) {
              next.push(children2[i]);
            }
        }
      } while (next.length);
      return this;
    }
    function node_eachBefore(callback) {
      var node = this, nodes = [node], children2, i;
      while (node = nodes.pop()) {
        callback(node), children2 = node.children;
        if (children2)
          for (i = children2.length - 1; i >= 0; --i) {
            nodes.push(children2[i]);
          }
      }
      return this;
    }
    function node_eachAfter(callback) {
      var node = this, nodes = [node], next = [], children2, i, n;
      while (node = nodes.pop()) {
        next.push(node), children2 = node.children;
        if (children2)
          for (i = 0, n = children2.length; i < n; ++i) {
            nodes.push(children2[i]);
          }
      }
      while (node = next.pop()) {
        callback(node);
      }
      return this;
    }
    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum2 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
        while (--i >= 0)
          sum2 += children2[i].value;
        node.value = sum2;
      });
    }
    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }
    function node_path(end2) {
      var start2 = this, ancestor = leastCommonAncestor(start2, end2), nodes = [start2];
      while (start2 !== ancestor) {
        start2 = start2.parent;
        nodes.push(start2);
      }
      var k = nodes.length;
      while (end2 !== ancestor) {
        nodes.splice(k, 0, end2);
        end2 = end2.parent;
      }
      return nodes;
    }
    function leastCommonAncestor(a, b) {
      if (a === b)
        return a;
      var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }
    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }
    function node_descendants() {
      var nodes = [];
      this.each(function(node) {
        nodes.push(node);
      });
      return nodes;
    }
    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }
    function node_links() {
      var root2 = this, links = [];
      root2.each(function(node) {
        if (node !== root2) {
          links.push({ source: node.parent, target: node });
        }
      });
      return links;
    }
    function hierarchy(data, children2) {
      var root2 = new Node(data), valued = +data.value && (root2.value = data.value), node, nodes = [root2], child, childs, i, n;
      if (children2 == null)
        children2 = defaultChildren;
      while (node = nodes.pop()) {
        if (valued)
          node.value = +node.data.value;
        if ((childs = children2(node.data)) && (n = childs.length)) {
          node.children = new Array(n);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new Node(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }
      return root2.eachBefore(computeHeight);
    }
    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }
    function defaultChildren(d) {
      return d.children;
    }
    function copyData(node) {
      node.data = node.data.data;
    }
    function computeHeight(node) {
      var height = 0;
      do
        node.height = height;
      while ((node = node.parent) && node.height < ++height);
    }
    function Node(data) {
      this.data = data;
      this.depth = this.height = 0;
      this.parent = null;
    }
    Node.prototype = hierarchy.prototype = {
      constructor: Node,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy
    };
    const name = "d3-flextree";
    const version$1 = "2.1.2";
    const main = "build/d3-flextree.js";
    const module$1 = "index";
    const author = {
      name: "Chris Maloney",
      url: "http://chrismaloney.org"
    };
    const description = "Flexible tree layout algorithm that allows for variable node sizes.";
    const keywords = [
      "d3",
      "d3-module",
      "layout",
      "tree",
      "hierarchy",
      "d3-hierarchy",
      "plugin",
      "d3-plugin",
      "infovis",
      "visualization",
      "2d"
    ];
    const homepage = "https://github.com/klortho/d3-flextree";
    const license = "WTFPL";
    const repository = {
      type: "git",
      url: "https://github.com/klortho/d3-flextree.git"
    };
    const scripts = {
      clean: "rm -rf build demo test",
      "build:demo": "rollup -c --environment BUILD:demo",
      "build:dev": "rollup -c --environment BUILD:dev",
      "build:prod": "rollup -c --environment BUILD:prod",
      "build:test": "rollup -c --environment BUILD:test",
      build: "rollup -c",
      lint: "eslint index.js src",
      "test:main": "node test/bundle.js",
      "test:browser": "node test/browser-tests.js",
      test: "npm-run-all test:*",
      prepare: "npm-run-all clean build lint test"
    };
    const dependencies = {
      "d3-hierarchy": "^1.1.5"
    };
    const devDependencies = {
      "babel-plugin-external-helpers": "^6.22.0",
      "babel-preset-es2015-rollup": "^3.0.0",
      d3: "^4.13.0",
      "d3-selection-multi": "^1.0.1",
      eslint: "^4.19.1",
      jsdom: "^11.6.2",
      "npm-run-all": "^4.1.2",
      rollup: "^0.55.3",
      "rollup-plugin-babel": "^2.7.1",
      "rollup-plugin-commonjs": "^8.0.2",
      "rollup-plugin-copy": "^0.2.3",
      "rollup-plugin-json": "^2.3.0",
      "rollup-plugin-node-resolve": "^3.0.2",
      "rollup-plugin-uglify": "^3.0.0",
      "uglify-es": "^3.3.9"
    };
    const packageInfo = {
      name,
      version: version$1,
      main,
      module: module$1,
      "jsnext:main": "index",
      author,
      description,
      keywords,
      homepage,
      license,
      repository,
      scripts,
      dependencies,
      devDependencies
    };
    const { version } = packageInfo;
    const defaults = Object.freeze({
      children: (data) => data.children,
      nodeSize: (node) => node.data.size,
      spacing: 0
    });
    function flextree(options) {
      const opts = Object.assign({}, defaults, options);
      function accessor(name2) {
        const opt = opts[name2];
        return typeof opt === "function" ? opt : () => opt;
      }
      function layout(tree2) {
        const wtree = wrap(getWrapper(), tree2, (node) => node.children);
        wtree.update();
        return wtree.data;
      }
      function getFlexNode() {
        const nodeSize = accessor("nodeSize");
        const spacing = accessor("spacing");
        return class FlexNode extends hierarchy.prototype.constructor {
          constructor(data) {
            super(data);
          }
          copy() {
            const c = wrap(this.constructor, this, (node) => node.children);
            c.each((node) => node.data = node.data.data);
            return c;
          }
          get size() {
            return nodeSize(this);
          }
          spacing(oNode) {
            return spacing(this, oNode);
          }
          get nodes() {
            return this.descendants();
          }
          get xSize() {
            return this.size[0];
          }
          get ySize() {
            return this.size[1];
          }
          get top() {
            return this.y;
          }
          get bottom() {
            return this.y + this.ySize;
          }
          get left() {
            return this.x - this.xSize / 2;
          }
          get right() {
            return this.x + this.xSize / 2;
          }
          get root() {
            const ancs = this.ancestors();
            return ancs[ancs.length - 1];
          }
          get numChildren() {
            return this.hasChildren ? this.children.length : 0;
          }
          get hasChildren() {
            return !this.noChildren;
          }
          get noChildren() {
            return this.children === null;
          }
          get firstChild() {
            return this.hasChildren ? this.children[0] : null;
          }
          get lastChild() {
            return this.hasChildren ? this.children[this.numChildren - 1] : null;
          }
          get extents() {
            return (this.children || []).reduce(
              (acc, kid) => FlexNode.maxExtents(acc, kid.extents),
              this.nodeExtents
            );
          }
          get nodeExtents() {
            return {
              top: this.top,
              bottom: this.bottom,
              left: this.left,
              right: this.right
            };
          }
          static maxExtents(e0, e1) {
            return {
              top: Math.min(e0.top, e1.top),
              bottom: Math.max(e0.bottom, e1.bottom),
              left: Math.min(e0.left, e1.left),
              right: Math.max(e0.right, e1.right)
            };
          }
        };
      }
      function getWrapper() {
        const FlexNode = getFlexNode();
        const nodeSize = accessor("nodeSize");
        const spacing = accessor("spacing");
        return class extends FlexNode {
          constructor(data) {
            super(data);
            Object.assign(this, {
              x: 0,
              y: 0,
              relX: 0,
              prelim: 0,
              shift: 0,
              change: 0,
              lExt: this,
              lExtRelX: 0,
              lThr: null,
              rExt: this,
              rExtRelX: 0,
              rThr: null
            });
          }
          get size() {
            return nodeSize(this.data);
          }
          spacing(oNode) {
            return spacing(this.data, oNode.data);
          }
          get x() {
            return this.data.x;
          }
          set x(v) {
            this.data.x = v;
          }
          get y() {
            return this.data.y;
          }
          set y(v) {
            this.data.y = v;
          }
          update() {
            layoutChildren(this);
            resolveX(this);
            return this;
          }
        };
      }
      function wrap(FlexClass, treeData, children2) {
        const _wrap = (data, parent) => {
          const node = new FlexClass(data);
          Object.assign(node, {
            parent,
            depth: parent === null ? 0 : parent.depth + 1,
            height: 0,
            length: 1
          });
          const kidsData = children2(data) || [];
          node.children = kidsData.length === 0 ? null : kidsData.map((kd) => _wrap(kd, node));
          if (node.children) {
            Object.assign(node, node.children.reduce(
              (hl, kid) => ({
                height: Math.max(hl.height, kid.height + 1),
                length: hl.length + kid.length
              }),
              node
            ));
          }
          return node;
        };
        return _wrap(treeData, null);
      }
      Object.assign(layout, {
        nodeSize(arg) {
          return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;
        },
        spacing(arg) {
          return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;
        },
        children(arg) {
          return arguments.length ? (opts.children = arg, layout) : opts.children;
        },
        hierarchy(treeData, children2) {
          const kids = typeof children2 === "undefined" ? opts.children : children2;
          return wrap(getFlexNode(), treeData, kids);
        },
        dump(tree2) {
          const nodeSize = accessor("nodeSize");
          const _dump = (i0) => (node) => {
            const i1 = i0 + "  ";
            const i2 = i0 + "    ";
            const { x: x2, y: y2 } = node;
            const size2 = nodeSize(node);
            const kids = node.children || [];
            const kdumps = kids.length === 0 ? " " : `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;
            return `{ size: [${size2.join(", ")}],${i1}x: ${x2}, y: ${y2}${kdumps}},`;
          };
          return _dump("\n")(tree2);
        }
      });
      return layout;
    }
    flextree.version = version;
    const layoutChildren = (w, y2 = 0) => {
      w.y = y2;
      (w.children || []).reduce((acc, kid) => {
        const [i, lastLows] = acc;
        layoutChildren(kid, w.y + w.ySize);
        const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;
        if (i !== 0)
          separate(w, i, lastLows);
        const lows = updateLows(lowY, i, lastLows);
        return [i + 1, lows];
      }, [0, null]);
      shiftChange(w);
      positionRoot(w);
      return w;
    };
    const resolveX = (w, prevSum, parentX) => {
      if (typeof prevSum === "undefined") {
        prevSum = -w.relX - w.prelim;
        parentX = 0;
      }
      const sum2 = prevSum + w.relX;
      w.relX = sum2 + w.prelim - parentX;
      w.prelim = 0;
      w.x = parentX + w.relX;
      (w.children || []).forEach((k) => resolveX(k, sum2, w.x));
      return w;
    };
    const shiftChange = (w) => {
      (w.children || []).reduce((acc, child) => {
        const [lastShiftSum, lastChangeSum] = acc;
        const shiftSum = lastShiftSum + child.shift;
        const changeSum = lastChangeSum + shiftSum + child.change;
        child.relX += changeSum;
        return [shiftSum, changeSum];
      }, [0, 0]);
    };
    const separate = (w, i, lows) => {
      const lSib = w.children[i - 1];
      const curSubtree = w.children[i];
      let rContour = lSib;
      let rSumMods = lSib.relX;
      let lContour = curSubtree;
      let lSumMods = curSubtree.relX;
      let isFirst = true;
      while (rContour && lContour) {
        if (rContour.bottom > lows.lowY)
          lows = lows.next;
        const dist = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);
        if (dist > 0 || dist < 0 && isFirst) {
          lSumMods += dist;
          moveSubtree(curSubtree, dist);
          distributeExtra(w, i, lows.index, dist);
        }
        isFirst = false;
        const rightBottom = rContour.bottom;
        const leftBottom = lContour.bottom;
        if (rightBottom <= leftBottom) {
          rContour = nextRContour(rContour);
          if (rContour)
            rSumMods += rContour.relX;
        }
        if (rightBottom >= leftBottom) {
          lContour = nextLContour(lContour);
          if (lContour)
            lSumMods += lContour.relX;
        }
      }
      if (!rContour && lContour)
        setLThr(w, i, lContour, lSumMods);
      else if (rContour && !lContour)
        setRThr(w, i, rContour, rSumMods);
    };
    const moveSubtree = (subtree, distance) => {
      subtree.relX += distance;
      subtree.lExtRelX += distance;
      subtree.rExtRelX += distance;
    };
    const distributeExtra = (w, curSubtreeI, leftSibI, dist) => {
      const curSubtree = w.children[curSubtreeI];
      const n = curSubtreeI - leftSibI;
      if (n > 1) {
        const delta = dist / n;
        w.children[leftSibI + 1].shift += delta;
        curSubtree.shift -= delta;
        curSubtree.change -= dist - delta;
      }
    };
    const nextLContour = (w) => {
      return w.hasChildren ? w.firstChild : w.lThr;
    };
    const nextRContour = (w) => {
      return w.hasChildren ? w.lastChild : w.rThr;
    };
    const setLThr = (w, i, lContour, lSumMods) => {
      const firstChild = w.firstChild;
      const lExt = firstChild.lExt;
      const curSubtree = w.children[i];
      lExt.lThr = lContour;
      const diff2 = lSumMods - lContour.relX - firstChild.lExtRelX;
      lExt.relX += diff2;
      lExt.prelim -= diff2;
      firstChild.lExt = curSubtree.lExt;
      firstChild.lExtRelX = curSubtree.lExtRelX;
    };
    const setRThr = (w, i, rContour, rSumMods) => {
      const curSubtree = w.children[i];
      const rExt = curSubtree.rExt;
      const lSib = w.children[i - 1];
      rExt.rThr = rContour;
      const diff2 = rSumMods - rContour.relX - curSubtree.rExtRelX;
      rExt.relX += diff2;
      rExt.prelim -= diff2;
      curSubtree.rExt = lSib.rExt;
      curSubtree.rExtRelX = lSib.rExtRelX;
    };
    const positionRoot = (w) => {
      if (w.hasChildren) {
        const k0 = w.firstChild;
        const kf = w.lastChild;
        const prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;
        Object.assign(w, {
          prelim,
          lExt: k0.lExt,
          lExtRelX: k0.lExtRelX,
          rExt: kf.rExt,
          rExtRelX: kf.rExtRelX
        });
      }
    };
    const updateLows = (lowY, index, lastLows) => {
      while (lastLows !== null && lowY >= lastLows.lowY)
        lastLows = lastLows.next;
      return {
        lowY,
        index,
        next: lastLows
      };
    };
    function constant(x2) {
      return function constant2() {
        return x2;
      };
    }
    const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
    function append(strings) {
      this._ += strings[0];
      for (let i = 1, n = strings.length; i < n; ++i) {
        this._ += arguments[i] + strings[i];
      }
    }
    function appendRound(digits) {
      let d = Math.floor(digits);
      if (!(d >= 0))
        throw new Error(`invalid digits: ${digits}`);
      if (d > 15)
        return append;
      const k = 10 ** d;
      return function(strings) {
        this._ += strings[0];
        for (let i = 1, n = strings.length; i < n; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }
    class Path {
      constructor(digits) {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null;
        this._ = "";
        this._append = digits == null ? append : appendRound(digits);
      }
      moveTo(x2, y2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._append`Z`;
        }
      }
      lineTo(x2, y2) {
        this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
      }
      quadraticCurveTo(x1, y1, x2, y2) {
        this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
      }
      bezierCurveTo(x1, y1, x2, y2, x3, y3) {
        this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
      }
      arcTo(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (this._x1 === null) {
          this._append`M${this._x1 = x1},${this._y1 = y1}`;
        } else if (!(l01_2 > epsilon))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._append`L${this._x1 = x1},${this._y1 = y1}`;
        } else {
          let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon) {
            this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
          }
          this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
        }
      }
      arc(x2, y2, r, a0, a1, ccw) {
        x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
        if (r < 0)
          throw new Error(`negative radius: ${r}`);
        let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (this._x1 === null) {
          this._append`M${x0},${y0}`;
        } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._append`L${x0},${y0}`;
        }
        if (!r)
          return;
        if (da < 0)
          da = da % tau + tau;
        if (da > tauEpsilon) {
          this._append`A${r},${r},0,1,${cw},${x2 - dx},${y2 - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
        } else if (da > epsilon) {
          this._append`A${r},${r},0,${+(da >= pi)},${cw},${this._x1 = x2 + r * Math.cos(a1)},${this._y1 = y2 + r * Math.sin(a1)}`;
        }
      }
      rect(x2, y2, w, h2) {
        this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w = +w}v${+h2}h${-w}Z`;
      }
      toString() {
        return this._;
      }
    }
    function withPath(shape) {
      let digits = 3;
      shape.digits = function(_) {
        if (!arguments.length)
          return digits;
        if (_ == null) {
          digits = null;
        } else {
          const d = Math.floor(_);
          if (!(d >= 0))
            throw new RangeError(`invalid digits: ${_}`);
          digits = d;
        }
        return shape;
      };
      return () => new Path(digits);
    }
    var slice = Array.prototype.slice;
    function x(p2) {
      return p2[0];
    }
    function y(p2) {
      return p2[1];
    }
    class Bump {
      constructor(context, x2) {
        this._context = context;
        this._x = x2;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x2, y2) {
        x2 = +x2, y2 = +y2;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line)
              this._context.lineTo(x2, y2);
            else
              this._context.moveTo(x2, y2);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x)
              this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
            else
              this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
            break;
          }
        }
        this._x0 = x2, this._y0 = y2;
      }
    }
    function bumpX(context) {
      return new Bump(context, true);
    }
    function linkSource(d) {
      return d.source;
    }
    function linkTarget(d) {
      return d.target;
    }
    function link(curve) {
      let source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null, output = null, path = withPath(link2);
      function link2() {
        let buffer;
        const argv = slice.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null)
          output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
        argv[0] = t, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
        output.lineEnd();
        if (buffer)
          return output = null, buffer + "" || null;
      }
      link2.source = function(_) {
        return arguments.length ? (source = _, link2) : source;
      };
      link2.target = function(_) {
        return arguments.length ? (target = _, link2) : target;
      };
      link2.x = function(_) {
        return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), link2) : x$1;
      };
      link2.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), link2) : y$1;
      };
      link2.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
      };
      return link2;
    }
    function linkHorizontal() {
      return link(bumpX);
    }
    const d3 = {
      selection,
      select,
      max,
      min,
      sum,
      cumsum,
      tree,
      stratify,
      zoom,
      zoomIdentity: identity,
      linkHorizontal,
      flextree
    };
    class OrgChart {
      constructor() {
        const attrs = {
          /* NOT INTENDED FOR PUBLIC OVERRIDE */
          id: `ID${Math.floor(Math.random() * 1e6)}`,
          // Id for event handlings
          firstDraw: true,
          // Whether chart is drawn for the first time
          ctx: document.createElement("canvas").getContext("2d"),
          initialExpandLevel: 1,
          nodeDefaultBackground: "none",
          lastTransform: { x: 0, y: 0, k: 1 },
          // Panning and zooming values
          allowedNodesCount: {},
          zoomBehavior: null,
          generateRoot: null,
          /*  INTENDED FOR PUBLIC OVERRIDE */
          svgWidth: 800,
          // Configure svg width
          svgHeight: window.innerHeight - 100,
          // Configure svg height
          container: "body",
          // Set parent container, either CSS style selector or DOM element
          data: null,
          // Set data, it must be an array of objects, where hierarchy is clearly defined via id and parent ID (property names are configurable)
          connections: [],
          // Sets connection data, array of objects, SAMPLE:  [{from:"145",to:"201",label:"Conflicts of interest"}]
          defaultFont: "Helvetica",
          // Set default font
          nodeId: (d) => d.nodeId || d.id,
          // Configure accessor for node id, default is either odeId or id
          parentNodeId: (d) => d.parentNodeId || d.parentId,
          // Configure accessor for parent node id, default is either parentNodeId or parentId
          rootMargin: 40,
          // Configure how much root node is offset from top
          nodeWidth: (d3Node) => 250,
          // Configure each node width, use with caution, it is better to have the same value set for all nodes
          nodeHeight: (d) => 150,
          //  Configure each node height, use with caution, it is better to have the same value set for all nodes
          neighbourMargin: (n1, n2) => 80,
          // Configure margin between two nodes, use with caution, it is better to have the same value set for all nodes
          siblingsMargin: (d3Node) => 20,
          // Configure margin between two siblings, use with caution, it is better to have the same value set for all nodes
          childrenMargin: (d) => 60,
          // Configure margin between parent and children, use with caution, it is better to have the same value set for all nodes
          compactMarginPair: (d) => 100,
          // Configure margin between two nodes in compact mode, use with caution, it is better to have the same value set for all nodes
          compactMarginBetween: (d3Node) => 20,
          // Configure margin between two nodes in compact mode, use with caution, it is better to have the same value set for all nodes
          nodeButtonWidth: (d) => 40,
          // Configure expand & collapse button width
          nodeButtonHeight: (d) => 40,
          // Configure expand & collapse button height
          nodeButtonX: (d) => -20,
          // Configure expand & collapse button x position
          nodeButtonY: (d) => -20,
          // Configure expand & collapse button y position
          linkYOffset: 30,
          // When correcting links which is not working for safari
          pagingStep: (d) => 5,
          // Configure how many nodes to show when making new nodes appear
          minPagingVisibleNodes: (d) => 2e3,
          // Configure minimum number of visible nodes , after which paging button appears
          scaleExtent: [1e-3, 20],
          // Configure zoom scale extent , if you don't want any kind of zooming, set it to [1,1]
          duration: 400,
          // Configure duration of transitions
          imageName: "Chart",
          // Configure exported PNG and SVG image name
          setActiveNodeCentered: true,
          // Configure if active node should be centered when expanded and collapsed
          layout: "top",
          // Configure layout direction , possible values are "top", "left", "right", "bottom"
          compact: true,
          // Configure if compact mode is enabled , when enabled, nodes are shown in compact positions, instead of horizontal spread
          createZoom: (d) => d3.zoom(),
          onZoomStart: (e) => {
          },
          // Callback for zoom & panning start
          onZoom: (e) => {
          },
          // Callback for zoom & panning 
          onZoomEnd: (e) => {
          },
          // Callback for zoom & panning end
          onNodeClick: (d) => d,
          // Callback for node click
          onExpandOrCollapse: (d) => d,
          // Callback for node expand or collapse
          /*
                      * Node HTML content generation , remember that you can access some helper methods:
          
                      * node=> node.data - to access node's original data
                      * node=> node.leaves() - to access node's leaves
                      * node=> node.descendants() - to access node's descendants
                      * node=> node.children - to access node's children
                      * node=> node.parent - to access node's parent
                      * node=> node.depth - to access node's depth
                      * node=> node.hierarchyHeight - to access node's hierarchy height ( Height, which d3 assigns to hierarchy nodes)
                      * node=> node.height - to access node's height
                      * node=> node.width - to access node's width
                      * 
                      * You can also access additional properties to style your node:
                      * 
                      * d=>d.data._centeredWithDescendants - when node is centered with descendants
                      * d=>d.data._directSubordinatesPaging - subordinates count in paging mode
                      * d=>d.data._directSubordinates - subordinates count
                      * d=>d.data._totalSubordinates - total subordinates count
                      * d=>d._highlighted - when node is highlighted
                      * d=>d._upToTheRootHighlighted - when node is highlighted up to the root
                      * d=>d._expanded - when node is expanded
                      * d=>d.data._centered - when node is centered
                      */
          nodeContent: (d) => `<div style="padding:5px;font-size:10px;">Sample Node(id=${d.id}), override using <br/> 
            <code>chart.nodeContent({data}=>{ <br/>
             &nbsp;&nbsp;&nbsp;&nbsp;return '' // Custom HTML <br/>
             })</code>
             <br/> 
             Or check different <a href="https://github.com/bumbeishvili/org-chart#jump-to-examples" target="_blank">layout examples</a>
             </div>`,
          /* Node expand & collapse button content and styling. You can access same helper methods as above */
          buttonContent: ({ node, state }) => {
            const icons = {
              "left": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
                      </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
                          </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>`,
              "bottom": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="margin-left:1px;color:#716E7B" >${node.data._directSubordinatesPaging} </span></div>
                       ` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="margin-left:1px;color:#716E7B" >${node.data._directSubordinatesPaging} </span></div>
                    `,
              "right": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>`,
              "top": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
                        </svg></span><span style="margin-left:1px;color:#716E7B">${node.data._directSubordinatesPaging} </span></div>
                        ` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
                        </svg></span><span style="margin-left:1px;color:#716E7B">${node.data._directSubordinatesPaging} </span></div>
                    `
            };
            return `<div style="border:1px solid #E4E2E9;border-radius:3px;padding:3px;font-size:9px;margin:auto auto;background-color:white"> ${icons[state.layout](node.children)}  </div>`;
          },
          /* Node paging button content and styling. You can access same helper methods as above. */
          pagingButton: (d, i, arr, state) => {
            const step = state.pagingStep(d.parent);
            const currentIndex = d.parent.data._pagingStep;
            const diff2 = d.parent.data._directSubordinatesPaging - currentIndex;
            const min2 = Math.min(diff2, step);
            return `
                   <div style="margin-top:90px;">
                      <div style="display:flex;width:170px;border-radius:20px;padding:5px 15px; padding-bottom:4px;;background-color:#E5E9F2">
                      <div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M5.59 7.41L10.18 12L5.59 16.59L7 18L13 12L7 6L5.59 7.41ZM16 6H18V18H16V6Z" fill="#716E7B" stroke="#716E7B"/>
                      </svg>
                      </div><div style="line-height:2"> Show next ${min2}  nodes </div></div>
                   </div>
                `;
          },
          /* You can access and modify actual node DOM element in runtime using this method. */
          nodeUpdate: function(d, i, arr) {
            d3.select(this).select(".node-rect").attr("stroke", (d2) => d2.data._highlighted || d2.data._upToTheRootHighlighted ? "#E27396" : "none").attr("stroke-width", d.data._highlighted || d.data._upToTheRootHighlighted ? 10 : 1);
          },
          nodeEnter: (d) => d,
          // Custom handling of node update
          nodeExit: (d) => d,
          // Custom handling of exit node
          /* You can access and modify actual link DOM element in runtime using this method. */
          linkUpdate: function(d, i, arr) {
            d3.select(this).attr("stroke", (d2) => d2.data._upToTheRootHighlighted ? "#E27396" : "#E4E2E9").attr("stroke-width", (d2) => d2.data._upToTheRootHighlighted ? 5 : 1);
            if (d.data._upToTheRootHighlighted) {
              d3.select(this).raise();
            }
          },
          /* Horizontal diagonal generation algorithm - https://observablehq.com/@bumbeishvili/curved-edges-compact-horizontal */
          hdiagonal: function(s, t, m) {
            const x2 = s.x;
            const y2 = s.y;
            const ex = t.x;
            const ey = t.y;
            let mx = m && m.x != null ? m.x : x2;
            let my = m && m.y != null ? m.y : y2;
            let xrvs = ex - x2 < 0 ? -1 : 1;
            let yrvs = ey - y2 < 0 ? -1 : 1;
            let rdef = 35;
            let r = Math.abs(ex - x2) / 2 < rdef ? Math.abs(ex - x2) / 2 : rdef;
            r = Math.abs(ey - y2) / 2 < r ? Math.abs(ey - y2) / 2 : r;
            let w = Math.abs(ex - x2) / 2 - r;
            return `
                          M ${mx} ${my}
                          L ${mx} ${y2}
                          L ${x2} ${y2}
                          L ${x2 + w * xrvs} ${y2}
                          C ${x2 + w * xrvs + r * xrvs} ${y2} 
                            ${x2 + w * xrvs + r * xrvs} ${y2} 
                            ${x2 + w * xrvs + r * xrvs} ${y2 + r * yrvs}
                          L ${x2 + w * xrvs + r * xrvs} ${ey - r * yrvs} 
                          C ${x2 + w * xrvs + r * xrvs}  ${ey} 
                            ${x2 + w * xrvs + r * xrvs}  ${ey} 
                            ${ex - w * xrvs}  ${ey}
                          L ${ex} ${ey}
               `;
          },
          /* Vertical diagonal generation algorithm - https://observablehq.com/@bumbeishvili/curved-edges-compacty-vertical */
          diagonal: function(s, t, m, offsets = { sy: 0 }) {
            const x2 = s.x;
            let y2 = s.y;
            const ex = t.x;
            const ey = t.y;
            let mx = m && m.x != null ? m.x : x2;
            let my = m && m.y != null ? m.y : y2;
            let xrvs = ex - x2 < 0 ? -1 : 1;
            let yrvs = ey - y2 < 0 ? -1 : 1;
            y2 += offsets.sy;
            let rdef = 35;
            let r = Math.abs(ex - x2) / 2 < rdef ? Math.abs(ex - x2) / 2 : rdef;
            r = Math.abs(ey - y2) / 2 < r ? Math.abs(ey - y2) / 2 : r;
            let h2 = Math.abs(ey - y2) / 2 - r;
            let w = Math.abs(ex - x2) - r * 2;
            const path = `
                          M ${mx} ${my}
                          L ${x2} ${my}
                          L ${x2} ${y2}
                          L ${x2} ${y2 + h2 * yrvs}
                          C  ${x2} ${y2 + h2 * yrvs + r * yrvs} ${x2} ${y2 + h2 * yrvs + r * yrvs} ${x2 + r * xrvs} ${y2 + h2 * yrvs + r * yrvs}
                          L ${x2 + w * xrvs + r * xrvs} ${y2 + h2 * yrvs + r * yrvs}
                          C  ${ex}  ${y2 + h2 * yrvs + r * yrvs} ${ex}  ${y2 + h2 * yrvs + r * yrvs} ${ex} ${ey - h2 * yrvs}
                          L ${ex} ${ey}
               `;
            return path;
          },
          // Defining arrows with markers for connections
          defs: function(state, visibleConnections) {
            return `<defs>
                    ${visibleConnections.map((conn) => {
              const labelWidth = this.getTextWidth(conn.label, { ctx: state.ctx, fontSize: 2, defaultFont: state.defaultFont });
              return `
                       <marker id="${conn.from + "_" + conn.to}" refX="${conn._source.x < conn._target.x ? -7 : 7}" refY="5" markerWidth="500"  markerHeight="500"  orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <rect rx=0.5 width=${conn.label ? labelWidth + 3 : 0} height=3 y=1  fill="#E27396"></rect>
                       <text font-size="2px" x=1 fill="white" y=3>${conn.label || ""}</text>
                       </marker>

                       <marker id="arrow-${conn.from + "_" + conn.to}"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <path transform="translate(0)" d='M0,0 V4 L2,2 Z' fill='#E27396' />
                       </marker>
                    `;
            }).join("")}
                    </defs>
                    `;
          },
          /* You can update connections with custom styling using this function */
          connectionsUpdate: function(d, i, arr) {
            d3.select(this).attr("stroke", (d2) => "#E27396").attr("stroke-linecap", "round").attr("stroke-width", (d2) => "5").attr("pointer-events", "none").attr("marker-start", (d2) => `url(#${d2.from + "_" + d2.to})`).attr("marker-end", (d2) => `url(#arrow-${d2.from + "_" + d2.to})`);
          },
          // Link generator for connections
          linkGroupArc: d3.linkHorizontal().x((d) => d.x).y((d) => d.y),
          /*
          *   You can customize/offset positions for each node and link by overriding these functions
          *   For example, suppose you want to move link y position 30 px bellow in top layout. You can do it like this:
          *   ```javascript
          *   const layout = chart.layoutBindings();
          *   layout.top.linkY = node => node.y + 30;
          *   chart.layoutBindings(layout);
          *   ```
          */
          layoutBindings: {
            "left": {
              "nodeLeftX": (node) => 0,
              "nodeRightX": (node) => node.width,
              "nodeTopY": (node) => -node.height / 2,
              "nodeBottomY": (node) => node.height / 2,
              "nodeJoinX": (node) => node.x + node.width,
              "nodeJoinY": (node) => node.y - node.height / 2,
              "linkJoinX": (node) => node.x + node.width,
              "linkJoinY": (node) => node.y,
              "linkX": (node) => node.x,
              "linkY": (node) => node.y,
              "linkCompactXStart": (node) => node.x + node.width / 2,
              //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
              "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
              "compactLinkMidX": (node, state) => node.firstCompactNode.x,
              // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "linkParentX": (node) => node.parent.x + node.parent.width,
              "linkParentY": (node) => node.parent.y,
              "buttonX": (node) => node.width,
              "buttonY": (node) => node.height / 2,
              "centerTransform": ({ root: root2, rootMargin, centerY, scale, centerX }) => `translate(${rootMargin},${centerY}) scale(${scale})`,
              "compactDimension": {
                sizeColumn: (node) => node.height,
                sizeRow: (node) => node.width,
                reverse: (arr) => arr.slice().reverse()
              },
              "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
                if (state.compact && node.flexCompactDim) {
                  const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
                  return result;
                }
                return [height + siblingsMargin, width + childrenMargin];
              },
              "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
              "diagonal": this.hdiagonal.bind(this),
              "swap": (d) => {
                const x2 = d.x;
                d.x = d.y;
                d.y = x2;
              },
              "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2},${y2 - height / 2})`
            },
            "top": {
              "nodeLeftX": (node) => -node.width / 2,
              "nodeRightX": (node) => node.width / 2,
              "nodeTopY": (node) => 0,
              "nodeBottomY": (node) => node.height,
              "nodeJoinX": (node) => node.x - node.width / 2,
              "nodeJoinY": (node) => node.y + node.height,
              "linkJoinX": (node) => node.x,
              "linkJoinY": (node) => node.y + node.height,
              "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
              "linkCompactYStart": (node) => node.y + node.height / 2,
              "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "compactLinkMidY": (node) => node.firstCompactNode.y,
              "compactDimension": {
                sizeColumn: (node) => node.width,
                sizeRow: (node) => node.height,
                reverse: (arr) => arr
              },
              "linkX": (node) => node.x,
              "linkY": (node) => node.y,
              "linkParentX": (node) => node.parent.x,
              "linkParentY": (node) => node.parent.y + node.parent.height,
              "buttonX": (node) => node.width / 2,
              "buttonY": (node) => node.height,
              "centerTransform": ({ root: root2, rootMargin, centerY, scale, centerX }) => `translate(${centerX},${rootMargin}) scale(${scale})`,
              "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node, compactViewIndex }) => {
                if (state.compact && node.flexCompactDim) {
                  const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
                  return result;
                }
                return [width + siblingsMargin, height + childrenMargin];
              },
              "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
              "diagonal": this.diagonal.bind(this),
              "swap": (d) => {
              },
              "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width / 2},${y2})`
            },
            "bottom": {
              "nodeLeftX": (node) => -node.width / 2,
              "nodeRightX": (node) => node.width / 2,
              "nodeTopY": (node) => -node.height,
              "nodeBottomY": (node) => 0,
              "nodeJoinX": (node) => node.x - node.width / 2,
              "nodeJoinY": (node) => node.y - node.height - node.height,
              "linkJoinX": (node) => node.x,
              "linkJoinY": (node) => node.y - node.height,
              "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
              "linkCompactYStart": (node) => node.y - node.height / 2,
              "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "compactLinkMidY": (node) => node.firstCompactNode.y,
              "linkX": (node) => node.x,
              "linkY": (node) => node.y,
              "compactDimension": {
                sizeColumn: (node) => node.width,
                sizeRow: (node) => node.height,
                reverse: (arr) => arr
              },
              "linkParentX": (node) => node.parent.x,
              "linkParentY": (node) => node.parent.y - node.parent.height,
              "buttonX": (node) => node.width / 2,
              "buttonY": (node) => 0,
              "centerTransform": ({ root: root2, rootMargin, centerY, scale, centerX, chartHeight }) => `translate(${centerX},${chartHeight - rootMargin}) scale(${scale})`,
              "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
                if (state.compact && node.flexCompactDim) {
                  const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
                  return result;
                }
                return [width + siblingsMargin, height + childrenMargin];
              },
              "zoomTransform": ({ centerX, scale }) => `translate(${centerX},0}) scale(${scale})`,
              "diagonal": this.diagonal.bind(this),
              "swap": (d) => {
                d.y = -d.y;
              },
              "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width / 2},${y2 - height})`
            },
            "right": {
              "nodeLeftX": (node) => -node.width,
              "nodeRightX": (node) => 0,
              "nodeTopY": (node) => -node.height / 2,
              "nodeBottomY": (node) => node.height / 2,
              "nodeJoinX": (node) => node.x - node.width - node.width,
              "nodeJoinY": (node) => node.y - node.height / 2,
              "linkJoinX": (node) => node.x - node.width,
              "linkJoinY": (node) => node.y,
              "linkX": (node) => node.x,
              "linkY": (node) => node.y,
              "linkParentX": (node) => node.parent.x - node.parent.width,
              "linkParentY": (node) => node.parent.y,
              "buttonX": (node) => 0,
              "buttonY": (node) => node.height / 2,
              "linkCompactXStart": (node) => node.x - node.width / 2,
              //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
              "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
              "compactLinkMidX": (node, state) => node.firstCompactNode.x,
              // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
              "centerTransform": ({ root: root2, rootMargin, centerY, scale, centerX, chartWidth }) => `translate(${chartWidth - rootMargin},${centerY}) scale(${scale})`,
              "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
                if (state.compact && node.flexCompactDim) {
                  const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
                  return result;
                }
                return [height + siblingsMargin, width + childrenMargin];
              },
              "compactDimension": {
                sizeColumn: (node) => node.height,
                sizeRow: (node) => node.width,
                reverse: (arr) => arr.slice().reverse()
              },
              "zoomTransform": ({ centerY, scale }) => `translate(${0},${centerY}) scale(${scale})`,
              "diagonal": this.hdiagonal.bind(this),
              "swap": (d) => {
                const x2 = d.x;
                d.x = -d.y;
                d.y = x2;
              },
              "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width},${y2 - height / 2})`
            }
          }
        };
        this.getChartState = () => attrs;
        Object.keys(attrs).forEach((key) => {
          this[key] = function(_) {
            if (!arguments.length) {
              return attrs[key];
            } else {
              attrs[key] = _;
            }
            return this;
          };
        });
        this.initializeEnterExitUpdatePattern();
      }
      initializeEnterExitUpdatePattern() {
        d3.selection.prototype.patternify = function(params) {
          var container = this;
          var selector2 = params.selector;
          var elementTag = params.tag;
          var data = params.data || [selector2];
          var selection2 = container.selectAll("." + selector2).data(data, (d, i) => {
            if (typeof d === "object") {
              if (d.id) {
                return d.id;
              }
            }
            return i;
          });
          selection2.exit().remove();
          selection2 = selection2.enter().append(elementTag).merge(selection2);
          selection2.attr("class", selector2);
          return selection2;
        };
      }
      // This method retrieves passed node's children IDs (including node)
      getNodeChildren({ data, children: children2, _children }, nodeStore) {
        nodeStore.push(data);
        if (children2) {
          children2.forEach((d) => {
            this.getNodeChildren(d, nodeStore);
          });
        }
        if (_children) {
          _children.forEach((d) => {
            this.getNodeChildren(d, nodeStore);
          });
        }
        return nodeStore;
      }
      // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale
      initialZoom(zoomLevel) {
        const attrs = this.getChartState();
        attrs.lastTransform.k = zoomLevel;
        return this;
      }
      render() {
        const attrs = this.getChartState();
        if (!attrs.data || attrs.data.length == 0) {
          console.log("ORG CHART - Data is empty");
          if (attrs.container) {
            select(attrs.container).select(".nodes-wrapper").remove();
            select(attrs.container).select(".links-wrapper").remove();
            select(attrs.container).select(".connections-wrapper").remove();
          }
          return this;
        }
        const container = d3.select(attrs.container);
        const containerRect = container.node().getBoundingClientRect();
        if (containerRect.width > 0)
          attrs.svgWidth = containerRect.width;
        const calc = {
          id: `ID${Math.floor(Math.random() * 1e6)}`,
          // id for event handlings,
          chartWidth: attrs.svgWidth,
          chartHeight: attrs.svgHeight
        };
        attrs.calc = calc;
        calc.centerX = calc.chartWidth / 2;
        calc.centerY = calc.chartHeight / 2;
        if (attrs.firstDraw) {
          const behaviors = {
            zoom: null
          };
          behaviors.zoom = attrs.createZoom().clickDistance(10).on("start", (event, d) => attrs.onZoomStart(event)).on("end", (event, d) => attrs.onZoomEnd(event)).on("zoom", (event, d) => {
            attrs.onZoom(event);
            this.zoomed(event, d);
          }).scaleExtent(attrs.scaleExtent);
          attrs.zoomBehavior = behaviors.zoom;
        }
        attrs.flexTreeLayout = flextree({
          nodeSize: (node) => {
            const width = attrs.nodeWidth(node);
            const height = attrs.nodeHeight(node);
            const siblingsMargin = attrs.siblingsMargin(node);
            const childrenMargin = attrs.childrenMargin(node);
            return attrs.layoutBindings[attrs.layout].nodeFlexSize({
              state: attrs,
              node,
              width,
              height,
              siblingsMargin,
              childrenMargin
            });
          }
        }).spacing((nodeA, nodeB) => nodeA.parent == nodeB.parent ? 0 : attrs.neighbourMargin(nodeA, nodeB));
        this.setLayouts({ expandNodesFirst: false });
        const svg = container.patternify({
          tag: "svg",
          selector: "svg-chart-container"
        }).attr("width", attrs.svgWidth).attr("height", attrs.svgHeight).attr("font-family", attrs.defaultFont);
        if (attrs.firstDraw) {
          svg.call(attrs.zoomBehavior).on("dblclick.zoom", null).attr("cursor", "move");
        }
        attrs.svg = svg;
        const chart = svg.patternify({
          tag: "g",
          selector: "chart"
        });
        attrs.centerG = chart.patternify({
          tag: "g",
          selector: "center-group"
        });
        attrs.linksWrapper = attrs.centerG.patternify({
          tag: "g",
          selector: "links-wrapper"
        });
        attrs.nodesWrapper = attrs.centerG.patternify({
          tag: "g",
          selector: "nodes-wrapper"
        });
        attrs.connectionsWrapper = attrs.centerG.patternify({
          tag: "g",
          selector: "connections-wrapper"
        });
        attrs.defsWrapper = svg.patternify({
          tag: "g",
          selector: "defs-wrapper"
        });
        if (attrs.firstDraw) {
          attrs.centerG.attr("transform", () => {
            return attrs.layoutBindings[attrs.layout].centerTransform({
              centerX: calc.centerX,
              centerY: calc.centerY,
              scale: attrs.lastTransform.k,
              rootMargin: attrs.rootMargin,
              root: attrs.root,
              chartHeight: calc.chartHeight,
              chartWidth: calc.chartWidth
            });
          });
        }
        attrs.chart = chart;
        this.update(attrs.root);
        d3.select(window).on(`resize.${attrs.id}`, () => {
          const containerRect2 = d3.select(attrs.container).node().getBoundingClientRect();
          attrs.svg.attr("width", containerRect2.width);
        });
        if (attrs.firstDraw) {
          attrs.firstDraw = false;
        }
        return this;
      }
      // This function can be invoked via chart.addNode API, and it adds node in tree at runtime
      addNode(obj) {
        const attrs = this.getChartState();
        if (obj && (attrs.parentNodeId(obj) == null || attrs.parentNodeId(obj) == attrs.nodeId(obj)) && attrs.data.length == 0) {
          attrs.data.push(obj);
          this.render();
          return this;
        }
        const root2 = attrs.generateRoot(attrs.data);
        const descendants = root2.descendants();
        const nodeFound = descendants.filter(({ data }) => attrs.nodeId(data).toString() === attrs.nodeId(obj).toString())[0];
        descendants.filter(({ data }) => attrs.nodeId(data).toString() === attrs.parentNodeId(obj).toString())[0];
        if (nodeFound) {
          console.log(`ORG CHART - ADD - Node with id "${attrs.nodeId(obj)}" already exists in tree`);
          return this;
        }
        if (obj._centered && !obj._expanded)
          obj._expanded = true;
        attrs.data.push(obj);
        this.updateNodesState();
        return this;
      }
      // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime
      removeNode(nodeId2) {
        const attrs = this.getChartState();
        const root2 = attrs.generateRoot(attrs.data);
        const descendants = root2.descendants();
        const node = descendants.filter(({ data }) => attrs.nodeId(data) == nodeId2)[0];
        if (!node) {
          console.log(`ORG CHART - REMOVE - Node with id "${nodeId2}" not found in the tree`);
          return this;
        }
        const nodeDescendants = node.descendants();
        nodeDescendants.forEach((d) => d.data._filteredOut = true);
        attrs.data = attrs.data.filter((d) => !d._filteredOut);
        if (attrs.data.length == 0) {
          this.render();
        } else {
          const updateNodesState = this.updateNodesState.bind(this);
          updateNodesState();
        }
        return this;
      }
      groupBy(array2, accessor, aggegator) {
        const grouped = {};
        array2.forEach((item) => {
          const key = accessor(item);
          if (!grouped[key]) {
            grouped[key] = [];
          }
          grouped[key].push(item);
        });
        Object.keys(grouped).forEach((key) => {
          grouped[key] = aggegator(grouped[key]);
        });
        return Object.entries(grouped);
      }
      calculateCompactFlexDimensions(root2) {
        const attrs = this.getChartState();
        root2.eachBefore((node) => {
          node.firstCompact = null;
          node.compactEven = null;
          node.flexCompactDim = null;
          node.firstCompactNode = null;
        });
        root2.eachBefore((node) => {
          if (node.children && node.children.length > 1) {
            const compactChildren = node.children.filter((d) => !d.children);
            if (compactChildren.length < 2)
              return;
            compactChildren.forEach((child, i) => {
              if (!i)
                child.firstCompact = true;
              if (i % 2)
                child.compactEven = false;
              else
                child.compactEven = true;
              child.row = Math.floor(i / 2);
            });
            const evenMaxColumnDimension = d3.max(compactChildren.filter((d) => d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
            const oddMaxColumnDimension = d3.max(compactChildren.filter((d) => !d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
            const columnSize = Math.max(evenMaxColumnDimension, oddMaxColumnDimension) * 2;
            const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d) + attrs.compactMarginBetween(d)));
            const rowSize = d3.sum(rowsMapNew.map((v) => v[1]));
            compactChildren.forEach((node2) => {
              node2.firstCompactNode = compactChildren[0];
              if (node2.firstCompact) {
                node2.flexCompactDim = [
                  columnSize + attrs.compactMarginPair(node2),
                  rowSize - attrs.compactMarginBetween(node2)
                ];
              } else {
                node2.flexCompactDim = [0, 0];
              }
            });
            node.flexCompactDim = null;
          }
        });
      }
      calculateCompactFlexPositions(root2) {
        const attrs = this.getChartState();
        root2.eachBefore((node) => {
          if (node.children) {
            const compactChildren = node.children.filter((d) => d.flexCompactDim);
            const fch = compactChildren[0];
            if (!fch)
              return;
            compactChildren.forEach((child, i, arr) => {
              if (i == 0)
                fch.x -= fch.flexCompactDim[0] / 2;
              if (i & i % 2 - 1)
                child.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(child) / 4;
              else if (i)
                child.x = fch.x + fch.flexCompactDim[0] * 0.75 + attrs.compactMarginPair(child) / 4;
            });
            const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
            fch.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(fch) / 4;
            const offsetX = node.x - centerX;
            if (Math.abs(offsetX) < 10) {
              compactChildren.forEach((d) => d.x += offsetX);
            }
            const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d)));
            const cumSum = d3.cumsum(rowsMapNew.map((d) => d[1] + attrs.compactMarginBetween(d)));
            compactChildren.forEach((node2, i) => {
              if (node2.row) {
                node2.y = fch.y + cumSum[node2.row - 1];
              } else {
                node2.y = fch.y;
              }
            });
          }
        });
      }
      // This function basically redraws visible graph, based on nodes state
      update({ x0, y0, x: x2 = 0, y: y2 = 0, width, height }) {
        const attrs = this.getChartState();
        attrs.calc;
        if (attrs.compact) {
          this.calculateCompactFlexDimensions(attrs.root);
        }
        const treeData = attrs.flexTreeLayout(attrs.root);
        if (attrs.compact) {
          this.calculateCompactFlexPositions(attrs.root);
        }
        const nodes = treeData.descendants();
        const links = treeData.descendants().slice(1);
        nodes.forEach(attrs.layoutBindings[attrs.layout].swap);
        const connections = attrs.connections;
        const allNodesMap = {};
        attrs.allNodes.forEach((d) => allNodesMap[attrs.nodeId(d.data)] = d);
        const visibleNodesMap = {};
        nodes.forEach((d) => visibleNodesMap[attrs.nodeId(d.data)] = d);
        connections.forEach((connection) => {
          const source = allNodesMap[connection.from];
          const target = allNodesMap[connection.to];
          connection._source = source;
          connection._target = target;
        });
        const visibleConnections = connections.filter((d) => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
        const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
        const existingString = attrs.defsWrapper.html();
        if (defsString !== existingString) {
          attrs.defsWrapper.html(defsString);
        }
        const linkSelection = attrs.linksWrapper.selectAll("path.link").data(links, (d) => attrs.nodeId(d.data));
        const linkEnter = linkSelection.enter().insert("path", "g").attr("class", "link").attr("d", (d) => {
          const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
          const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
          const o = { x: xo, y: yo };
          return attrs.layoutBindings[attrs.layout].diagonal(o, o, o);
        });
        const linkUpdate = linkEnter.merge(linkSelection);
        linkUpdate.attr("fill", "none");
        if (this.isEdge()) {
          linkUpdate.style("display", (d) => {
            const display = d.data._pagingButton ? "none" : "auto";
            return display;
          });
        } else {
          linkUpdate.attr("display", (d) => {
            const display = d.data._pagingButton ? "none" : "auto";
            return display;
          });
        }
        linkUpdate.each(attrs.linkUpdate);
        linkUpdate.transition().duration(attrs.duration).attr("d", (d) => {
          const n = attrs.compact && d.flexCompactDim ? {
            x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
            y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
          } : {
            x: attrs.layoutBindings[attrs.layout].linkX(d),
            y: attrs.layoutBindings[attrs.layout].linkY(d)
          };
          const p2 = {
            x: attrs.layoutBindings[attrs.layout].linkParentX(d),
            y: attrs.layoutBindings[attrs.layout].linkParentY(d)
          };
          const m = attrs.compact && d.flexCompactDim ? {
            x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
            y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d)
          } : n;
          return attrs.layoutBindings[attrs.layout].diagonal(n, p2, m, { sy: attrs.linkYOffset });
        });
        linkSelection.exit().transition().duration(attrs.duration).attr("d", (d) => {
          const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x2, y: y2, width, height });
          const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x2, y: y2, width, height });
          const o = { x: xo, y: yo };
          return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
        }).remove();
        const connectionsSel = attrs.connectionsWrapper.selectAll("path.connection").data(visibleConnections);
        const connEnter = connectionsSel.enter().insert("path", "g").attr("class", "connection").attr("d", (d) => {
          const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
          const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
          const o = { x: xo, y: yo };
          return attrs.layoutBindings[attrs.layout].diagonal(o, o, null, { sy: attrs.linkYOffset });
        });
        const connUpdate = connEnter.merge(connectionsSel);
        connUpdate.attr("fill", "none");
        connUpdate.transition().duration(attrs.duration).attr("d", (d) => {
          const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
          const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
          const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
          const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
          return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } });
        });
        connUpdate.each(attrs.connectionsUpdate);
        connectionsSel.exit().transition().duration(attrs.duration).attr("opacity", 0).remove();
        const nodesSelection = attrs.nodesWrapper.selectAll("g.node").data(nodes, ({ data }) => attrs.nodeId(data));
        const nodeEnter = nodesSelection.enter().append("g").attr("class", "node").attr("transform", (d) => {
          if (d == attrs.root)
            return `translate(${x0},${y0})`;
          const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
          const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
          return `translate(${xj},${yj})`;
        }).attr("cursor", "pointer").on("click.node", (event, node) => {
          const { data } = node;
          if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
            return;
          }
          if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
            this.loadPagingNodes(node);
            return;
          }
          if (!data._pagingButton) {
            attrs.onNodeClick(node);
            return;
          }
          console.log("event fired, no handlers");
        }).on("keydown.node", (event, node) => {
          if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
            if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
              return;
            }
            if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
              this.loadPagingNodes(node);
              return;
            }
            if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
              this.onButtonClick(event, node);
            }
          }
        });
        nodeEnter.each(attrs.nodeEnter);
        nodeEnter.patternify({
          tag: "rect",
          selector: "node-rect",
          data: (d) => [d]
        });
        const nodeUpdate = nodeEnter.merge(nodesSelection).style("font", "12px sans-serif");
        const fo = nodeUpdate.patternify({
          tag: "foreignObject",
          selector: "node-foreign-object",
          data: (d) => [d]
        }).style("overflow", "visible");
        fo.patternify({
          tag: "xhtml:div",
          selector: "node-foreign-object-div",
          data: (d) => [d]
        });
        this.restyleForeignObjectElements();
        const nodeButtonGroups = nodeEnter.patternify({
          tag: "g",
          selector: "node-button-g",
          data: (d) => [d]
        }).on("click", (event, d) => this.onButtonClick(event, d)).on("keydown", (event, d) => {
          if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
            this.onButtonClick(event, d);
          }
        });
        nodeButtonGroups.patternify({
          tag: "rect",
          selector: "node-button-rect",
          data: (d) => [d]
        }).attr("opacity", 0).attr("pointer-events", "all").attr("width", (d) => attrs.nodeButtonWidth(d)).attr("height", (d) => attrs.nodeButtonHeight(d)).attr("x", (d) => attrs.nodeButtonX(d)).attr("y", (d) => attrs.nodeButtonY(d));
        nodeButtonGroups.patternify({
          tag: "foreignObject",
          selector: "node-button-foreign-object",
          data: (d) => [d]
        }).attr("width", (d) => attrs.nodeButtonWidth(d)).attr("height", (d) => attrs.nodeButtonHeight(d)).attr("x", (d) => attrs.nodeButtonX(d)).attr("y", (d) => attrs.nodeButtonY(d)).style("overflow", "visible").patternify({
          tag: "xhtml:div",
          selector: "node-button-div",
          data: (d) => [d]
        }).style("pointer-events", "none").style("display", "flex").style("width", "100%").style("height", "100%");
        nodeUpdate.transition().attr("opacity", 0).duration(attrs.duration).attr("transform", ({ x: x3, y: y3, width: width2, height: height2 }) => {
          return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x: x3, y: y3, width: width2, height: height2 });
        }).attr("opacity", 1);
        nodeUpdate.select(".node-rect").attr("width", ({ width: width2 }) => width2).attr("height", ({ height: height2 }) => height2).attr("x", ({ width: width2 }) => 0).attr("y", ({ height: height2 }) => 0).attr("cursor", "pointer").attr("rx", 3).attr("fill", attrs.nodeDefaultBackground);
        nodeUpdate.select(".node-button-g").attr("transform", ({ data, width: width2, height: height2 }) => {
          const x3 = attrs.layoutBindings[attrs.layout].buttonX({ width: width2, height: height2 });
          const y3 = attrs.layoutBindings[attrs.layout].buttonY({ width: width2, height: height2 });
          return `translate(${x3},${y3})`;
        }).attr("display", ({ data }) => {
          return data._directSubordinates > 0 ? null : "none";
        }).attr("opacity", ({ data, children: children2, _children }) => {
          if (data._pagingButton) {
            return 0;
          }
          if (children2 || _children) {
            return 1;
          }
          return 0;
        });
        nodeUpdate.select(".node-button-foreign-object .node-button-div").html((node) => {
          return attrs.buttonContent({ node, state: attrs });
        });
        nodeUpdate.select(".node-button-text").attr("text-anchor", "middle").attr("alignment-baseline", "middle").attr("font-size", ({ children: children2 }) => {
          if (children2)
            return 40;
          return 26;
        }).text(({ children: children2 }) => {
          if (children2)
            return "-";
          return "+";
        }).attr("y", this.isEdge() ? 10 : 0);
        nodeUpdate.each(attrs.nodeUpdate);
        const nodeExitTransition = nodesSelection.exit();
        nodeExitTransition.each(attrs.nodeExit);
        const maxDepthNode = nodeExitTransition.data().reduce((a, b) => a.depth < b.depth ? a : b, { depth: Infinity });
        nodeExitTransition.attr("opacity", 1).transition().duration(attrs.duration).attr("transform", (d) => {
          let { x: x3, y: y3, width: width2, height: height2 } = maxDepthNode.parent || {};
          const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x3, y: y3, width: width2, height: height2 });
          const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x3, y: y3, width: width2, height: height2 });
          return `translate(${ex},${ey})`;
        }).on("end", function() {
          d3.select(this).remove();
        }).attr("opacity", 0);
        nodes.forEach((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
        const centeredNode = attrs.allNodes.filter((d) => d.data._centered)[0];
        if (centeredNode) {
          let centeredNodes = [centeredNode];
          if (centeredNode.data._centeredWithDescendants) {
            if (attrs.compact) {
              centeredNodes = centeredNode.descendants().filter((d, i) => i < 7);
            } else {
              centeredNodes = centeredNode.descendants().filter((d, i, arr) => {
                const h2 = Math.round(arr.length / 2);
                const spread2 = 2;
                if (arr.length % 2) {
                  return i > h2 - spread2 && i < h2 + spread2 - 1;
                }
                return i > h2 - spread2 && i < h2 + spread2;
              });
            }
          }
          centeredNode.data._centeredWithDescendants = null;
          centeredNode.data._centered = null;
          this.fit({
            animate: true,
            scale: false,
            nodes: centeredNodes
          });
        }
      }
      // This function detects whether current browser is edge
      isEdge() {
        return window.navigator.userAgent.includes("Edge");
      }
      // Generate horizontal diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges-horizontal-d3-v3-v4-v5-v6
      hdiagonal(s, t, m, offsets) {
        const state = this.getChartState();
        return state.hdiagonal(s, t, m, offsets);
      }
      // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges
      diagonal(s, t, m, offsets) {
        const state = this.getChartState();
        return state.diagonal(s, t, m, offsets);
      }
      restyleForeignObjectElements() {
        const attrs = this.getChartState();
        attrs.svg.selectAll(".node-foreign-object").attr("width", ({ width }) => width).attr("height", ({ height }) => height).attr("x", ({ width }) => 0).attr("y", ({ height }) => 0);
        attrs.svg.selectAll(".node-foreign-object-div").style("width", ({ width }) => `${width}px`).style("height", ({ height }) => `${height}px`).html(function(d, i, arr) {
          if (d.data._pagingButton) {
            return `<div class="paging-button-wrapper"><div style="pointer-events:none">${attrs.pagingButton(d, i, arr, attrs)}</div></div>`;
          }
          return attrs.nodeContent.bind(this)(d, i, arr, attrs);
        });
      }
      // Toggle children on click.
      onButtonClick(event, d) {
        const attrs = this.getChartState();
        if (d.data._pagingButton) {
          return;
        }
        if (attrs.setActiveNodeCentered) {
          d.data._centered = true;
          d.data._centeredWithDescendants = true;
        }
        if (d.children) {
          d._children = d.children;
          d.children = null;
          this.setExpansionFlagToChildren(d, false);
        } else {
          d.children = d._children;
          d._children = null;
          if (d.children) {
            d.children.forEach(({ data }) => data._expanded = true);
          }
        }
        this.update(d);
        event.stopPropagation();
        attrs.onExpandOrCollapse(d);
      }
      // This function changes `expanded` property to descendants
      setExpansionFlagToChildren({ data, children: children2, _children }, flag) {
        data._expanded = flag;
        if (children2) {
          children2.forEach((d) => {
            this.setExpansionFlagToChildren(d, flag);
          });
        }
        if (_children) {
          _children.forEach((d) => {
            this.setExpansionFlagToChildren(d, flag);
          });
        }
      }
      // Method which only expands nodes, which have property set "expanded=true"
      expandSomeNodes(d) {
        if (d.data._expanded) {
          let parent = d.parent;
          while (parent && parent._children) {
            parent.children = parent._children;
            parent._children = null;
            parent = parent.parent;
          }
        }
        if (d._children) {
          d._children.forEach((ch) => this.expandSomeNodes(ch));
        }
        if (d.children) {
          d.children.forEach((ch) => this.expandSomeNodes(ch));
        }
      }
      // This function updates nodes state and redraws graph, usually after data change
      updateNodesState() {
        const attrs = this.getChartState();
        this.setLayouts({ expandNodesFirst: true });
        this.update(attrs.root);
      }
      setLayouts({ expandNodesFirst = true }) {
        const attrs = this.getChartState();
        attrs.generateRoot = d3.stratify().id((d) => attrs.nodeId(d)).parentId((d) => attrs.parentNodeId(d));
        attrs.root = attrs.generateRoot(attrs.data);
        const descendantsBefore = attrs.root.descendants();
        if (attrs.initialExpandLevel > 1 && descendantsBefore.length > 0) {
          descendantsBefore.forEach((d) => {
            if (d.depth <= attrs.initialExpandLevel) {
              d.data._expanded = true;
            }
          });
          attrs.initialExpandLevel = 1;
        }
        const hiddenNodesMap = {};
        attrs.root.descendants().filter((node) => node.children).filter((node) => !node.data._pagingStep).forEach((node) => {
          node.data._pagingStep = attrs.minPagingVisibleNodes(node);
        });
        attrs.root.eachBefore((node, i) => {
          node.data._directSubordinatesPaging = node.children ? node.children.length : 0;
          if (node.children) {
            node.children.forEach((child, j) => {
              child.data._pagingButton = false;
              if (j > node.data._pagingStep) {
                hiddenNodesMap[child.id] = true;
              }
              if (j === node.data._pagingStep && node.children.length - 1 > node.data._pagingStep) {
                child.data._pagingButton = true;
              }
              if (hiddenNodesMap[child.parent.id]) {
                hiddenNodesMap[child.id] = true;
              }
              if (child.data._expanded || child.data._centered || child.data._highlighted || child.data._upToTheRootHighlighted) {
                let localNode = child;
                while (localNode && (hiddenNodesMap[localNode.id] || localNode.data._pagingButton)) {
                  hiddenNodesMap[localNode.id] = false;
                  if (localNode.data._pagingButton) {
                    localNode.data._pagingButton = false;
                    localNode.parent.children.forEach((ch) => {
                      ch.data._expanded = true;
                      hiddenNodesMap[ch.id] = false;
                    });
                  }
                  localNode = localNode.parent;
                }
              }
            });
          }
        });
        attrs.root = d3.stratify().id((d) => attrs.nodeId(d)).parentId((d) => attrs.parentNodeId(d))(attrs.data.filter((d) => hiddenNodesMap[d.id] !== true));
        attrs.root.each((node, i, arr) => {
          let _hierarchyHeight = node._hierarchyHeight || node.height;
          let width = attrs.nodeWidth(node);
          let height = attrs.nodeHeight(node);
          Object.assign(node, { width, height, _hierarchyHeight });
        });
        attrs.root.x0 = 0;
        attrs.root.y0 = 0;
        attrs.allNodes = attrs.root.descendants();
        attrs.allNodes.forEach((d) => {
          Object.assign(d.data, {
            _directSubordinates: d.children ? d.children.length : 0,
            _totalSubordinates: d.descendants().length - 1
          });
        });
        if (attrs.root.children) {
          if (expandNodesFirst) {
            attrs.root.children.forEach(this.expand);
          }
          attrs.root.children.forEach((d) => this.collapse(d));
          if (attrs.initialExpandLevel == 0) {
            attrs.root._children = attrs.root.children;
            attrs.root.children = null;
          }
          [attrs.root].forEach((ch) => this.expandSomeNodes(ch));
        }
      }
      // Function which collapses passed node and it's descendants
      collapse(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach((ch) => this.collapse(ch));
          d.children = null;
        }
      }
      // Function which expands passed node and it's descendants
      expand(d) {
        if (d._children) {
          d.children = d._children;
          d.children.forEach((ch) => this.expand(ch));
          d._children = null;
        }
      }
      // Zoom handler function
      zoomed(event, d) {
        const attrs = this.getChartState();
        const chart = attrs.chart;
        const transform = event.transform;
        attrs.lastTransform = transform;
        chart.attr("transform", transform);
        if (this.isEdge()) {
          this.restyleForeignObjectElements();
        }
      }
      zoomTreeBounds({ x0, x1, y0, y1, params = { animate: true, scale: true, onCompleted: () => {
      } } }) {
        const { centerG, svgWidth: w, svgHeight: h2, svg, zoomBehavior, duration, lastTransform } = this.getChartState();
        let scaleVal = Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h2));
        let identity2 = d3.zoomIdentity.translate(w / 2, h2 / 2);
        identity2 = identity2.scale(params.scale ? scaleVal : lastTransform.k);
        identity2 = identity2.translate(-(x0 + x1) / 2, -(y0 + y1) / 2);
        svg.transition().duration(params.animate ? duration : 0).call(zoomBehavior.transform, identity2);
        centerG.transition().duration(params.animate ? duration : 0).attr("transform", "translate(0,0)").on("end", function() {
          if (params.onCompleted) {
            params.onCompleted();
          }
        });
      }
      fit({ animate = true, nodes, scale = true, onCompleted = () => {
      } } = {}) {
        const attrs = this.getChartState();
        const { root: root2 } = attrs;
        let descendants = nodes ? nodes : root2.descendants();
        const minX = d3.min(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeLeftX(d));
        const maxX = d3.max(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeRightX(d));
        const minY = d3.min(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeTopY(d));
        const maxY = d3.max(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeBottomY(d));
        this.zoomTreeBounds({
          params: { animate, scale, onCompleted },
          x0: minX - 50,
          x1: maxX + 50,
          y0: minY - 50,
          y1: maxY + 50
        });
        return this;
      }
      // Load Paging Nodes
      loadPagingNodes(node) {
        const attrs = this.getChartState();
        node.data._pagingButton = false;
        const current = node.parent.data._pagingStep;
        const step = attrs.pagingStep(node.parent);
        const newPagingIndex = current + step;
        node.parent.data._pagingStep = newPagingIndex;
        this.updateNodesState();
      }
      // This function can be invoked via chart.setExpanded API, it expands or collapses particular node
      setExpanded(id2, expandedFlag = true) {
        const attrs = this.getChartState();
        const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == id2)[0];
        if (!node) {
          console.log(`ORG CHART - ${expandedFlag ? "EXPAND" : "COLLAPSE"} - Node with id (${id2})  not found in the tree`);
          return this;
        }
        node.data._expanded = expandedFlag;
        if (expandedFlag == false) {
          const parent = node.parent || { descendants: () => [] };
          const descendants = parent.descendants().filter((d) => d != parent);
          descendants.forEach((d) => d.data._expanded = false);
        }
        return this;
      }
      setCentered(nodeId2) {
        const attrs = this.getChartState();
        const root2 = attrs.generateRoot(attrs.data);
        const descendants = root2.descendants();
        const node = descendants.filter(({ data }) => attrs.nodeId(data).toString() == nodeId2.toString())[0];
        if (!node) {
          console.log(`ORG CHART - CENTER - Node with id (${nodeId2}) not found in the tree`);
          return this;
        }
        const ancestors = node.ancestors();
        ancestors.forEach((d) => d.data._expanded = true);
        node.data._centered = true;
        node.data._expanded = true;
        return this;
      }
      setHighlighted(nodeId2) {
        const attrs = this.getChartState();
        const root2 = attrs.generateRoot(attrs.data);
        const descendants = root2.descendants();
        const node = descendants.filter((d) => attrs.nodeId(d.data).toString() === nodeId2.toString())[0];
        if (!node) {
          console.log(`ORG CHART - HIGHLIGHT - Node with id (${nodeId2})  not found in the tree`);
          return this;
        }
        const ancestors = node.ancestors();
        ancestors.forEach((d) => d.data._expanded = true);
        node.data._highlighted = true;
        node.data._expanded = true;
        node.data._centered = true;
        return this;
      }
      setUpToTheRootHighlighted(nodeId2) {
        const attrs = this.getChartState();
        const root2 = attrs.generateRoot(attrs.data);
        const descendants = root2.descendants();
        const node = descendants.filter((d) => attrs.nodeId(d.data).toString() === nodeId2.toString())[0];
        if (!node) {
          console.log(`ORG CHART - HIGHLIGHTROOT - Node with id (${nodeId2}) not found in the tree`);
          return this;
        }
        const ancestors = node.ancestors();
        ancestors.forEach((d) => d.data._expanded = true);
        node.data._upToTheRootHighlighted = true;
        node.data._expanded = true;
        node.ancestors().forEach((d) => d.data._upToTheRootHighlighted = true);
        return this;
      }
      clearHighlighting() {
        const attrs = this.getChartState();
        attrs.allNodes.forEach((d) => {
          d.data._highlighted = false;
          d.data._upToTheRootHighlighted = false;
        });
        this.update(attrs.root);
        return this;
      }
      // It can take selector which would go fullscreen
      fullscreen(elem) {
        const attrs = this.getChartState();
        const el = d3.select(elem || attrs.container).node();
        d3.select(document).on("fullscreenchange." + attrs.id, function(d) {
          const fsElement = document.fullscreenElement || document.mozFullscreenElement || document.webkitFullscreenElement;
          if (fsElement == el) {
            setTimeout((d2) => {
              attrs.svg.attr("height", window.innerHeight - 40);
            }, 500);
          } else {
            attrs.svg.attr("height", attrs.svgHeight);
          }
        });
        if (el.requestFullscreen) {
          el.requestFullscreen();
        } else if (el.mozRequestFullScreen) {
          el.mozRequestFullScreen();
        } else if (el.webkitRequestFullscreen) {
          el.webkitRequestFullscreen();
        } else if (el.msRequestFullscreen) {
          el.msRequestFullscreen();
        }
      }
      // Zoom in exposed method
      zoomIn() {
        const { svg, zoomBehavior } = this.getChartState();
        svg.transition().call(zoomBehavior.scaleBy, 1.3);
      }
      // Zoom out exposed method
      zoomOut() {
        const { svg, zoomBehavior } = this.getChartState();
        svg.transition().call(zoomBehavior.scaleBy, 0.78);
      }
      toDataURL(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.onload = function() {
          var reader = new FileReader();
          reader.onloadend = function() {
            callback(reader.result);
          };
          reader.readAsDataURL(xhr.response);
        };
        xhr.open("GET", url);
        xhr.responseType = "blob";
        xhr.send();
      }
      exportImg({ full = false, scale = 3, onLoad = (d) => d, save = true, backgroundColor = "#FAFAFA" } = {}) {
        const that = this;
        const attrs = this.getChartState();
        const { svg: svgImg, root: root2 } = attrs;
        let count2 = 0;
        const selection2 = svgImg.selectAll("img");
        let total = selection2.size();
        const exportImage = () => {
          JSON.parse(JSON.stringify(that.lastTransform()));
          const duration = that.duration();
          if (full) {
            that.fit();
          }
          const { svg } = that.getChartState();
          setTimeout((d) => {
            that.downloadImage({
              node: svg.node(),
              scale,
              isSvg: false,
              backgroundColor,
              onAlreadySerialized: (d2) => {
                that.update(root2);
              },
              imageName: attrs.imageName,
              onLoad,
              save
            });
          }, full ? duration + 10 : 0);
        };
        if (total > 0) {
          selection2.each(function() {
            that.toDataURL(this.src, (dataUrl) => {
              this.src = dataUrl;
              if (++count2 == total) {
                exportImage();
              }
            });
          });
        } else {
          exportImage();
        }
      }
      exportSvg() {
        const { svg, imageName } = this.getChartState();
        this.downloadImage({ imageName, node: svg.node(), scale: 3, isSvg: true });
        return this;
      }
      expandAll() {
        const { allNodes, root: root2, data } = this.getChartState();
        data.forEach((d) => d._expanded = true);
        this.render();
        return this;
      }
      collapseAll() {
        const { allNodes, root: root2 } = this.getChartState();
        allNodes.forEach((d) => d.data._expanded = false);
        this.initialExpandLevel(0);
        this.render();
        return this;
      }
      downloadImage({ node, scale = 2, imageName = "graph", isSvg = false, save = true, backgroundColor = "#FAFAFA", onAlreadySerialized = (d) => {
      }, onLoad = (d) => {
      } }) {
        const svgNode2 = node;
        function saveAs(uri, filename) {
          var link2 = document.createElement("a");
          if (typeof link2.download === "string") {
            document.body.appendChild(link2);
            link2.download = filename;
            link2.href = uri;
            link2.click();
            document.body.removeChild(link2);
          } else {
            location.replace(uri);
          }
        }
        function serializeString(svg) {
          const xmlns = "http://www.w3.org/2000/xmlns/";
          const xlinkns = "http://www.w3.org/1999/xlink";
          const svgns = "http://www.w3.org/2000/svg";
          svg = svg.cloneNode(true);
          const fragment = window.location.href + "#";
          const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false);
          while (walker.nextNode()) {
            for (const attr of walker.currentNode.attributes) {
              if (attr.value.includes(fragment)) {
                attr.value = attr.value.replace(fragment, "#");
              }
            }
          }
          svg.setAttributeNS(xmlns, "xmlns", svgns);
          svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);
          const serializer = new XMLSerializer();
          const string = serializer.serializeToString(svg);
          return string;
        }
        if (isSvg) {
          let source = serializeString(svgNode2);
          source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
          var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
          saveAs(url, imageName + ".svg");
          onAlreadySerialized();
          return;
        }
        const quality = scale;
        const image = document.createElement("img");
        image.onload = function() {
          const canvas = document.createElement("canvas");
          const rect = svgNode2.getBoundingClientRect();
          canvas.width = rect.width * quality;
          canvas.height = rect.height * quality;
          const context = canvas.getContext("2d");
          context.fillStyle = backgroundColor;
          context.fillRect(0, 0, rect.width * quality, rect.height * quality);
          context.drawImage(image, 0, 0, rect.width * quality, rect.height * quality);
          let dt = canvas.toDataURL("image/png");
          if (onLoad) {
            onLoad(dt);
          }
          if (save) {
            saveAs(dt, imageName + ".png");
          }
        };
        var url = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(serializeString(svgNode2));
        onAlreadySerialized();
        image.src = url;
      }
      // Calculate what size text will take
      getTextWidth(text, {
        fontSize = 14,
        fontWeight = 400,
        defaultFont = "Helvetice",
        ctx
      } = {}) {
        ctx.font = `${fontWeight || ""} ${fontSize}px ${defaultFont} `;
        const measurement = ctx.measureText(text);
        return measurement.width;
      }
      // Clear after moving off from the page
      clear() {
        const attrs = this.getChartState();
        d3.select(window).on(`resize.${attrs.id}`, null);
        attrs.svg && attrs.svg.selectAll("*").remove();
      }
    }
    const _sfc_main$g = {
      name: "ConfirmModal",
      components: {
        Button,
        Checkbox,
        Icon,
        Modal
      },
      props: ["config"],
      computed: {
        confirmButtonClass() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.confirmButton) == null ? void 0 : _b.type) ? `slds-button slds-button_${this.config.confirmButton.type}` : "slds-button slds-button_brand";
        },
        confirmButtonText() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.confirmButton) == null ? void 0 : _b.label) ? this.config.confirmButton.label : "Confirm";
        },
        cancelButtonClass() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.cancelButton) == null ? void 0 : _b.type) ? `slds-button slds-button_${this.config.cancelButton.type}` : "slds-button slds-button_neutral";
        },
        cancelButtonText() {
          var _a, _b;
          return ((_b = (_a = this.config) == null ? void 0 : _a.cancelButton) == null ? void 0 : _b.label) ? this.config.cancelButton.label : "Cancel";
        }
      },
      methods: {
        confirm() {
          this.config.callback({ options: this.config.options });
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$g = { class: "slds-grid slds-grid_vertical slds-grid_vertical-align-center slds-grid_align-center" };
    const _hoisted_2$g = { key: 0 };
    const _hoisted_3$e = {
      class: "slds-text-color_weak slds-text-heading_small",
      style: { "text-align": "center" }
    };
    const _hoisted_4$d = { style: { "white-space": "pre-wrap" } };
    const _hoisted_5$d = { class: "slds-grid" };
    const _hoisted_6$c = { class: "slds-col_bump-left" };
    function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Icon = resolveComponent("Icon");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: $props.config.title,
        size: "small",
        detach: "",
        onClose: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_1$g, [
            $props.config.icon ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
              createVNode(_component_Icon, {
                category: $props.config.icon.category,
                name: $props.config.icon.name,
                iconClass: "slds-button__icon",
                assistiveText: $props.config.icon.text,
                size: $props.config.icon.size
              }, null, 8, ["category", "name", "assistiveText", "size"])
            ])) : createCommentVNode("", true),
            createBaseVNode("div", null, [
              createBaseVNode("div", _hoisted_3$e, [
                createBaseVNode("span", _hoisted_4$d, toDisplayString($props.config.description), 1)
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.config.options, (option) => {
                return openBlock(), createElementBlock("div", {
                  key: option.id,
                  class: "slds-m-top_small"
                }, [
                  createVNode(_component_Checkbox, {
                    modelValue: option.selected,
                    "onUpdate:modelValue": ($event) => option.selected = $event,
                    labels: { name: option.label }
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "labels"])
                ]);
              }), 128))
            ])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_5$d, [
              createBaseVNode("div", _hoisted_6$c, [
                createVNode(_component_Button, {
                  class: normalizeClass($options.cancelButtonClass),
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($options.cancelButtonText), 1)
                  ]),
                  _: 1
                }, 8, ["class"]),
                createVNode(_component_Button, {
                  class: normalizeClass($options.confirmButtonClass),
                  onClick: $options.confirm
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($options.confirmButtonText), 1)
                  ]),
                  _: 1
                }, 8, ["class", "onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const ConfirmModal = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
    const _sfc_main$f = {
      name: "CheckboxButton",
      props: ["modelValue", "icon", "id", "title"],
      emits: ["update:modelValue"],
      data() {
        return {
          hasFocus: false
        };
      },
      computed: {
        labelClass() {
          return [
            "slds-checkbox-button",
            this.modelValue ? "slds-checkbox-button_is-checked" : "",
            this.hasFocus ? "slds-checkbox-button_is-focused" : ""
          ];
        },
        svgStyle() {
          return {
            transform: this.icon === "burndown" ? "rotateX(180deg)" : ""
          };
        },
        svgViewBox() {
          return {
            arrow_bottom: "0 0 520 520",
            contract_alt: "0 0 520 520",
            org_chart: "0 0 520 520",
            settings: "0 0 520 520",
            search: "0 0 520 520"
          }[this.icon] || "0 0 52 52";
        }
      }
    };
    const _hoisted_1$f = ["for"];
    const _hoisted_2$f = ["id", "value"];
    const _hoisted_3$d = ["title"];
    const _hoisted_4$c = ["viewBox"];
    const _hoisted_5$c = {
      key: 0,
      d: "M50.1,30.56a1.16,1.16,0,0,1-2,.82L42.73,26,30.32,36.65a3.39,3.39,0,0,1-4.92,0l-7.49-8.54L4.57,39.81a1.13,1.13,0,0,1-1.64,0l-.59-.59a1.13,1.13,0,0,1,0-1.64L15.46,19.68a3.39,3.39,0,0,1,4.92,0l7.49,7.49,7.61-8.78-4.92-4.45a1.26,1.26,0,0,1,.82-2.11H47.76A2.35,2.35,0,0,1,50,14.3Z"
    };
    const _hoisted_6$b = { key: 1 };
    const _hoisted_7$a = /* @__PURE__ */ createStaticVNode('<path d="M8,10.5C8,9.7,7.3,9,6.5,9h-3C2.7,9,2,9.7,2,10.5v3C2,14.3,2.7,15,3.5,15h3C7.3,15,8,14.3,8,13.5V10.5z"></path><path d="M50,10.5C50,9.7,49.3,9,48.5,9h-35C12.7,9,12,9.7,12,10.5v3c0,0.8,0.7,1.5,1.5,1.5h35 c0.8,0,1.5-0.7,1.5-1.5V10.5z"></path><path d="M8,24.5C8,23.7,7.3,23,6.5,23h-3C2.7,23,2,23.7,2,24.5v3C2,28.3,2.7,29,3.5,29h3C7.3,29,8,28.3,8,27.5V24.5z"></path><path d="M46,24.5c0-0.8-0.7-1.5-1.5-1.5h-31c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h31c0.8,0,1.5-0.7,1.5-1.5V24.5z"></path><path d="M8,38.5C8,37.7,7.3,37,6.5,37h-3C2.7,37,2,37.7,2,38.5v3C2,42.3,2.7,43,3.5,43h3C7.3,43,8,42.3,8,41.5V38.5z"></path><path d="M50,38.5c0-0.8-0.7-1.5-1.5-1.5h-35c-0.8,0-1.5,0.7-1.5,1.5v3c0,0.8,0.7,1.5,1.5,1.5h35c0.8,0,1.5-0.7,1.5-1.5V38.5z"></path>', 6);
    const _hoisted_13$5 = [
      _hoisted_7$a
    ];
    const _hoisted_14$4 = {
      key: 2,
      d: "M423 418a20 20 0 0 1 20 20v42a20 20 0 0 1-20 20H97a20 20 0 0 1-20-20v-41a20 20 0 0 1 20-20ZM280 20a21 21 0 0 1 20 20v174a13 13 0 0 0 23 10l48-48a20 20 0 0 1 28 0l30 28a19 19 0 0 1 0 27L274 381a20 20 0 0 1-29 0L92 231a19 19 0 0 1 0-27l28-28a20 20 0 0 1 29 0l48 47a13 13 0 0 0 22-9V40a22 22 0 0 1 21-20h40Z"
    };
    const _hoisted_15$2 = { key: 3 };
    const _hoisted_16$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M467 192H360a12 12 0 0 0-12 12v37h-74l-1-147a15 15 0 0 0-15-14H157V40a12 12 0 0 0-12-12H37a12 12 0 0 0-12 12v108a12 12 0 0 0 12 12h108a12 12 0 0 0 12-12v-38h86l1 146a15 15 0 0 0 15 15h89v40a12 12 0 0 0 12 12h107a12 12 0 0 0 12-12V204a12 12 0 0 0-12-12Z" }, null, -1);
    const _hoisted_17$2 = /* @__PURE__ */ createBaseVNode("rect", {
      width: "132",
      height: "132",
      x: "348",
      y: "28",
      rx: "12"
    }, null, -1);
    const _hoisted_18$2 = /* @__PURE__ */ createBaseVNode("rect", {
      width: "132",
      height: "132",
      x: "348",
      y: "355",
      rx: "12"
    }, null, -1);
    const _hoisted_19$2 = [
      _hoisted_16$2,
      _hoisted_17$2,
      _hoisted_18$2
    ];
    const _hoisted_20$2 = {
      key: 4,
      d: "M296 239h154c10 0 13-11 5-19l-49-50 90-91c5-5 5-14 0-19l-37-37c-5-4-13-4-19 1l-90 90-51-49c-8-8-19-5-19 5v154c0 7 9 15 16 15zm-72 41H70c-10 0-13 11-5 19l49 50-90 91c-5 5-5 14 0 19l37 37c5 5 13 5 19 0l91-91 51 49c7 9 18 6 18-4V297c0-7-9-17-16-17z"
    };
    const _hoisted_21$2 = {
      key: 5,
      d: "M261 191c-39 0-70 31-70 70s31 70 70 70 70-31 70-70-31-70-70-70zm210 133-37-31a195 195 0 0 0 0-68l37-31c12-10 16-28 8-42l-16-28a34 34 0 0 0-40-14l-46 17a168 168 0 0 0-59-34l-8-47c-3-16-17-25-33-25h-32c-16 0-30 9-33 25l-8 46a180 180 0 0 0-60 34l-46-17-11-2c-12 0-23 6-29 16l-16 28c-8 14-5 32 8 42l37 31a195 195 0 0 0 0 68l-37 31a34 34 0 0 0-8 42l16 28a34 34 0 0 0 40 14l46-17c18 16 38 27 59 34l8 48a33 33 0 0 0 33 27h32c16 0 30-12 33-28l8-48a170 170 0 0 0 62-37l43 17 12 2c12 0 23-6 29-16l15-26c9-11 5-29-7-39zm-210 47c-61 0-110-49-110-110s49-110 110-110 110 49 110 110-49 110-110 110z"
    };
    const _hoisted_22$1 = {
      key: 6,
      "fill-rule": "evenodd",
      d: "M44.863,44.863 L44.863,37.317 C44.863,36.59 45.453,36 46.179,36 L50.411,36 C51.137,36 51.727,36.59 51.727,37.317 L51.727,51.727 L37.317,51.727 C36.59,51.727 36,51.137 36,50.411 L36,46.179 C36,45.453 36.59,44.863 37.317,44.863 L44.863,44.863 Z M5.80799999,36 C6.53499999,36 7.12399999,36.59 7.12399999,37.317 L7.12399999,44.863 L14.67,44.863 C15.398,44.863 15.988,45.453 15.988,46.18 L15.988,50.411 C15.988,51.138 15.398,51.728 14.67,51.728 L0.25999999,51.728 L0.25999999,37.317 C0.25999999,36.59 0.84999999,36 1.57699999,36 L5.80799999,36 Z M36,1.57699999 C36,0.84999999 36.59,0.25999999 37.317,0.25999999 L51.728,0.25999999 L51.728,14.671 C51.728,15.398 51.138,15.987 50.411,15.987 L46.18,15.987 C45.453,15.987 44.863,15.398 44.863,14.671 L44.863,7.12399999 L37.317,7.12399999 C36.59,7.12399999 36,6.53499999 36,5.80699999 L36,1.57699999 Z M1.57599999,15.987 C0.84899999,15.987 0.25999999,15.398 0.25999999,14.671 L0.25999999,0.25999999 L14.67,0.25999999 C15.397,0.25999999 15.987,0.84999999 15.987,1.57699999 L15.987,5.80699999 C15.987,6.53499999 15.397,7.12399999 14.67,7.12399999 L7.12399999,7.12399999 L7.12399999,14.671 C7.12399999,15.398 6.53399999,15.987 5.80699999,15.987 L1.57599999,15.987 Z M39.457,36.919 C39.745,37.323 39.745,37.899 39.399,38.246 L38.187,39.457 C37.842,39.803 37.322,39.803 36.976,39.457 L30.343,32.823 C28.439,34.208 26.074,35.073 23.536,35.073 C17.191,35.073 12,29.882 12,23.536 C12,17.191 17.191,12 23.536,12 C29.882,12 35.073,17.191 35.073,23.536 C35.073,26.074 34.208,28.439 32.823,30.342 L39.457,36.919 Z M23.536,31.612 C27.977,31.612 31.612,27.978 31.612,23.536 C31.612,19.095 27.977,15.461 23.536,15.461 C19.095,15.461 15.461,19.095 15.461,23.536 C15.461,27.978 19.095,31.612 23.536,31.612 Z"
    };
    const _hoisted_23$1 = {
      key: 7,
      d: "M496 453 362 320a189 189 0 1 0-340-92 190 190 0 0 0 298 135l133 133a14 14 0 0 0 21 0l21-21a17 17 0 0 0 1-22ZM210 338a129 129 0 1 1 130-130 129 129 0 0 1-130 130Z"
    };
    const _hoisted_24$1 = { class: "slds-assistive-text" };
    function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
      return openBlock(), createElementBlock("label", {
        class: normalizeClass($options.labelClass),
        for: $props.id
      }, [
        createBaseVNode("input", {
          id: $props.id,
          value: $props.id,
          type: "checkbox",
          class: "slds-assistive-text",
          checked: "",
          onChange: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("update:modelValue", !$props.modelValue)),
          onFocus: _cache[1] || (_cache[1] = ($event) => $data.hasFocus = true),
          onBlur: _cache[2] || (_cache[2] = ($event) => $data.hasFocus = false)
        }, null, 40, _hoisted_2$f),
        createBaseVNode("span", {
          class: "slds-icon_container slds-current-color",
          title: $props.title
        }, [
          (openBlock(), createElementBlock("svg", {
            class: "slds-icon slds-icon_x-small",
            style: normalizeStyle($options.svgStyle),
            xmlns: "http://www.w3.org/2000/svg",
            width: "52",
            height: "52",
            viewBox: $options.svgViewBox
          }, [
            $props.icon === "burndown" ? (openBlock(), createElementBlock("path", _hoisted_5$c)) : createCommentVNode("", true),
            $props.icon === "list" ? (openBlock(), createElementBlock("g", _hoisted_6$b, _hoisted_13$5)) : createCommentVNode("", true),
            $props.icon === "arrow_bottom" ? (openBlock(), createElementBlock("path", _hoisted_14$4)) : createCommentVNode("", true),
            $props.icon === "org_chart" ? (openBlock(), createElementBlock("g", _hoisted_15$2, _hoisted_19$2)) : createCommentVNode("", true),
            $props.icon === "contract_alt" ? (openBlock(), createElementBlock("path", _hoisted_20$2)) : createCommentVNode("", true),
            $props.icon === "settings" ? (openBlock(), createElementBlock("path", _hoisted_21$2)) : createCommentVNode("", true),
            $props.icon === "zoom_to_fit" ? (openBlock(), createElementBlock("path", _hoisted_22$1)) : createCommentVNode("", true),
            $props.icon === "search" ? (openBlock(), createElementBlock("path", _hoisted_23$1)) : createCommentVNode("", true)
          ], 12, _hoisted_4$c)),
          createBaseVNode("span", _hoisted_24$1, toDisplayString($props.title), 1)
        ], 8, _hoisted_3$d)
      ], 10, _hoisted_1$f);
    }
    const CheckboxButton = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
    const _sfc_main$e = {
      name: "ConfigureModal",
      components: {
        SLDSButton: Button,
        Picklist,
        Modal,
        Spinner
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loadingMsg: "Loading...",
          // kpis
          kpi1: SPM.Components.Root.preferences.kpis[0] || "",
          kpi2: SPM.Components.Root.preferences.kpis[1] || "",
          kpi3: SPM.Components.Root.preferences.kpis[2] || "",
          kpiOptions: SPM.Components.OrgView.kpiOptions
        };
      },
      computed: {
        sampleSegmentHTML() {
          return SPM.Components.OrgView.nodeContent({
            d: {
              data: {
                node: {
                  Name: "AMER Enterprise",
                  sfsp__SalesNodeRules__r: [],
                  _kpis: {
                    [this.kpi1]: 223123,
                    [this.kpi2]: 11123,
                    [this.kpi3]: 934829438
                  }
                }
              }
            },
            compact: false,
            preferences: {
              kpis: [this.kpi1, this.kpi2, this.kpi3].filter((id2) => !!id2)
            }
          });
        }
      },
      async mounted() {
        SPM.Components.ConfigureModal = this;
        this.loadingMsg = "";
      },
      methods: {
        async save() {
          const newKPIs = [this.kpi1, this.kpi2, this.kpi3].filter((id2) => !!id2);
          const kpiCountChanged = SPM.Components.Root.preferences.kpis.length !== newKPIs.length;
          SPM.Components.Root.preferences.kpis = newKPIs;
          if (kpiCountChanged) {
            SPM.Components.OrgView.chart.render();
          }
          SPM.Components.OrgView.updateSegmentValues();
          this.$emit("close");
        }
      }
    };
    const _withScopeId$4 = (n) => (pushScopeId("data-v-170d6947"), n = n(), popScopeId(), n);
    const _hoisted_1$e = { class: "slds-grid" };
    const _hoisted_2$e = { class: "slds-size_7-of-12 slds-p-around_medium slds-grid" };
    const _hoisted_3$c = { class: "slds-col slds-size_1-of-1 slds-large-size_11-of-12" };
    const _hoisted_4$b = { class: "configure-modal-preview slds-size_5-of-12 slds-p-around_medium" };
    const _hoisted_5$b = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createBaseVNode("div", { class: "preview-title" }, "Preview", -1));
    const _hoisted_6$a = ["innerHTML"];
    const _hoisted_7$9 = { class: "slds-grid" };
    const _hoisted_8$9 = { class: "slds-col_bump-left" };
    function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_SLDSButton = resolveComponent("SLDSButton");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        class: "configure-modal",
        title: "Configure",
        size: "base",
        detach: "",
        onClose: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_1$e, [
            createBaseVNode("div", _hoisted_2$e, [
              createBaseVNode("div", _hoisted_3$c, [
                createVNode(_component_Picklist, {
                  modelValue: $data.kpi1,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.kpi1 = $event),
                  labels: { name: "KPI 1" },
                  options: $data.kpiOptions,
                  titleKey: "label",
                  filterable: ""
                }, null, 8, ["modelValue", "options"]),
                createVNode(_component_Picklist, {
                  modelValue: $data.kpi2,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.kpi2 = $event),
                  labels: { name: "KPI 2" },
                  options: $data.kpiOptions,
                  titleKey: "label",
                  filterable: ""
                }, null, 8, ["modelValue", "options"]),
                createVNode(_component_Picklist, {
                  modelValue: $data.kpi3,
                  "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.kpi3 = $event),
                  labels: { name: "KPI 3" },
                  options: $data.kpiOptions,
                  titleKey: "label",
                  filterable: ""
                }, null, 8, ["modelValue", "options"])
              ])
            ]),
            createBaseVNode("div", _hoisted_4$b, [
              _hoisted_5$b,
              createBaseVNode("div", {
                innerHTML: $options.sampleSegmentHTML,
                class: "slds-p-around_medium"
              }, null, 8, _hoisted_6$a)
            ])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_7$9, [
              createBaseVNode("div", _hoisted_8$9, [
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }),
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_brand",
                  onClick: $options.save
                }, {
                  default: withCtx(() => [
                    createTextVNode("Save")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 512);
    }
    const ConfigureModal = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e], ["__scopeId", "data-v-170d6947"]]);
    const _sfc_main$d = {
      name: "AddSegmentsModal",
      components: {
        Modal,
        Spinner,
        Tabs,
        Tab,
        Button,
        ButtonIcon,
        Picklist
      },
      props: {
        // { parentId }
        config: {
          type: Object,
          required: true
        }
      },
      emits: ["close"],
      data() {
        return {
          loadingMsg: "",
          tabId: "Add",
          newSegments: [{ Name: "" }],
          splitFieldOptions: SPM.Components.OrgView.dataSourceFields,
          splitFieldId: "",
          splitBuckets: [],
          splitBucketColumns: [
            { id: "__Bucket", label: "" },
            { id: "__Records", label: "Records" },
            ...SPM.Components.Root.preferences.kpis.map((kpiId) => ({ id: kpiId, label: SPM.Components.OrgView.kpiOptions.find((kpi) => kpi.id === kpiId).label }))
          ],
          errors: {
            splitField: []
          }
        };
      },
      computed: {
        hasDataSource() {
          return SPM.Components.Root.plan._hasDataSource;
        }
      },
      watch: {
        async splitFieldId() {
          this.loadingMsg = "Splitting...";
          this.errors.splitField = [];
          if (!this.splitFieldId) {
            this.splitBuckets = [];
            this.loadingMsg = "";
            return;
          }
          const splitField = this.splitFieldOptions.find((f) => f.id === this.splitFieldId);
          this.splitBucketColumns[0].label = splitField.label;
          if (splitField.dataType === "Numeric") {
            const { results: aggregateResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: `
                    ${SPM.Utils.Segment.Node.generateNodeFilterSaql({
              node: SPM.Components.Root.nodeMap[this.config.parentId],
              nodeMap: SPM.Components.Root.nodeMap,
              dataSource: SPM.Components.OrgView.dataSource
            })}

                    -- results
                    results = group results by all;
                    results = foreach results generate min('${this.splitFieldId}') as min, max('${this.splitFieldId}') as max, avg('${this.splitFieldId}') as avg, stddevp('${this.splitFieldId}') as stddev;
                `.replace(/^ */gm, "") });
            const { min: min2, max: max2, avg, stddev } = aggregateResults.records[0];
            const numRanges = 50;
            const step = Math.floor((max2 - min2) / numRanges);
            const ranges = [];
            let current = min2;
            while (current < max2) {
              ranges.push([current, current + step, "range"]);
              current += step + 1;
            }
            ranges.at(-1)[1] = max2;
            const stddevStep = Math.floor(stddev);
            let stddevRanges = [];
            let currentBottom = Math.floor(avg);
            let currentTop = currentBottom + 1;
            for (let i = 0; i < 4; i++) {
              if (currentBottom > min2) {
                stddevRanges[3 - i] = [currentBottom - stddevStep, currentBottom, "stddevrange"];
                currentBottom -= stddevStep;
              }
              if (currentTop < max2) {
                stddevRanges[4 + i] = [currentTop, currentTop + stddevStep, "stddevrange"];
                currentTop += stddevStep;
              }
            }
            stddevRanges = stddevRanges.filter((r) => !!r);
            stddevRanges[0][0] = min2;
            stddevRanges.at(-1)[1] = max2;
            const { results: rangeResults } = await SPM.Utils.Rest.invoke("RunSaql", { query: `
                    ${SPM.Utils.Segment.Node.generateNodeFilterSaql({
              node: SPM.Components.Root.nodeMap[this.config.parentId],
              nodeMap: SPM.Components.Root.nodeMap,
              dataSource: SPM.Components.OrgView.dataSource
            })}

                    -- results
                    ${[...ranges, ...stddevRanges].map(([from2, to2, type], i) => `
                        ${type}${i} = filter results by (${splitField.id} >= ${from2} && ${splitField.id} <= ${to2});
                        ${type}${i} = group ${type}${i} by all;
                        ${type}${i} = foreach ${type}${i} generate ${[
              `"${type}${i}" as bucket`,
              `"${this.$F("Numeric", from2)} to ${this.$F("Numeric", to2)}" as __Bucket`,
              `"${from2}" as __From`,
              `"${to2}" as __To`,
              `min(${splitField.id}) as __Min`,
              `max(${splitField.id}) as __Max`,
              "count() as __Records",
              ...SPM.Components.Root.preferences.kpis.map((kpiId) => `sum(${kpiId}) as ${kpiId}`)
            ].join(", ")};
                    `).join("\r\n")}
                    results = union ${[...ranges, ...stddevRanges].map(([, , type], i) => `${type}${i}`).join(", ")};
                `.replace(/^ */gm, "") });
            this.splitBuckets = rangeResults.records.filter((r) => r.bucket.startsWith("stddevrange")).map((r) => ({ ...r, selected: true }));
          } else {
            const saql = `
                    ${SPM.Utils.Segment.Node.generateNodeFilterSaql({
              node: SPM.Components.Root.nodeMap[this.config.parentId],
              nodeMap: SPM.Components.Root.nodeMap,
              dataSource: SPM.Components.OrgView.dataSource
            })}

                    -- include null values
                    results = foreach results generate ${[
              `case when ${this.splitFieldId} is null then "<Blank>" else ${this.splitFieldId} end as ${this.splitFieldId}`,
              ...SPM.Components.Root.preferences.kpis.filter((kpiId) => kpiId !== this.splitFieldId).map((kpiId) => `${kpiId} as ${kpiId}`)
            ].join(", ")};

                    -- generate groups
                    results = group results by ${this.splitFieldId};
                    results = foreach results generate ${[
              `${this.splitFieldId} as __Bucket`,
              "count() as __Records",
              ...SPM.Components.Root.preferences.kpis.map((kpiId) => `sum(${kpiId}) as ${kpiId}`)
            ].join(", ")};
                `;
            const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
            this.splitBuckets = results.records.map((r) => ({ ...r, selected: true })).sort(this.sortBlankToBottom);
            if (results.records.length > 50) {
              this.splitBuckets = [];
              this.errors.splitField.push("Select a field that includes as many as 50 unique values.");
            }
          }
          this.loadingMsg = "";
        }
      },
      mounted() {
        SPM.Components.AddSegmentsModal = this;
      },
      methods: {
        formatSummary(id2) {
          if (id2 === "__Bucket") {
            const groups = this.splitBuckets.filter((b) => b.selected).length;
            return `${this.$F("Numeric", groups)} ${groups === 1 ? "group" : "groups"} selected`;
          }
          return this.$F("Numeric", this.splitBuckets.filter((b) => b.selected).reduce((total, b) => total + (b[id2] || 0), 0));
        },
        selectBucket(bucket, shiftKey) {
          const bucketsToUpdate = [bucket];
          if (shiftKey && this.lastSelectedBucket) {
            const selectedBucketIndex = this.splitBuckets.findIndex((b) => b === bucket);
            let currentIndex = this.splitBuckets.findIndex((b) => b === this.lastSelectedBucket);
            while (currentIndex !== -1 && currentIndex !== selectedBucketIndex) {
              bucketsToUpdate.push(this.splitBuckets[currentIndex]);
              currentIndex += currentIndex > selectedBucketIndex ? -1 : 1;
            }
          }
          this.lastSelectedBucket = bucket;
          const newSelectionState = !bucket.selected;
          bucketsToUpdate.forEach((b) => b.selected = newSelectionState);
          SPM.Utils.Browser.clearSelection();
        },
        sortBlankToBottom(a, b) {
          if (a.__Bucket === b.__Bucket)
            return 0;
          if (a.__Bucket === "<Blank>")
            return 1;
          return b.__Bucket === "<Blank>" ? -1 : 0;
        },
        async add() {
          this.loadingMsg = "Saving Segments...";
          if (this.tabId === "Split") {
            const { dataType } = this.splitFieldOptions.find((f) => f.id === this.splitFieldId);
            this.newSegments = this.splitBuckets.filter((b) => b.selected).map((b) => ({
              Name: b.__Bucket,
              sfsp__SalesNodeRules__r: [{
                sobjectType: "sfsp__SalesNodeRule__c",
                Name: b.__Bucket,
                sfsp__SortOrder__c: 1,
                sfsp__FilterLogic__c: "custom",
                sfsp__BooleanFilter__c: "1",
                sfsp__SalesNodeRuleItems__r: [{
                  sobjectType: "sfsp__SalesNodeRuleItem__c",
                  sfsp__SortOrder__c: 1,
                  sfsp__Field__c: this.splitFieldId,
                  sfsp__Operator__c: dataType === "Numeric" ? "between" : "==",
                  sfsp__Value__c: dataType === "Numeric" ? `${b.__From},${b.__To}` : b.__Bucket.replace(/^<Blank>$/, "")
                }]
              }]
            }));
          }
          this.newSegments.forEach((s) => {
            Object.assign(s, {
              sobjectType: "sfsp__SalesNode__c",
              sfsp__SalesPlan__c: SPM.Components.Root.plan.Id,
              sfsp__Parent__c: this.config.parentId.replace("all_org", ""),
              sfsp__Owner__c: SPM.currentUser.Id,
              sfsp__Owner__r: SPM.currentUser
            });
          });
          await SPM.Utils.CRM.upsert({ records: this.newSegments });
          const rulesToInsert = this.newSegments.reduce((arr, s) => {
            const newRules = (s.sfsp__SalesNodeRules__r || []).map((r) => Object.assign(r, { sfsp__SalesNode__c: s.Id }));
            return arr.concat(newRules);
          }, []);
          await SPM.Utils.CRM.upsert({ records: rulesToInsert });
          const ruleItemsToInsert = rulesToInsert.reduce((arr, r) => {
            const newRuleItems = (r.sfsp__SalesNodeRuleItems__r || []).map((ri) => Object.assign(ri, { sfsp__SalesNodeRule__c: r.Id }));
            return arr.concat(newRuleItems);
          }, []);
          await SPM.Utils.CRM.upsert({ records: ruleItemsToInsert });
          SPM.Utils.CRM.upsert({
            records: this.newSegments.map((s) => ({
              sobjectType: "sfsp__SalesActivity__c",
              Name: `Create ${s.Name}`,
              sfsp__Description__c: "",
              sfsp__SalesPlan__c: s.sfsp__SalesPlan__c,
              sfsp__SalesNode__c: s.Id,
              sfsp__Type__c: "Segment",
              sfsp__Subtype__c: "Created"
            }))
          });
          SPM.Utils.Pendo.track("SP | Segmentation - Add segments", {
            planId: SPM.Components.Root.plan.Id,
            method: this.tabId,
            count: this.newSegments.length
          });
          this.config.callback({ newSegments: this.newSegments });
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$d = { key: 1 };
    const _hoisted_2$d = {
      class: "slds-p-right_xx-small",
      style: { "max-height": "20rem", "overflow": "auto" }
    };
    const _hoisted_3$b = ["for"];
    const _hoisted_4$a = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_5$a = ["id", "onUpdate:modelValue"];
    const _hoisted_6$9 = { key: 2 };
    const _hoisted_7$8 = {
      key: 0,
      class: "slds-m-top_small",
      style: { "max-height": "600px", "overflow": "auto" }
    };
    const _hoisted_8$8 = { class: "bucket-table slds-table slds-table_bordered slds-table_col-bordered" };
    const _hoisted_9$7 = { class: "summary-header" };
    const _hoisted_10$6 = { class: "column-header" };
    const _hoisted_11$6 = ["onClick"];
    const _hoisted_12$4 = {
      key: 0,
      class: "slds-grid"
    };
    const _hoisted_13$4 = { class: "slds-grid" };
    const _hoisted_14$3 = { class: "slds-col_bump-left" };
    function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Tab = resolveComponent("Tab");
      const _component_Tabs = resolveComponent("Tabs");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Button = resolveComponent("Button");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: "Add Segments",
        detach: "",
        headless: true,
        footless: !!$data.loadingMsg,
        onClose: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createTextVNode(toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createVNode(_component_Tabs, {
            modelValue: $data.tabId,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.tabId = $event),
            class: "add-segment-tabs"
          }, {
            default: withCtx(() => [
              createVNode(_component_Tab, {
                id: "Add",
                title: "Add",
                class: "slds-size_1-of-2"
              }),
              $options.hasDataSource ? (openBlock(), createBlock(_component_Tab, {
                key: 0,
                id: "Split",
                title: "Split",
                class: "slds-size_1-of-2"
              })) : createCommentVNode("", true)
            ]),
            _: 1
          }, 8, ["modelValue"]),
          $data.tabId === "Add" ? (openBlock(), createElementBlock("div", _hoisted_1$d, [
            createBaseVNode("div", _hoisted_2$d, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.newSegments, (newSegment, i) => {
                return openBlock(), createElementBlock("div", {
                  key: i,
                  class: "slds-m-bottom_x-small"
                }, [
                  createBaseVNode("label", {
                    class: "slds-form-element__label",
                    for: `new-segment-input-${i + 1}`
                  }, toDisplayString(`Segment Name ${i + 1}`), 9, _hoisted_3$b),
                  createBaseVNode("div", _hoisted_4$a, [
                    withDirectives(createBaseVNode("input", {
                      id: `new-segment-input-${i + 1}`,
                      "onUpdate:modelValue": ($event) => newSegment.Name = $event,
                      type: "text",
                      class: "slds-input"
                    }, null, 8, _hoisted_5$a), [
                      [vModelText, newSegment.Name]
                    ]),
                    createVNode(_component_ButtonIcon, {
                      class: "slds-col_bump-left",
                      iconCategory: "utility",
                      iconName: "close",
                      size: "small",
                      assistiveText: "Remove Segment",
                      title: "Remove Segment",
                      onClick: ($event) => $data.newSegments.splice(i, 1)
                    }, null, 8, ["onClick"])
                  ])
                ]);
              }), 128))
            ]),
            createVNode(_component_ButtonIcon, {
              iconCategory: "utility",
              iconName: "add",
              variant: "border-filled",
              size: "small",
              assistiveText: "Next Level",
              title: "Next Level",
              onClick: _cache[1] || (_cache[1] = ($event) => $data.newSegments.push({ Name: "" }))
            })
          ])) : createCommentVNode("", true),
          $data.tabId === "Split" ? (openBlock(), createElementBlock("div", _hoisted_6$9, [
            createVNode(_component_Picklist, {
              modelValue: $data.splitFieldId,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.splitFieldId = $event),
              labels: { name: "Field" },
              options: $data.splitFieldOptions,
              titleKey: "label",
              filterable: "",
              errors: $data.errors.splitField
            }, null, 8, ["modelValue", "options", "errors"]),
            $data.splitBuckets.length ? (openBlock(), createElementBlock("div", _hoisted_7$8, [
              createBaseVNode("table", _hoisted_8$8, [
                createBaseVNode("thead", null, [
                  createBaseVNode("tr", _hoisted_9$7, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.splitBucketColumns, (col) => {
                      return openBlock(), createElementBlock("td", {
                        key: col.id,
                        class: normalizeClass([col.id === "__Bucket" ? "Unique" : "Sum"])
                      }, toDisplayString($options.formatSummary(col.id)), 3);
                    }), 128))
                  ]),
                  createBaseVNode("tr", _hoisted_10$6, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList($data.splitBucketColumns, (col) => {
                      return openBlock(), createElementBlock("th", {
                        key: col.id
                      }, toDisplayString(col.label), 1);
                    }), 128))
                  ])
                ]),
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.splitBuckets, (bucket) => {
                    return openBlock(), createElementBlock("tr", {
                      key: bucket.__Bucket,
                      onClick: (e) => $options.selectBucket(bucket, e.shiftKey)
                    }, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($data.splitBucketColumns, (col) => {
                        return openBlock(), createElementBlock("td", {
                          key: col.id
                        }, [
                          col.id === "__Bucket" ? (openBlock(), createElementBlock("div", _hoisted_12$4, [
                            createBaseVNode("div", {
                              class: normalizeClass(["checkbox slds-m-right_x-small", { checked: bucket.selected }])
                            }, null, 2),
                            createTextVNode(" " + toDisplayString(bucket[col.id]), 1)
                          ])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                            createTextVNode(toDisplayString(_ctx.$F("Numeric", bucket[col.id])), 1)
                          ], 64))
                        ]);
                      }), 128))
                    ], 8, _hoisted_11$6);
                  }), 128))
                ])
              ])
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_13$4, [
              createBaseVNode("div", _hoisted_14$3, [
                createVNode(_component_Button, {
                  label: "Cancel",
                  onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("close"))
                }),
                createVNode(_component_Button, {
                  label: "Add",
                  variant: "brand",
                  onClick: $options.add
                }, null, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["footless"]);
    }
    const AddSegmentsModal = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d], ["__scopeId", "data-v-25913b15"]]);
    const _sfc_main$c = {
      name: "DuelingPicklist",
      components: {
        ButtonIcon,
        Icon
      },
      props: ["labels", "fields"],
      computed: {
        availableFields() {
          return this.fields.filter((f) => !f.selected);
        },
        selectedFields() {
          return this.fields.filter((f) => f.selected).sort((a, b) => {
            if (a.order < b.order)
              return -1;
            if (a.order > b.order)
              return 1;
            return 0;
          }).map((f, i) => Object.assign(f, { order: i + 1 }));
        }
      },
      methods: {
        moveToSelected() {
          this.availableFields.filter((f) => f.active).forEach((f) => {
            if (f.locked)
              return;
            f.selected = true;
            f.active = false;
            f.order = this.selectedFields.length + 1;
          });
        },
        moveToAvailable() {
          this.selectedFields.filter((f) => f.active).forEach((f) => {
            f.selected = false;
            f.active = false;
          });
          this.selectedFields.forEach((f, i) => f.order = i + 1);
        },
        moveUp() {
          this.selectedFields.forEach((f, i) => {
            if (f.active && f.order > 1) {
              this.selectedFields[i - 1].order += 1;
              f.order -= 1;
            }
          });
        },
        moveDown() {
          this.selectedFields.forEach((f, i) => {
            if (f.active && f.order < this.selectedFields.length) {
              this.selectedFields[i + 1].order -= 1;
              f.order += 1;
            }
          });
        }
      }
    };
    const _hoisted_1$c = { key: 0 };
    const _hoisted_2$c = { class: "slds-form-element__label" };
    const _hoisted_3$a = { class: "slds-dueling-list" };
    const _hoisted_4$9 = { class: "slds-dueling-list__column slds-size_5-of-12" };
    const _hoisted_5$9 = {
      class: "slds-form-element__label",
      style: { "position": "relative" }
    };
    const _hoisted_6$8 = { style: { "position": "absolute", "top": "0", "right": "0" } };
    const _hoisted_7$7 = {
      class: "slds-dueling-list__options",
      style: { "width": "auto" }
    };
    const _hoisted_8$7 = {
      "aria-multiselectable": "true",
      class: "slds-listbox slds-listbox_vertical",
      role: "listbox"
    };
    const _hoisted_9$6 = ["onClick"];
    const _hoisted_10$5 = ["aria-selected", "aria-disabled"];
    const _hoisted_11$5 = { class: "slds-media__body slds-grid" };
    const _hoisted_12$3 = ["title"];
    const _hoisted_13$3 = ["title"];
    const _hoisted_14$2 = {
      key: 2,
      class: "slds-icon_container slds-current-color"
    };
    const _hoisted_15$1 = { class: "slds-dueling-list__column" };
    const _hoisted_16$1 = { class: "slds-dueling-list__column slds-size_5-of-12" };
    const _hoisted_17$1 = { class: "slds-form-element__label" };
    const _hoisted_18$1 = {
      class: "slds-dueling-list__options",
      style: { "width": "auto" }
    };
    const _hoisted_19$1 = {
      "aria-multiselectable": "true",
      class: "slds-listbox slds-listbox_vertical",
      role: "listbox"
    };
    const _hoisted_20$1 = ["onClick"];
    const _hoisted_21$1 = ["aria-selected", "aria-disabled"];
    const _hoisted_22 = { class: "slds-media__body" };
    const _hoisted_23 = ["title"];
    const _hoisted_24 = {
      key: 0,
      class: "slds-icon_container slds-current-color"
    };
    const _hoisted_25 = { class: "slds-dueling-list__column" };
    function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
      var _a, _b, _c;
      const _component_Icon = resolveComponent("Icon");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        ((_a = $props.labels) == null ? void 0 : _a.name) ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
          createBaseVNode("label", _hoisted_2$c, [
            createBaseVNode("strong", null, toDisplayString($props.labels.name), 1)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$a, [
          createBaseVNode("div", _hoisted_4$9, [
            createBaseVNode("span", _hoisted_5$9, [
              createTextVNode(toDisplayString(((_b = $props.labels) == null ? void 0 : _b.available) || "Available") + " ", 1),
              createBaseVNode("div", _hoisted_6$8, [
                createBaseVNode("button", {
                  class: "slds-button slds-m-around_none",
                  onClick: _cache[0] || (_cache[0] = ($event) => {
                    $props.fields.forEach((f, i) => {
                      if (!f.locked)
                        f.selected = true;
                      f.active = false;
                      f.order = i + 1;
                    });
                  })
                }, "Select All"),
                createTextVNode(" | "),
                createBaseVNode("button", {
                  class: "slds-button slds-m-around_none",
                  onClick: _cache[1] || (_cache[1] = ($event) => {
                    $props.fields.filter((f) => !f.locked).forEach((f) => {
                      f.selected = false;
                      f.active = false;
                      f.locked = f.message ? true : false;
                    });
                  })
                }, "None")
              ])
            ]),
            createBaseVNode("div", _hoisted_7$7, [
              createBaseVNode("ul", _hoisted_8$7, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.availableFields, (field, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    role: "presentation",
                    class: "slds-listbox__item",
                    onClick: ($event) => field.active = !field.active && !field.locked
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline", { active: field.active }]),
                      "aria-selected": field.active,
                      role: "option",
                      "aria-disabled": field.locked
                    }, [
                      createBaseVNode("span", _hoisted_11$5, [
                        field.locked ? (openBlock(), createElementBlock("span", {
                          key: 0,
                          class: "slds-truncate",
                          title: `${field.message}`
                        }, toDisplayString(field.label), 9, _hoisted_12$3)) : (openBlock(), createElementBlock("span", {
                          key: 1,
                          class: "slds-truncate",
                          title: field.label
                        }, toDisplayString(field.label), 9, _hoisted_13$3)),
                        field.locked ? (openBlock(), createElementBlock("span", _hoisted_14$2, [
                          createVNode(_component_Icon, {
                            category: "utility",
                            name: "warning",
                            size: "x-small",
                            class: "slds-media__figure slds-media__figure_reverse"
                          })
                        ])) : createCommentVNode("", true)
                      ]),
                      renderSlot(_ctx.$slots, "fieldEnd", normalizeProps(guardReactiveProps({ field })))
                    ], 10, _hoisted_10$5)
                  ], 8, _hoisted_9$6);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$1, [
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection to Second Category",
              iconCategory: "utility",
              iconName: "right",
              title: "Move Selection to Second Category",
              variant: "container",
              onClick: $options.moveToSelected
            }, null, 8, ["onClick"]),
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection to First Category",
              iconCategory: "utility",
              iconName: "left",
              title: "Move Selection to First Category",
              variant: "container",
              onClick: $options.moveToAvailable
            }, null, 8, ["onClick"])
          ]),
          createBaseVNode("div", _hoisted_16$1, [
            createBaseVNode("span", _hoisted_17$1, toDisplayString(((_c = $props.labels) == null ? void 0 : _c.selected) || "Selected"), 1),
            createBaseVNode("div", _hoisted_18$1, [
              createBaseVNode("ul", _hoisted_19$1, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.selectedFields, (field, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    role: "presentation",
                    class: "slds-listbox__item",
                    onClick: ($event) => field.active = !field.active && !field.locked
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline", { active: field.active }]),
                      "aria-selected": field.active,
                      "aria-disabled": field.locked,
                      role: "option"
                    }, [
                      createBaseVNode("span", _hoisted_22, [
                        createBaseVNode("span", {
                          class: "slds-truncate",
                          title: field.label
                        }, toDisplayString(field.label), 9, _hoisted_23)
                      ]),
                      field.locked ? (openBlock(), createElementBlock("span", _hoisted_24, [
                        createVNode(_component_Icon, {
                          category: "utility",
                          name: "lock",
                          size: "x-small",
                          class: "slds-media__figure slds-media__figure_reverse"
                        })
                      ])) : createCommentVNode("", true),
                      renderSlot(_ctx.$slots, "fieldEnd", normalizeProps(guardReactiveProps({ field })))
                    ], 10, _hoisted_21$1)
                  ], 8, _hoisted_20$1);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_25, [
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection Up",
              iconCategory: "utility",
              iconName: "up",
              title: "Move Selection Up",
              variant: "container",
              onClick: $options.moveUp
            }, null, 8, ["onClick"]),
            createVNode(_component_ButtonIcon, {
              assistiveText: "Move Selection Down",
              iconCategory: "utility",
              iconName: "down",
              title: "Move Selection Down",
              variant: "container",
              onClick: $options.moveDown
            }, null, 8, ["onClick"])
          ])
        ])
      ]);
    }
    const DuelingPicklist = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
    const _sfc_main$b = {
      name: "ErrorPopover",
      components: {
        ButtonIcon,
        Popover
      },
      props: {
        error: String,
        errors: Object,
        lazy: Boolean,
        refs: Object
      },
      data() {
        return {
          renderPopover: false
        };
      },
      mounted() {
        SPM.Components.FormErrorIndicator = this;
        if (!this.lazy)
          this.renderPopover = true;
      },
      methods: {
        focusElementWithError(error) {
          this.renderPopover = false;
          this.$nextTick(() => this.refs[error.ref].focus());
        }
      }
    };
    const _hoisted_1$b = /* @__PURE__ */ createBaseVNode("span", null, "We hit a snag.", -1);
    const _hoisted_2$b = { key: 0 };
    const _hoisted_3$9 = /* @__PURE__ */ createBaseVNode("div", { style: { "margin-bottom": "0.25rem", "margin-left": "-0.5rem", "font-weight": "600" } }, " Review the following fields ", -1);
    const _hoisted_4$8 = {
      class: "slds-m-left_medium",
      style: { "list-style": "disc" }
    };
    const _hoisted_5$8 = ["onClick"];
    function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Popover = resolveComponent("Popover");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_ButtonIcon, {
          ref: "errorButtonIcon",
          assistiveText: "Error",
          title: "Error",
          iconCategory: "utility",
          iconName: "error",
          iconSize: "large",
          class: "slds-button_icon-error",
          onClick: _cache[0] || (_cache[0] = ($event) => $data.renderPopover = !$data.renderPopover)
        }, null, 512),
        $data.renderPopover ? (openBlock(), createBlock(_component_Popover, {
          key: 0,
          ref: "errorPopover",
          bindTo: _ctx.$refs.errorButtonIcon.$el,
          theme: "error",
          width: "medium",
          class: "slds-text-align_left",
          onClose: _cache[1] || (_cache[1] = ($event) => $data.renderPopover = false)
        }, {
          header: withCtx(() => [
            _hoisted_1$b
          ]),
          content: withCtx(() => [
            $props.error ? (openBlock(), createElementBlock("div", _hoisted_2$b, toDisplayString($props.error), 1)) : createCommentVNode("", true),
            $props.errors ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _hoisted_3$9,
              createBaseVNode("ul", _hoisted_4$8, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.errors, (error, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    class: normalizeClass({ "slds-text-link": error.ref }),
                    onClick: ($event) => $options.focusElementWithError(error)
                  }, toDisplayString(error.message), 11, _hoisted_5$8);
                }), 128))
              ])
            ], 64)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["bindTo"])) : createCommentVNode("", true)
      ], 64);
    }
    const FormErrorIndicator = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
    const _sfc_main$a = {
      name: "ConfigureModal",
      components: {
        DuelingPicklist,
        FormErrorIndicator,
        // slds vue
        SLDSButton: Button,
        Modal,
        Spinner
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loadingMsg: "Loading...",
          errorMsg: "",
          columns: []
        };
      },
      async mounted() {
        SPM.Components.ConfigureColumnsModal = this;
        const visibleColumnIds = (SPM.Components.ViewRecords.isRecordMode ? SPM.Components.RecordTable : SPM.Components.BucketTable).visibleColumnIds;
        this.columns = SPM.Components.Root.plan.sfsp__SalesDataSource__r._referenceFields.reduce((arr, f, i) => {
          if (SPM.Components.ViewRecords.isRecordMode || f.dataType === "Numeric") {
            const currentIndex = visibleColumnIds.findIndex((id2) => id2 === f.id);
            arr.push({
              id: f.id,
              label: f.label,
              selected: currentIndex !== -1,
              locked: SPM.Components.ViewRecords.isRecordMode && f.isId,
              order: currentIndex === -1 ? i + 1 : currentIndex,
              active: false
            });
          }
          return arr;
        }, []);
        this.loadingMsg = "";
      },
      methods: {
        async save() {
          const newVisibleColumnIds = this.columns.filter((c) => c.selected).sort(({ order: a }, { order: b }) => a === b ? 0 : a > b ? 1 : -1).map((c) => c.id);
          if (newVisibleColumnIds.length === 0) {
            this.errorMsg = "Please select at least one column";
            return;
          }
          if (SPM.Components.ViewRecords.isRecordMode) {
            SPM.Components.RecordTable.visibleColumnIds = newVisibleColumnIds;
            SPM.Components.Root.preferences.recordView = newVisibleColumnIds;
            SPM.Components.RecordTable.loadRecords();
          } else {
            SPM.Components.BucketTable.visibleColumnIds = newVisibleColumnIds;
            SPM.Components.Root.preferences.groupView = newVisibleColumnIds;
            SPM.Components.BucketTable.loadRoot();
          }
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$a = { class: "slds-grid" };
    const _hoisted_2$a = { class: "slds-col_bump-left" };
    const _hoisted_3$8 = { class: "slds-m-right_x-small" };
    function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_DuelingPicklist = resolveComponent("DuelingPicklist");
      const _component_FormErrorIndicator = resolveComponent("FormErrorIndicator");
      const _component_SLDSButton = resolveComponent("SLDSButton");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        title: "Select Columns to Display",
        size: "base",
        detach: "",
        onClose: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createVNode(_component_DuelingPicklist, {
            class: "slds-m-top_small",
            fields: $data.columns
          }, null, 8, ["fields"])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_1$a, [
              createBaseVNode("div", _hoisted_2$a, [
                createBaseVNode("span", _hoisted_3$8, [
                  $data.errorMsg ? (openBlock(), createBlock(_component_FormErrorIndicator, {
                    key: 0,
                    error: $data.errorMsg
                  }, null, 8, ["error"])) : createCommentVNode("", true)
                ]),
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("close"))
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }),
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_brand",
                  onClick: $options.save
                }, {
                  default: withCtx(() => [
                    createTextVNode("Save")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      });
    }
    const ConfigureColumnsModal = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
    const _sfc_main$9 = {
      name: "RecordTable",
      components: {
        Spinner,
        Checkbox,
        Icon
      },
      props: ["segmentId", "filters"],
      emits: ["selection-updated"],
      data() {
        return {
          loading: true,
          sortField: "",
          sortDir: "desc",
          records: [],
          // columns
          visibleColumnIds: SPM.Components.Root.preferences.recordView
        };
      },
      computed: {
        fields() {
          return this.visibleColumnIds.map((id2) => SPM.Components.OrgView.dataSource._referenceFields.find((f) => f.id === id2));
        },
        idField() {
          return this.fields.find((f) => f.isId);
        },
        nameField() {
          return this.fields.find((f) => f.isName);
        },
        columns() {
          const columns = [...this.fields];
          if (columns.find((c) => c.isId) && columns.find((c) => c.isName)) {
            const idColumn = SPM.Utils.Arr.splice(columns, (c) => c.isId)[0];
            const nameColumn = idColumn.isName ? idColumn : SPM.Utils.Arr.splice(columns, (c) => c.isName)[0];
            columns.unshift({ isIdName: true, label: nameColumn.label, id: idColumn.id, nameFieldId: nameColumn.id, dataType: "Text" });
          }
          return columns.sort((a, b) => a.isName ? 1 : b.isName ? -1 : 0);
        },
        selectionSummary() {
          const aggregates = this.columns.reduce((map2, f) => {
            map2[f.id] = f.dataType === "Text" ? /* @__PURE__ */ new Set() : 0;
            return map2;
          }, {});
          const selectedRecords = [];
          this.records.forEach((r) => {
            if (!r._selected)
              return;
            selectedRecords.push(r);
            this.columns.forEach((f) => {
              switch (f.dataType) {
                case "Text":
                  aggregates[f.id].add(r[f.id]);
                  break;
                case "Numeric":
                  aggregates[f.id] += r[f.id] || 0;
                  break;
              }
            });
          });
          return {
            records: selectedRecords,
            rules: selectedRecords.length === 0 ? [] : [{
              sobjectType: "sfsp__SalesNodeRule__c",
              Name: selectedRecords.map((r) => {
                var _a;
                return r[((_a = this == null ? void 0 : this.nameField) == null ? void 0 : _a.id) || this.idField.id];
              }).join(", ").slice(0, 80),
              sfsp__FilterLogic__c: "custom",
              sfsp__BooleanFilter__c: "1",
              sfsp__SalesNodeRuleItems__r: [{
                sobjectType: "sfsp__SalesNodeRuleItem__c",
                sfsp__Field__c: this.idField.id,
                sfsp__Operator__c: "==",
                sfsp__Value__c: selectedRecords.map((r) => r[this.idField.id]).join(","),
                sfsp__SortOrder__c: 1
              }]
            }],
            aggregates,
            columns: this.columns.reduce((map2, { dataType, id: id2 }) => {
              switch (dataType) {
                case "Text":
                  const val = aggregates[id2].size;
                  map2[id2] = `${this.$F("Numeric", val)} ${val === 1 ? "value" : "values"}`;
                  break;
                case "Numeric":
                  map2[id2] = this.$F("Numeric", aggregates[id2]);
                  break;
              }
              return map2;
            }, {})
          };
        }
      },
      watch: {
        filters: {
          handler() {
            this.loading = true;
            clearTimeout(this.loadRecordsTimeout);
            this.loadRecordsTimeout = setTimeout(this.loadRecords, 500);
          },
          deep: true,
          immediate: true
        },
        selectionSummary() {
          this.$emit("selection-updated");
        }
      },
      async mounted() {
        SPM.Components.RecordTable = this;
      },
      methods: {
        // saql
        nodeSaql() {
          return SPM.Utils.Segment.Node.generateNodeFilterSaql({
            node: SPM.Components.Root.nodeMap[this.segmentId],
            nodeMap: SPM.Components.Root.nodeMap,
            dataSource: SPM.Components.OrgView.dataSource,
            isBurndown: this.filters.isBurndown
          });
        },
        projectionSaql() {
          return this.fields.reduce((arr, f) => [
            `sum(${f.id}) as sum__${f.id}`,
            `floor(min(${f.id})) as min__${f.id}`,
            `floor(max(${f.id})) as max__${f.id}`
          ].concat(arr), []).join(", ");
        },
        // records
        async loadRecords() {
          var _a;
          this.loading = true;
          const requestKey = this.loadRecordsRequestKey = SPM.Utils.getGUID();
          const saql = `
                ${this.nodeSaql()}

                ${((_a = this.filters.searchTerm) == null ? void 0 : _a.length) > 1 ? `
                    -- Search
                    results = filter results by ${SPM.Utils.Segment.Filter.toSaql({ field: this.nameField.id, operator: "matches", value: this.filters.searchTerm, dataType: "Text" })};
                ` : ""}

                ${this.sortField ? `
                    -- Sort By
                    results = order results by ${this.sortField} ${this.sortDir};
                ` : ""}

                -- results
                results = foreach results generate ${this.fields.map((f) => `${f.id} as ${f.id}`).join(", ")};
                results = limit results 10;
            `;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          if (requestKey === this.loadRecordsRequestKey) {
            this.records = results.records.map((r) => ({ ...r, _selected: false }));
            this.loadRecordsRequestKey = null;
            this.loading = false;
          }
        },
        async sort(field) {
          if (this.sortField === field.id) {
            this.sortDir = this.sortDir === "asc" ? "desc" : "asc";
          } else {
            this.sortField = field.id;
            this.sortDir = "desc";
          }
          this.loadRecords();
        },
        selectRecord(record, shiftKey) {
          const recordsToUpdate = [record];
          if (shiftKey && this.lastSelectedRecord) {
            const selectedRecordIndex = this.records.findIndex((r) => r === record);
            let currentIndex = this.records.findIndex((r) => r === this.lastSelectedRecord);
            while (currentIndex !== -1 && currentIndex !== selectedRecordIndex) {
              recordsToUpdate.push(this.records[currentIndex]);
              currentIndex += currentIndex > selectedRecordIndex ? -1 : 1;
            }
          }
          this.lastSelectedRecord = record;
          const newSelectionState = !record._selected;
          recordsToUpdate.forEach((r) => r._selected = newSelectionState);
          SPM.Utils.Browser.clearSelection();
        }
      }
    };
    const _withScopeId$3 = (n) => (pushScopeId("data-v-5440e65e"), n = n(), popScopeId(), n);
    const _hoisted_1$9 = { style: { "position": "relative" } };
    const _hoisted_2$9 = { style: { "max-height": "calc(100% - 30px)", "overflow": "auto" } };
    const _hoisted_3$7 = { class: "record-table spm-table slds-table slds-table_bordered slds-table_col-bordered" };
    const _hoisted_4$7 = { class: "summary-header" };
    const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("td", { style: { "width": "1px" } }, null, -1));
    const _hoisted_6$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("th", null, null, -1));
    const _hoisted_7$6 = ["onClick"];
    const _hoisted_8$6 = ["href"];
    const _hoisted_9$5 = {
      key: 1,
      class: "slds-text-align_center slds-m-vertical_large"
    };
    const _hoisted_10$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-heading_medium slds-p-bottom_x-small" }, "No Results", -1));
    const _hoisted_11$4 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-body_regular" }, "Adjust filters or add rules to add records to this segment", -1));
    const _hoisted_12$2 = [
      _hoisted_10$4,
      _hoisted_11$4
    ];
    const _hoisted_13$2 = {
      key: 2,
      class: "slds-text-align_center slds-m-top_small"
    };
    function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Icon = resolveComponent("Icon");
      const _component_Checkbox = resolveComponent("Checkbox");
      return openBlock(), createElementBlock("div", _hoisted_1$9, [
        $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$9, [
          createBaseVNode("table", _hoisted_3$7, [
            createBaseVNode("thead", null, [
              createBaseVNode("tr", _hoisted_4$7, [
                _hoisted_5$7,
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column, i) => {
                  return openBlock(), createElementBlock("td", {
                    key: i,
                    class: normalizeClass(column.dataType)
                  }, [
                    createBaseVNode("span", null, toDisplayString($options.selectionSummary.columns[column.id]), 1)
                  ], 2);
                }), 128))
              ]),
              createBaseVNode("tr", {
                class: normalizeClass(["column-header", $data.sortDir === "desc" ? "sort-desc" : "sort-asc"])
              }, [
                _hoisted_6$7,
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column) => {
                  return openBlock(), createElementBlock("th", {
                    key: column.id,
                    class: normalizeClass({ sorted: column.id === $data.sortField }),
                    onClick: ($event) => $options.sort(column)
                  }, [
                    createTextVNode(toDisplayString(column.label) + " ", 1),
                    createVNode(_component_Icon, {
                      class: "sort-indicator",
                      category: "utility",
                      name: "arrowup",
                      iconClass: ["slds-icon_xx-small"]
                    })
                  ], 10, _hoisted_7$6);
                }), 128))
              ], 2)
            ]),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.records, (record) => {
                return openBlock(), createElementBlock("tr", {
                  key: record[$options.idField.id]
                }, [
                  createBaseVNode("td", null, [
                    createVNode(_component_Checkbox, {
                      modelValue: record._selected,
                      labels: { name: record[$options.idField.id] },
                      hideLabel: "",
                      onClick: withModifiers((e) => $options.selectRecord(record, e.shiftKey), ["prevent"])
                    }, null, 8, ["modelValue", "labels", "onClick"])
                  ]),
                  (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column) => {
                    return openBlock(), createElementBlock("td", {
                      key: column.id
                    }, [
                      column.isIdName ? (openBlock(), createElementBlock("a", {
                        key: 0,
                        href: `/${record[column.id]}`,
                        target: "_blank"
                      }, toDisplayString(record[column.nameFieldId]), 9, _hoisted_8$6)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                        createTextVNode(toDisplayString(column.dataType === "Text" ? record[column.id] : _ctx.$F("Numeric", record[column.id])), 1)
                      ], 64))
                    ]);
                  }), 128))
                ]);
              }), 128))
            ])
          ])
        ]),
        !$data.loading && !$data.records.length ? (openBlock(), createElementBlock("div", _hoisted_9$5, _hoisted_12$2)) : !$data.loading ? (openBlock(), createElementBlock("div", _hoisted_13$2, "10 records max appear here. Use search to view different ones.")) : createCommentVNode("", true)
      ]);
    }
    const RecordTable = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-5440e65e"]]);
    const _sfc_main$8 = {
      name: "BucketTable",
      components: {
        Spinner,
        ButtonIcon,
        Checkbox,
        Picklist,
        Popover
      },
      props: ["segmentId", "filters"],
      emits: ["selection-updated"],
      data() {
        return {
          loading: true,
          // buckets
          bucketHierarchy: null,
          // split popover
          splitPopoverConfig: null,
          splitFieldOptions: SPM.Components.OrgView.dataSource._referenceFields,
          // columns
          visibleColumnIds: SPM.Components.Root.preferences.groupView
        };
      },
      computed: {
        fields() {
          return this.visibleColumnIds.map((id2) => SPM.Components.OrgView.dataSource._referenceFields.find((f) => f.id === id2));
        },
        numericFields() {
          return this.splitFieldOptions.filter((f) => f.dataType === "Numeric");
        },
        idField() {
          return SPM.Components.OrgView.dataSource._referenceFields.find((f) => f.isId);
        },
        columns() {
          const { maxDepth } = SPM.Utils.Tree.inspect({ node: this.bucketHierarchy });
          return [
            { label: "Bucket", type: "Bucket", id: "__Bucket" },
            ...Array(maxDepth - 1).fill().map((item, i) => ({ label: `Group ${i + 2}`, type: "Group", id: `Group ${i + 2}` })),
            { label: "Records", type: "Value", id: "__Records" },
            ...this.fields.map((f) => ({ label: f.label, type: "Sum", id: f.id }))
          ];
        },
        rows() {
          var _a;
          if (!((_a = this == null ? void 0 : this.bucketHierarchy) == null ? void 0 : _a.values))
            return [];
          const { nodeCount, maxDepth } = SPM.Utils.Tree.inspect({ node: this.bucketHierarchy });
          const rows = [];
          for (let i = 0; i < nodeCount; i++)
            rows.push({ cells: [] });
          const createCells = (bucket, depth, rowIndex) => {
            const bucketCell = {
              type: bucket.splitField ? "Split Bucket" : "Bucket",
              label: bucket.id,
              attr: {
                class: ["bucket-cell", bucket.splitField ? "split" : "", bucket.selected !== "none" ? "selected" : ""]
              },
              bucket
            };
            rows[rowIndex].cells.push(bucketCell);
            let currentRowIndex = rowIndex;
            if (bucket.splitField) {
              bucket.children.forEach((b, i) => currentRowIndex = createCells(b, depth + 1, currentRowIndex + (i === 0 ? 0 : 1)));
              rows[++currentRowIndex].cells.push(
                {
                  label: "Subtotal",
                  attr: {
                    colspan: maxDepth - depth - 1,
                    class: ["subtotal-cell"]
                  }
                },
                {
                  label: this.$F("Numeric", bucket.values.__Records),
                  attr: {
                    class: ["subtotal-cell"]
                  }
                },
                ...this.fields.map((f) => ({
                  label: this.$F("Numeric", bucket.values[`sum__${f.id}`]),
                  attr: {
                    class: ["subtotal-cell"]
                  }
                }))
              );
              bucketCell.label += ` -> ${bucket.splitField}`;
              bucketCell.attr.rowspan = currentRowIndex - rowIndex + 1;
            } else {
              for (let i = depth + 1; i < maxDepth; i++) {
                rows[currentRowIndex].cells.push({
                  label: "-"
                });
              }
              rows[currentRowIndex].cells.push({ label: this.$F("Numeric", bucket.values.__Records) });
              this.fields.forEach((f) => {
                rows[currentRowIndex].cells.push({
                  label: this.$F("Numeric", bucket.values[`sum__${f.id}`])
                });
              });
            }
            return currentRowIndex;
          };
          createCells(this.bucketHierarchy, 0, 0);
          return rows;
        },
        selectionSummary() {
          var _a;
          if (!((_a = this == null ? void 0 : this.bucketHierarchy) == null ? void 0 : _a.values))
            return { rules: [], aggregates: {}, columns: [] };
          const rules = [];
          const aggregates = this.columns.reduce((map2, f) => {
            map2[f.id] = 0;
            return map2;
          }, {});
          const traverse2 = (buckets, depth) => {
            const currentLevelSelectedBuckets = buckets.filter((b) => !b.splitField && b.selected === "all");
            if (currentLevelSelectedBuckets.length) {
              const parent = currentLevelSelectedBuckets[0].parent;
              const booleanFilterParts = [];
              const ruleItems = [];
              if (parent) {
                booleanFilterParts.push(...parent.ruleItems.map((ri, i) => i + 1));
                ruleItems.push(...parent.ruleItems);
                const field = this.splitFieldOptions.find((f) => f.id === parent.splitField);
                if (field.dataType === "Text") {
                  booleanFilterParts.push(String(parent.ruleItems.length + 1));
                  ruleItems.push({
                    sobjectType: "sfsp__SalesNodeRuleItem__c",
                    sfsp__Field__c: field.id,
                    sfsp__Operator__c: "==",
                    sfsp__Value__c: currentLevelSelectedBuckets.map((b) => b.id.replace(/^<Blank>$/, "")).join(",")
                  });
                } else {
                  const indices = currentLevelSelectedBuckets.map((b, index) => parent.ruleItems.length + index + 1);
                  booleanFilterParts.push(`(${indices.join(" or ")})`);
                  ruleItems.push(...currentLevelSelectedBuckets.map((b) => b.ruleItems.at(-1)));
                }
              } else {
                booleanFilterParts.push(1);
                ruleItems.push({
                  sobjectType: "sfsp__SalesNodeRuleItem__c",
                  sfsp__Field__c: this.idField.id,
                  sfsp__Operator__c: "!=",
                  sfsp__Value__c: ""
                });
              }
              rules.push({
                sobjectType: "sfsp__SalesNodeRule__c",
                Name: currentLevelSelectedBuckets[0].ruleItems.reduce((arr, ri) => arr.concat(this.splitFieldOptions.find((f) => f.id === ri.sfsp__Field__c).label), []).join(" -> ") || "All",
                sfsp__FilterLogic__c: "custom",
                sfsp__BooleanFilter__c: booleanFilterParts.join(" and "),
                sfsp__SalesNodeRuleItems__r: ruleItems.map((ruleItem, i) => ({
                  ...ruleItem,
                  sfsp__SortOrder__c: i + 1
                }))
              });
              this.columns.forEach((column, columnIndex) => {
                switch (column.type) {
                  case "Sum":
                    aggregates[column.id] += currentLevelSelectedBuckets.reduce((total, bucket) => total + (bucket.values[`sum__${column.id}`] || 0), 0);
                    break;
                  case "Value":
                    aggregates[column.id] += currentLevelSelectedBuckets.reduce((total, bucket) => total + (bucket.values[column.id] || 0), 0);
                    break;
                  case "Group":
                    aggregates[column.id] += columnIndex === depth ? currentLevelSelectedBuckets.length : 0;
                    break;
                  case "Bucket":
                    aggregates[column.id] += currentLevelSelectedBuckets.reduce((total, bucket) => total + bucket.values.__Records, 0);
                    break;
                }
              });
            }
            buckets.filter((b) => b.selected === "some" || b.splitField && b.selected === "all").forEach((b) => traverse2(b.children, depth + 1));
          };
          traverse2([this.bucketHierarchy], 0);
          return {
            rules,
            aggregates,
            columns: this.columns.reduce((map2, { type, id: id2 }) => {
              switch (type) {
                case "Sum":
                case "Value":
                  map2[id2] = this.$F("Numeric", aggregates[id2]);
                  break;
                case "Bucket":
                  const bucketUnits = aggregates.__Bucket;
                  const totalUnits = this.bucketHierarchy.values.__Records;
                  map2[id2] = `${this.$F("Numeric", bucketUnits)} of ${this.$F("Numeric", totalUnits)} ${totalUnits === 1 ? "item" : "items"} selected`;
                  break;
                case "Group":
                  const groups = aggregates[id2];
                  map2[id2] = `${this.$F("Numeric", groups)} ${groups === 1 ? "group" : "groups"} selected`;
                  break;
              }
              return map2;
            }, {})
          };
        }
      },
      watch: {
        filters: {
          handler() {
            this.loadRoot();
          },
          deep: true,
          immediate: true
        },
        selectionSummary() {
          this.$emit("selection-updated");
        }
      },
      async mounted() {
        SPM.Components.BucketTable = this;
      },
      methods: {
        // saql
        nodeSaql({ bucket } = {}) {
          var _a;
          let saql = SPM.Utils.Segment.Node.generateNodeFilterSaql({
            node: SPM.Components.Root.nodeMap[this.segmentId],
            nodeMap: SPM.Components.Root.nodeMap,
            dataSource: SPM.Components.OrgView.dataSource,
            isBurndown: this.filters.isBurndown
          });
          if ((_a = bucket == null ? void 0 : bucket.ruleItems) == null ? void 0 : _a.length) {
            const filters = bucket.ruleItems.map((ri) => SPM.Utils.Segment.Filter.toSaql({
              field: ri.sfsp__Field__c,
              operator: ri.sfsp__Operator__c,
              value: ri.sfsp__Value__c,
              dataType: ri._dataType
            }));
            saql += `
                    -- parent bucket filters
                    results = filter results by ${filters.join(" && ")};
                `;
          }
          return saql;
        },
        projectionSaql(fields) {
          return fields.reduce((arr, f) => [
            `sum(${f.id}) as sum__${f.id}`,
            `floor(min(${f.id})) as min__${f.id}`,
            `floor(max(${f.id})) as max__${f.id}`
          ].concat(arr), []).join(", ");
        },
        // buckets
        toggleBucket(bucket) {
          if (bucket.splitField)
            return this.unsplit(bucket);
          this.splitPopoverConfig = {
            bucket,
            callback: ({ field, ranges }) => {
              this.split({ bucket, field, ranges });
              this.splitPopoverConfig = null;
            }
          };
          this.$nextTick(() => {
            var _a;
            return (_a = this.$el.querySelector(".slds-popover .slds-input")) == null ? void 0 : _a.focus();
          });
        },
        selectBucket(bucket, shiftKey) {
          var _a;
          const bucketsToUpdate = [bucket];
          if (shiftKey && this.lastSelectedBucket) {
            const bucketsToConsider = ((_a = bucket == null ? void 0 : bucket.parent) == null ? void 0 : _a.children) || [];
            const selectedBucketIndex = bucketsToConsider.findIndex((b) => b === bucket);
            let currentIndex = bucketsToConsider.findIndex((b) => b === this.lastSelectedBucket);
            while (currentIndex !== -1 && currentIndex !== selectedBucketIndex) {
              bucketsToUpdate.push(bucketsToConsider[currentIndex]);
              currentIndex += currentIndex > selectedBucketIndex ? -1 : 1;
            }
          }
          this.lastSelectedBucket = bucket;
          const newSelectionState = bucket.selected === "none" ? "all" : "none";
          bucketsToUpdate.forEach((b) => {
            b.selected = newSelectionState;
            const traverse2 = (child) => {
              var _a2;
              (_a2 = child == null ? void 0 : child.children) == null ? void 0 : _a2.forEach((descendant) => {
                descendant.selected = newSelectionState;
                traverse2(descendant);
              });
            };
            traverse2(b);
          });
          let parent = bucket.parent;
          while (parent) {
            this.updateBucketState(parent);
            parent = parent.parent;
          }
          SPM.Utils.Browser.clearSelection();
        },
        removeSelectedBuckets() {
          if (this.bucketHierarchy.selected === "all") {
            delete this.bucketHierarchy.values;
            this.bucketHierarchy.children.splice(0);
            return;
          }
          const removeBuckets = (buckets) => {
            buckets.forEach((b) => {
              SPM.Utils.Arr.splice(b.children, (b2) => b2.selected === "all");
              removeBuckets(b.children);
              this.updateBucketState(b);
            });
          };
          removeBuckets([this.bucketHierarchy]);
        },
        updateBucketState(bucket) {
          let hasSelected = false;
          let hasUnselected = false;
          bucket.children.some((child) => {
            if (child.selected !== "none")
              hasSelected = true;
            if (child.selected !== "all")
              hasUnselected = true;
            if (hasSelected && hasUnselected)
              return true;
          });
          bucket.selected = hasSelected ? hasUnselected ? "some" : "all" : "none";
          if (bucket.splitField) {
            Object.keys(bucket.values).forEach((key) => {
              if (key === "__Bucket")
                return;
              bucket.values[key] = bucket.children.reduce((value, child, i) => {
                const childValue = child.values[key] || 0;
                if (key.startsWith("min__"))
                  return i === 0 ? childValue : Math.min(value, childValue);
                if (key.startsWith("max__"))
                  return i === 0 ? childValue : Math.max(value, childValue);
                return value + childValue;
              }, 0);
            });
          }
        },
        // splits
        async loadRoot() {
          this.loading = true;
          const saql = `
                ${this.nodeSaql()}

                -- results
                results = group results by all;
                results = foreach results generate count() as __Records, ${this.projectionSaql(this.numericFields)};
            `;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          this.bucketHierarchy = {
            id: "All",
            selected: "none",
            values: results.records[0],
            ruleItems: [],
            splitField: "",
            children: []
          };
          this.loading = false;
        },
        async onSelectSplitField(field) {
          if (field.dataType === "Text")
            return this.splitPopoverConfig.callback({ field });
          const numRanges = 5;
          const min2 = this.splitPopoverConfig.bucket.values[`min__${field.id}`];
          const max2 = this.splitPopoverConfig.bucket.values[`max__${field.id}`];
          const step = Math.floor((max2 - min2) / numRanges);
          const ranges = [];
          let current = min2;
          while (current < max2) {
            ranges.push([current, current + step]);
            current += step + 1;
          }
          ranges.at(-1)[1] = max2;
          this.splitPopoverConfig.callback({ field, ranges });
        },
        async split({ bucket, field, ranges }) {
          this.loading = true;
          let saql = this.nodeSaql({ bucket });
          if (field.dataType === "Text") {
            saql += `
                    -- include null values
                    results = foreach results generate ${[
              `case when ${field.id} is null then "<Blank>" else ${field.id} end as ${field.id}`,
              ...this.fields.filter((f) => f !== field).map((f) => `${f.id} as ${f.id}`)
            ].join(", ")};

                    -- results
                    results = group results by ${field.id};
                    results = foreach results generate ${field.id} as __Bucket, count() as __Records, ${this.projectionSaql(this.fields)};
                `;
          } else {
            ranges.forEach(([from2, to2], i) => {
              saql += `
                        range${i} = filter results by (${field.id} >= ${from2} && ${field.id} <= ${to2});
                        range${i} = group range${i} by all;
                        range${i} = foreach range${i} generate ${i} as rangeIndex, "${field.label} from ${this.$F("Numeric", from2)} to ${this.$F("Numeric", to2)}" as __Bucket, count() as __Records, ${this.projectionSaql(this.fields)};
                    `;
            });
            saql += `results = union ${ranges.map((r, i) => `range${i}`).join(", ")}`;
          }
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          bucket.splitField = field.id;
          results.records.sort(this.sortBlankToBottom).forEach((r) => {
            bucket.children.push({
              id: r.__Bucket,
              parent: bucket,
              selected: bucket.selected === "all" ? "all" : "none",
              values: r,
              ruleItems: [
                ...bucket.ruleItems,
                {
                  sobjectType: "sfsp__SalesNodeRuleItem__c",
                  sfsp__Field__c: field.id,
                  sfsp__Operator__c: field.dataType === "Text" ? "==" : "between",
                  sfsp__Value__c: field.dataType === "Text" ? r.__Bucket.replace(/^<Blank>$/, "") : ranges[r.rangeIndex].join(","),
                  _dataType: field.dataType
                }
              ],
              splitField: "",
              children: []
            });
          });
          this.loading = false;
        },
        async unsplit(bucket) {
          bucket.splitField = "";
          bucket.children.splice(0);
          if (bucket.selected === "some")
            this.selectBucket(bucket);
        },
        sortBlankToBottom(a, b) {
          if (a.__Bucket === b.__Bucket)
            return 0;
          if (a.__Bucket === "<Blank>")
            return 1;
          return b.__Bucket === "<Blank>" ? -1 : 0;
        },
        // highlights
        highlightCells(cell, e) {
          if (!cell.bucket.splitField) {
            e.target.closest("th").classList.add("highlight-split");
            return;
          }
          let tr = e.target.closest("tr");
          for (let i = 0; i < e.target.closest("th").rowSpan - 1; i++) {
            tr.querySelectorAll("th").forEach((th) => th.classList.add("highlight-unsplit"));
            tr = tr.nextElementSibling;
          }
        },
        clearHighlightedCells() {
          document.querySelectorAll(".bucket-table .highlight-split, .bucket-table .highlight-unsplit").forEach((el) => {
            el.classList.remove("highlight-split");
            el.classList.remove("highlight-unsplit");
          });
        }
      }
    };
    const _withScopeId$2 = (n) => (pushScopeId("data-v-1be01667"), n = n(), popScopeId(), n);
    const _hoisted_1$8 = { style: { "max-height": "100%", "overflow": "auto" } };
    const _hoisted_2$8 = { class: "bucket-table spm-table slds-table slds-table_bordered slds-table_col-bordered slds-no-row-hover" };
    const _hoisted_3$6 = { class: "summary-header" };
    const _hoisted_4$6 = { class: "column-header" };
    const _hoisted_5$6 = {
      key: 0,
      class: "slds-grid slds-grid_vertical-align-center"
    };
    const _hoisted_6$6 = {
      key: 1,
      class: "slds-align_absolute-center slds-grid slds-grid_vertical slds-m-vertical_large"
    };
    const _hoisted_7$5 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-heading_medium slds-p-bottom_x-small" }, "No Results", -1));
    const _hoisted_8$5 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-body_regular" }, "Adjust filters or add rules to add records to this segment", -1));
    const _hoisted_9$4 = [
      _hoisted_7$5,
      _hoisted_8$5
    ];
    function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Popover = resolveComponent("Popover");
      return openBlock(), createElementBlock("div", null, [
        $data.loading ? (openBlock(), createBlock(_component_Spinner, { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_1$8, [
          createBaseVNode("table", _hoisted_2$8, [
            createBaseVNode("thead", null, [
              createBaseVNode("tr", _hoisted_3$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column, i) => {
                  return openBlock(), createElementBlock("td", {
                    key: i,
                    class: normalizeClass(column.type)
                  }, [
                    createBaseVNode("span", null, toDisplayString($options.selectionSummary.columns[column.id]), 1)
                  ], 2);
                }), 128))
              ]),
              createBaseVNode("tr", _hoisted_4$6, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.columns, (column, i) => {
                  return openBlock(), createElementBlock("th", { key: i }, toDisplayString(column.label), 1);
                }), 128))
              ])
            ]),
            createBaseVNode("tbody", null, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.rows, (row, i) => {
                return openBlock(), createElementBlock("tr", { key: i }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(row.cells, (cell, j) => {
                    return openBlock(), createElementBlock(Fragment, { key: j }, [
                      ["Bucket", "Split Bucket"].includes(cell.type) ? (openBlock(), createElementBlock("th", normalizeProps(mergeProps({ key: 0 }, cell.attr || {})), [
                        ["Bucket", "Split Bucket"].includes(cell.type) ? (openBlock(), createElementBlock("div", _hoisted_5$6, [
                          createVNode(_component_Checkbox, {
                            modelValue: cell.bucket.selected !== "none",
                            indeterminate: cell.bucket.selected === "some",
                            labels: { name: cell.label },
                            class: "slds-grow",
                            onClick: withModifiers((e) => $options.selectBucket(cell.bucket, e.shiftKey), ["prevent"])
                          }, null, 8, ["modelValue", "indeterminate", "labels", "onClick"]),
                          createVNode(_component_ButtonIcon, {
                            name: cell.type === "Bucket" ? "aggregation-table-split" : "aggregation-table-unsplit",
                            class: "slds-col_bump-left",
                            iconCategory: "utility",
                            iconName: cell.type === "Bucket" ? "rules" : "close",
                            variant: "border-filled",
                            size: "small",
                            assistiveText: cell.type === "Bucket" ? "Split" : "Unsplit",
                            title: cell.type === "Bucket" ? "Split" : "Unsplit",
                            onClick: ($event) => $options.toggleBucket(cell.bucket),
                            onMouseover: (e) => $options.highlightCells(cell, e),
                            onMouseout: $options.clearHighlightedCells
                          }, null, 8, ["name", "iconName", "assistiveText", "title", "onClick", "onMouseover", "onMouseout"])
                        ])) : createCommentVNode("", true)
                      ], 16)) : (openBlock(), createElementBlock("td", normalizeProps(mergeProps({ key: 1 }, cell.attr || {})), toDisplayString(cell.label), 17))
                    ], 64);
                  }), 128))
                ]);
              }), 128))
            ])
          ])
        ]),
        !$data.loading && !$data.bucketHierarchy.values ? (openBlock(), createElementBlock("div", _hoisted_6$6, _hoisted_9$4)) : createCommentVNode("", true),
        $data.splitPopoverConfig ? (openBlock(), createBlock(_component_Popover, {
          key: 2,
          closeOnClickOutside: "",
          alignment: "right",
          onClose: _cache[0] || (_cache[0] = ($event) => $data.splitPopoverConfig = null)
        }, {
          content: withCtx(() => [
            createVNode(_component_Picklist, {
              labels: { name: "Split By Field" },
              options: $data.splitFieldOptions,
              titleKey: "label",
              filterable: "",
              onSelectedOption: $options.onSelectSplitField
            }, null, 8, ["options", "onSelectedOption"])
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ]);
    }
    const BucketTable = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-1be01667"]]);
    const _sfc_main$7 = {
      name: "AddSegmentsModal",
      components: {
        Button,
        Checkbox,
        RadioButtonGroup,
        Spinner,
        TextInput,
        Icon,
        ButtonIcon,
        Tooltip,
        ConfigureColumnsModal,
        RecordTable,
        BucketTable
      },
      props: {
        // { parentId }
        config: {
          type: Object,
          required: true
        }
      },
      emits: ["close"],
      data() {
        return {
          loadingMsg: "",
          viewMode: "Group",
          filters: {
            isBurndown: true,
            searchTerm: ""
          },
          showSearch: false,
          selectionSummary: null,
          newSegment: null,
          configureColumnsModalConfig: null
        };
      },
      computed: {
        isRecordMode() {
          return this.viewMode === "Record";
        },
        segmentName() {
          return SPM.Components.Root.nodeMap[this.config.parentId].Name;
        },
        childSegments() {
          return SPM.Components.Root.nodeMap[this.config.parentId].sfsp__SalesNodes__r;
        }
      },
      async mounted() {
        SPM.Components.ViewRecords = this;
      },
      methods: {
        onSelectionUpdated() {
          this.selectionSummary = this.isRecordMode ? SPM.Components.RecordTable.selectionSummary : SPM.Components.BucketTable.selectionSummary;
        },
        onNewSegmentClick() {
          this.newSegment = { Name: "" };
          this.$nextTick(() => this.$refs.newSegmentInput.focus());
        },
        async assignTo(segment) {
          this.loadingMsg = "Assigning...";
          if (!segment.Id) {
            Object.assign(segment, {
              ...SPM.Utils.Segment.Node.defaults(),
              Name: segment.Name || "New Segment",
              sfsp__SalesPlan__c: SPM.Components.Root.plan.Id,
              sfsp__Parent__c: this.config.parentId.replace("all_org", ""),
              sfsp__Owner__c: SPM.currentUser.Id,
              sfsp__Owner__r: SPM.currentUser
            });
            this.newSegment = null;
            SPM.Utils.Pendo.track("SP | Segmentation - Add segments", {
              planId: SPM.Components.Root.plan.Id,
              method: this.viewMode,
              count: 1
            });
          }
          if (segment.sfsp__SalesNodeRules__r.length >= 10) {
            SPM.Components.Root.toast({ state: "error", message: "This segment has reached the maximum number of rules allowed" });
            this.loadingMsg = "";
            return;
          }
          const newRuleIndices = this.selectionSummary.rules.map((r, i) => i + 1 + segment.sfsp__SalesNodeRules__r.length);
          SPM.Utils.Segment.Node.setRuleLogic({
            node: segment,
            logic: [
              SPM.Utils.Segment.Node.getRuleLogic({ node: segment }),
              ...newRuleIndices
            ].filter((logic) => !!logic).join(" or ")
          });
          await SPM.Utils.CRM.upsert({ records: [segment] });
          this.selectionSummary.rules.forEach((rule) => {
            rule.sfsp__SalesNode__c = segment.Id;
            rule.sfsp__SortOrder__c = segment.sfsp__SalesNodeRules__r.length + 1;
            segment.sfsp__SalesNodeRules__r.push(rule);
          });
          await SPM.Utils.CRM.upsert({ records: this.selectionSummary.rules });
          const ruleItems = this.selectionSummary.rules.reduce((arr, rule) => {
            rule.sfsp__SalesNodeRuleItems__r.forEach((ri) => {
              ri.sfsp__SalesNodeRule__c = rule.Id;
              arr.push(ri);
            });
            return arr;
          }, []);
          await SPM.Utils.CRM.upsert({ records: ruleItems });
          if (!SPM.Components.Root.nodeMap[segment.Id]) {
            await SPM.Components.OrgView.addSegments({
              parent: SPM.Components.Root.nodeMap[this.config.parentId],
              segments: [segment]
            });
          } else {
            await SPM.Components.OrgView.updateSegmentValues();
          }
          if (this.filters.isBurndown) {
            this.isRecordMode ? SPM.Utils.Arr.splice(SPM.Components.RecordTable.records, (r) => r._selected) : SPM.Components.BucketTable.removeSelectedBuckets();
          }
          SPM.Utils.Pendo.track("SP | Segmentation - Assign records", {
            planId: SPM.Components.Root.plan.Id,
            method: this.viewMode,
            count: this.selectionSummary.aggregates.__Records
          });
          this.loadingMsg = "";
        },
        onShowSearch() {
          this.showSearch = true;
          this.$nextTick(() => this.$el.querySelector(".search-input input").focus());
        },
        formatTooltipText(rule) {
          return SPM.Utils.Rule.toString(rule);
        }
      }
    };
    const _withScopeId$1 = (n) => (pushScopeId("data-v-0d10e60b"), n = n(), popScopeId(), n);
    const _hoisted_1$7 = {
      id: "view-records",
      class: "slds-grid slds-grid_vertical"
    };
    const _hoisted_2$7 = {
      class: "slds-grid slds-grid_vertical",
      style: { "height": "100%", "overflow": "hidden" }
    };
    const _hoisted_3$5 = { class: "slds-grid slds-grid_align-spread slds-p-around_small" };
    const _hoisted_4$5 = { class: "slds-col" };
    const _hoisted_5$5 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", null, "View Records", -1));
    const _hoisted_6$5 = { class: "slds-text-color_default slds-page-header__title" };
    const _hoisted_7$4 = { class: "slds-grid slds-grid_vertical-align-center" };
    const _hoisted_8$4 = { class: "slds-grow slds-scrollable_none slds-grid" };
    const _hoisted_9$3 = {
      class: "slds-grow",
      style: { "overflow": "auto" }
    };
    const _hoisted_10$3 = { style: { "width": "300px", "min-width": "300px", "box-shadow": "-1px 0 3px 0 rgba(0,0,0,.25)", "z-index": "3", "border-top": "1px solid #C9C9C9" } };
    const _hoisted_11$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", {
      class: "slds-panel__header",
      style: { "border-top": "1px solid #bbb" }
    }, [
      /* @__PURE__ */ createBaseVNode("h2", { class: "slds-panel__header-title slds-text-heading_small slds-truncate" }, "Assignment")
    ], -1));
    const _hoisted_12$1 = { class: "slds-p-around_small" };
    const _hoisted_13$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-title_bold" }, "Segments", -1));
    const _hoisted_14$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { style: { "font-size": "10px" } }, "Click a segment to assign the selection to it", -1));
    const _hoisted_15 = ["onClick"];
    const _hoisted_16 = {
      class: "slds-truncate",
      style: { "max-width": "180px" }
    };
    const _hoisted_17 = { style: { "font-weight": "700", "margin-left": "12px" } };
    const _hoisted_18 = {
      key: 1,
      class: "slds-grid slds-m-top_small"
    };
    const _hoisted_19 = {
      key: 0,
      class: "slds-p-around_small"
    };
    const _hoisted_20 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-title_bold" }, "Rules Preview", -1));
    const _hoisted_21 = { class: "spm-box" };
    function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_Checkbox = resolveComponent("Checkbox");
      const _component_RadioButtonGroup = resolveComponent("RadioButtonGroup");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Icon = resolveComponent("Icon");
      const _component_TextInput = resolveComponent("TextInput");
      const _component_RecordTable = resolveComponent("RecordTable");
      const _component_BucketTable = resolveComponent("BucketTable");
      const _component_Button = resolveComponent("Button");
      const _component_ConfigureColumnsModal = resolveComponent("ConfigureColumnsModal");
      return openBlock(), createElementBlock("div", _hoisted_1$7, [
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$7, [
          createBaseVNode("div", _hoisted_3$5, [
            createBaseVNode("div", _hoisted_4$5, [
              _hoisted_5$5,
              createBaseVNode("div", _hoisted_6$5, toDisplayString($options.segmentName), 1)
            ]),
            createBaseVNode("div", _hoisted_7$4, [
              createVNode(_component_Tooltip, {
                class: "slds-m-right_xx-small",
                alignment: "left",
                text: "Only show unassigned records to work towards complete distribution to segments"
              }),
              createVNode(_component_Checkbox, {
                modelValue: $data.filters.isBurndown,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.filters.isBurndown = $event),
                labels: { name: "Burndown" },
                class: "slds-m-right_x-small",
                slide: ""
              }, null, 8, ["modelValue"]),
              createVNode(_component_RadioButtonGroup, {
                modelValue: $data.viewMode,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.viewMode = $event),
                options: [{ label: "Group View", value: "Group" }, { label: "Record View", value: "Record" }],
                class: "slds-m-right_x-small"
              }, null, 8, ["modelValue"]),
              !$options.isRecordMode || !$data.showSearch && !$data.filters.searchTerm ? (openBlock(), createBlock(_component_ButtonIcon, {
                key: 0,
                iconCategory: "utility",
                iconName: "search",
                variant: "border-filled",
                assistiveText: "Search",
                title: "Search",
                disabled: !$options.isRecordMode,
                onClick: $options.onShowSearch
              }, null, 8, ["disabled", "onClick"])) : (openBlock(), createBlock(_component_TextInput, {
                key: 1,
                modelValue: $data.filters.searchTerm,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.filters.searchTerm = $event),
                class: "search-input slds-input-has-icon slds-input-has-icon_left-right slds-m-right_x-small",
                labels: { placeholder: "Search..." }
              }, {
                extend: withCtx(() => [
                  createVNode(_component_Icon, {
                    category: "utility",
                    name: "search",
                    iconClass: ["slds-input__icon", "slds-input__icon_left"]
                  }),
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "clear",
                    assistiveText: "Clear",
                    iconClass: ["slds-button__icon", "slds-icon-text-light"],
                    class: "slds-button slds-button_icon slds-input__icon slds-input__icon_right",
                    title: "Clear",
                    onClick: _cache[2] || (_cache[2] = ($event) => $data.filters.searchTerm = "")
                  })
                ]),
                _: 1
              }, 8, ["modelValue", "labels"])),
              createVNode(_component_ButtonIcon, {
                iconCategory: "utility",
                iconName: "settings",
                variant: "border-filled",
                assistiveText: "Configure",
                title: "Configure",
                onClick: _cache[4] || (_cache[4] = ($event) => $data.configureColumnsModalConfig = {})
              }),
              createVNode(_component_ButtonIcon, {
                iconCategory: "utility",
                iconName: "close",
                variant: "border-filled",
                assistiveText: "Close",
                title: "Close",
                onClick: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
              })
            ])
          ]),
          createBaseVNode("div", _hoisted_8$4, [
            createBaseVNode("div", _hoisted_9$3, [
              $options.isRecordMode ? (openBlock(), createBlock(_component_RecordTable, {
                key: 0,
                segmentId: $props.config.parentId,
                filters: $data.filters,
                style: { "height": "100%" },
                onSelectionUpdated: $options.onSelectionUpdated
              }, null, 8, ["segmentId", "filters", "onSelectionUpdated"])) : createCommentVNode("", true),
              !$options.isRecordMode ? (openBlock(), createBlock(_component_BucketTable, {
                key: 1,
                segmentId: $props.config.parentId,
                filters: $data.filters,
                style: { "height": "100%" },
                onSelectionUpdated: $options.onSelectionUpdated
              }, null, 8, ["segmentId", "filters", "onSelectionUpdated"])) : createCommentVNode("", true)
            ]),
            createBaseVNode("div", _hoisted_10$3, [
              _hoisted_11$3,
              createBaseVNode("div", _hoisted_12$1, [
                _hoisted_13$1,
                _hoisted_14$1,
                (openBlock(true), createElementBlock(Fragment, null, renderList($options.childSegments, (segment) => {
                  var _a;
                  return openBlock(), createElementBlock("div", {
                    key: segment.Id,
                    class: "spm-box slds-grid slds-p-around_x-small",
                    style: { "background": "#eef4ff", "margin": ".5rem 0 0 0", "cursor": "pointer" },
                    onClick: ($event) => $options.assignTo(segment)
                  }, [
                    createBaseVNode("span", _hoisted_16, toDisplayString(segment.Name), 1),
                    createBaseVNode("span", _hoisted_17, toDisplayString(_ctx.$F("Compact", ((_a = segment == null ? void 0 : segment._kpis) == null ? void 0 : _a.__Records) || 0)), 1)
                  ], 8, _hoisted_15);
                }), 128)),
                !$data.newSegment ? (openBlock(), createBlock(_component_Button, {
                  key: 0,
                  iconCategory: "utility",
                  iconName: "add",
                  variant: "neutral",
                  label: "Add New Segment",
                  class: "slds-m-top_small",
                  onClick: $options.onNewSegmentClick
                }, null, 8, ["onClick"])) : (openBlock(), createElementBlock("div", _hoisted_18, [
                  withDirectives(createBaseVNode("input", {
                    ref: "newSegmentInput",
                    "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.newSegment.Name = $event),
                    type: "text",
                    class: "slds-input slds-grow slds-m-right_small",
                    placeholder: "Segment Name"
                  }, null, 512), [
                    [vModelText, $data.newSegment.Name]
                  ]),
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "check",
                    variant: "brand",
                    class: "slds-col_bump-left",
                    assistiveText: "Add Segment",
                    title: "Add Segment",
                    onClick: _cache[7] || (_cache[7] = ($event) => $options.assignTo($data.newSegment))
                  }),
                  createVNode(_component_ButtonIcon, {
                    iconCategory: "utility",
                    iconName: "close",
                    variant: "border-filled",
                    assistiveText: "Close",
                    title: "Close",
                    onClick: _cache[8] || (_cache[8] = ($event) => $data.newSegment = null)
                  })
                ]))
              ]),
              $data.selectionSummary ? (openBlock(), createElementBlock("div", _hoisted_19, [
                _hoisted_20,
                createBaseVNode("div", _hoisted_21, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.selectionSummary.rules, (rule, i) => {
                    return openBlock(), createElementBlock("div", {
                      key: i,
                      class: "slds-grid slds-grid_vertical-align-center slds-p-vertical_x-small slds-p-horizontal_small slds-border_top"
                    }, [
                      createVNode(_component_Tooltip, {
                        text: $options.formatTooltipText(rule),
                        alignment: "left"
                      }, {
                        source: withCtx(() => [
                          createBaseVNode("span", null, toDisplayString(rule.Name), 1)
                        ]),
                        _: 2
                      }, 1032, ["text"])
                    ]);
                  }), 128))
                ])
              ])) : createCommentVNode("", true)
            ])
          ])
        ]),
        $data.configureColumnsModalConfig ? (openBlock(), createBlock(_component_ConfigureColumnsModal, {
          key: 1,
          onClose: _cache[9] || (_cache[9] = ($event) => $data.configureColumnsModalConfig = null)
        })) : createCommentVNode("", true)
      ]);
    }
    const ViewRecords = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-0d10e60b"]]);
    const _sfc_main$6 = {
      name: "Listbox",
      components: {
        ButtonIcon
      },
      props: ["labels", "options"],
      methods: {
        moveUp() {
          for (let i = 1; i < this.options.length; i++) {
            if (this.options[i].active && !this.options[i - 1].active) {
              const [first, second] = this.options.slice(i - 1, i + 1);
              this.options.splice(i - 1, 2, second, first);
            }
          }
        },
        moveDown() {
          for (let i = this.options.length - 2; i >= 0; i--) {
            if (this.options[i].active && !this.options[i + 1].active) {
              const [first, second] = this.options.slice(i, i + 2);
              this.options.splice(i, 2, second, first);
            }
          }
        },
        moveToTop() {
          this.options.splice(0, this.options.length, ...this.options.filter((o) => o.active), ...this.options.filter((o) => !o.active));
        },
        moveToBottom() {
          this.options.splice(0, this.options.length, ...this.options.filter((o) => !o.active), ...this.options.filter((o) => o.active));
        }
      }
    };
    const _hoisted_1$6 = { key: 0 };
    const _hoisted_2$6 = { class: "slds-form-element__label" };
    const _hoisted_3$4 = { class: "slds-dueling-list" };
    const _hoisted_4$4 = {
      class: "slds-dueling-list__column",
      style: { "flex": "1 0 0" }
    };
    const _hoisted_5$4 = {
      class: "slds-dueling-list__options",
      style: { "width": "auto", "height": "12rem" }
    };
    const _hoisted_6$4 = {
      "aria-multiselectable": "true",
      class: "slds-listbox slds-listbox_vertical",
      role: "listbox"
    };
    const _hoisted_7$3 = ["onClick"];
    const _hoisted_8$3 = ["aria-selected"];
    const _hoisted_9$2 = { class: "slds-media__body" };
    const _hoisted_10$2 = ["title"];
    const _hoisted_11$2 = { class: "slds-m-left_small spm-listbox-order-controls" };
    function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
      var _a;
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      return openBlock(), createElementBlock("div", null, [
        ((_a = $props.labels) == null ? void 0 : _a.name) ? (openBlock(), createElementBlock("div", _hoisted_1$6, [
          createBaseVNode("label", _hoisted_2$6, [
            createBaseVNode("strong", null, toDisplayString($props.labels.name), 1)
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_3$4, [
          createBaseVNode("div", _hoisted_4$4, [
            createBaseVNode("div", _hoisted_5$4, [
              createBaseVNode("ul", _hoisted_6$4, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.options, (option, i) => {
                  return openBlock(), createElementBlock("li", {
                    key: i,
                    role: "presentation",
                    class: "slds-listbox__item",
                    onClick: ($event) => option.active = !option.active
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline", { active: option.active }]),
                      "aria-selected": option.active,
                      draggable: "true",
                      role: "option"
                    }, [
                      createBaseVNode("span", _hoisted_9$2, [
                        createBaseVNode("span", {
                          class: "slds-truncate",
                          title: option.label
                        }, toDisplayString(option.label), 9, _hoisted_10$2)
                      ])
                    ], 10, _hoisted_8$3)
                  ], 8, _hoisted_7$3);
                }), 128))
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_11$2, [
            createBaseVNode("div", null, [
              createVNode(_component_ButtonIcon, {
                variant: "border-filled",
                iconCategory: "utility",
                iconName: "arrow_top",
                title: "Move Selection Up",
                assistiveText: "Move Selection To Top",
                onClick: $options.moveToTop
              }, null, 8, ["onClick"])
            ]),
            createBaseVNode("div", null, [
              createVNode(_component_ButtonIcon, {
                variant: "border-filled",
                iconCategory: "utility",
                iconName: "arrowup",
                title: "Move Selection Down",
                assistiveText: "Move Selection Up",
                onClick: $options.moveUp
              }, null, 8, ["onClick"])
            ]),
            createBaseVNode("div", null, [
              createVNode(_component_ButtonIcon, {
                variant: "border-filled",
                iconCategory: "utility",
                iconName: "arrowdown",
                title: "Move Selection Down",
                assistiveText: "Move Selection Down",
                onClick: $options.moveDown
              }, null, 8, ["onClick"])
            ]),
            createBaseVNode("div", null, [
              createVNode(_component_ButtonIcon, {
                variant: "border-filled",
                iconCategory: "utility",
                iconName: "arrow_bottom",
                title: "Move Selection Down",
                assistiveText: "Move Selection To Bottom",
                onClick: $options.moveToBottom
              }, null, 8, ["onClick"])
            ])
          ])
        ])
      ]);
    }
    const Listbox = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-d1cb60ee"]]);
    const _sfc_main$5 = {
      name: "EditNodeModal",
      components: {
        SLDSButton: Button,
        TextInput,
        Picklist,
        Modal,
        Spinner,
        Listbox
      },
      props: ["config"],
      emits: ["close"],
      data() {
        return {
          loadingMsg: "Loading...",
          // details
          name: "",
          // children
          nodeChildren: [],
          // parent
          parentId: this.config.node._parentId,
          parentOptions: Object.values(SPM.Components.Root.nodeMap),
          // owner
          ownerId: "",
          ownerRecord: null,
          ownerOptions: [
            {
              options: async (term) => {
                term = term.replace(/'/g, "\\'");
                return SPM.Utils.Rest.invoke("Query", { query: `SELECT Id, Name, FirstName, LastName, SmallPhotoUrl, Title FROM User WHERE Name LIKE '%${term}%' LIMIT 10` });
              }
            }
          ],
          errors: {
            parent: []
          }
        };
      },
      watch: {
        parentId() {
          this.errors.parent.splice(0);
        }
      },
      async mounted() {
        SPM.Components.EditNodeModal = this;
        this.name = this.config.node.Name;
        this.ownerId = this.config.node.sfsp__Owner__c || "";
        this.ownerRecord = this.config.node.sfsp__Owner__r;
        this.$nextTick(() => {
          var _a, _b;
          return this.$refs.owner.input = ((_b = (_a = this.config.node) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Name) || "";
        });
        this.nodeChildren = this.config.node.sfsp__SalesNodes__r.map((node) => ({
          active: false,
          label: node.Name,
          node
        }));
        this.loadingMsg = "";
      },
      methods: {
        async save() {
          var _a, _b, _c, _d;
          Object.values(this.errors).forEach((errors) => errors.splice(0));
          this.loadingMsg = "Saving...";
          const recordsToUpdate = [];
          const newParentNode = SPM.Components.Root.nodeMap[this.parentId];
          const currentParentNode = SPM.Components.Root.nodeMap[this.config.node._parentId];
          if (this.config.node.Id !== "all_org") {
            if (newParentNode === this.config.node || SPM.Utils.Segment.Node.isAncestor({ node: newParentNode, ancestor: this.config.node, nodeMap: SPM.Components.Root.nodeMap })) {
              this.errors.parent.push("Unable to reparent this node to its descendant.");
              return;
            }
            if (currentParentNode !== newParentNode) {
              SPM.Utils.Arr.splice(currentParentNode.sfsp__SalesNodes__r, (n) => n.Id === this.config.node.Id);
              newParentNode.sfsp__SalesNodes__r.push(this.config.node);
            }
          }
          const currentName = this.config.node.Name;
          const currentOwner = this.config.node.sfsp__Owner__r;
          if (this.config.node.Id !== "all_org") {
            Object.assign(this.config.node, {
              Name: this.name,
              sfsp__Parent__c: newParentNode.Id.replace("all_org", ""),
              sfsp__Priority__c: newParentNode.sfsp__SalesNodes__r.length,
              sfsp__Owner__c: this.ownerId,
              sfsp__Owner__r: this.ownerRecord,
              _parentId: newParentNode.Id
            });
            recordsToUpdate.push(this.config.node);
          }
          let childOrderChanged = false;
          this.nodeChildren.forEach((nodeChild, i) => {
            if (nodeChild.node.Id !== this.config.node.sfsp__SalesNodes__r[i].Id) {
              childOrderChanged = true;
              nodeChild.node.sfsp__Priority__c = i + 1;
              recordsToUpdate.push(nodeChild.node);
            }
          });
          if (childOrderChanged) {
            this.config.node.sfsp__SalesNodes__r.splice(
              0,
              this.config.node.sfsp__SalesNodes__r.length,
              ...this.nodeChildren.map((nodeChild) => nodeChild.node)
            );
          }
          await SPM.Utils.CRM.upsert({ records: recordsToUpdate });
          const changes = [];
          if (currentName !== this.config.node.Name)
            changes.push(`• Name changed from ${currentName} to ${this.config.node.Name}`);
          if ((currentOwner == null ? void 0 : currentOwner.Id) !== ((_b = (_a = this.config.node) == null ? void 0 : _a.sfsp__Owner__r) == null ? void 0 : _b.Id))
            changes.push(`• Owner changed from ${(currentOwner == null ? void 0 : currentOwner.Name) || "None"} to ${((_d = (_c = this.config.node) == null ? void 0 : _c.sfsp__Owner__r) == null ? void 0 : _d.Name) || "None"}`);
          if (currentParentNode !== newParentNode)
            changes.push(`• Parent changed from ${currentParentNode.Name} to ${newParentNode.Name}`);
          if (childOrderChanged)
            changes.push("• Child order changed");
          if (changes.length) {
            SPM.Utils.CRM.upsert({
              records: [{
                sobjectType: "sfsp__SalesActivity__c",
                Name: `Update ${this.config.node.Name}`,
                sfsp__Description__c: ["Updates:", ...changes].join("\r\n"),
                sfsp__SalesPlan__c: this.config.node.sfsp__SalesPlan__c,
                sfsp__SalesNode__c: this.config.node.Id !== "all_org" ? this.config.node.Id : "",
                sfsp__Type__c: "Segment",
                sfsp__Subtype__c: "Updated"
              }]
            });
          }
          this.config.callback({ node: this.config.node, childOrderChanged });
          this.$emit("close");
        }
      }
    };
    const _hoisted_1$5 = { class: "slds-grid slds-gutters_medium slds-m-bottom_small" };
    const _hoisted_2$5 = { class: "slds-col slds-size_1-of-2" };
    const _hoisted_3$3 = { class: "slds-col slds-size_1-of-2" };
    const _hoisted_4$3 = { class: "slds-grid slds-gutters_medium slds-m-bottom_small" };
    const _hoisted_5$3 = { class: "slds-col slds-size_1-of-2" };
    const _hoisted_6$3 = { style: { "font-size": "12px", "line-height": "20px", "font-weight": "500", "color": "#000" } };
    const _hoisted_7$2 = { style: { "font-size": "10px", "line-height": "20px", "font-weight": "400", "color": "#444" } };
    const _hoisted_8$2 = { class: "slds-grid slds-gutters_medium slds-m-bottom_small" };
    const _hoisted_9$1 = { class: "slds-col slds-size_1-of-2" };
    const _hoisted_10$1 = { class: "slds-grid" };
    const _hoisted_11$1 = { class: "slds-col_bump-left" };
    function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_TextInput = resolveComponent("TextInput");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_Listbox = resolveComponent("Listbox");
      const _component_SLDSButton = resolveComponent("SLDSButton");
      const _component_Modal = resolveComponent("Modal");
      return openBlock(), createBlock(_component_Modal, {
        ref: "modal",
        title: `Edit ${$props.config.node.Name}`,
        size: "small",
        detach: "",
        onClose: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
      }, {
        content: withCtx(() => [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createBaseVNode("div", null, toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_1$5, [
            createBaseVNode("div", _hoisted_2$5, [
              createVNode(_component_TextInput, {
                modelValue: $data.name,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.name = $event),
                labels: { name: "Name" },
                class: "slds-grow",
                disabled: $props.config.node.Id === "all_org"
              }, null, 8, ["modelValue", "disabled"])
            ]),
            createBaseVNode("div", _hoisted_3$3, [
              createVNode(_component_Picklist, {
                modelValue: $data.parentId,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.parentId = $event),
                labels: { name: "Parent" },
                options: $data.parentOptions,
                idKey: "Id",
                titleKey: "Name",
                filterable: "",
                disabled: $props.config.node.Id === "all_org",
                errors: $data.errors.parent
              }, null, 8, ["modelValue", "options", "disabled", "errors"])
            ])
          ]),
          createBaseVNode("div", _hoisted_4$3, [
            createBaseVNode("div", _hoisted_5$3, [
              createVNode(_component_Picklist, {
                ref: "owner",
                modelValue: $data.ownerId,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.ownerId = $event),
                labels: { name: "Owner", search: "Search users..." },
                options: $data.ownerOptions,
                idKey: "Id",
                titleKey: "Name",
                filterable: "",
                disabled: $props.config.node.Id === "all_org",
                onSelectedOption: _cache[3] || (_cache[3] = (opt) => $data.ownerRecord = opt)
              }, {
                option: withCtx(({ option: { Name, Title } }) => [
                  createBaseVNode("div", null, [
                    createBaseVNode("div", _hoisted_6$3, toDisplayString(Name), 1),
                    createBaseVNode("div", _hoisted_7$2, toDisplayString(Title), 1)
                  ])
                ]),
                _: 1
              }, 8, ["modelValue", "labels", "options", "disabled"])
            ])
          ]),
          createBaseVNode("div", _hoisted_8$2, [
            createBaseVNode("div", _hoisted_9$1, [
              createVNode(_component_Listbox, {
                options: $data.nodeChildren,
                labels: { name: "Reorder Children" }
              }, null, 8, ["options"])
            ])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", null, [
            createBaseVNode("div", _hoisted_10$1, [
              createBaseVNode("div", _hoisted_11$1, [
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_neutral",
                  onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("close"))
                }, {
                  default: withCtx(() => [
                    createTextVNode("Cancel")
                  ]),
                  _: 1
                }),
                createVNode(_component_SLDSButton, {
                  class: "slds-button slds-button_brand",
                  onClick: $options.save
                }, {
                  default: withCtx(() => [
                    createTextVNode("Save")
                  ]),
                  _: 1
                }, 8, ["onClick"])
              ])
            ])
          ])
        ]),
        _: 1
      }, 8, ["title"]);
    }
    const EditNodeModal = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
    const _sfc_main$4 = {
      name: "OrgView",
      components: {
        Spinner,
        ConfirmModal,
        CheckboxButton,
        ConfigureModal,
        AddSegmentsModal,
        ViewRecords,
        EditNodeModal
      },
      props: ["nodeMap", "nodeHierarchy"],
      setup() {
        return {
          chart: new OrgChart().container(".chart-container").compact(false).layout("left").childrenMargin((n1, n2) => 150)
        };
      },
      data() {
        return {
          // chart
          compactLayout: false,
          horizontalLayout: true,
          updateSegmentValuesRequestKey: null,
          // chart search
          showChartSearch: false,
          chartSearchTerm: "",
          // action menu
          actionMenuConfig: null,
          // confirm
          confirmModalConfig: null,
          // configure
          configureModalConfig: null,
          // add segments
          addSegmentsModalConfig: null,
          // view records
          viewRecordsConfig: null,
          // edit node
          editNodeModalConfig: null
        };
      },
      computed: {
        selectedNode() {
          return SPM.Components.Root.selectedNode;
        },
        // data source
        dataSource() {
          return SPM.Components.Root.plan.sfsp__SalesDataSource__r;
        },
        dataSourceFields() {
          return this.dataSource._referenceFields;
        },
        kpiOptions() {
          return this.dataSourceFields.filter((f) => f.dataType === "Numeric");
        },
        // chart
        nodeHeight() {
          return this.compactLayout ? 42 : 140 + (SPM.Components.Root.plan._hasDataSource ? SPM.Components.Root.preferences.kpis.length * 20 : 0);
        },
        // action menu
        segmentActions() {
          if (!this.actionMenuConfig.segmentId)
            return [];
          const actions = [
            { id: "View Records", label: "View Records" },
            { id: "View Segment", label: "View Segment" },
            { id: "Edit Segment", label: "Edit Segment" },
            { id: "Manage Rules", label: "Manage Rules" },
            { spacer: true },
            { id: "Delete Descendants", label: "Delete Descendants", destructive: true },
            { id: "Delete Segment", label: "Delete Segment", destructive: true }
          ];
          if (this.actionMenuConfig.segmentId === "all_org")
            SPM.Utils.Arr.splice(actions, (a) => !["View Records", "Edit Segment"].includes(a.id));
          if (!SPM.Components.Root.plan._hasDataSource)
            SPM.Utils.Arr.splice(actions, (a) => ["View Records", "Manage Rules"].includes(a.id));
          if (this.nodeMap[this.actionMenuConfig.segmentId].sfsp__SalesNodes__r.length === 0)
            SPM.Utils.Arr.splice(actions, (a) => ["Delete Descendants"].includes(a.id));
          return actions;
        }
      },
      watch: {
        compactLayout() {
          this.chart.nodeContent((d) => this.nodeContent({ d, compact: this.compactLayout, allOrg: d.data.id === "all_org" })).render();
        },
        horizontalLayout() {
          this.chart.layout(this.horizontalLayout ? "left" : "top").render().fit();
        },
        updateSegmentValuesRequestKey(value) {
          SPM.Components.BuilderHeader.segmentBuilderStatus = value ? "Running Rules..." : "Ready";
        },
        selectedNode() {
          var _a, _b, _c;
          this.chart.data().forEach((d) => {
            var _a2;
            return d.node._highlighted = d.id === ((_a2 = this.selectedNode) == null ? void 0 : _a2.Id);
          });
          document.querySelectorAll("#org-view .segment-highlight:not(.off)").forEach((el) => el.classList.add("off"));
          (_c = (_b = document.querySelector(`#org-view .segment[data-id="${(_a = this.selectedNode) == null ? void 0 : _a.Id}"] .segment-highlight`)) == null ? void 0 : _b.classList) == null ? void 0 : _c.remove("off");
        }
      },
      mounted() {
        SPM.Components.OrgView = this;
        this.chart.nodeHeight((d) => this.nodeHeight).nodeContent((d) => this.nodeContent({ d, allOrg: d.data.id === "all_org" })).data([
          { id: "all_org", parentId: "", kpi: "", node: this.nodeHierarchy },
          ...Object.values(this.nodeMap).reduce((arr, parent) => arr.concat(
            parent.sfsp__SalesNodes__r.map((child) => ({
              id: child.Id,
              parentId: parent.Id,
              kpi: "",
              node: child
            }))
          ), [])
        ]);
        this.resizeChart(true);
        this.updateSegmentValues();
        window.addEventListener("keydown", this.onWindowKeydown);
        window.addEventListener("resize", this.resizeChart);
      },
      unmounted() {
        window.removeEventListener("keydown", this.onWindowKeydown);
        window.removeEventListener("resize", this.resizeChart);
      },
      methods: {
        // segments
        launchAddSegments(segment) {
          this.addSegmentsModalConfig = {
            parentId: segment.Id,
            callback: ({ newSegments }) => {
              this.addSegments({ parent: segment, segments: newSegments });
            }
          };
        },
        async addSegments({ parent, segments }) {
          segments.forEach((s) => {
            const newSegment = {
              ...SPM.Utils.Segment.Node.defaults(),
              ...s,
              _parentId: parent.Id
            };
            parent.sfsp__SalesNodes__r.push(newSegment);
            this.nodeMap[newSegment.Id] = newSegment;
            this.chart.addNode({
              id: newSegment.Id,
              parentId: parent.Id,
              node: newSegment
            });
            this.chart.setExpanded(newSegment.Id);
          });
          this.chart.render();
          await this.updateSegmentValues();
        },
        viewSegment(segment) {
          window.open(`/one/one.app#/alohaRedirect/apex/sfsp__SegmentDetails?segmentId=${segment.Id}`);
        },
        viewSegmentRules(segment) {
          SPM.Components.Root.selectedNode = segment;
          SPM.Components.Root.sidePanel = "RulesPanel";
        },
        viewSegmentRecords(segment) {
          this.viewRecordsConfig = { parentId: segment.Id };
          SPM.Components.Root.selectedNode = null;
          SPM.Components.Root.sidePanel = "";
        },
        async deleteSegment(segment, deleteChildrenOnly) {
          let descendants = SPM.Utils.Segment.Node.getDescendants({ nodes: [segment] });
          if (deleteChildrenOnly) {
            descendants = descendants.filter((n) => n.Id !== segment.Id);
            descendants.forEach((n) => {
              delete SPM.Components.Root.nodeMap[n.Id];
              if (n.sfsp__Parent__c === segment.Id)
                this.chart.removeNode(n.Id);
            });
            SPM.Components.Root.nodeMap[segment.Id].sfsp__SalesNodes__r = [];
          } else {
            this.chart.removeNode(segment.Id);
            descendants.forEach(({ Id }) => delete SPM.Components.Root.nodeMap[Id]);
            const childNodes = SPM.Components.Root.nodeMap[segment._parentId].sfsp__SalesNodes__r;
            childNodes.splice(childNodes.indexOf(segment), 1);
          }
          descendants.forEach((n) => {
            n.sfsp__SalesPlan__c = "";
          });
          await Promise.all([
            SPM.Utils.CRM.upsert({
              records: descendants
            }),
            SPM.Utils.CRM.upsert({
              records: [{
                sobjectType: "sfsp__SalesActivity__c",
                Name: SPM.Utils.Str.truncate(`Delete ${deleteChildrenOnly ? `${segment.Name}'s descendants` : segment.Name}`),
                sfsp__Description__c: "",
                sfsp__SalesPlan__c: segment.sfsp__SalesPlan__c,
                sfsp__SalesNode__c: segment.Id,
                sfsp__Type__c: "Segment",
                sfsp__Subtype__c: "Deleted"
              }]
            })
          ]);
        },
        updateSegmentDetails(segment) {
          var _a, _b, _c;
          const nodeEl = document.querySelector(`#org-view .segment[data-id="${segment.Id}"]`);
          if (nodeEl) {
            nodeEl.querySelector(".segment-name").textContent = segment.Name;
            nodeEl.querySelector(".segment-owner-avatar").innerHTML = ((_a = segment == null ? void 0 : segment.sfsp__Owner__r) == null ? void 0 : _a.SmallPhotoUrl) ? `<img src="${segment.sfsp__Owner__r.SmallPhotoUrl}" />` : "?";
            nodeEl.querySelector(".segment-owner-name").textContent = ((_b = segment == null ? void 0 : segment.sfsp__Owner__r) == null ? void 0 : _b.Name) || "TBH";
            nodeEl.querySelector(".segment-owner-title").textContent = ((_c = segment == null ? void 0 : segment.sfsp__Owner__r) == null ? void 0 : _c.Title) || "TBD";
          }
        },
        async updateSegmentValues() {
          var _a;
          if (!SPM.Components.Root.plan._hasDataSource)
            return;
          const requestKey = this.updateSegmentValuesRequestKey = SPM.Utils.getGUID();
          const kpis = [...new Set(SPM.Components.Root.preferences.kpis)];
          const saql = SPM.Utils.Segment.Node.generateHierarchySaql({
            node: SPM.Components.Root.nodeHierarchy,
            nodeMap: SPM.Components.Root.nodeMap,
            dataSource: this.dataSource,
            fields: kpis
          });
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          const resultsMap = (_a = results == null ? void 0 : results.records) == null ? void 0 : _a.reduce((map2, record) => {
            map2[record.__NodeId] = record;
            return map2;
          }, {});
          if (requestKey === this.updateSegmentValuesRequestKey) {
            const { nodeMap } = SPM.Components.Root;
            Object.values(nodeMap).forEach((node) => node._kpis = resultsMap[node.Id] || {});
            if (!this.compactLayout) {
              document.querySelectorAll("#org-view .segment").forEach((segmentEl) => {
                const segmentId = segmentEl.getAttribute("data-id");
                const kpiTemplate = document.createElement("template");
                kpiTemplate.innerHTML = this.kpiContent({ segment: nodeMap[segmentId] });
                segmentEl.querySelector(".segment-kpis").replaceWith(kpiTemplate.content);
                const buttonTemplate = document.createElement("template");
                buttonTemplate.innerHTML = this.buttonContent({ segment: nodeMap[segmentId] });
                segmentEl.querySelector(".segment-buttons").replaceWith(buttonTemplate.content);
              });
            }
            this.updateSegmentValuesRequestKey = null;
          }
        },
        // chart rendering
        nodeContent({ d, compact, allOrg = false, preferences = SPM.Components.Root.preferences }) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          return `
                <div class="segment" data-id="${d.data.id}">

                    <!-- Name -->
                    <div class="segment-name ${allOrg ? "" : "segment-cursor"} slds-truncate slds-p-right_large">${SPM.Utils.Str.sanitizeHTML(d.data.node.Name)}</div>

                    ${compact ? "" : `
                        <!-- Owner -->
                        <div class="segment-owner slds-grid slds-grid_vertical-align-center slds-m-vertical_x-small">
                            <div class="segment-owner-avatar slds-grid slds-grid_vertical-align-center slds-grid_align-center">
                                ${((_b = (_a = d.data) == null ? void 0 : _a.node) == null ? void 0 : _b.sfsp__Owner__r) ? `<img src="${d.data.node.sfsp__Owner__r.SmallPhotoUrl}" />` : '<span class="slds-icon_container slds-icon__svg--default"><svg class="slds-icon slds-icon_x-small" xmlns="http://www.w3.org/2000/svg" height="52" width="52" viewBox="0 0 520 520" fill="#fff"><path d="M500 430v22c0 26-22 48-48 48H68a49 49 0 0 1-48-48v-22c0-58 68-94 132-122l6-3c5-2 10-2 15 1a155 155 0 0 0 172 0c5-3 10-3 15-1l6 3c66 28 134 63 134 122zM260 20c66 0 119 59 119 132s-53 132-119 132-119-59-119-132S194 20 260 20z"/></svg></span>'}
                            </div>
                            <div class="slds-m-left_x-small">
                                <div class="segment-owner-name">${SPM.Utils.Str.sanitizeHTML(((_e = (_d = (_c = d.data) == null ? void 0 : _c.node) == null ? void 0 : _d.sfsp__Owner__r) == null ? void 0 : _e.Name) || "TBH")}</div>
                                <div class="segment-owner-title">${SPM.Utils.Str.sanitizeHTML(((_h = (_g = (_f = d.data) == null ? void 0 : _f.node) == null ? void 0 : _g.sfsp__Owner__r) == null ? void 0 : _h.Title) || "TBD")}</div>
                            </div>
                        </div>

                        <!-- Rules & Records -->
                        ${this.buttonContent({ segment: d.data.node })}

                        <!-- KPIs -->
                        ${this.kpiContent({ segment: d.data.node, preferences })}
                    `}

                    <!-- Action -->
                    <button class="segment-action-menu slds-button slds-button_icon" title="More Options">
                        <svg xmlns="http://www.w3.org/2000/svg" class="slds-button__icon" width="52px" height="52px" viewBox="0 0 52 52" xml:space="preserve" aria-hidden="true">
                            <path d="M20,44c0-3.3,2.7-6,6-6s6,2.7,6,6s-2.7,6-6,6S20,47.3,20,44z M20,26c0-3.3,2.7-6,6-6s6,2.7,6,6s-2.7,6-6,6 S20,29.3,20,26z M20,8c0-3.3,2.7-6,6-6s6,2.7,6,6s-2.7,6-6,6S20,11.3,20,8z"/>
                        </svg>
                        <span class="slds-assistive-text">More Options</span>
                    </button>

                    <!-- Add Segment -->
                    <div class="segment-add${this.horizontalLayout ? "" : " segment-add-vertical"}">
                        <button class="segment-add-plus slds-button slds-button_icon" title="Add a Segment">
                            <svg xmlns="http://www.w3.org/2000/svg" class="slds-button__icon slds-button__icon_small" height="52" width="52" viewBox="0 0 520 520" fill="#fff">
                                <path d="M300 290h165c8 0 15-7 15-15v-30c0-8-7-15-15-15H300c-6 0-10-4-10-10V55c0-8-7-15-15-15h-30c-8 0-15 7-15 15v165c0 6-4 10-10 10H55c-8 0-15 7-15 15v30c0 8 7 15 15 15h165c6 0 10 4 10 10v165c0 8 7 15 15 15h30c8 0 15-7 15-15V300c0-6 4-10 10-10z"/>
                            </svg>
                        </button>
                        <span class="slds-assistive-text">Add a Segment</span>
                    </div>

                    <!-- Highlight Segment -->
                    <div class="segment-highlight${d.data.node._highlighted ? "" : " off"}"></div>

                </div>
            `;
        },
        kpiContent({ segment, preferences = SPM.Components.Root.preferences }) {
          return !SPM.Components.Root.plan._hasDataSource ? "" : `
                <div class="segment-kpis slds-grid slds-grid_vertical slds-m-top_medium" style="font-size: 10px;">
                    ${preferences.kpis.map((kpiId, i) => {
            var _a, _b;
            const kpiLabel = (_a = this.kpiOptions.find((kpi) => kpi.id === kpiId)) == null ? void 0 : _a.label;
            const kpiValue = ((_b = segment == null ? void 0 : segment._kpis) == null ? void 0 : _b[kpiId]) || 0;
            return `
                            <div class="slds-p-vertical_xxx-small slds-col${i === preferences.kpis.length - 1 ? "" : " slds-border_bottom"}">
                                <div class="segment-kpi-text">${SPM.Utils.Str.sanitizeHTML(kpiLabel)} : ${this.$F("Compact", kpiValue)}</div>
                            </div>
                        `;
          }).join("")}
                </div>
            `;
        },
        buttonContent({ segment }) {
          var _a;
          return !SPM.Components.Root.plan._hasDataSource ? "" : `
                <div class="segment-buttons slds-grid slds-grid_align-spread">
                    ${segment.Id === "all_org" ? "" : `
                        <div class="slds-border_right slds-col slds-size_1-of-2 slds-p-left_x-small">
                            <div class="slds-text-color_weak slds-text-title segment-button-title">Rules</div>
                            <button class="slds-button segment-button segment-button-rules">${segment.sfsp__SalesNodeRules__r.length}</button>
                        </div>
                    `}

                    <div class="slds-col slds-size_1-of-2 slds-p-left_small">
                        <div class="slds-text-color_weak slds-text-title segment-button-title">Records</div>
                        <button class="slds-button segment-button segment-button-records">${this.$F("Compact", ((_a = segment == null ? void 0 : segment._kpis) == null ? void 0 : _a.__Records) || 0)}</button>
                    </div>
                </div>
            `;
        },
        resizeChart(immediate) {
          clearTimeout(this.resizeChartTimeout);
          this.resizeChartTimeout = setTimeout(() => {
            const chartRect = document.querySelector(".chart-container").getBoundingClientRect();
            this.chart.svgWidth(chartRect.width).svgHeight(chartRect.height).layout(this.horizontalLayout ? "left" : "top").render();
          }, immediate === true ? 0 : 200);
        },
        zoomToFit() {
          this.chart.fit();
        },
        // chart events
        onClickChart(e) {
          if (e.target.closest(".segment-name")) {
            const dataId = e.target.closest(".segment").getAttribute("data-id");
            if (dataId !== "all_org") {
              this.viewSegment(this.nodeMap[dataId]);
            }
          }
          if (e.target.closest(".segment-action-menu")) {
            const rect = e.target.getBoundingClientRect();
            this.actionMenuConfig = {
              segmentId: e.target.closest(".segment").getAttribute("data-id"),
              style: {
                top: `${rect.top - 50}px`,
                left: `${rect.left}px`
              }
            };
          }
          if (e.target.closest(".segment-button-records")) {
            this.viewSegmentRecords({ Id: e.target.closest(".segment").getAttribute("data-id") });
          }
          if (e.target.closest(".segment-button-rules")) {
            this.viewSegmentRules(this.nodeMap[e.target.closest(".segment").getAttribute("data-id")]);
          }
          if (e.target.closest(".segment-add-plus")) {
            this.launchAddSegments(this.nodeMap[e.target.closest(".segment").getAttribute("data-id")]);
          }
        },
        onClickAction(action) {
          const segment = this.nodeMap[this.actionMenuConfig.segmentId];
          switch (action.id) {
            case "View Records":
              this.viewSegmentRecords({ Id: this.actionMenuConfig.segmentId });
              break;
            case "View Segment":
              this.viewSegment(segment);
              break;
            case "Edit Segment":
              this.editNodeModalConfig = {
                node: segment,
                callback: ({ node, childOrderChanged }) => {
                  let doUpdateRender = false;
                  let doUpdateValues = false;
                  const chartData = this.chart.data();
                  const nodeData = chartData.find((d) => d.id === node.Id);
                  this.updateSegmentDetails(node);
                  if (nodeData.parentId !== node._parentId) {
                    nodeData.parentId = node._parentId;
                    doUpdateRender = true;
                    doUpdateValues = true;
                  }
                  if (childOrderChanged) {
                    doUpdateRender = true;
                    const childMap = node.sfsp__SalesNodes__r.reduce((map2, childNode, i) => {
                      map2[childNode.Id] = i + 1;
                      return map2;
                    }, {});
                    const childData = SPM.Utils.Arr.splice(chartData, (d) => !!childMap[d.id]);
                    childData.sort((a, b) => childMap[a.id] === childMap[b.id] ? 0 : childMap[a.id] > childMap[b.id] ? 1 : -1);
                    chartData.push(...childData);
                  }
                  if (doUpdateRender)
                    this.chart.render();
                  if (doUpdateValues)
                    this.updateSegmentValues();
                }
              };
              break;
            case "Manage Rules":
              this.viewSegmentRules(segment);
              break;
            case "Delete Descendants":
              this.confirmModalConfig = {
                title: `Delete ${segment.Name}'s descendants`,
                description: "Deleting this segment's descendants also deletes their rules and descendants permanently.",
                confirmButton: {
                  label: "Delete",
                  type: "destructive"
                },
                cancelButton: {
                  label: "Cancel",
                  type: "neutral"
                },
                callback: () => {
                  this.deleteSegment(segment, true);
                }
              };
              break;
            case "Delete Segment":
              this.confirmModalConfig = {
                title: `Delete ${segment.Name}`,
                description: "Deleting this segment also deletes its rules and descendants permanently.",
                confirmButton: {
                  label: "Delete",
                  type: "destructive"
                },
                cancelButton: {
                  label: "Cancel",
                  type: "neutral"
                },
                callback: () => {
                  this.deleteSegment(segment);
                }
              };
              break;
          }
          this.closeActionMenu();
        },
        onWindowKeydown({ metaKey, key }) {
          if (metaKey && key === "k") {
            this.openChartSearch();
          }
          if (key === "Escape") {
            this.closeChartSearch();
          }
        },
        // action menu
        closeActionMenu(e) {
          var _a;
          if (!((_a = e == null ? void 0 : e.target) == null ? void 0 : _a.closest(".segment-action-menu"))) {
            this.actionMenuConfig = null;
          }
        },
        // chart search
        searchChart(e) {
          if (!this.chartSearchTerm)
            return;
          this.chart.data().forEach((d) => {
            if (d.node.Name.toLowerCase().includes(this.chartSearchTerm.toLowerCase())) {
              d._highlighted = true;
              d._expanded = true;
            } else {
              d._highlighted = false;
            }
          });
          this.chart.render().fit();
        },
        openChartSearch() {
          this.showChartSearch = true;
          this.$nextTick(() => this.$refs.chartSearchInput.focus());
        },
        closeChartSearch() {
          this.chart.clearHighlighting();
          this.showChartSearch = false;
          this.chartSearchTerm = "";
        }
      }
    };
    const _hoisted_1$4 = { class: "org-view" };
    const _hoisted_2$4 = { class: "chart-controls" };
    const _hoisted_3$2 = {
      key: 0,
      class: "chart-search"
    };
    const _hoisted_4$2 = {
      class: "slds-dropdown__list",
      role: "menu"
    };
    const _hoisted_5$2 = {
      key: 0,
      class: "slds-has-divider_top-space",
      role: "separator"
    };
    const _hoisted_6$2 = ["onClick"];
    const _hoisted_7$1 = ["tabindex"];
    const _hoisted_8$1 = ["title"];
    function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_CheckboxButton = resolveComponent("CheckboxButton");
      const _component_AddSegmentsModal = resolveComponent("AddSegmentsModal");
      const _component_EditNodeModal = resolveComponent("EditNodeModal");
      const _component_ConfigureModal = resolveComponent("ConfigureModal");
      const _component_ConfirmModal = resolveComponent("ConfirmModal");
      const _component_ViewRecords = resolveComponent("ViewRecords");
      const _directive_click_outside = resolveDirective("click-outside");
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$4, [
          createVNode(_component_CheckboxButton, {
            modelValue: $data.horizontalLayout,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.horizontalLayout = $event),
            icon: "org_chart",
            title: `Change Chart Layout to ${$data.horizontalLayout ? "Vertical" : "Horizontal"}`,
            class: "slds-m-right_xx-small"
          }, null, 8, ["modelValue", "title"]),
          createVNode(_component_CheckboxButton, {
            modelValue: $data.compactLayout,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.compactLayout = $event),
            icon: "contract_alt",
            title: "Compact Layout",
            class: "slds-m-right_xx-small"
          }, null, 8, ["modelValue"]),
          createVNode(_component_CheckboxButton, {
            icon: "zoom_to_fit",
            title: "Zoom to Fit",
            class: "slds-m-right_xx-small",
            onClick: $options.zoomToFit
          }, null, 8, ["onClick"]),
          createVNode(_component_CheckboxButton, {
            icon: "search",
            title: "Search Segments",
            class: "slds-m-right_xx-small",
            onClick: $options.openChartSearch
          }, null, 8, ["onClick"])
        ]),
        $data.showChartSearch ? withDirectives((openBlock(), createElementBlock("div", _hoisted_3$2, [
          withDirectives(createBaseVNode("input", {
            ref: "chartSearchInput",
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.chartSearchTerm = $event),
            type: "text",
            onKeyup: _cache[3] || (_cache[3] = (...args) => $options.searchChart && $options.searchChart(...args))
          }, null, 544), [
            [vModelText, $data.chartSearchTerm]
          ])
        ])), [
          [_directive_click_outside, $options.closeChartSearch]
        ]) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: "chart-container",
          style: { "width": "100%", "height": "100%", "background": "#f5f5f5", "overflow": "hidden" },
          onClick: _cache[4] || (_cache[4] = (...args) => $options.onClickChart && $options.onClickChart(...args))
        }),
        $data.actionMenuConfig ? withDirectives((openBlock(), createElementBlock("div", {
          key: 1,
          class: "slds-dropdown slds-dropdown_left",
          style: normalizeStyle($data.actionMenuConfig.style)
        }, [
          createBaseVNode("ul", _hoisted_4$2, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($options.segmentActions, (action, i) => {
              return openBlock(), createElementBlock(Fragment, {
                key: action.id
              }, [
                action.spacer ? (openBlock(), createElementBlock("li", _hoisted_5$2)) : (openBlock(), createElementBlock("li", {
                  key: 1,
                  class: "slds-dropdown__item",
                  role: "presentation",
                  onClick: ($event) => $options.onClickAction(action)
                }, [
                  createBaseVNode("a", {
                    href: "#",
                    role: "menuitem",
                    tabindex: i
                  }, [
                    createBaseVNode("span", {
                      class: normalizeClass(["slds-truncate", { "slds-text-color_destructive": action.destructive }]),
                      title: action.label
                    }, toDisplayString(action.label), 11, _hoisted_8$1)
                  ], 8, _hoisted_7$1)
                ], 8, _hoisted_6$2))
              ], 64);
            }), 128))
          ])
        ], 4)), [
          [_directive_click_outside, $options.closeActionMenu]
        ]) : createCommentVNode("", true),
        $data.addSegmentsModalConfig ? (openBlock(), createBlock(_component_AddSegmentsModal, {
          key: 2,
          config: $data.addSegmentsModalConfig,
          onClose: _cache[5] || (_cache[5] = ($event) => $data.addSegmentsModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true),
        $data.editNodeModalConfig ? (openBlock(), createBlock(_component_EditNodeModal, {
          key: 3,
          config: $data.editNodeModalConfig,
          onClose: _cache[6] || (_cache[6] = ($event) => $data.editNodeModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true),
        $data.configureModalConfig ? (openBlock(), createBlock(_component_ConfigureModal, {
          key: 4,
          config: $data.configureModalConfig,
          onClose: _cache[7] || (_cache[7] = ($event) => $data.configureModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true),
        $data.confirmModalConfig ? (openBlock(), createBlock(_component_ConfirmModal, {
          key: 5,
          config: $data.confirmModalConfig,
          onClose: _cache[8] || (_cache[8] = ($event) => $data.confirmModalConfig = null)
        }, null, 8, ["config"])) : createCommentVNode("", true),
        createVNode(Transition$1, { name: "slide-fade-drawer" }, {
          default: withCtx(() => [
            $data.viewRecordsConfig ? (openBlock(), createBlock(_component_ViewRecords, {
              key: 0,
              class: "bottom-drawer",
              config: $data.viewRecordsConfig,
              onClose: _cache[9] || (_cache[9] = ($event) => $data.viewRecordsConfig = null)
            }, null, 8, ["config"])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    }
    const OrgView = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-ae088942"]]);
    const _sfc_main$3 = {
      name: "ValuePicklist",
      components: { Picklist, SLDSButton: Button },
      props: ["field", "values", "label"],
      emits: ["values-selected", "disable-picklist"],
      data() {
        return {
          selectedValues: [],
          valueOptions: [],
          showSelectedOptions: false,
          picklistIsOpen: false,
          isInitializing: false
        };
      },
      computed: {
        showSelectedButton() {
          return this.selectedValues.length && !this.showSelectedOptions;
        },
        buttonLabel() {
          return this.showSelectedButton ? `Show Selected (${this.computedSelectedValues.length})` : "Show All";
        },
        computedPlaceholder() {
          if (this.isInitializing)
            return "";
          return this.picklistIsOpen ? "Search..." : `${this.computedSelectedValues.length} Values Selected`;
        },
        computedSelectedValues() {
          return this.selectedValues.filter((value) => value !== "All");
        },
        picklistOptions() {
          let options = [...this.valueOptions];
          if (this.showSelectedOptions) {
            options = options.filter((option) => this.selectedValues.includes(option) && option !== "All");
          } else {
            options.unshift("All");
          }
          return options;
        },
        allValuesSelected() {
          return this.picklistOptions.filter((value) => value !== "All").length === this.computedSelectedValues.length;
        }
      },
      watch: {
        selectedValues: {
          handler() {
            this.convertValuesToString();
          },
          deep: true
        }
      },
      mounted() {
        this.isInitializing = true;
        if (this.$props.values)
          this.selectedValues = this.$props.values.split(",");
        this.getValueOptions();
      },
      methods: {
        async getValueOptions() {
          let saql = SPM.Utils.Segment.Node.generateNodeFilterSaql({
            node: SPM.Components.Root.nodeMap[SPM.Components.RulesPanel.node._parentId],
            nodeMap: SPM.Components.Root.nodeMap,
            dataSource: SPM.Components.OrgView.dataSource
          });
          saql += `
                    -- results
                    results = group results by ${this.$props.field};
                    results = foreach results generate ${this.$props.field};
                    results = limit results 2001;
                `;
          const { results } = await SPM.Utils.Rest.invoke("RunSaql", { query: saql.replace(/^ */gm, "") });
          if (results.records.length > 2e3) {
            this.$emit("disable-picklist");
            return;
          }
          this.isInitializing = false;
          this.valueOptions = results.records.map((record) => record[this.$props.field]);
          if (this.allValuesSelected)
            this.selectedValues = [...this.selectedValues, "All"];
        },
        async togglePicklist() {
          this.$refs.valuePicklist.reset();
          this.showSelectedOptions = this.showSelectedButton;
          await this.$nextTick();
          this.$refs.valuePicklist.activationHandler();
        },
        convertValuesToString() {
          const valueString = this.computedSelectedValues.join(",");
          this.$emit("values-selected", valueString);
        },
        onPicklistOpen() {
          this.picklistIsOpen = true;
          if (!this.showSelectedOptions)
            this.checkForAllSelectedOptions();
        },
        onPicklistClose() {
          this.showSelectedOptions = false;
          this.picklistIsOpen = false;
        },
        async onOptionSelected(option) {
          if (this.showSelectedOptions && !this.selectedValues.includes(option.id)) {
            this.$refs.valuePicklist.reset();
            await this.$nextTick();
            this.$refs.valuePicklist.activationHandler();
            if (this.selectedValues.length === 0)
              this.showSelectedOptions = false;
            return;
          }
          if (option.id === "All") {
            if (this.selectedValues.includes("All")) {
              this.selectedValues = this.picklistOptions;
            } else {
              this.selectedValues = [];
            }
            return;
          }
          this.checkForAllSelectedOptions();
        },
        checkForAllSelectedOptions() {
          if (this.allValuesSelected) {
            this.selectedValues = [...this.selectedValues, "All"];
          } else {
            this.selectedValues = this.selectedValues.filter((value) => value !== "All");
          }
        }
      }
    };
    const _hoisted_1$3 = { class: "slds-is-relative" };
    const _hoisted_2$3 = {
      key: 0,
      class: "slds-is-absolute spm-show-button"
    };
    function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Picklist = resolveComponent("Picklist");
      const _component_SLDSButton = resolveComponent("SLDSButton");
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createVNode(_component_Picklist, {
          ref: "valuePicklist",
          modelValue: $data.selectedValues,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.selectedValues = $event),
          labels: { name: _ctx.$props.label, search: $options.computedPlaceholder },
          minSearchLength: 0,
          remainOpenOnSelect: "",
          multiselect: "",
          filterable: "",
          options: $options.picklistOptions,
          disabled: $data.isInitializing,
          onDetached: $options.onPicklistOpen,
          onReset: $options.onPicklistClose,
          onSelectedOption: $options.onOptionSelected
        }, null, 8, ["modelValue", "labels", "options", "disabled", "onDetached", "onReset", "onSelectedOption"]),
        !$data.isInitializing ? (openBlock(), createElementBlock("div", _hoisted_2$3, [
          createVNode(_component_SLDSButton, {
            label: $options.buttonLabel,
            variant: "base",
            onClick: $options.togglePicklist
          }, null, 8, ["label", "onClick"])
        ])) : createCommentVNode("", true)
      ]);
    }
    const ValuePicklist = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-c7f682f0"]]);
    const inputUtils = {
      validateNumberInput(value) {
        const errors = [];
        if (!value || !/^[-+]?\d*\.?\d+$/.test(value))
          errors.push("Please enter a valid value");
        return errors;
      }
    };
    const _sfc_main$2 = {
      components: {
        Button,
        ButtonIcon,
        Picklist,
        Popover,
        TextInput,
        ValuePicklist
      },
      props: {
        bindTo: {
          type: HTMLElement,
          required: true
        },
        rule: {
          type: Object,
          default: () => {
          }
        }
      },
      emits: ["close", "update:useFilterLogic", "update:filterLogic", "rule-added"],
      data() {
        return {
          fieldOptions: SPM.Components.OrgView.dataSource._referenceFields,
          errors: {
            name: [],
            filterLogic: []
          },
          operatorOptions: {
            Numeric: [
              { id: "==", title: "equals" },
              { id: "!=", title: "not equal to" },
              { id: "<", title: "less than" },
              { id: "<=", title: "less than or equal to" },
              { id: ">", title: "greater than" },
              { id: ">=", title: "greater than or equal to" }
            ],
            Text: [
              { id: "==", title: "equals" },
              { id: "!=", title: "not equal to" },
              { id: "like", title: "contains" },
              { id: "doesnotcontain", title: "does not contain" },
              { id: "startsWith", title: "starts with" }
            ]
          }
        };
      },
      created() {
        SPM.Components.RulePopover = this;
        this.rule.sfsp__SalesNodeRuleItems__r = this.rule.sfsp__SalesNodeRuleItems__r || [];
        this.rule.sfsp__SalesNodeRuleItems__r.forEach((item) => {
          var _a;
          const dataType = (_a = this.fieldOptions.find((f) => f.id === item.sfsp__Field__c)) == null ? void 0 : _a.dataType;
          item._operatorOptions = this.operatorOptions[dataType] || [];
          this.onOperatorSelected(item);
        });
        this.rule.sfsp__BooleanFilter__c = this.rule.sfsp__BooleanFilter__c || "";
      },
      methods: {
        addItem() {
          this.rule.sfsp__SalesNodeRuleItems__r.push({
            sobjectType: "sfsp__SalesNodeRuleItem__c",
            sfsp__Field__c: "",
            sfsp__Operator__c: "",
            sfsp__Value__c: "",
            _operatorOptions: [],
            _showValuePicklist: false
          });
          this.rule.sfsp__BooleanFilter__c += this.rule.sfsp__BooleanFilter__c ? ` and ${this.rule.sfsp__SalesNodeRuleItems__r.length}` : "1";
        },
        removeItem(item) {
          const itemIndex = this.rule.sfsp__SalesNodeRuleItems__r.indexOf(item);
          this.rule.sfsp__SalesNodeRuleItems__r.splice(itemIndex, 1);
          this.rule.sfsp__BooleanFilter__c = SPM.Utils.Filter.removeBooleanFilterExpression(this.rule.sfsp__BooleanFilter__c, itemIndex + 1);
        },
        onFieldSelected(item) {
          var _a;
          const dataType = (_a = this.fieldOptions.find((f) => f.id === item.sfsp__Field__c)) == null ? void 0 : _a.dataType;
          item._operatorOptions = this.operatorOptions[dataType] || [];
          item._showValuePicklist = false;
          item.sfsp__Operator__c = "";
          item.sfsp__Value__c = "";
          item._fieldErrors = [];
          this.onOperatorSelected(item);
        },
        onOperatorSelected(item) {
          var _a;
          const dataType = (_a = this.fieldOptions.find((f) => f.id === item.sfsp__Field__c)) == null ? void 0 : _a.dataType;
          item._showValuePicklist = dataType === "Text" && ["==", "!="].includes(item.sfsp__Operator__c);
          item._operatorErrors = [];
        },
        addRule() {
          this.validateName();
          this.validateFilterLogic();
          this.validateItems();
          if (this.errors.name.length || this.errors.filterLogic.length || this.rule.sfsp__SalesNodeRuleItems__r.find((item) => item._fieldErrors.length || item._operatorErrors.length || item._valueErrors.length))
            return;
          this.$emit("rule-added", this.rule);
        },
        validateName() {
          this.errors.name = [];
          if (!this.rule.Name)
            this.errors.name.push("Please enter a rule name");
          else if (this.rule.Name.length > 80)
            this.errors.name.push("Rule name should be less than 80 characters long");
        },
        validateFilterLogic() {
          this.errors.filterLogic = SPM.Utils.Rule.validateCustomLogic(this.rule.sfsp__BooleanFilter__c, this.rule.sfsp__SalesNodeRuleItems__r.length) ? [] : ["Rule logic is invalid"];
        },
        validateItems() {
          this.rule.sfsp__SalesNodeRuleItems__r.forEach((item) => {
            var _a;
            item._fieldErrors = item.sfsp__Field__c ? [] : ["Field is required"];
            item._operatorErrors = item.sfsp__Operator__c ? [] : ["Operator is required"];
            const dataType = (_a = this.fieldOptions.find((f) => f.id === item.sfsp__Field__c)) == null ? void 0 : _a.dataType;
            item._valueErrors = dataType === "Numeric" ? this.validateNumeric(item.sfsp__Value__c) : [];
          });
        },
        validateNumeric(value) {
          return inputUtils.validateNumberInput(value);
        }
      }
    };
    const _withScopeId = (n) => (pushScopeId("data-v-cb371009"), n = n(), popScopeId(), n);
    const _hoisted_1$2 = { class: "max-height slds-scrollable_y" };
    const _hoisted_2$2 = { class: "slds-m-top_small" };
    const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h2", { class: "slds-expression__title" }, "Rule Criteria", -1));
    const _hoisted_4$1 = {
      key: 0,
      class: "items-table slds-m-top_small"
    };
    const _hoisted_5$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("thead", null, [
      /* @__PURE__ */ createBaseVNode("tr", null, [
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "1.5rem" } }),
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "10rem" } }, "Field"),
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "8rem" } }, "Operator"),
        /* @__PURE__ */ createBaseVNode("th", null, "Value"),
        /* @__PURE__ */ createBaseVNode("th", { style: { "width": "0" } })
      ])
    ], -1));
    const _hoisted_6$1 = { class: "slds-grid slds-grid_vertical-align-center" };
    function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_TextInput = resolveComponent("TextInput");
      const _component_Picklist = resolveComponent("Picklist");
      const _component_ValuePicklist = resolveComponent("ValuePicklist");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_Button = resolveComponent("Button");
      const _component_Popover = resolveComponent("Popover");
      return openBlock(), createBlock(_component_Popover, {
        width: "x-large",
        bindTo: _ctx.$props.bindTo,
        alignment: "left bottom",
        position: "fixed",
        onClose: _cache[5] || (_cache[5] = ($event) => _ctx.$emit("close"))
      }, {
        header: withCtx(() => [
          createTextVNode(toDisplayString($props.rule.Id ? "Edit Rule" : "Add Rule"), 1)
        ]),
        content: withCtx(() => [
          createBaseVNode("div", _hoisted_1$2, [
            createVNode(_component_TextInput, {
              modelValue: $props.rule.Name,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $props.rule.Name = $event),
              class: "slds-size_1-of-2",
              labels: { name: "Name" },
              errors: $data.errors.name,
              onInput: _cache[1] || (_cache[1] = ($event) => $data.errors.name = [])
            }, null, 8, ["modelValue", "errors"]),
            createBaseVNode("div", _hoisted_2$2, [
              _hoisted_3$1,
              createVNode(_component_TextInput, {
                modelValue: $props.rule.sfsp__BooleanFilter__c,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $props.rule.sfsp__BooleanFilter__c = $event),
                labels: { name: "Filter Logic", placeholder: "1 or 2..." },
                errors: $data.errors.filterLogic,
                onInput: _cache[3] || (_cache[3] = ($event) => $data.errors.filterLogic = [])
              }, null, 8, ["modelValue", "labels", "errors"]),
              $props.rule.sfsp__SalesNodeRuleItems__r.length ? (openBlock(), createElementBlock("table", _hoisted_4$1, [
                _hoisted_5$1,
                createBaseVNode("tbody", null, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($props.rule.sfsp__SalesNodeRuleItems__r, (item, i) => {
                    return openBlock(), createElementBlock("tr", { key: i }, [
                      createBaseVNode("td", null, toDisplayString(i + 1), 1),
                      createBaseVNode("td", null, [
                        createVNode(_component_Picklist, {
                          modelValue: item.sfsp__Field__c,
                          "onUpdate:modelValue": [($event) => item.sfsp__Field__c = $event, ($event) => $options.onFieldSelected(item)],
                          labelForId: `item-${i}-field`,
                          options: $data.fieldOptions,
                          titleKey: "label",
                          filterable: "",
                          errors: item._fieldErrors
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "labelForId", "options", "errors"])
                      ]),
                      createBaseVNode("td", null, [
                        createVNode(_component_Picklist, {
                          modelValue: item.sfsp__Operator__c,
                          "onUpdate:modelValue": [($event) => item.sfsp__Operator__c = $event, ($event) => $options.onOperatorSelected(item)],
                          labelForId: `item-${i}-operator`,
                          options: item._operatorOptions,
                          disabled: !item.sfsp__Field__c,
                          errors: item._operatorErrors
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "labelForId", "options", "disabled", "errors"])
                      ]),
                      createBaseVNode("td", null, [
                        item._showValuePicklist ? (openBlock(), createBlock(_component_ValuePicklist, {
                          key: 0,
                          labelForId: `item-${i}-value`,
                          values: item.sfsp__Value__c,
                          field: item.sfsp__Field__c,
                          onValuesSelected: (values) => item.sfsp__Value__c = values,
                          onDisablePicklist: ($event) => item._showValuePicklist = false
                        }, null, 8, ["labelForId", "values", "field", "onValuesSelected", "onDisablePicklist"])) : (openBlock(), createBlock(_component_TextInput, {
                          key: 1,
                          modelValue: item.sfsp__Value__c,
                          "onUpdate:modelValue": ($event) => item.sfsp__Value__c = $event,
                          errors: item._valueErrors,
                          disabled: !item.sfsp__Field__c || !item.sfsp__Operator__c
                        }, null, 8, ["modelValue", "onUpdate:modelValue", "errors", "disabled"]))
                      ]),
                      createBaseVNode("td", null, [
                        createVNode(_component_ButtonIcon, {
                          iconCategory: "utility",
                          iconName: "delete",
                          variant: "border-filled",
                          assistiveText: "Remove",
                          title: "Remove",
                          onClick: ($event) => $options.removeItem(item)
                        }, null, 8, ["onClick"])
                      ])
                    ]);
                  }), 128))
                ])
              ])) : createCommentVNode("", true),
              $props.rule.sfsp__SalesNodeRuleItems__r.length < 10 ? (openBlock(), createBlock(_component_Button, {
                key: 1,
                variant: "neutral",
                iconCategory: "utility",
                iconName: "add",
                label: "Add Rule Criteria",
                class: "slds-m-top_x-small",
                onClick: $options.addItem
              }, null, 8, ["onClick"])) : createCommentVNode("", true)
            ])
          ])
        ]),
        footer: withCtx(() => [
          createBaseVNode("div", _hoisted_6$1, [
            createVNode(_component_Button, {
              class: "slds-col_bump-left",
              variant: "neutral",
              label: "Cancel",
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.$emit("close"))
            }),
            createVNode(_component_Button, {
              variant: "brand",
              label: "Save",
              onClick: $options.addRule
            }, null, 8, ["onClick"])
          ])
        ]),
        _: 1
      }, 8, ["bindTo"]);
    }
    const RulePopover = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-cb371009"]]);
    const _sfc_main$1 = {
      name: "RulesPanel",
      components: {
        RulePopover,
        Button,
        ButtonIcon,
        Spinner,
        ActionMenu,
        ActionMenuItem,
        Tooltip,
        TextInput
      },
      props: ["node"],
      data() {
        return {
          loadingMsg: "",
          rulePopoverBindTo: null,
          rule: null,
          logic: "",
          editingLogic: false,
          errors: {
            logic: []
          },
          addNewRuleDisabled: false
        };
      },
      watch: {
        node: {
          handler() {
            this.logic = SPM.Utils.Segment.Node.getRuleLogic({ node: this.node });
            this.editingLogic = false;
          },
          immediate: true
        }
      },
      async mounted() {
        SPM.Components.RulesPanel = this;
      },
      methods: {
        // rules
        getRuleTooltipContent(rule) {
          return rule.sfsp__SalesNodeRuleItems__r ? SPM.Utils.Rule.toString(rule) : "";
        },
        async saveRule({ Id, Name, sfsp__SortOrder__c, sfsp__BooleanFilter__c, sfsp__SalesNodeRuleItems__r }) {
          this.closeRulePopover();
          let rule = this.node.sfsp__SalesNodeRules__r.find((r) => r.Id === Id);
          SPM.Utils.CRM.delete({ records: (rule == null ? void 0 : rule.sfsp__SalesNodeRuleItems__r) || [] });
          if (!rule) {
            rule = arguments[0];
            this.node.sfsp__SalesNodeRules__r.push(rule);
            this.logic += this.logic ? ` or ${this.node.sfsp__SalesNodeRules__r.length}` : "1";
            await this.saveRuleLogic({ silent: true });
          }
          Object.assign(rule, {
            sobjectType: "sfsp__SalesNodeRule__c",
            Name,
            sfsp__SalesNode__c: this.node.Id,
            sfsp__SortOrder__c: sfsp__SortOrder__c || this.node.sfsp__SalesNodeRules__r.length,
            sfsp__FilterLogic__c: "custom",
            sfsp__BooleanFilter__c,
            sfsp__SalesNodeRuleItems__r: sfsp__SalesNodeRuleItems__r.map((item, i) => ({
              ...item,
              sobjectType: "sfsp__SalesNodeRuleItem__c",
              Id: void 0,
              sfsp__SortOrder__c: i
            }))
          });
          SPM.Components.OrgView.updateSegmentValues();
          await SPM.Utils.CRM.upsert({ records: [rule] });
          rule.sfsp__SalesNodeRuleItems__r.forEach((ri) => ri.sfsp__SalesNodeRule__c = rule.Id);
          await SPM.Utils.CRM.upsert({ records: rule.sfsp__SalesNodeRuleItems__r });
        },
        deleteRule(rule) {
          this.closeRulePopover();
          const ruleIndex = this.node.sfsp__SalesNodeRules__r.indexOf(rule);
          this.node.sfsp__SalesNodeRules__r.splice(ruleIndex, 1);
          if (this.logic === "1" && ruleIndex === 0) {
            this.logic = "";
          } else {
            this.logic = SPM.Utils.Filter.removeBooleanFilterExpression(this.logic, ruleIndex + 1);
          }
          this.saveRuleLogic();
          SPM.Utils.CRM.delete({ records: [rule] });
        },
        async saveRuleLogic({ silent } = {}) {
          if (this.logic) {
            if (SPM.Utils.Rule.validateCustomLogic(this.logic, this.node.sfsp__SalesNodeRules__r.length)) {
              this.errors.logic = [];
              this.editingLogic = false;
            } else {
              this.errors.logic = ["Rule logic is invalid"];
              this.editingLogic = true;
              return;
            }
          }
          SPM.Utils.Segment.Node.setRuleLogic({ node: this.node, logic: this.logic });
          await SPM.Utils.CRM.upsert({ records: [this.node] });
          if (!silent)
            SPM.Components.OrgView.updateSegmentValues();
        },
        // rule popover
        openRulePopover({ bindTo, rule }) {
          this.rulePopoverBindTo = bindTo;
          this.rule = rule;
          this.addNewRuleDisabled = true;
        },
        closeRulePopover() {
          this.rule = null;
          this.addNewRuleDisabled = false;
        },
        // panel
        closePanel() {
          this.closeRulePopover();
          SPM.Components.Root.selectedNode = null;
          SPM.Components.Root.sidePanel = "";
        }
      }
    };
    const _hoisted_1$1 = { class: "slds-panel slds-panel_docked slds-panel_docked-right slds-size_medium slds-grid slds-grid_vertical" };
    const _hoisted_2$1 = { class: "slds-panel__header" };
    const _hoisted_3 = /* @__PURE__ */ createBaseVNode("h2", { class: "slds-panel__header-title slds-text-heading_small slds-truncate" }, "Manage Rules", -1);
    const _hoisted_4 = { class: "slds-panel__header-actions" };
    const _hoisted_5 = { class: "slds-panel__body slds-grid slds-grid_vertical slds-grow" };
    const _hoisted_6 = /* @__PURE__ */ createBaseVNode("div", { style: { "font-weight": "700" } }, "Segment", -1);
    const _hoisted_7 = /* @__PURE__ */ createBaseVNode("div", {
      class: "slds-m-top_small",
      style: { "font-weight": "700" }
    }, "Rules", -1);
    const _hoisted_8 = {
      key: 0,
      class: "slds-m-vertical_x-small"
    };
    const _hoisted_9 = {
      ref: "objectRules",
      class: "spm-box"
    };
    const _hoisted_10 = { class: "slds-m-right_large" };
    const _hoisted_11 = {
      key: 1,
      class: "slds-grid slds-grid_vertical slds-align_absolute-center slds-m-vertical_large"
    };
    const _hoisted_12 = /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-heading_small slds-m-bottom_xx-small" }, "No rules yet", -1);
    const _hoisted_13 = /* @__PURE__ */ createBaseVNode("div", { class: "slds-text-body" }, "Create rules to start assigning records.", -1);
    const _hoisted_14 = [
      _hoisted_12,
      _hoisted_13
    ];
    function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Spinner = resolveComponent("Spinner");
      const _component_ButtonIcon = resolveComponent("ButtonIcon");
      const _component_TextInput = resolveComponent("TextInput");
      const _component_Tooltip = resolveComponent("Tooltip");
      const _component_ActionMenuItem = resolveComponent("ActionMenuItem");
      const _component_ActionMenu = resolveComponent("ActionMenu");
      const _component_Button = resolveComponent("Button");
      const _component_RulePopover = resolveComponent("RulePopover");
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
          description: withCtx(() => [
            createTextVNode(toDisplayString($data.loadingMsg), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_2$1, [
          _hoisted_3,
          createBaseVNode("div", _hoisted_4, [
            createVNode(_component_ButtonIcon, {
              iconCategory: "utility",
              iconName: "close",
              title: "Collapse Panel Header",
              assistiveText: "Collapse Panel Header",
              onClick: $options.closePanel
            }, null, 8, ["onClick"])
          ])
        ]),
        createBaseVNode("div", _hoisted_5, [
          _hoisted_6,
          createBaseVNode("div", null, toDisplayString($props.node.Name), 1),
          _hoisted_7,
          $props.node.sfsp__SalesNodeRules__r.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_8, [
            !$data.editingLogic ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: "slds-button_reset slds-grid slds-grid_vertical-align-center",
              style: { "width": "100%" },
              onClick: _cache[0] || (_cache[0] = ($event) => $data.editingLogic = true)
            }, [
              createTextVNode(toDisplayString($data.logic) + " ", 1),
              createVNode(_component_ButtonIcon, {
                class: "slds-col_bump-left",
                iconCategory: "utility",
                iconName: "edit",
                title: "Edit Filter Logic",
                assistiveText: "Edit Filter Logic"
              })
            ])) : (openBlock(), createBlock(_component_TextInput, {
              key: 1,
              modelValue: $data.logic,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.logic = $event),
              class: "slds-input-has-icon slds-input-has-icon_right",
              errors: $data.errors.logic,
              onInput: _cache[2] || (_cache[2] = ($event) => $data.errors.logic = [])
            }, {
              extend: withCtx(() => [
                createVNode(_component_ButtonIcon, {
                  iconCategory: "utility",
                  iconName: "check",
                  iconClass: ["slds-button__icon"],
                  class: "slds-button slds-button_icon slds-input__icon slds-input__icon_right",
                  title: "Save",
                  assistiveText: "Save",
                  onClick: $options.saveRuleLogic
                }, null, 8, ["onClick"])
              ]),
              _: 1
            }, 8, ["modelValue", "errors"]))
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_9, [
            $props.node.sfsp__SalesNodeRules__r.length > 0 ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($props.node.sfsp__SalesNodeRules__r, (rule, i) => {
              return openBlock(), createElementBlock("div", {
                key: i,
                ref_for: true,
                ref: `rule-${i}`,
                class: "slds-grid slds-grid_vertical-align-center slds-p-vertical_x-small slds-p-horizontal_small slds-border_top"
              }, [
                createVNode(_component_Tooltip, {
                  text: $options.getRuleTooltipContent(rule),
                  alignment: "left"
                }, {
                  source: withCtx(() => [
                    createBaseVNode("span", _hoisted_10, toDisplayString(i + 1), 1),
                    createBaseVNode("span", null, toDisplayString(rule.Name), 1)
                  ]),
                  _: 2
                }, 1032, ["text"]),
                createVNode(_component_ActionMenu, { class: "slds-col_bump-left" }, {
                  button: withCtx(() => [
                    createVNode(_component_ButtonIcon, {
                      iconCategory: "utility",
                      iconName: "down",
                      variant: "border-filled",
                      size: "x-small",
                      assistiveText: `${rule.Name} Actions`,
                      title: `${rule.Name} Actions`
                    }, null, 8, ["assistiveText", "title"])
                  ]),
                  default: withCtx(() => [
                    createVNode(_component_ActionMenuItem, {
                      label: "Edit",
                      onClick: ($event) => $options.openRulePopover({ bindTo: _ctx.$refs[`rule-${i}`][0], rule: JSON.parse(JSON.stringify(rule)) })
                    }, null, 8, ["onClick"]),
                    createVNode(_component_ActionMenuItem, {
                      label: "Delete",
                      onClick: ($event) => $options.deleteRule(rule)
                    }, null, 8, ["onClick"])
                  ]),
                  _: 2
                }, 1024)
              ]);
            }), 128)) : (openBlock(), createElementBlock("div", _hoisted_11, _hoisted_14))
          ], 512),
          $props.node.sfsp__SalesNodeRules__r.length < 10 ? (openBlock(), createBlock(_component_Button, {
            key: 1,
            ref: "new-rule",
            iconCategory: "utility",
            iconName: "add",
            variant: "neutral",
            label: "Add New Rule",
            class: "slds-m-top_small",
            style: { "align-self": "flex-start" },
            disabled: $data.addNewRuleDisabled,
            onClick: _cache[3] || (_cache[3] = ($event) => $options.openRulePopover({ bindTo: _ctx.$refs["new-rule"].$el, rule: {} }))
          }, null, 8, ["disabled"])) : createCommentVNode("", true)
        ]),
        $data.rule ? (openBlock(), createBlock(_component_RulePopover, {
          key: 1,
          bindTo: $data.rulePopoverBindTo,
          rule: $data.rule,
          onClose: $options.closeRulePopover,
          onRuleAdded: $options.saveRule
        }, null, 8, ["bindTo", "rule", "onClose", "onRuleAdded"])) : createCommentVNode("", true)
      ]);
    }
    const RulesPanel = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
    const _sfc_main = {
      name: "AppRoot",
      components: {
        BuilderHeader,
        OrgView,
        RulesPanel,
        NoAccess,
        // slds
        Spinner,
        Toasts
      },
      data() {
        return {
          userAccess: [],
          loadingMsg: "Loading plan...",
          ready: false,
          modals: {},
          modalConfig: {},
          toasts: [],
          // side panel
          sidePanel: "",
          selectedNode: null,
          plan: SPM.Utils.Plan.defaults(),
          preferences: {
            kpis: []
          },
          nodeMap: {},
          nodeHierarchy: {
            ...SPM.Utils.Segment.Node.defaults(),
            Id: "all_org",
            Name: "All Org",
            _expanded: true
          }
        };
      },
      computed: {
        noAccess() {
          var _a;
          return !(SPM.isAdmin || ((_a = this.userAccess) == null ? void 0 : _a.length));
        }
      },
      watch: {
        preferences: {
          handler() {
            if (!this.ready)
              return;
            this.saveUserPreferences();
          },
          deep: true
        }
      },
      async created() {
        SPM.Components.Root = this;
        if (SPM.UITheme === "Theme4d") {
          document.body.style.marginTop = "-1.25rem";
        }
      },
      async mounted() {
        var _a, _b, _c, _d;
        const params = new URLSearchParams(window.location.search);
        const planId = params.get("planId");
        if (!planId) {
          alert("no plan found");
          return;
        }
        this.userAccess = await SPM.Utils.Apex.invoke("Query", [`
            SELECT
                Id,
                sfsp__User__c
            FROM sfsp__SalesUserAccess__c
            WHERE sfsp__SalesPlan__c = '${planId}' AND sfsp__User__c = '${SPM.currentUser.Id}'
            `]);
        this.plan = {
          ...SPM.Utils.Plan.defaults(),
          ...(await SPM.Utils.Apex.invoke("Query", [`
                SELECT
                    Id,
                    Name,
                    sfsp__Owner__r.Name,
                    sfsp__Owner__r.SmallPhotoUrl,
                    sfsp__Owner__r.Title,
                    sfsp__SalesDataSource__r.sfsp__SourceId__c,
                    sfsp__SalesDataSource__r.sfsp__ReferenceFields__c,
                    (SELECT sfsp__Preferences__c FROM sfsp__SalesUserPreferences__r WHERE sfsp__User__c = '${SPM.currentUser.Id}')
                FROM sfsp__SalesPlan__c
                WHERE Id = '${planId}'
            `]))[0]
        };
        Object.assign(this.preferences, JSON.parse(((_c = (_b = (_a = this.plan) == null ? void 0 : _a.sfsp__SalesUserPreferences__r) == null ? void 0 : _b[0]) == null ? void 0 : _c.sfsp__Preferences__c) || "{}"));
        const nodes = await SPM.Utils.Apex.invoke(
          "Query",
          [`
                SELECT
                    Id,
                    Name,
                    sfsp__Parent__c,
                    sfsp__Owner__r.Name,
                    sfsp__Owner__r.SmallPhotoUrl,
                    sfsp__Owner__r.Title,
                    sfsp__RuleLogics__c,
                    sfsp__HierarchyReferenceData__c,
                    (
                        SELECT Id, Name, sfsp__SalesNode__c, sfsp__FilterLogic__c, sfsp__BooleanFilter__c
                        FROM sfsp__SalesNodeRules__r
                    ),
                    (
                        SELECT Id, sfsp__SalesNode__c, sfsp__User__c, sfsp__User__r.Name, sfsp__Role__c
                        FROM sfsp__SalesNodeUsers__r
                    )
                FROM sfsp__SalesNode__c
                WHERE sfsp__SalesPlan__c = '${planId}'
                ORDER BY sfsp__Priority__c ASC
            `]
        );
        this.nodeHierarchy.sfsp__SalesPlan__c = this.plan.Id;
        this.nodeHierarchy.sfsp__Owner__r = this.plan.sfsp__Owner__r;
        this.nodeMap.all_org = this.nodeHierarchy;
        nodes.forEach((node) => {
          const parentNode = this.nodeMap[node.sfsp__Parent__c || "all_org"] = this.nodeMap[node.sfsp__Parent__c || "all_org"] || {
            ...SPM.Utils.Segment.Node.defaults(),
            Id: node.sfsp__Parent__c || "all_org",
            _expanded: true
          };
          const childNode = this.nodeMap[node.Id] = this.nodeMap[node.Id] || {
            ...SPM.Utils.Segment.Node.defaults(),
            Id: node.Id,
            sfsp__SalesPlan__c: this.plan.Id,
            _expanded: true
          };
          Object.assign(this.nodeMap[node.Id], {
            ...node,
            _parentId: parentNode.Id
          });
          this.nodeMap[parentNode.Id].sfsp__SalesNodes__r.push(childNode);
        });
        const removeOrphans = (nodes2) => {
          const orphans2 = [...nodes2];
          nodes2.forEach((n) => {
            delete this.nodeMap[n.Id];
            orphans2.push(...removeOrphans(n.sfsp__SalesNodes__r));
          });
          return orphans2;
        };
        const orphans = removeOrphans(Object.values(this.nodeMap).filter((n) => n.Id !== "all_org" && !n._parentId));
        if (orphans.length)
          this.toast({ state: "warning", message: `This plan contains orphaned segments: ${orphans.map((o) => o.Name).join(", ")}`, duration: 0 });
        const ruleItems = await SPM.Utils.Apex.invoke(
          "Query",
          [`
                SELECT Id, sfsp__SalesNodeRule__r.sfsp__SalesNode__c, sfsp__Field__c, sfsp__Operator__c, sfsp__Value__c
                FROM sfsp__SalesNodeRuleItem__c
                WHERE sfsp__SalesNodeRule__r.sfsp__SalesNode__r.sfsp__SalesPlan__c = '${planId}'
                ORDER BY sfsp__SortOrder__c
            `]
        );
        ruleItems.forEach((item) => {
          const node = this.nodeMap[item.sfsp__SalesNodeRule__r.sfsp__SalesNode__c];
          if (node) {
            const rule = node.sfsp__SalesNodeRules__r.find((r) => r.Id === item.sfsp__SalesNodeRule__c);
            rule.sfsp__SalesNodeRuleItems__r = rule.sfsp__SalesNodeRuleItems__r || [];
            rule.sfsp__SalesNodeRuleItems__r.push(item);
          }
        });
        if (this.plan.sfsp__SalesDataSource__r) {
          this.plan._hasDataSource = true;
          this.plan.sfsp__SalesDataSource__r._referenceFields = JSON.parse(this.plan.sfsp__SalesDataSource__r.sfsp__ReferenceFields__c);
          this.plan.sfsp__SalesDataSource__r._dataset = await SPM.Utils.Rest.invoke("GetDataset", { id: this.plan.sfsp__SalesDataSource__r.sfsp__SourceId__c });
          this.dataSource = this.plan.sfsp__SalesDataSource__r;
          const removedValues = /* @__PURE__ */ new Set();
          if (this.plan.sfsp__SalesUserPreferences__r === void 0 && this.preferences.kpis.length === 0) {
            this.preferences.kpis = this.plan.sfsp__SalesDataSource__r._referenceFields.filter((f) => f.dataType === "Numeric").slice(0, 3).map((f) => f.id);
          } else {
            this.preferences.kpis.forEach((kpi) => {
              if (this.plan.sfsp__SalesDataSource__r._referenceFields.find((field) => field.id === kpi) === void 0) {
                this.preferences.kpis = this.preferences.kpis.filter((a) => a !== kpi);
                removedValues.add(kpi);
              }
            });
          }
          if (this.plan.sfsp__SalesUserPreferences__r === void 0 || this.preferences.groupView === void 0) {
            this.preferences.groupView = this.plan.sfsp__SalesDataSource__r._referenceFields.filter((f) => f.dataType === "Numeric").slice(0, 3).map((f) => f.id);
          } else if (this.preferences.groupView.length) {
            this.preferences.groupView.forEach((column) => {
              if (this.plan.sfsp__SalesDataSource__r._referenceFields.find((field) => field.id === column) === void 0) {
                this.preferences.groupView = this.preferences.groupView.filter((a) => a !== column);
                removedValues.add(column);
              }
            });
          }
          if (this.plan.sfsp__SalesUserPreferences__r === void 0 || this.preferences.recordView === void 0) {
            this.preferences.recordView = [
              this.plan.sfsp__SalesDataSource__r._referenceFields.find((f) => f.isId).id,
              (_d = this.plan.sfsp__SalesDataSource__r._referenceFields.find((f) => f.isName)) == null ? void 0 : _d.id
            ].filter((id2) => !!id2);
            this.preferences.recordView = this.preferences.recordView.concat(this.plan.sfsp__SalesDataSource__r._referenceFields.filter((f) => f.dataType === "Numeric").slice(0, 3).map((f) => f.id));
          } else if (this.preferences.recordView.length) {
            this.preferences.recordView.forEach((column) => {
              if (this.plan.sfsp__SalesDataSource__r._referenceFields.find((field) => field.id === column) === void 0) {
                this.preferences.recordView = this.preferences.recordView.filter((a) => a !== column);
                removedValues.add(column);
              }
            });
          }
          if (removedValues.size > 0) {
            this.toast({ state: "warning", message: `The following fields were removed from your legend configuration because they were removed from the data source: ${Array.from(removedValues).join(", ")}`, duration: 0 });
          }
        } else {
          this.plan._hasDataSource = false;
          this.plan.sfsp__SalesDataSource__r = {
            _referenceFields: [],
            _dataset: {}
          };
        }
        this.loadingMsg = "";
        this.ready = true;
      },
      methods: {
        openModal(name2, config) {
          this.modalConfig = {
            callback: () => {
            },
            ...config || {}
          };
          this.modals[name2] = true;
        },
        async saveUserPreferences() {
          var _a, _b, _c;
          await SPM.Utils.CRM.upsert({
            records: [{
              sobjectType: "sfsp__SalesUserPreference__c",
              Id: (_c = (_b = (_a = this.plan) == null ? void 0 : _a.sfsp__SalesUserPreferences__r) == null ? void 0 : _b[0]) == null ? void 0 : _c.Id,
              sfsp__SalesPlan__c: this.plan.Id,
              sfsp__User__c: SPM.currentUser.Id,
              sfsp__Preferences__c: JSON.stringify(this.preferences, 0, 4)
            }]
          });
          if (this.plan.sfsp__SalesUserPreferences__r === void 0) {
            this.plan.sfsp__SalesUserPreferences__r = await SPM.Utils.Apex.invoke("Query", [`
                    SELECT
                        Id,
                        sfsp__Preferences__c
                    FROM sfsp__SalesUserPreference__c
                    WHERE sfsp__User__c = '${SPM.currentUser.Id}'
                    AND sfsp__SalesPlan__c = '${this.plan.Id}'
                `]);
          }
        },
        toast(options) {
          this.toasts.push({
            ...{
              duration: 5e3,
              position: "top-center",
              state: "success"
            },
            ...options
          });
        }
      }
    };
    const _hoisted_1 = {
      key: 1,
      class: "slds-grid slds-grid_vertical",
      style: { "height": "100%" }
    };
    const _hoisted_2 = {
      class: "slds-grid",
      style: { "position": "relative", "overflow": "hidden", "height": "100%" }
    };
    function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
      const _component_Toasts = resolveComponent("Toasts");
      const _component_NoAccess = resolveComponent("NoAccess");
      const _component_Spinner = resolveComponent("Spinner");
      const _component_BuilderHeader = resolveComponent("BuilderHeader");
      const _component_OrgView = resolveComponent("OrgView");
      const _component_RulesPanel = resolveComponent("RulesPanel");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_component_Toasts, { toasts: $data.toasts }, null, 8, ["toasts"]),
        $options.noAccess === true && !$data.loadingMsg ? (openBlock(), createBlock(_component_NoAccess, {
          key: 0,
          id: "noAccess"
        })) : (openBlock(), createElementBlock("div", _hoisted_1, [
          $data.loadingMsg ? (openBlock(), createBlock(_component_Spinner, { key: 0 }, {
            description: withCtx(() => [
              createTextVNode(toDisplayString($data.loadingMsg), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          createVNode(_component_BuilderHeader, { plan: $data.plan }, null, 8, ["plan"]),
          createBaseVNode("div", _hoisted_2, [
            !$data.loadingMsg ? (openBlock(), createBlock(_component_OrgView, {
              key: 0,
              id: "org-view",
              plan: $data.plan,
              nodeMap: $data.nodeMap,
              nodeHierarchy: $data.nodeHierarchy,
              style: { "height": "100%", "width": "100%" }
            }, null, 8, ["plan", "nodeMap", "nodeHierarchy"])) : createCommentVNode("", true),
            createVNode(Transition$1, { name: "slide-fade-panel" }, {
              default: withCtx(() => [
                $data.sidePanel === "RulesPanel" ? (openBlock(), createBlock(_component_RulesPanel, {
                  key: 0,
                  class: "right-panel",
                  node: $data.selectedNode
                }, null, 8, ["node"])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ])
        ]))
      ], 64);
    }
    const Root = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-8461fa22"]]);
    SPM.Utils = UtilsClient();
    SPM.Utils.getGUID = getGUID;
    SPM.Components = {};
    SPM.$store = {
      txnId: SPM.Utils.getGUID(),
      toast() {
        SPM.Components.Root.toast(...arguments);
      }
    };
    SPM.app = createApp({
      components: { IconSettings },
      render() {
        return h(
          IconSettings,
          {
            iconPath: `/resource/${(/* @__PURE__ */ new Date()).getTime()}/sfsp__SLDSAssets/icons`
          },
          () => [h(Root)]
        );
      }
    });
    SPM.app.directive("click-outside", ClickOutside);
    const locale = SPM.currentUser.Locale.replace("sh_ME_USD", "sh-ME").replace("_", "-").slice(0, 5);
    const formatters = {
      Currency: new Intl.NumberFormat(locale, { style: "currency", currency: SPM.currentUser.CurrencyIsoCode, maximumFractionDigits: 0 }),
      Numeric: new Intl.NumberFormat(locale, { style: "decimal", maximumFractionDigits: 0 }),
      Compact: new Intl.NumberFormat(locale, { notation: "compact" }),
      DateTime: (options = {}) => new Intl.DateTimeFormat(locale, options)
    };
    SPM.app.config.globalProperties.$F = (type, value, options) => type === "DateTime" ? formatters[type](options).format(value) : formatters[type].format(value);
    SPM.app.mount("#vue-root");
    SPM.version = 246;
    SPM.app.config.errorHandler = (ex, vm, info) => {
      var _a;
      if ((ex == null ? void 0 : ex.type) === "RemoteActionException") {
        const { error } = ex;
        SPM.Components.Root.toast({
          message: error.type,
          subMessage: error.message,
          state: "error",
          duration: 0
        });
      }
      const errorMsg = ((_a = ex.response) == null ? void 0 : _a.data[0].message) || "";
      if (errorMsg.includes("Edgemart not found")) {
        SPM.Components.Root.toast({
          message: "Segment data not found. Please contact your admin.",
          state: "error",
          duration: null
        });
        SPM.Components.Root.noAccess = true;
      }
      console.log("Vue Error", ex, vm, info);
    };
  }
});
export default require_bundle();
